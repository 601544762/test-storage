easy.c:sigpipe_ignore:
   44|  3.16k|{
   45|       |  /* get a local copy of no_signal because the Curl_easy might not be
   46|       |     around when we restore */
   47|  3.16k|  ig->no_signal = data->set.no_signal;
   48|  3.16k|  if(!data->set.no_signal) {
   49|  3.16k|    struct sigaction action;
   50|       |    /* first, extract the existing situation */
   51|  3.16k|    memset(&ig->old_pipe_act, 0, sizeof(struct sigaction));
   52|  3.16k|    sigaction(SIGPIPE, NULL, &ig->old_pipe_act);
   53|  3.16k|    action = ig->old_pipe_act;
   54|       |    /* ignore this signal */
   55|  3.16k|    action.sa_handler = SIG_IGN;
   56|  3.16k|    sigaction(SIGPIPE, &action, NULL);
   57|  3.16k|  }
   58|  3.16k|}
easy.c:sigpipe_restore:
   66|  3.16k|{
   67|  3.16k|  if(!ig->no_signal)
   68|       |    /* restore the outside state */
   69|  3.16k|    sigaction(SIGPIPE, &ig->old_pipe_act, NULL);
   70|  3.16k|}
multi.c:sigpipe_ignore:
   44|  5.78M|{
   45|       |  /* get a local copy of no_signal because the Curl_easy might not be
   46|       |     around when we restore */
   47|  5.78M|  ig->no_signal = data->set.no_signal;
   48|  5.78M|  if(!data->set.no_signal) {
   49|  5.78M|    struct sigaction action;
   50|       |    /* first, extract the existing situation */
   51|  5.78M|    memset(&ig->old_pipe_act, 0, sizeof(struct sigaction));
   52|  5.78M|    sigaction(SIGPIPE, NULL, &ig->old_pipe_act);
   53|  5.78M|    action = ig->old_pipe_act;
   54|       |    /* ignore this signal */
   55|  5.78M|    action.sa_handler = SIG_IGN;
   56|  5.78M|    sigaction(SIGPIPE, &action, NULL);
   57|  5.78M|  }
   58|  5.78M|}
multi.c:sigpipe_restore:
   66|  5.78M|{
   67|  5.78M|  if(!ig->no_signal)
   68|       |    /* restore the outside state */
   69|  5.78M|    sigaction(SIGPIPE, &ig->old_pipe_act, NULL);
   70|  5.78M|}
conncache.c:sigpipe_ignore:
   44|  3.60k|{
   45|       |  /* get a local copy of no_signal because the Curl_easy might not be
   46|       |     around when we restore */
   47|  3.60k|  ig->no_signal = data->set.no_signal;
   48|  3.60k|  if(!data->set.no_signal) {
   49|  3.60k|    struct sigaction action;
   50|       |    /* first, extract the existing situation */
   51|  3.60k|    memset(&ig->old_pipe_act, 0, sizeof(struct sigaction));
   52|  3.60k|    sigaction(SIGPIPE, NULL, &ig->old_pipe_act);
   53|  3.60k|    action = ig->old_pipe_act;
   54|       |    /* ignore this signal */
   55|  3.60k|    action.sa_handler = SIG_IGN;
   56|  3.60k|    sigaction(SIGPIPE, &action, NULL);
   57|  3.60k|  }
   58|  3.60k|}
conncache.c:sigpipe_restore:
   66|  3.60k|{
   67|  3.60k|  if(!ig->no_signal)
   68|       |    /* restore the outside state */
   69|  3.60k|    sigaction(SIGPIPE, &ig->old_pipe_act, NULL);
   70|  3.60k|}

Curl_altsvc_cleanup:
  306|  6.25k|{
  307|  6.25k|  struct Curl_llist_element *e;
  308|  6.25k|  struct Curl_llist_element *n;
  309|  6.25k|  if(*altsvcp) {
  310|      0|    struct altsvcinfo *altsvc = *altsvcp;
  311|      0|    for(e = altsvc->list.head; e; e = n) {
  312|      0|      struct altsvc *as = e->ptr;
  313|      0|      n = e->next;
  314|      0|      altsvc_free(as);
  315|      0|    }
  316|      0|    free(altsvc->filename);
  317|      0|    free(altsvc);
  318|      0|    *altsvcp = NULL; /* clear the pointer */
  319|      0|  }
  320|  6.25k|}
Curl_altsvc_save:
  327|  6.25k|{
  328|  6.25k|  struct Curl_llist_element *e;
  329|  6.25k|  struct Curl_llist_element *n;
  330|  6.25k|  CURLcode result = CURLE_OK;
  331|  6.25k|  FILE *out;
  332|  6.25k|  char *tempstore;
  333|  6.25k|  unsigned char randsuffix[9];
  334|       |
  335|  6.25k|  if(!altsvc)
  336|       |    /* no cache activated */
  337|  6.25k|    return CURLE_OK;
  338|       |
  339|       |  /* if not new name is given, use the one we stored from the load */
  340|      0|  if(!file && altsvc->filename)
  341|      0|    file = altsvc->filename;
  342|       |
  343|      0|  if((altsvc->flags & CURLALTSVC_READONLYFILE) || !file || !file[0])
  344|       |    /* marked as read-only, no file or zero length file name */
  345|      0|    return CURLE_OK;
  346|       |
  347|      0|  if(Curl_rand_hex(data, randsuffix, sizeof(randsuffix)))
  348|      0|    return CURLE_FAILED_INIT;
  349|       |
  350|      0|  tempstore = aprintf("%s.%s.tmp", file, randsuffix);
  351|      0|  if(!tempstore)
  352|      0|    return CURLE_OUT_OF_MEMORY;
  353|       |
  354|      0|  out = fopen(tempstore, FOPEN_WRITETEXT);
  355|      0|  if(!out)
  356|      0|    result = CURLE_WRITE_ERROR;
  357|      0|  else {
  358|      0|    fputs("# Your alt-svc cache. https://curl.se/docs/alt-svc.html\n"
  359|      0|          "# This file was generated by libcurl! Edit at your own risk.\n",
  360|      0|          out);
  361|      0|    for(e = altsvc->list.head; e; e = n) {
  362|      0|      struct altsvc *as = e->ptr;
  363|      0|      n = e->next;
  364|      0|      result = altsvc_out(as, out);
  365|      0|      if(result)
  366|      0|        break;
  367|      0|    }
  368|      0|    fclose(out);
  369|      0|    if(!result && Curl_rename(tempstore, file))
  370|      0|      result = CURLE_WRITE_ERROR;
  371|       |
  372|      0|    if(result)
  373|      0|      unlink(tempstore);
  374|      0|  }
  375|      0|  free(tempstore);
  376|      0|  return result;
  377|      0|}

Curl_resolver_global_init:
   92|      1|{
   93|      1|  return CURLE_OK;
   94|      1|}
Curl_resolver_init:
  112|  6.25k|{
  113|  6.25k|  (void)easy;
  114|  6.25k|  *resolver = calloc(1, sizeof(struct resdata));
  115|  6.25k|  if(!*resolver)
  116|      0|    return CURLE_OUT_OF_MEMORY;
  117|  6.25k|  return CURLE_OK;
  118|  6.25k|}
Curl_resolver_cleanup:
  127|  6.25k|{
  128|  6.25k|  free(resolver);
  129|  6.25k|}
Curl_resolver_cancel:
  148|  6.01k|{
  149|  6.01k|  destroy_async_data(&data->state.async);
  150|  6.01k|}
Curl_resolver_kill:
  531|  2.95k|{
  532|  2.95k|  struct thread_data *td = data->state.async.tdata;
  533|       |
  534|       |  /* If we're still resolving, we must wait for the threads to fully clean up,
  535|       |     unfortunately.  Otherwise, we can simply cancel to clean up any resolver
  536|       |     data. */
  537|  2.95k|  if(td && td->thread_hnd != curl_thread_t_null)
  538|      0|    (void)thread_wait_resolv(data, NULL, FALSE);
  539|  2.95k|  else
  540|  2.95k|    Curl_resolver_cancel(data);
  541|  2.95k|}
Curl_resolver_wait_resolv:
  558|      7|{
  559|      7|  return thread_wait_resolv(data, entry, TRUE);
  560|      7|}
Curl_resolver_is_resolved:
  569|      7|{
  570|      7|  struct thread_data *td = data->state.async.tdata;
  571|      7|  int done = 0;
  572|       |
  573|      7|  DEBUGASSERT(entry);
  574|      7|  *entry = NULL;
  575|       |
  576|      7|  if(!td) {
  577|      0|    DEBUGASSERT(td);
  578|      0|    return CURLE_COULDNT_RESOLVE_HOST;
  579|      0|  }
  580|       |
  581|      7|  Curl_mutex_acquire(td->tsd.mtx);
  582|      7|  done = td->tsd.done;
  583|      7|  Curl_mutex_release(td->tsd.mtx);
  584|       |
  585|      7|  if(done) {
  586|      0|    getaddrinfo_complete(data);
  587|       |
  588|      0|    if(!data->state.async.dns) {
  589|      0|      CURLcode result = Curl_resolver_error(data);
  590|      0|      destroy_async_data(&data->state.async);
  591|      0|      return result;
  592|      0|    }
  593|      0|    destroy_async_data(&data->state.async);
  594|      0|    *entry = data->state.async.dns;
  595|      0|  }
  596|      7|  else {
  597|       |    /* poll for name lookup done with exponential backoff up to 250ms */
  598|       |    /* should be fine even if this converts to 32 bit */
  599|      7|    timediff_t elapsed = Curl_timediff(Curl_now(),
  600|      7|                                       data->progress.t_startsingle);
  601|      7|    if(elapsed < 0)
  602|      0|      elapsed = 0;
  603|       |
  604|      7|    if(td->poll_interval == 0)
  605|       |      /* Start at 1ms poll interval */
  606|      7|      td->poll_interval = 1;
  607|      0|    else if(elapsed >= td->interval_end)
  608|       |      /* Back-off exponentially if last interval expired  */
  609|      0|      td->poll_interval *= 2;
  610|       |
  611|      7|    if(td->poll_interval > 250)
  612|      0|      td->poll_interval = 250;
  613|       |
  614|      7|    td->interval_end = elapsed + td->poll_interval;
  615|      7|    Curl_expire(data, td->poll_interval, EXPIRE_ASYNC_NAME);
  616|      7|  }
  617|       |
  618|      7|  return CURLE_OK;
  619|      7|}
Curl_resolver_getaddrinfo:
  695|      7|{
  696|      7|  struct addrinfo hints;
  697|      7|  int pf = PF_INET;
  698|      7|  struct resdata *reslv = (struct resdata *)data->state.async.resolver;
  699|       |
  700|      7|  *waitp = 0; /* default to synchronous response */
  701|       |
  702|      7|#ifdef CURLRES_IPV6
  703|      7|  if(Curl_ipv6works(data))
  704|       |    /* The stack seems to be IPv6-enabled */
  705|      7|    pf = PF_UNSPEC;
  706|      7|#endif /* CURLRES_IPV6 */
  707|       |
  708|      7|  memset(&hints, 0, sizeof(hints));
  709|      7|  hints.ai_family = pf;
  710|      7|  hints.ai_socktype = (data->conn->transport == TRNSPRT_TCP)?
  711|      7|    SOCK_STREAM : SOCK_DGRAM;
  712|       |
  713|      7|  reslv->start = Curl_now();
  714|       |  /* fire up a new resolver thread! */
  715|      7|  if(init_resolve_thread(data, hostname, port, &hints)) {
  716|      7|    *waitp = 1; /* expect asynchronous response */
  717|      7|    return NULL;
  718|      7|  }
  719|       |
  720|      0|  failf(data, "getaddrinfo() thread failed to start");
  721|      0|  return NULL;
  722|       |
  723|      7|}
asyn-thread.c:destroy_async_data:
  380|  6.01k|{
  381|  6.01k|  if(async->tdata) {
  382|      7|    struct thread_data *td = async->tdata;
  383|      7|    int done;
  384|      7|#ifndef CURL_DISABLE_SOCKETPAIR
  385|      7|    curl_socket_t sock_rd = td->tsd.sock_pair[0];
  386|      7|    struct Curl_easy *data = td->tsd.data;
  387|      7|#endif
  388|       |
  389|       |    /*
  390|       |     * if the thread is still blocking in the resolve syscall, detach it and
  391|       |     * let the thread do the cleanup...
  392|       |     */
  393|      7|    Curl_mutex_acquire(td->tsd.mtx);
  394|      7|    done = td->tsd.done;
  395|      7|    td->tsd.done = 1;
  396|      7|    Curl_mutex_release(td->tsd.mtx);
  397|       |
  398|      7|    if(!done) {
  399|      0|      Curl_thread_destroy(td->thread_hnd);
  400|      0|    }
  401|      7|    else {
  402|      7|      if(td->thread_hnd != curl_thread_t_null)
  403|      0|        Curl_thread_join(&td->thread_hnd);
  404|       |
  405|      7|      destroy_thread_sync_data(&td->tsd);
  406|       |
  407|      7|      free(async->tdata);
  408|      7|    }
  409|      7|#ifndef CURL_DISABLE_SOCKETPAIR
  410|       |    /*
  411|       |     * ensure CURLMOPT_SOCKETFUNCTION fires CURL_POLL_REMOVE
  412|       |     * before the FD is invalidated to avoid EBADF on EPOLL_CTL_DEL
  413|       |     */
  414|      7|    Curl_multi_closed(data, sock_rd);
  415|      7|    sclose(sock_rd);
  416|      7|#endif
  417|      7|  }
  418|  6.01k|  async->tdata = NULL;
  419|       |
  420|  6.01k|  free(async->hostname);
  421|  6.01k|  async->hostname = NULL;
  422|  6.01k|}
asyn-thread.c:destroy_thread_sync_data:
  192|      7|{
  193|      7|  if(tsd->mtx) {
  194|      7|    Curl_mutex_destroy(tsd->mtx);
  195|      7|    free(tsd->mtx);
  196|      7|  }
  197|       |
  198|      7|  free(tsd->hostname);
  199|       |
  200|      7|  if(tsd->res)
  201|      0|    Curl_freeaddrinfo(tsd->res);
  202|       |
  203|      7|#ifndef CURL_DISABLE_SOCKETPAIR
  204|       |  /*
  205|       |   * close one end of the socket pair (may be done in resolver thread);
  206|       |   * the other end (for reading) is always closed in the parent thread.
  207|       |   */
  208|      7|  if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {
  209|      7|    sclose(tsd->sock_pair[1]);
  210|      7|  }
  211|      7|#endif
  212|      7|  memset(tsd, 0, sizeof(*tsd));
  213|      7|}
asyn-thread.c:thread_wait_resolv:
  491|      7|{
  492|      7|  struct thread_data *td;
  493|      7|  CURLcode result = CURLE_OK;
  494|       |
  495|      7|  DEBUGASSERT(data);
  496|      7|  td = data->state.async.tdata;
  497|      7|  DEBUGASSERT(td);
  498|      7|  DEBUGASSERT(td->thread_hnd != curl_thread_t_null);
  499|       |
  500|       |  /* wait for the thread to resolve the name */
  501|      7|  if(Curl_thread_join(&td->thread_hnd)) {
  502|      7|    if(entry)
  503|      7|      result = getaddrinfo_complete(data);
  504|      7|  }
  505|      0|  else
  506|      7|    DEBUGASSERT(0);
  507|       |
  508|      7|  data->state.async.done = TRUE;
  509|       |
  510|      7|  if(entry)
  511|      7|    *entry = data->state.async.dns;
  512|       |
  513|      7|  if(!data->state.async.dns && report)
  514|       |    /* a name was not resolved, report error */
  515|      7|    result = Curl_resolver_error(data);
  516|       |
  517|      7|  destroy_async_data(&data->state.async);
  518|       |
  519|      7|  if(!data->state.async.dns && report)
  520|      7|    connclose(data->conn, "asynch resolve failed");
  521|       |
  522|      7|  return result;
  523|      7|}
asyn-thread.c:getaddrinfo_complete:
  271|      7|{
  272|      7|  struct thread_sync_data *tsd = conn_thread_sync_data(data);
  273|      7|  int rc;
  274|       |
  275|      7|  rc = Curl_addrinfo_callback(data, tsd->sock_error, tsd->res);
  276|       |  /* The tsd->res structure has been copied to async.dns and perhaps the DNS
  277|       |     cache.  Set our copy to NULL so destroy_thread_sync_data doesn't free it.
  278|       |  */
  279|      7|  tsd->res = NULL;
  280|       |
  281|      7|  return rc;
  282|      7|}
asyn-thread.c:conn_thread_sync_data:
  185|      7|{
  186|      7|  return &(data->state.async.tdata->tsd);
  187|      7|}
asyn-thread.c:init_resolve_thread:
  433|      7|{
  434|      7|  struct thread_data *td = calloc(1, sizeof(struct thread_data));
  435|      7|  int err = ENOMEM;
  436|      7|  struct Curl_async *asp = &data->state.async;
  437|       |
  438|      7|  data->state.async.tdata = td;
  439|      7|  if(!td)
  440|      0|    goto errno_exit;
  441|       |
  442|      7|  asp->port = port;
  443|      7|  asp->done = FALSE;
  444|      7|  asp->status = 0;
  445|      7|  asp->dns = NULL;
  446|      7|  td->thread_hnd = curl_thread_t_null;
  447|       |
  448|      7|  if(!init_thread_sync_data(td, hostname, port, hints)) {
  449|      0|    asp->tdata = NULL;
  450|      0|    free(td);
  451|      0|    goto errno_exit;
  452|      0|  }
  453|       |
  454|      7|  free(asp->hostname);
  455|      7|  asp->hostname = strdup(hostname);
  456|      7|  if(!asp->hostname)
  457|      0|    goto err_exit;
  458|       |
  459|       |  /* The thread will set this to 1 when complete. */
  460|      7|  td->tsd.done = 0;
  461|       |
  462|      7|#ifdef HAVE_GETADDRINFO
  463|      7|  td->thread_hnd = Curl_thread_create(getaddrinfo_thread, &td->tsd);
  464|       |#else
  465|       |  td->thread_hnd = Curl_thread_create(gethostbyname_thread, &td->tsd);
  466|       |#endif
  467|       |
  468|      7|  if(!td->thread_hnd) {
  469|       |    /* The thread never started, so mark it as done here for proper cleanup. */
  470|      0|    td->tsd.done = 1;
  471|      0|    err = errno;
  472|      0|    goto err_exit;
  473|      0|  }
  474|       |
  475|      7|  return TRUE;
  476|       |
  477|      0| err_exit:
  478|      0|  destroy_async_data(asp);
  479|       |
  480|      0| errno_exit:
  481|      0|  errno = err;
  482|      0|  return FALSE;
  483|      0|}
asyn-thread.c:init_thread_sync_data:
  221|      7|{
  222|      7|  struct thread_sync_data *tsd = &td->tsd;
  223|       |
  224|      7|  memset(tsd, 0, sizeof(*tsd));
  225|       |
  226|      7|  tsd->td = td;
  227|      7|  tsd->port = port;
  228|       |  /* Treat the request as done until the thread actually starts so any early
  229|       |   * cleanup gets done properly.
  230|       |   */
  231|      7|  tsd->done = 1;
  232|      7|#ifdef HAVE_GETADDRINFO
  233|      7|  DEBUGASSERT(hints);
  234|      7|  tsd->hints = *hints;
  235|       |#else
  236|       |  (void) hints;
  237|       |#endif
  238|       |
  239|      7|  tsd->mtx = malloc(sizeof(curl_mutex_t));
  240|      7|  if(!tsd->mtx)
  241|      0|    goto err_exit;
  242|       |
  243|      7|  Curl_mutex_init(tsd->mtx);
  244|       |
  245|      7|#ifndef CURL_DISABLE_SOCKETPAIR
  246|       |  /* create socket pair, avoid AF_LOCAL since it doesn't build on Solaris */
  247|      7|  if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, &tsd->sock_pair[0]) < 0) {
  248|      0|    tsd->sock_pair[0] = CURL_SOCKET_BAD;
  249|      0|    tsd->sock_pair[1] = CURL_SOCKET_BAD;
  250|      0|    goto err_exit;
  251|      0|  }
  252|      7|#endif
  253|      7|  tsd->sock_error = CURL_ASYNC_SUCCESS;
  254|       |
  255|       |  /* Copying hostname string because original can be destroyed by parent
  256|       |   * thread during gethostbyname execution.
  257|       |   */
  258|      7|  tsd->hostname = strdup(hostname);
  259|      7|  if(!tsd->hostname)
  260|      0|    goto err_exit;
  261|       |
  262|      7|  return 1;
  263|       |
  264|      0| err_exit:
  265|       |  /* Memory allocation failed */
  266|      0|  destroy_thread_sync_data(tsd);
  267|      0|  return 0;
  268|      7|}
asyn-thread.c:getaddrinfo_thread:
  294|      7|{
  295|      7|  struct thread_sync_data *tsd = (struct thread_sync_data *)arg;
  296|      7|  struct thread_data *td = tsd->td;
  297|      7|  char service[12];
  298|      7|  int rc;
  299|      7|#ifndef CURL_DISABLE_SOCKETPAIR
  300|      7|  char buf[1];
  301|      7|#endif
  302|       |
  303|      7|  msnprintf(service, sizeof(service), "%d", tsd->port);
  304|       |
  305|      7|  rc = Curl_getaddrinfo_ex(tsd->hostname, service, &tsd->hints, &tsd->res);
  306|       |
  307|      7|  if(rc) {
  308|      7|    tsd->sock_error = SOCKERRNO?SOCKERRNO:rc;
  309|      7|    if(tsd->sock_error == 0)
  310|      0|      tsd->sock_error = RESOLVER_ENOMEM;
  311|      7|  }
  312|      0|  else {
  313|      0|    Curl_addrinfo_set_port(tsd->res, tsd->port);
  314|      0|  }
  315|       |
  316|      7|  Curl_mutex_acquire(tsd->mtx);
  317|      7|  if(tsd->done) {
  318|       |    /* too late, gotta clean up the mess */
  319|      0|    Curl_mutex_release(tsd->mtx);
  320|      0|    destroy_thread_sync_data(tsd);
  321|      0|    free(td);
  322|      0|  }
  323|      7|  else {
  324|      7|#ifndef CURL_DISABLE_SOCKETPAIR
  325|      7|    if(tsd->sock_pair[1] != CURL_SOCKET_BAD) {
  326|       |      /* DNS has been resolved, signal client task */
  327|      7|      buf[0] = 1;
  328|      7|      if(swrite(tsd->sock_pair[1],  buf, sizeof(buf)) < 0) {
  329|       |        /* update sock_erro to errno */
  330|      0|        tsd->sock_error = SOCKERRNO;
  331|      0|      }
  332|      7|    }
  333|      7|#endif
  334|      7|    tsd->done = 1;
  335|      7|    Curl_mutex_release(tsd->mtx);
  336|      7|  }
  337|       |
  338|      7|  return 0;
  339|      7|}

Curl_base64_decode:
  109|     62|{
  110|     62|  size_t srclen = 0;
  111|     62|  size_t length = 0;
  112|     62|  size_t padding = 0;
  113|     62|  size_t i;
  114|     62|  size_t numQuantums;
  115|     62|  size_t rawlen = 0;
  116|     62|  unsigned char *pos;
  117|     62|  unsigned char *newstr;
  118|       |
  119|     62|  *outptr = NULL;
  120|     62|  *outlen = 0;
  121|     62|  srclen = strlen(src);
  122|       |
  123|       |  /* Check the length of the input string is valid */
  124|     62|  if(!srclen || srclen % 4)
  125|     24|    return CURLE_BAD_CONTENT_ENCODING;
  126|       |
  127|       |  /* Find the position of any = padding characters */
  128|    942|  while((src[length] != '=') && src[length])
  129|    904|    length++;
  130|       |
  131|       |  /* A maximum of two = padding characters is allowed */
  132|     38|  if(src[length] == '=') {
  133|      6|    padding++;
  134|      6|    if(src[length + 1] == '=')
  135|      1|      padding++;
  136|      6|  }
  137|       |
  138|       |  /* Check the = padding characters weren't part way through the input */
  139|     38|  if(length + padding != srclen)
  140|      4|    return CURLE_BAD_CONTENT_ENCODING;
  141|       |
  142|       |  /* Calculate the number of quantums */
  143|     34|  numQuantums = srclen / 4;
  144|       |
  145|       |  /* Calculate the size of the decoded string */
  146|     34|  rawlen = (numQuantums * 3) - padding;
  147|       |
  148|       |  /* Allocate our buffer including room for a zero terminator */
  149|     34|  newstr = malloc(rawlen + 1);
  150|     34|  if(!newstr)
  151|      0|    return CURLE_OUT_OF_MEMORY;
  152|       |
  153|     34|  pos = newstr;
  154|       |
  155|       |  /* Decode the quantums */
  156|    210|  for(i = 0; i < numQuantums; i++) {
  157|    191|    size_t result = decodeQuantum(pos, src);
  158|    191|    if(!result) {
  159|     15|      free(newstr);
  160|       |
  161|     15|      return CURLE_BAD_CONTENT_ENCODING;
  162|     15|    }
  163|       |
  164|    176|    pos += result;
  165|    176|    src += 4;
  166|    176|  }
  167|       |
  168|       |  /* Zero terminate */
  169|     19|  *pos = '\0';
  170|       |
  171|       |  /* Return the decoded data */
  172|     19|  *outptr = newstr;
  173|     19|  *outlen = rawlen;
  174|       |
  175|     19|  return CURLE_OK;
  176|     34|}
Curl_base64_encode:
  301|    287|{
  302|    287|  return base64_encode(base64, data, inputbuff, insize, outptr, outlen);
  303|    287|}
base64.c:decodeQuantum:
   54|    191|{
   55|    191|  size_t padding = 0;
   56|    191|  const char *s, *p;
   57|    191|  unsigned long i, x = 0;
   58|       |
   59|    913|  for(i = 0, s = src; i < 4; i++, s++) {
   60|    737|    if(*s == '=') {
   61|      3|      x = (x << 6);
   62|      3|      padding++;
   63|      3|    }
   64|    734|    else {
   65|    734|      unsigned long v = 0;
   66|    734|      p = base64;
   67|       |
   68|  27.6k|      while(*p && (*p != *s)) {
   69|  26.9k|        v++;
   70|  26.9k|        p++;
   71|  26.9k|      }
   72|       |
   73|    734|      if(*p == *s)
   74|    719|        x = (x << 6) + v;
   75|     15|      else
   76|     15|        return 0;
   77|    734|    }
   78|    737|  }
   79|       |
   80|    176|  if(padding < 1)
   81|    174|    dest[2] = curlx_ultouc(x & 0xFFUL);
   82|       |
   83|    176|  x >>= 8;
   84|    176|  if(padding < 2)
   85|    175|    dest[1] = curlx_ultouc(x & 0xFFUL);
   86|       |
   87|    176|  x >>= 8;
   88|    176|  dest[0] = curlx_ultouc(x & 0xFFUL);
   89|       |
   90|    176|  return 3 - padding;
   91|    191|}
base64.c:base64_encode:
  182|    287|{
  183|    287|  CURLcode result;
  184|    287|  unsigned char ibuf[3];
  185|    287|  unsigned char obuf[4];
  186|    287|  int i;
  187|    287|  int inputparts;
  188|    287|  char *output;
  189|    287|  char *base64data;
  190|    287|  char *convbuf = NULL;
  191|       |
  192|    287|  const char *indata = inputbuff;
  193|       |
  194|    287|  *outptr = NULL;
  195|    287|  *outlen = 0;
  196|       |
  197|    287|  if(!insize)
  198|      0|    insize = strlen(indata);
  199|       |
  200|       |#if SIZEOF_SIZE_T == 4
  201|       |  if(insize > UINT_MAX/4)
  202|       |    return CURLE_OUT_OF_MEMORY;
  203|       |#endif
  204|       |
  205|    287|  base64data = output = malloc(insize * 4 / 3 + 4);
  206|    287|  if(!output)
  207|      0|    return CURLE_OUT_OF_MEMORY;
  208|       |
  209|       |  /*
  210|       |   * The base64 data needs to be created using the network encoding
  211|       |   * not the host encoding.  And we can't change the actual input
  212|       |   * so we copy it to a buffer, translate it, and use that instead.
  213|       |   */
  214|    287|  result = Curl_convert_clone(data, indata, insize, &convbuf);
  215|    287|  if(result) {
  216|      0|    free(output);
  217|      0|    return result;
  218|      0|  }
  219|       |
  220|    287|  if(convbuf)
  221|      0|    indata = (char *)convbuf;
  222|       |
  223|  8.63k|  while(insize > 0) {
  224|  33.3k|    for(i = inputparts = 0; i < 3; i++) {
  225|  25.0k|      if(insize > 0) {
  226|  24.7k|        inputparts++;
  227|  24.7k|        ibuf[i] = (unsigned char) *indata;
  228|  24.7k|        indata++;
  229|  24.7k|        insize--;
  230|  24.7k|      }
  231|    267|      else
  232|    267|        ibuf[i] = 0;
  233|  25.0k|    }
  234|       |
  235|  8.34k|    obuf[0] = (unsigned char)  ((ibuf[0] & 0xFC) >> 2);
  236|  8.34k|    obuf[1] = (unsigned char) (((ibuf[0] & 0x03) << 4) | \
  237|  8.34k|                               ((ibuf[1] & 0xF0) >> 4));
  238|  8.34k|    obuf[2] = (unsigned char) (((ibuf[1] & 0x0F) << 2) | \
  239|  8.34k|                               ((ibuf[2] & 0xC0) >> 6));
  240|  8.34k|    obuf[3] = (unsigned char)   (ibuf[2] & 0x3F);
  241|       |
  242|  8.34k|    switch(inputparts) {
  243|     61|    case 1: /* only one byte read */
  244|     61|      msnprintf(output, 5, "%c%c==",
  245|     61|                table64[obuf[0]],
  246|     61|                table64[obuf[1]]);
  247|     61|      break;
  248|       |
  249|    145|    case 2: /* two bytes read */
  250|    145|      msnprintf(output, 5, "%c%c%c=",
  251|    145|                table64[obuf[0]],
  252|    145|                table64[obuf[1]],
  253|    145|                table64[obuf[2]]);
  254|    145|      break;
  255|       |
  256|  8.14k|    default:
  257|  8.14k|      msnprintf(output, 5, "%c%c%c%c",
  258|  8.14k|                table64[obuf[0]],
  259|  8.14k|                table64[obuf[1]],
  260|  8.14k|                table64[obuf[2]],
  261|  8.14k|                table64[obuf[3]]);
  262|  8.14k|      break;
  263|  8.34k|    }
  264|  8.34k|    output += 4;
  265|  8.34k|  }
  266|       |
  267|       |  /* Zero terminate */
  268|    287|  *output = '\0';
  269|       |
  270|       |  /* Return the pointer to the new data (allocated memory) */
  271|    287|  *outptr = base64data;
  272|       |
  273|    287|  free(convbuf);
  274|       |
  275|       |  /* Return the length of the new data */
  276|    287|  *outlen = strlen(base64data);
  277|       |
  278|    287|  return CURLE_OK;
  279|    287|}

Curl_bufref_init:
   36|    537|{
   37|    537|  DEBUGASSERT(br);
   38|    537|  br->dtor = NULL;
   39|    537|  br->ptr = NULL;
   40|    537|  br->len = 0;
   41|       |
   42|    537|#ifdef DEBUGBUILD
   43|    537|  br->signature = SIGNATURE;
   44|    537|#endif
   45|    537|}
Curl_bufref_free:
   53|    528|{
   54|    528|  DEBUGASSERT(br);
   55|    528|  DEBUGASSERT(br->signature == SIGNATURE);
   56|    528|  DEBUGASSERT(br->ptr || !br->len);
   57|       |
   58|    528|  if(br->ptr && br->dtor)
   59|     92|    br->dtor((void *) br->ptr);
   60|       |
   61|    528|  br->dtor = NULL;
   62|    528|  br->ptr = NULL;
   63|    528|  br->len = 0;
   64|    528|}
Curl_bufref_set:
   72|    206|{
   73|    206|  DEBUGASSERT(ptr || !len);
   74|    206|  DEBUGASSERT(len <= CURL_MAX_INPUT_LENGTH);
   75|       |
   76|    206|  Curl_bufref_free(br);
   77|    206|  br->ptr = (const unsigned char *) ptr;
   78|    206|  br->len = len;
   79|    206|  br->dtor = dtor;
   80|    206|}
Curl_bufref_ptr:
   86|    507|{
   87|    507|  DEBUGASSERT(br);
   88|    507|  DEBUGASSERT(br->signature == SIGNATURE);
   89|    507|  DEBUGASSERT(br->ptr || !br->len);
   90|       |
   91|    507|  return br->ptr;
   92|    507|}
Curl_bufref_len:
   98|    231|{
   99|    231|  DEBUGASSERT(br);
  100|    231|  DEBUGASSERT(br->signature == SIGNATURE);
  101|    231|  DEBUGASSERT(br->ptr || !br->len);
  102|       |
  103|    231|  return br->len;
  104|    231|}

Curl_conncache_init:
  115|  3.09k|{
  116|  3.09k|  int rc;
  117|       |
  118|       |  /* allocate a new easy handle to use when closing cached connections */
  119|  3.09k|  connc->closure_handle = curl_easy_init();
  120|  3.09k|  if(!connc->closure_handle)
  121|      0|    return 1; /* bad */
  122|       |
  123|  3.09k|  rc = Curl_hash_init(&connc->hash, size, Curl_hash_str,
  124|  3.09k|                      Curl_str_key_compare, free_bundle_hash_entry);
  125|  3.09k|  if(rc)
  126|      0|    Curl_close(&connc->closure_handle);
  127|  3.09k|  else
  128|  3.09k|    connc->closure_handle->state.conn_cache = connc;
  129|       |
  130|  3.09k|  return rc;
  131|  3.09k|}
Curl_conncache_destroy:
  134|  3.09k|{
  135|  3.09k|  if(connc)
  136|  3.09k|    Curl_hash_destroy(&connc->hash);
  137|  3.09k|}
Curl_conncache_size:
  172|    571|{
  173|    571|  size_t num;
  174|    571|  CONNCACHE_LOCK(data);
  175|    571|  num = data->state.conn_cache->num_conn;
  176|    571|  CONNCACHE_UNLOCK(data);
  177|    571|  return num;
  178|    571|}
Curl_conncache_find_bundle:
  189|  8.83k|{
  190|  8.83k|  struct connectbundle *bundle = NULL;
  191|  8.83k|  CONNCACHE_LOCK(data);
  192|  8.83k|  if(connc) {
  193|  8.83k|    char key[HASHKEY_SIZE];
  194|  8.83k|    hashkey(conn, key, sizeof(key), hostp);
  195|  8.83k|    bundle = Curl_hash_pick(&connc->hash, key, strlen(key));
  196|  8.83k|  }
  197|       |
  198|  8.83k|  return bundle;
  199|  8.83k|}
Curl_conncache_add_conn:
  235|  2.96k|{
  236|  2.96k|  CURLcode result = CURLE_OK;
  237|  2.96k|  struct connectbundle *bundle = NULL;
  238|  2.96k|  struct connectdata *conn = data->conn;
  239|  2.96k|  struct conncache *connc = data->state.conn_cache;
  240|  2.96k|  DEBUGASSERT(conn);
  241|       |
  242|       |  /* *find_bundle() locks the connection cache */
  243|  2.96k|  bundle = Curl_conncache_find_bundle(data, conn, data->state.conn_cache,
  244|  2.96k|                                      NULL);
  245|  2.96k|  if(!bundle) {
  246|  2.95k|    int rc;
  247|  2.95k|    char key[HASHKEY_SIZE];
  248|       |
  249|  2.95k|    result = bundle_create(&bundle);
  250|  2.95k|    if(result) {
  251|      0|      goto unlock;
  252|      0|    }
  253|       |
  254|  2.95k|    hashkey(conn, key, sizeof(key), NULL);
  255|  2.95k|    rc = conncache_add_bundle(data->state.conn_cache, key, bundle);
  256|       |
  257|  2.95k|    if(!rc) {
  258|      0|      bundle_destroy(bundle);
  259|      0|      result = CURLE_OUT_OF_MEMORY;
  260|      0|      goto unlock;
  261|      0|    }
  262|  2.95k|  }
  263|       |
  264|  2.96k|  bundle_add_conn(bundle, conn);
  265|  2.96k|  conn->connection_id = connc->next_connection_id++;
  266|  2.96k|  connc->num_conn++;
  267|       |
  268|  2.96k|  DEBUGF(infof(data, "Added connection %ld. "
  269|  2.96k|               "The cache now contains %zu members",
  270|  2.96k|               conn->connection_id, connc->num_conn));
  271|       |
  272|  2.96k|  unlock:
  273|  2.96k|  CONNCACHE_UNLOCK(data);
  274|       |
  275|  2.96k|  return result;
  276|  2.96k|}
Curl_conncache_remove_conn:
  287|  3.05k|{
  288|  3.05k|  struct connectbundle *bundle = conn->bundle;
  289|  3.05k|  struct conncache *connc = data->state.conn_cache;
  290|       |
  291|       |  /* The bundle pointer can be NULL, since this function can be called
  292|       |     due to a failed connection attempt, before being added to a bundle */
  293|  3.05k|  if(bundle) {
  294|  2.96k|    if(lock) {
  295|    525|      CONNCACHE_LOCK(data);
  296|    525|    }
  297|  2.96k|    bundle_remove_conn(bundle, conn);
  298|  2.96k|    if(bundle->num_connections == 0)
  299|  2.95k|      conncache_remove_bundle(connc, bundle);
  300|  2.96k|    conn->bundle = NULL; /* removed from it */
  301|  2.96k|    if(connc) {
  302|  2.96k|      connc->num_conn--;
  303|  2.96k|      DEBUGF(infof(data, "The cache now contains %zu members",
  304|  2.96k|                   connc->num_conn));
  305|  2.96k|    }
  306|  2.96k|    if(lock) {
  307|    525|      CONNCACHE_UNLOCK(data);
  308|    525|    }
  309|  2.96k|  }
  310|  3.05k|}
Curl_conncache_foreach:
  329|  3.37k|{
  330|  3.37k|  struct Curl_hash_iterator iter;
  331|  3.37k|  struct Curl_llist_element *curr;
  332|  3.37k|  struct Curl_hash_element *he;
  333|       |
  334|  3.37k|  if(!connc)
  335|      0|    return FALSE;
  336|       |
  337|  3.37k|  CONNCACHE_LOCK(data);
  338|  3.37k|  Curl_hash_start_iterate(&connc->hash, &iter);
  339|       |
  340|  3.37k|  he = Curl_hash_next_element(&iter);
  341|  3.37k|  while(he) {
  342|    515|    struct connectbundle *bundle;
  343|       |
  344|    515|    bundle = he->ptr;
  345|    515|    he = Curl_hash_next_element(&iter);
  346|       |
  347|    515|    curr = bundle->conn_list.head;
  348|    516|    while(curr) {
  349|       |      /* Yes, we need to update curr before calling func(), because func()
  350|       |         might decide to remove the connection */
  351|    516|      struct connectdata *conn = curr->ptr;
  352|    516|      curr = curr->next;
  353|       |
  354|    516|      if(1 == func(data, conn, param)) {
  355|    515|        CONNCACHE_UNLOCK(data);
  356|    515|        return TRUE;
  357|    515|      }
  358|    516|    }
  359|    515|  }
  360|  2.86k|  CONNCACHE_UNLOCK(data);
  361|  2.86k|  return FALSE;
  362|  2.86k|}
Curl_conncache_return_conn:
  403|    571|{
  404|       |  /* data->multi->maxconnects can be negative, deal with it. */
  405|    571|  size_t maxconnects =
  406|    571|    (data->multi->maxconnects < 0) ? data->multi->num_easy * 4:
  407|    571|    data->multi->maxconnects;
  408|    571|  struct connectdata *conn_candidate = NULL;
  409|       |
  410|    571|  conn->lastused = Curl_now(); /* it was used up until now */
  411|    571|  if(maxconnects > 0 &&
  412|    571|     Curl_conncache_size(data) > maxconnects) {
  413|      0|    infof(data, "Connection cache is full, closing the oldest one");
  414|       |
  415|      0|    conn_candidate = Curl_conncache_extract_oldest(data);
  416|      0|    if(conn_candidate) {
  417|       |      /* the winner gets the honour of being disconnected */
  418|      0|      (void)Curl_disconnect(data, conn_candidate, /* dead_connection */ FALSE);
  419|      0|    }
  420|      0|  }
  421|       |
  422|    571|  return (conn_candidate == conn) ? FALSE : TRUE;
  423|       |
  424|    571|}
Curl_conncache_close_all_connections:
  540|  3.09k|{
  541|  3.09k|  struct connectdata *conn;
  542|  3.09k|  char buffer[READBUFFER_MIN + 1];
  543|  3.09k|  if(!connc->closure_handle)
  544|      0|    return;
  545|  3.09k|  connc->closure_handle->state.buffer = buffer;
  546|  3.09k|  connc->closure_handle->set.buffer_size = READBUFFER_MIN;
  547|       |
  548|  3.09k|  conn = conncache_find_first_connection(connc);
  549|  3.60k|  while(conn) {
  550|    516|    SIGPIPE_VARIABLE(pipe_st);
  551|    516|    sigpipe_ignore(connc->closure_handle, &pipe_st);
  552|       |    /* This will remove the connection from the cache */
  553|    516|    connclose(conn, "kill all");
  554|    516|    Curl_conncache_remove_conn(connc->closure_handle, conn, TRUE);
  555|    516|    (void)Curl_disconnect(connc->closure_handle, conn, FALSE);
  556|    516|    sigpipe_restore(&pipe_st);
  557|       |
  558|    516|    conn = conncache_find_first_connection(connc);
  559|    516|  }
  560|       |
  561|  3.09k|  connc->closure_handle->state.buffer = NULL;
  562|  3.09k|  if(connc->closure_handle) {
  563|  3.09k|    SIGPIPE_VARIABLE(pipe_st);
  564|  3.09k|    sigpipe_ignore(connc->closure_handle, &pipe_st);
  565|       |
  566|  3.09k|    Curl_hostcache_clean(connc->closure_handle,
  567|  3.09k|                         connc->closure_handle->dns.hostcache);
  568|  3.09k|    Curl_close(&connc->closure_handle);
  569|  3.09k|    sigpipe_restore(&pipe_st);
  570|  3.09k|  }
  571|  3.09k|}
conncache.c:free_bundle_hash_entry:
  108|  2.95k|{
  109|  2.95k|  struct connectbundle *b = (struct connectbundle *) freethis;
  110|       |
  111|  2.95k|  bundle_destroy(b);
  112|  2.95k|}
conncache.c:hashkey:
  143|  11.7k|{
  144|  11.7k|  const char *hostname;
  145|  11.7k|  long port = conn->remote_port;
  146|       |
  147|  11.7k|#ifndef CURL_DISABLE_PROXY
  148|  11.7k|  if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {
  149|      0|    hostname = conn->http_proxy.host.name;
  150|      0|    port = conn->port;
  151|      0|  }
  152|  11.7k|  else
  153|  11.7k|#endif
  154|  11.7k|    if(conn->bits.conn_to_host)
  155|  11.7k|      hostname = conn->conn_to_host.name;
  156|      4|  else
  157|      4|    hostname = conn->host.name;
  158|       |
  159|  11.7k|  if(hostp)
  160|       |    /* report back which name we used */
  161|  5.86k|    *hostp = hostname;
  162|       |
  163|       |  /* put the number first so that the hostname gets cut off if too long */
  164|  11.7k|  msnprintf(buf, len, "%ld%s", port, hostname);
  165|  11.7k|  Curl_strntolower(buf, buf, len);
  166|  11.7k|}
conncache.c:bundle_create:
   54|  2.95k|{
   55|  2.95k|  DEBUGASSERT(*bundlep == NULL);
   56|  2.95k|  *bundlep = malloc(sizeof(struct connectbundle));
   57|  2.95k|  if(!*bundlep)
   58|      0|    return CURLE_OUT_OF_MEMORY;
   59|       |
   60|  2.95k|  (*bundlep)->num_connections = 0;
   61|  2.95k|  (*bundlep)->multiuse = BUNDLE_UNKNOWN;
   62|       |
   63|  2.95k|  Curl_llist_init(&(*bundlep)->conn_list, (Curl_llist_dtor) conn_llist_dtor);
   64|  2.95k|  return CURLE_OK;
   65|  2.95k|}
conncache.c:conn_llist_dtor:
   47|  2.96k|{
   48|  2.96k|  struct connectdata *conn = element;
   49|  2.96k|  (void)user;
   50|  2.96k|  conn->bundle = NULL;
   51|  2.96k|}
conncache.c:conncache_add_bundle:
  204|  2.95k|{
  205|  2.95k|  void *p = Curl_hash_add(&connc->hash, key, strlen(key), bundle);
  206|       |
  207|  2.95k|  return p?TRUE:FALSE;
  208|  2.95k|}
conncache.c:bundle_destroy:
   68|  2.95k|{
   69|  2.95k|  if(!bundle)
   70|      0|    return;
   71|       |
   72|  2.95k|  Curl_llist_destroy(&bundle->conn_list, NULL);
   73|       |
   74|  2.95k|  free(bundle);
   75|  2.95k|}
conncache.c:bundle_add_conn:
   80|  2.96k|{
   81|  2.96k|  Curl_llist_insert_next(&bundle->conn_list, bundle->conn_list.tail, conn,
   82|  2.96k|                         &conn->bundle_node);
   83|  2.96k|  conn->bundle = bundle;
   84|  2.96k|  bundle->num_connections++;
   85|  2.96k|}
conncache.c:bundle_remove_conn:
   90|  2.96k|{
   91|  2.96k|  struct Curl_llist_element *curr;
   92|       |
   93|  2.96k|  curr = bundle->conn_list.head;
   94|  2.97k|  while(curr) {
   95|  2.97k|    if(curr->ptr == conn) {
   96|  2.96k|      Curl_llist_remove(&bundle->conn_list, curr, NULL);
   97|  2.96k|      bundle->num_connections--;
   98|  2.96k|      conn->bundle = NULL;
   99|  2.96k|      return 1; /* we removed a handle */
  100|  2.96k|    }
  101|      9|    curr = curr->next;
  102|      9|  }
  103|      0|  DEBUGASSERT(0);
  104|      0|  return 0;
  105|      0|}
conncache.c:conncache_remove_bundle:
  212|  2.95k|{
  213|  2.95k|  struct Curl_hash_iterator iter;
  214|  2.95k|  struct Curl_hash_element *he;
  215|       |
  216|  2.95k|  if(!connc)
  217|      0|    return;
  218|       |
  219|  2.95k|  Curl_hash_start_iterate(&connc->hash, &iter);
  220|       |
  221|  2.95k|  he = Curl_hash_next_element(&iter);
  222|  2.95k|  while(he) {
  223|  2.95k|    if(he->ptr == bundle) {
  224|       |      /* The bundle is destroyed by the hash destructor function,
  225|       |         free_bundle_hash_entry() */
  226|  2.95k|      Curl_hash_delete(&connc->hash, he->key, he->key_len);
  227|  2.95k|      return;
  228|  2.95k|    }
  229|       |
  230|      1|    he = Curl_hash_next_element(&iter);
  231|      1|  }
  232|  2.95k|}
conncache.c:conncache_find_first_connection:
  372|  3.60k|{
  373|  3.60k|  struct Curl_hash_iterator iter;
  374|  3.60k|  struct Curl_hash_element *he;
  375|  3.60k|  struct connectbundle *bundle;
  376|       |
  377|  3.60k|  Curl_hash_start_iterate(&connc->hash, &iter);
  378|       |
  379|  3.60k|  he = Curl_hash_next_element(&iter);
  380|  3.60k|  while(he) {
  381|    516|    struct Curl_llist_element *curr;
  382|    516|    bundle = he->ptr;
  383|       |
  384|    516|    curr = bundle->conn_list.head;
  385|    516|    if(curr) {
  386|    516|      return curr->ptr;
  387|    516|    }
  388|       |
  389|      0|    he = Curl_hash_next_element(&iter);
  390|      0|  }
  391|       |
  392|  3.09k|  return NULL;
  393|  3.60k|}

Curl_timeleft:
  187|  11.5M|{
  188|  11.5M|  unsigned int timeout_set = 0;
  189|  11.5M|  timediff_t connect_timeout_ms = 0;
  190|  11.5M|  timediff_t maxtime_timeout_ms = 0;
  191|  11.5M|  timediff_t timeout_ms = 0;
  192|  11.5M|  struct curltime now;
  193|       |
  194|       |  /* The duration of a connect and the total transfer are calculated from two
  195|       |     different time-stamps. It can end up with the total timeout being reached
  196|       |     before the connect timeout expires and we must acknowledge whichever
  197|       |     timeout that is reached first. The total timeout is set per entire
  198|       |     operation, while the connect timeout is set per connect. */
  199|       |
  200|  11.5M|  if(data->set.timeout > 0) {
  201|  11.5M|    timeout_set = TIMEOUT_MAXTIME;
  202|  11.5M|    maxtime_timeout_ms = data->set.timeout;
  203|  11.5M|  }
  204|  11.5M|  if(duringconnect) {
  205|  7.49k|    timeout_set |= TIMEOUT_CONNECT;
  206|  7.49k|    connect_timeout_ms = (data->set.connecttimeout > 0) ?
  207|  7.49k|      data->set.connecttimeout : DEFAULT_CONNECT_TIMEOUT;
  208|  7.49k|  }
  209|  11.5M|  if(!timeout_set)
  210|       |    /* no timeout  */
  211|      0|    return 0;
  212|       |
  213|  11.5M|  if(!nowp) {
  214|  5.92k|    now = Curl_now();
  215|  5.92k|    nowp = &now;
  216|  5.92k|  }
  217|       |
  218|  11.5M|  if(timeout_set & TIMEOUT_MAXTIME) {
  219|  11.5M|    maxtime_timeout_ms -= Curl_timediff(*nowp, data->progress.t_startop);
  220|  11.5M|    timeout_ms = maxtime_timeout_ms;
  221|  11.5M|  }
  222|       |
  223|  11.5M|  if(timeout_set & TIMEOUT_CONNECT) {
  224|  7.49k|    connect_timeout_ms -= Curl_timediff(*nowp, data->progress.t_startsingle);
  225|       |
  226|  7.49k|    if(!(timeout_set & TIMEOUT_MAXTIME) ||
  227|  7.49k|       (connect_timeout_ms < maxtime_timeout_ms))
  228|      0|      timeout_ms = connect_timeout_ms;
  229|  7.49k|  }
  230|       |
  231|  11.5M|  if(!timeout_ms)
  232|       |    /* avoid returning 0 as that means no timeout! */
  233|    131|    return -1;
  234|       |
  235|  11.5M|  return timeout_ms;
  236|  11.5M|}
Curl_persistconninfo:
  611|  2.96k|{
  612|  2.96k|  memcpy(data->info.conn_primary_ip, conn->primary_ip, MAX_IPADR_LEN);
  613|  2.96k|  if(local_ip && local_ip[0])
  614|      0|    memcpy(data->info.conn_local_ip, local_ip, MAX_IPADR_LEN);
  615|  2.96k|  else
  616|  2.96k|    data->info.conn_local_ip[0] = 0;
  617|  2.96k|  data->info.conn_scheme = conn->handler->scheme;
  618|  2.96k|  data->info.conn_protocol = conn->handler->protocol;
  619|  2.96k|  data->info.conn_primary_port = conn->port;
  620|  2.96k|  data->info.conn_local_port = local_port;
  621|  2.96k|}
Curl_addr2string:
  627|  8.75k|{
  628|  8.75k|  struct sockaddr_in *si = NULL;
  629|  8.75k|#ifdef ENABLE_IPV6
  630|  8.75k|  struct sockaddr_in6 *si6 = NULL;
  631|  8.75k|#endif
  632|  8.75k|#if (defined(HAVE_SYS_UN_H) || defined(WIN32_SOCKADDR_UN)) && defined(AF_UNIX)
  633|  8.75k|  struct sockaddr_un *su = NULL;
  634|       |#else
  635|       |  (void)salen;
  636|       |#endif
  637|       |
  638|  8.75k|  switch(sa->sa_family) {
  639|  2.92k|    case AF_INET:
  640|  2.92k|      si = (struct sockaddr_in *)(void *) sa;
  641|  2.92k|      if(Curl_inet_ntop(sa->sa_family, &si->sin_addr,
  642|  2.92k|                        addr, MAX_IPADR_LEN)) {
  643|  2.92k|        unsigned short us_port = ntohs(si->sin_port);
  644|  2.92k|        *port = us_port;
  645|  2.92k|        return TRUE;
  646|  2.92k|      }
  647|      0|      break;
  648|      0|#ifdef ENABLE_IPV6
  649|      0|    case AF_INET6:
  650|      0|      si6 = (struct sockaddr_in6 *)(void *) sa;
  651|      0|      if(Curl_inet_ntop(sa->sa_family, &si6->sin6_addr,
  652|      0|                        addr, MAX_IPADR_LEN)) {
  653|      0|        unsigned short us_port = ntohs(si6->sin6_port);
  654|      0|        *port = us_port;
  655|      0|        return TRUE;
  656|      0|      }
  657|      0|      break;
  658|      0|#endif
  659|      0|#if (defined(HAVE_SYS_UN_H) || defined(WIN32_SOCKADDR_UN)) && defined(AF_UNIX)
  660|  5.83k|    case AF_UNIX:
  661|  5.83k|      if(salen > (curl_socklen_t)sizeof(CURL_SA_FAMILY_T)) {
  662|      0|        su = (struct sockaddr_un*)sa;
  663|      0|        msnprintf(addr, MAX_IPADR_LEN, "%s", su->sun_path);
  664|      0|      }
  665|  5.83k|      else
  666|  5.83k|        addr[0] = 0; /* socket with no name */
  667|  5.83k|      *port = 0;
  668|  5.83k|      return TRUE;
  669|      0|#endif
  670|      0|    default:
  671|      0|      break;
  672|  8.75k|  }
  673|       |
  674|      0|  addr[0] = '\0';
  675|      0|  *port = 0;
  676|      0|  errno = EAFNOSUPPORT;
  677|      0|  return FALSE;
  678|  8.75k|}
Curl_conninfo_remote:
  684|  2.91k|{
  685|  2.91k|#ifdef HAVE_GETPEERNAME
  686|  2.91k|  char buffer[STRERROR_LEN];
  687|  2.91k|  struct Curl_sockaddr_storage ssrem;
  688|  2.91k|  curl_socklen_t plen;
  689|  2.91k|  int port;
  690|  2.91k|  plen = sizeof(struct Curl_sockaddr_storage);
  691|  2.91k|  memset(&ssrem, 0, sizeof(ssrem));
  692|  2.91k|  if(getpeername(sockfd, (struct sockaddr*) &ssrem, &plen)) {
  693|      0|    int error = SOCKERRNO;
  694|      0|    failf(data, "getpeername() failed with errno %d: %s",
  695|      0|          error, Curl_strerror(error, buffer, sizeof(buffer)));
  696|      0|    return;
  697|      0|  }
  698|  2.91k|  if(!Curl_addr2string((struct sockaddr*)&ssrem, plen,
  699|  2.91k|                       conn->primary_ip, &port)) {
  700|      0|    failf(data, "ssrem inet_ntop() failed with errno %d: %s",
  701|      0|          errno, Curl_strerror(errno, buffer, sizeof(buffer)));
  702|      0|    return;
  703|      0|  }
  704|       |#else
  705|       |  (void)data;
  706|       |  (void)conn;
  707|       |  (void)sockfd;
  708|       |#endif
  709|  2.91k|}
Curl_conninfo_local:
  715|  2.91k|{
  716|  2.91k|#ifdef HAVE_GETSOCKNAME
  717|  2.91k|  char buffer[STRERROR_LEN];
  718|  2.91k|  struct Curl_sockaddr_storage ssloc;
  719|  2.91k|  curl_socklen_t slen;
  720|  2.91k|  slen = sizeof(struct Curl_sockaddr_storage);
  721|  2.91k|  memset(&ssloc, 0, sizeof(ssloc));
  722|  2.91k|  if(getsockname(sockfd, (struct sockaddr*) &ssloc, &slen)) {
  723|      0|    int error = SOCKERRNO;
  724|      0|    failf(data, "getsockname() failed with errno %d: %s",
  725|      0|          error, Curl_strerror(error, buffer, sizeof(buffer)));
  726|      0|    return;
  727|      0|  }
  728|  2.91k|  if(!Curl_addr2string((struct sockaddr*)&ssloc, slen,
  729|  2.91k|                       local_ip, local_port)) {
  730|      0|    failf(data, "ssloc inet_ntop() failed with errno %d: %s",
  731|      0|          errno, Curl_strerror(errno, buffer, sizeof(buffer)));
  732|      0|    return;
  733|      0|  }
  734|       |#else
  735|       |  (void)data;
  736|       |  (void)sockfd;
  737|       |  (void)local_ip;
  738|       |  (void)local_port;
  739|       |#endif
  740|  2.91k|}
Curl_updateconninfo:
  746|  2.92k|{
  747|       |  /* 'local_ip' and 'local_port' get filled with local's numerical
  748|       |     ip address and port number whenever an outgoing connection is
  749|       |     **established** from the primary socket to a remote address. */
  750|  2.92k|  char local_ip[MAX_IPADR_LEN] = "";
  751|  2.92k|  int local_port = -1;
  752|       |
  753|  2.92k|  if(conn->transport == TRNSPRT_TCP) {
  754|  2.91k|    if(!conn->bits.reuse && !conn->bits.tcp_fastopen)
  755|  2.91k|      Curl_conninfo_remote(data, conn, sockfd);
  756|  2.91k|    Curl_conninfo_local(data, sockfd, local_ip, &local_port);
  757|  2.91k|  } /* end of TCP-only section */
  758|       |
  759|       |  /* persist connection info in session handle */
  760|  2.92k|  Curl_persistconninfo(data, conn, local_ip, local_port);
  761|  2.92k|}
Curl_is_connected:
  852|  2.92k|{
  853|  2.92k|  CURLcode result = CURLE_OK;
  854|  2.92k|  timediff_t allow;
  855|  2.92k|  int error = 0;
  856|  2.92k|  struct curltime now;
  857|  2.92k|  int rc = 0;
  858|  2.92k|  unsigned int i;
  859|       |
  860|  2.92k|  DEBUGASSERT(sockindex >= FIRSTSOCKET && sockindex <= SECONDARYSOCKET);
  861|       |
  862|  2.92k|  *connected = FALSE; /* a very negative world view is best */
  863|       |
  864|  2.92k|  if(conn->bits.tcpconnect[sockindex]) {
  865|       |    /* we are connected already! */
  866|      0|    *connected = TRUE;
  867|      0|    return CURLE_OK;
  868|      0|  }
  869|       |
  870|  2.92k|  now = Curl_now();
  871|       |
  872|  2.92k|  if(SOCKS_STATE(conn->cnnct.state)) {
  873|       |    /* still doing SOCKS */
  874|      0|    result = connect_SOCKS(data, sockindex, connected);
  875|      0|    if(!result && *connected)
  876|      0|      post_SOCKS(data, conn, sockindex, connected);
  877|      0|    return result;
  878|      0|  }
  879|       |
  880|  2.92k|  for(i = 0; i<2; i++) {
  881|  2.92k|    const int other = i ^ 1;
  882|  2.92k|    if(conn->tempsock[i] == CURL_SOCKET_BAD)
  883|      0|      continue;
  884|  2.92k|    error = 0;
  885|       |#ifdef ENABLE_QUIC
  886|       |    if(conn->transport == TRNSPRT_QUIC) {
  887|       |      result = Curl_quic_is_connected(data, conn, i, connected);
  888|       |      if(!result && *connected) {
  889|       |        /* use this socket from now on */
  890|       |        conn->sock[sockindex] = conn->tempsock[i];
  891|       |        conn->ip_addr = conn->tempaddr[i];
  892|       |        conn->tempsock[i] = CURL_SOCKET_BAD;
  893|       |        post_SOCKS(data, conn, sockindex, connected);
  894|       |        connkeep(conn, "HTTP/3 default");
  895|       |        return CURLE_OK;
  896|       |      }
  897|       |      if(result) {
  898|       |        conn->tempsock[i] = CURL_SOCKET_BAD;
  899|       |        error = SOCKERRNO;
  900|       |      }
  901|       |    }
  902|       |    else
  903|       |#endif
  904|  2.92k|    {
  905|       |#ifdef mpeix
  906|       |      /* Call this function once now, and ignore the results. We do this to
  907|       |         "clear" the error state on the socket so that we can later read it
  908|       |         reliably. This is reported necessary on the MPE/iX operating
  909|       |         system. */
  910|       |      (void)verifyconnect(conn->tempsock[i], NULL);
  911|       |#endif
  912|       |
  913|       |      /* check socket for connect */
  914|  2.92k|      rc = SOCKET_WRITABLE(conn->tempsock[i], 0);
  915|  2.92k|    }
  916|       |
  917|  2.92k|    if(rc == 0) { /* no connection yet */
  918|      0|      if(Curl_timediff(now, conn->connecttime) >=
  919|      0|         conn->timeoutms_per_addr[i]) {
  920|      0|        infof(data, "After %" CURL_FORMAT_TIMEDIFF_T
  921|      0|              "ms connect time, move on!", conn->timeoutms_per_addr[i]);
  922|      0|        error = ETIMEDOUT;
  923|      0|      }
  924|       |
  925|       |      /* should we try another protocol family? */
  926|      0|      if(i == 0 && !conn->bits.parallel_connect &&
  927|      0|         (Curl_timediff(now, conn->connecttime) >=
  928|      0|          data->set.happy_eyeballs_timeout)) {
  929|      0|        conn->bits.parallel_connect = TRUE; /* starting now */
  930|      0|        trynextip(data, conn, sockindex, 1);
  931|      0|      }
  932|      0|    }
  933|  2.92k|    else if(rc == CURL_CSELECT_OUT || conn->bits.tcp_fastopen) {
  934|  2.92k|      if(verifyconnect(conn->tempsock[i], &error)) {
  935|       |        /* we are connected with TCP, awesome! */
  936|       |
  937|       |        /* use this socket from now on */
  938|  2.92k|        conn->sock[sockindex] = conn->tempsock[i];
  939|  2.92k|        conn->ip_addr = conn->tempaddr[i];
  940|  2.92k|        conn->tempsock[i] = CURL_SOCKET_BAD;
  941|  2.92k|#ifdef ENABLE_IPV6
  942|  2.92k|        conn->bits.ipv6 = (conn->ip_addr->ai_family == AF_INET6)?TRUE:FALSE;
  943|  2.92k|#endif
  944|       |
  945|       |        /* close the other socket, if open */
  946|  2.92k|        if(conn->tempsock[other] != CURL_SOCKET_BAD) {
  947|      0|          Curl_closesocket(data, conn, conn->tempsock[other]);
  948|      0|          conn->tempsock[other] = CURL_SOCKET_BAD;
  949|      0|        }
  950|       |
  951|       |        /* see if we need to kick off any SOCKS proxy magic once we
  952|       |           connected */
  953|  2.92k|        result = connect_SOCKS(data, sockindex, connected);
  954|  2.92k|        if(result || !*connected)
  955|      0|          return result;
  956|       |
  957|  2.92k|        post_SOCKS(data, conn, sockindex, connected);
  958|       |
  959|  2.92k|        return CURLE_OK;
  960|  2.92k|      }
  961|  2.92k|    }
  962|      0|    else if(rc & CURL_CSELECT_ERR) {
  963|      0|      (void)verifyconnect(conn->tempsock[i], &error);
  964|      0|    }
  965|       |
  966|       |    /*
  967|       |     * The connection failed here, we should attempt to connect to the "next
  968|       |     * address" for the given host. But first remember the latest error.
  969|       |     */
  970|      0|    if(error) {
  971|      0|      data->state.os_errno = error;
  972|      0|      SET_SOCKERRNO(error);
  973|      0|      if(conn->tempaddr[i]) {
  974|      0|        CURLcode status;
  975|      0|#ifndef CURL_DISABLE_VERBOSE_STRINGS
  976|      0|        char ipaddress[MAX_IPADR_LEN];
  977|      0|        char buffer[STRERROR_LEN];
  978|      0|        Curl_printable_address(conn->tempaddr[i], ipaddress,
  979|      0|                               sizeof(ipaddress));
  980|      0|        infof(data, "connect to %s port %u failed: %s",
  981|      0|              ipaddress, conn->port,
  982|      0|              Curl_strerror(error, buffer, sizeof(buffer)));
  983|      0|#endif
  984|       |
  985|      0|        allow = Curl_timeleft(data, &now, TRUE);
  986|      0|        conn->timeoutms_per_addr[i] = conn->tempaddr[i]->ai_next == NULL ?
  987|      0|          allow : allow / 2;
  988|      0|        ainext(conn, i, TRUE);
  989|      0|        status = trynextip(data, conn, sockindex, i);
  990|      0|        if((status != CURLE_COULDNT_CONNECT) ||
  991|      0|           conn->tempsock[other] == CURL_SOCKET_BAD)
  992|       |          /* the last attempt failed and no other sockets remain open */
  993|      0|          result = status;
  994|      0|      }
  995|      0|    }
  996|      0|  }
  997|       |
  998|       |  /*
  999|       |   * Now that we've checked whether we are connected, check whether we've
 1000|       |   * already timed out.
 1001|       |   *
 1002|       |   * First figure out how long time we have left to connect */
 1003|       |
 1004|      0|  allow = Curl_timeleft(data, &now, TRUE);
 1005|       |
 1006|      0|  if(allow < 0) {
 1007|       |    /* time-out, bail out, go home */
 1008|      0|    failf(data, "Connection timeout after %ld ms",
 1009|      0|          Curl_timediff(now, data->progress.t_startsingle));
 1010|      0|    return CURLE_OPERATION_TIMEDOUT;
 1011|      0|  }
 1012|       |
 1013|      0|  if(result &&
 1014|      0|     (conn->tempsock[0] == CURL_SOCKET_BAD) &&
 1015|      0|     (conn->tempsock[1] == CURL_SOCKET_BAD)) {
 1016|       |    /* no more addresses to try */
 1017|      0|    const char *hostname;
 1018|      0|    char buffer[STRERROR_LEN];
 1019|       |
 1020|       |    /* if the first address family runs out of addresses to try before the
 1021|       |       happy eyeball timeout, go ahead and try the next family now */
 1022|      0|    result = trynextip(data, conn, sockindex, 1);
 1023|      0|    if(!result)
 1024|      0|      return result;
 1025|       |
 1026|      0|#ifndef CURL_DISABLE_PROXY
 1027|      0|    if(conn->bits.socksproxy)
 1028|      0|      hostname = conn->socks_proxy.host.name;
 1029|      0|    else if(conn->bits.httpproxy)
 1030|      0|      hostname = conn->http_proxy.host.name;
 1031|      0|    else
 1032|      0|#endif
 1033|      0|      if(conn->bits.conn_to_host)
 1034|      0|        hostname = conn->conn_to_host.name;
 1035|      0|    else
 1036|      0|      hostname = conn->host.name;
 1037|       |
 1038|      0|    failf(data, "Failed to connect to %s port %u after "
 1039|      0|                "%" CURL_FORMAT_TIMEDIFF_T " ms: %s",
 1040|      0|        hostname, conn->port,
 1041|      0|        Curl_timediff(now, data->progress.t_startsingle),
 1042|      0|        Curl_strerror(error, buffer, sizeof(buffer)));
 1043|       |
 1044|      0|    Curl_quic_disconnect(data, conn, 0);
 1045|      0|    Curl_quic_disconnect(data, conn, 1);
 1046|       |
 1047|       |#ifdef WSAETIMEDOUT
 1048|       |    if(WSAETIMEDOUT == data->state.os_errno)
 1049|       |      result = CURLE_OPERATION_TIMEDOUT;
 1050|       |#elif defined(ETIMEDOUT)
 1051|      0|    if(ETIMEDOUT == data->state.os_errno)
 1052|      0|      result = CURLE_OPERATION_TIMEDOUT;
 1053|      0|#endif
 1054|      0|  }
 1055|      0|  else
 1056|      0|    result = CURLE_OK; /* still trying */
 1057|       |
 1058|      0|  return result;
 1059|      0|}
Curl_connecthost:
 1357|  2.93k|{
 1358|  2.93k|  CURLcode result = CURLE_COULDNT_CONNECT;
 1359|  2.93k|  int i;
 1360|  2.93k|  timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
 1361|       |
 1362|  2.93k|  if(timeout_ms < 0) {
 1363|       |    /* a precaution, no need to continue if time already is up */
 1364|      0|    failf(data, "Connection time-out");
 1365|      0|    return CURLE_OPERATION_TIMEDOUT;
 1366|      0|  }
 1367|       |
 1368|  2.93k|  conn->num_addr = Curl_num_addresses(remotehost->addr);
 1369|  2.93k|  conn->tempaddr[0] = conn->tempaddr[1] = remotehost->addr;
 1370|  2.93k|  conn->tempsock[0] = conn->tempsock[1] = CURL_SOCKET_BAD;
 1371|       |
 1372|       |  /* Max time for the next connection attempt */
 1373|  2.93k|  conn->timeoutms_per_addr[0] =
 1374|  2.93k|    conn->tempaddr[0]->ai_next == NULL ? timeout_ms : timeout_ms / 2;
 1375|  2.93k|  conn->timeoutms_per_addr[1] =
 1376|  2.93k|    conn->tempaddr[1]->ai_next == NULL ? timeout_ms : timeout_ms / 2;
 1377|       |
 1378|  2.93k|  if(conn->ip_version == CURL_IPRESOLVE_WHATEVER) {
 1379|       |    /* any IP version is allowed */
 1380|  2.93k|    conn->tempfamily[0] = conn->tempaddr[0]?
 1381|  2.93k|      conn->tempaddr[0]->ai_family:0;
 1382|  2.93k|#ifdef ENABLE_IPV6
 1383|  2.93k|    conn->tempfamily[1] = conn->tempfamily[0] == AF_INET6 ?
 1384|      0|      AF_INET : AF_INET6;
 1385|       |#else
 1386|       |    conn->tempfamily[1] = AF_UNSPEC;
 1387|       |#endif
 1388|  2.93k|  }
 1389|      0|  else {
 1390|       |    /* only one IP version is allowed */
 1391|      0|    conn->tempfamily[0] = (conn->ip_version == CURL_IPRESOLVE_V4) ?
 1392|      0|      AF_INET :
 1393|      0|#ifdef ENABLE_IPV6
 1394|      0|      AF_INET6;
 1395|       |#else
 1396|       |      AF_UNSPEC;
 1397|       |#endif
 1398|      0|    conn->tempfamily[1] = AF_UNSPEC;
 1399|       |
 1400|      0|    ainext(conn, 0, FALSE); /* find first address of the right type */
 1401|      0|  }
 1402|       |
 1403|  2.93k|  ainext(conn, 1, FALSE); /* assigns conn->tempaddr[1] accordingly */
 1404|       |
 1405|  2.93k|  DEBUGF(infof(data, "family0 == %s, family1 == %s",
 1406|  2.93k|               conn->tempfamily[0] == AF_INET ? "v4" : "v6",
 1407|  2.93k|               conn->tempfamily[1] == AF_INET ? "v4" : "v6"));
 1408|       |
 1409|       |  /* get through the list in family order in case of quick failures */
 1410|  5.87k|  for(i = 0; (i < 2) && result; i++) {
 1411|  2.95k|    while(conn->tempaddr[i]) {
 1412|  2.93k|      result = singleipconnect(data, conn, conn->tempaddr[i], i);
 1413|  2.93k|      if(!result)
 1414|  2.92k|        break;
 1415|      9|      ainext(conn, i, TRUE);
 1416|      9|    }
 1417|  2.94k|  }
 1418|  2.93k|  if(result)
 1419|      9|    return result;
 1420|       |
 1421|  2.92k|  Curl_expire(data, data->set.happy_eyeballs_timeout,
 1422|  2.92k|              EXPIRE_HAPPY_EYEBALLS);
 1423|       |
 1424|  2.92k|  return CURLE_OK;
 1425|  2.93k|}
Curl_closesocket:
 1518|  2.92k|{
 1519|  2.92k|  if(conn && conn->fclosesocket) {
 1520|      0|    if((sock == conn->sock[SECONDARYSOCKET]) && conn->bits.sock_accepted)
 1521|       |      /* if this socket matches the second socket, and that was created with
 1522|       |         accept, then we MUST NOT call the callback but clear the accepted
 1523|       |         status */
 1524|      0|      conn->bits.sock_accepted = FALSE;
 1525|      0|    else {
 1526|      0|      int rc;
 1527|      0|      Curl_multi_closed(data, sock);
 1528|      0|      Curl_set_in_callback(data, true);
 1529|      0|      rc = conn->fclosesocket(conn->closesocket_client, sock);
 1530|      0|      Curl_set_in_callback(data, false);
 1531|      0|      return rc;
 1532|      0|    }
 1533|      0|  }
 1534|       |
 1535|  2.92k|  if(conn)
 1536|       |    /* tell the multi-socket code about this */
 1537|  2.92k|    Curl_multi_closed(data, sock);
 1538|       |
 1539|  2.92k|  sclose(sock);
 1540|       |
 1541|  2.92k|  return 0;
 1542|  2.92k|}
Curl_socket:
 1557|  2.93k|{
 1558|  2.93k|  struct connectdata *conn = data->conn;
 1559|  2.93k|  struct Curl_sockaddr_ex dummy;
 1560|       |
 1561|  2.93k|  if(!addr)
 1562|       |    /* if the caller doesn't want info back, use a local temp copy */
 1563|      0|    addr = &dummy;
 1564|       |
 1565|       |  /*
 1566|       |   * The Curl_sockaddr_ex structure is basically libcurl's external API
 1567|       |   * curl_sockaddr structure with enough space available to directly hold
 1568|       |   * any protocol-specific address structures. The variable declared here
 1569|       |   * will be used to pass / receive data to/from the fopensocket callback
 1570|       |   * if this has been set, before that, it is initialized from parameters.
 1571|       |   */
 1572|       |
 1573|  2.93k|  addr->family = ai->ai_family;
 1574|  2.93k|  addr->socktype = (conn->transport == TRNSPRT_TCP) ? SOCK_STREAM : SOCK_DGRAM;
 1575|  2.93k|  addr->protocol = conn->transport != TRNSPRT_TCP ? IPPROTO_UDP :
 1576|  2.93k|    ai->ai_protocol;
 1577|  2.93k|  addr->addrlen = ai->ai_addrlen;
 1578|       |
 1579|  2.93k|  if(addr->addrlen > sizeof(struct Curl_sockaddr_storage))
 1580|      0|     addr->addrlen = sizeof(struct Curl_sockaddr_storage);
 1581|  2.93k|  memcpy(&addr->sa_addr, ai->ai_addr, addr->addrlen);
 1582|       |
 1583|  2.93k|  if(data->set.fopensocket) {
 1584|       |   /*
 1585|       |    * If the opensocket callback is set, all the destination address
 1586|       |    * information is passed to the callback. Depending on this information the
 1587|       |    * callback may opt to abort the connection, this is indicated returning
 1588|       |    * CURL_SOCKET_BAD; otherwise it will return a not-connected socket. When
 1589|       |    * the callback returns a valid socket the destination address information
 1590|       |    * might have been changed and this 'new' address will actually be used
 1591|       |    * here to connect.
 1592|       |    */
 1593|  2.93k|    Curl_set_in_callback(data, true);
 1594|  2.93k|    *sockfd = data->set.fopensocket(data->set.opensocket_client,
 1595|  2.93k|                                    CURLSOCKTYPE_IPCXN,
 1596|  2.93k|                                    (struct curl_sockaddr *)addr);
 1597|  2.93k|    Curl_set_in_callback(data, false);
 1598|  2.93k|  }
 1599|      0|  else
 1600|       |    /* opensocket callback not set, so simply create the socket now */
 1601|      0|    *sockfd = socket(addr->family, addr->socktype, addr->protocol);
 1602|       |
 1603|  2.93k|  if(*sockfd == CURL_SOCKET_BAD)
 1604|       |    /* no socket, no connection */
 1605|      9|    return CURLE_COULDNT_CONNECT;
 1606|       |
 1607|  2.92k|  if(conn->transport == TRNSPRT_QUIC) {
 1608|       |    /* QUIC sockets need to be nonblocking */
 1609|      0|    (void)curlx_nonblock(*sockfd, TRUE);
 1610|      0|  }
 1611|       |
 1612|  2.92k|#if defined(ENABLE_IPV6) && defined(HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID)
 1613|  2.92k|  if(conn->scope_id && (addr->family == AF_INET6)) {
 1614|      0|    struct sockaddr_in6 * const sa6 = (void *)&addr->sa_addr;
 1615|      0|    sa6->sin6_scope_id = conn->scope_id;
 1616|      0|  }
 1617|  2.92k|#endif
 1618|       |
 1619|  2.92k|#if defined(__linux__) && defined(IP_RECVERR)
 1620|  2.92k|  if(addr->socktype == SOCK_DGRAM) {
 1621|      5|    int one = 1;
 1622|      5|    switch(addr->family) {
 1623|      5|    case AF_INET:
 1624|      5|      (void)setsockopt(*sockfd, SOL_IP, IP_RECVERR, &one, sizeof(one));
 1625|      5|      break;
 1626|      0|    case AF_INET6:
 1627|      0|      (void)setsockopt(*sockfd, SOL_IPV6, IPV6_RECVERR, &one, sizeof(one));
 1628|      0|      break;
 1629|      5|    }
 1630|      5|  }
 1631|  2.92k|#endif
 1632|       |
 1633|  2.92k|  return CURLE_OK;
 1634|  2.92k|}
Curl_conncontrol:
 1645|  12.0k|{
 1646|       |  /* close if a connection, or a stream that isn't multiplexed. */
 1647|       |  /* This function will be called both before and after this connection is
 1648|       |     associated with a transfer. */
 1649|  12.0k|  bool closeit;
 1650|  12.0k|  DEBUGASSERT(conn);
 1651|  12.0k|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
 1652|  12.0k|  (void)reason; /* useful for debugging */
 1653|  12.0k|#endif
 1654|  12.0k|  closeit = (ctrl == CONNCTRL_CONNECTION) ||
 1655|  12.0k|    ((ctrl == CONNCTRL_STREAM) && !(conn->handler->flags & PROTOPT_STREAM));
 1656|  12.0k|  if((ctrl == CONNCTRL_STREAM) &&
 1657|  12.0k|     (conn->handler->flags & PROTOPT_STREAM))
 1658|      0|    ;
 1659|  12.0k|  else if((bit)closeit != conn->bits.close) {
 1660|  8.74k|    conn->bits.close = closeit; /* the only place in the source code that
 1661|       |                                   should assign this bit */
 1662|  8.74k|  }
 1663|  12.0k|}
connect.c:connect_SOCKS:
  772|  2.92k|{
  773|  2.92k|  CURLcode result = CURLE_OK;
  774|  2.92k|#ifndef CURL_DISABLE_PROXY
  775|  2.92k|  CURLproxycode pxresult = CURLPX_OK;
  776|  2.92k|  struct connectdata *conn = data->conn;
  777|  2.92k|  if(conn->bits.socksproxy) {
  778|       |    /* for the secondary socket (FTP), use the "connect to host"
  779|       |     * but ignore the "connect to port" (use the secondary port)
  780|       |     */
  781|      0|    const char * const host =
  782|      0|      conn->bits.httpproxy ?
  783|      0|      conn->http_proxy.host.name :
  784|      0|      conn->bits.conn_to_host ?
  785|      0|      conn->conn_to_host.name :
  786|      0|      sockindex == SECONDARYSOCKET ?
  787|      0|      conn->secondaryhostname : conn->host.name;
  788|      0|    const int port =
  789|      0|      conn->bits.httpproxy ? (int)conn->http_proxy.port :
  790|      0|      sockindex == SECONDARYSOCKET ? conn->secondary_port :
  791|      0|      conn->bits.conn_to_port ? conn->conn_to_port :
  792|      0|      conn->remote_port;
  793|      0|    switch(conn->socks_proxy.proxytype) {
  794|      0|    case CURLPROXY_SOCKS5:
  795|      0|    case CURLPROXY_SOCKS5_HOSTNAME:
  796|      0|      pxresult = Curl_SOCKS5(conn->socks_proxy.user, conn->socks_proxy.passwd,
  797|      0|                             host, port, sockindex, data, done);
  798|      0|      break;
  799|       |
  800|      0|    case CURLPROXY_SOCKS4:
  801|      0|    case CURLPROXY_SOCKS4A:
  802|      0|      pxresult = Curl_SOCKS4(conn->socks_proxy.user, host, port, sockindex,
  803|      0|                             data, done);
  804|      0|      break;
  805|       |
  806|      0|    default:
  807|      0|      failf(data, "unknown proxytype option given");
  808|      0|      result = CURLE_COULDNT_CONNECT;
  809|      0|    } /* switch proxytype */
  810|      0|    if(pxresult) {
  811|      0|      result = CURLE_PROXY;
  812|      0|      data->info.pxcode = pxresult;
  813|      0|    }
  814|      0|  }
  815|  2.92k|  else
  816|       |#else
  817|       |    (void)data;
  818|       |    (void)sockindex;
  819|       |#endif /* CURL_DISABLE_PROXY */
  820|  2.92k|    *done = TRUE; /* no SOCKS proxy, so consider us connected */
  821|       |
  822|  2.92k|  return result;
  823|  2.92k|}
connect.c:post_SOCKS:
  833|  2.92k|{
  834|  2.92k|  conn->bits.tcpconnect[sockindex] = TRUE;
  835|       |
  836|  2.92k|  *connected = TRUE;
  837|  2.92k|  if(sockindex == FIRSTSOCKET)
  838|  2.92k|    Curl_pgrsTime(data, TIMER_CONNECT); /* connect done */
  839|  2.92k|  Curl_updateconninfo(data, conn, conn->sock[sockindex]);
  840|  2.92k|  Curl_verboseconnect(data, conn);
  841|  2.92k|  data->info.numconnects++; /* to track the number of connections made */
  842|  2.92k|}
connect.c:verifyconnect:
  494|  2.92k|{
  495|  2.92k|  bool rc = TRUE;
  496|  2.92k|#ifdef SO_ERROR
  497|  2.92k|  int err = 0;
  498|  2.92k|  curl_socklen_t errSize = sizeof(err);
  499|       |
  500|       |#ifdef WIN32
  501|       |  /*
  502|       |   * In October 2003 we effectively nullified this function on Windows due to
  503|       |   * problems with it using all CPU in multi-threaded cases.
  504|       |   *
  505|       |   * In May 2004, we bring it back to offer more info back on connect failures.
  506|       |   * Gisle Vanem could reproduce the former problems with this function, but
  507|       |   * could avoid them by adding this SleepEx() call below:
  508|       |   *
  509|       |   *    "I don't have Rational Quantify, but the hint from his post was
  510|       |   *    ntdll::NtRemoveIoCompletion(). So I'd assume the SleepEx (or maybe
  511|       |   *    just Sleep(0) would be enough?) would release whatever
  512|       |   *    mutex/critical-section the ntdll call is waiting on.
  513|       |   *
  514|       |   *    Someone got to verify this on Win-NT 4.0, 2000."
  515|       |   */
  516|       |
  517|       |#ifdef _WIN32_WCE
  518|       |  Sleep(0);
  519|       |#else
  520|       |  SleepEx(0, FALSE);
  521|       |#endif
  522|       |
  523|       |#endif
  524|       |
  525|  2.92k|  if(0 != getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void *)&err, &errSize))
  526|      0|    err = SOCKERRNO;
  527|       |#ifdef _WIN32_WCE
  528|       |  /* Old WinCE versions don't support SO_ERROR */
  529|       |  if(WSAENOPROTOOPT == err) {
  530|       |    SET_SOCKERRNO(0);
  531|       |    err = 0;
  532|       |  }
  533|       |#endif
  534|       |#if defined(EBADIOCTL) && defined(__minix)
  535|       |  /* Minix 3.1.x doesn't support getsockopt on UDP sockets */
  536|       |  if(EBADIOCTL == err) {
  537|       |    SET_SOCKERRNO(0);
  538|       |    err = 0;
  539|       |  }
  540|       |#endif
  541|  2.92k|  if((0 == err) || (EISCONN == err))
  542|       |    /* we are connected, awesome! */
  543|  2.92k|    rc = TRUE;
  544|      0|  else
  545|       |    /* This wasn't a successful connect */
  546|      0|    rc = FALSE;
  547|  2.92k|  if(error)
  548|  2.92k|    *error = err;
  549|       |#else
  550|       |  (void)sockfd;
  551|       |  if(error)
  552|       |    *error = SOCKERRNO;
  553|       |#endif
  554|  2.92k|  return rc;
  555|  2.92k|}
connect.c:ainext:
  562|  2.94k|{
  563|  2.94k|  struct Curl_addrinfo *ai = conn->tempaddr[tempindex];
  564|  2.94k|  if(ai && next)
  565|      9|    ai = ai->ai_next;
  566|  5.87k|  while(ai && (ai->ai_family != conn->tempfamily[tempindex]))
  567|  2.93k|    ai = ai->ai_next;
  568|  2.94k|  conn->tempaddr[tempindex] = ai;
  569|  2.94k|  return ai;
  570|  2.94k|}
connect.c:singleipconnect:
 1161|  2.93k|{
 1162|  2.93k|  struct Curl_sockaddr_ex addr;
 1163|  2.93k|  int rc = -1;
 1164|  2.93k|  int error = 0;
 1165|  2.93k|  bool isconnected = FALSE;
 1166|  2.93k|  curl_socket_t sockfd;
 1167|  2.93k|  CURLcode result;
 1168|  2.93k|  char ipaddress[MAX_IPADR_LEN];
 1169|  2.93k|  int port;
 1170|  2.93k|  bool is_tcp;
 1171|  2.93k|#ifdef TCP_FASTOPEN_CONNECT
 1172|  2.93k|  int optval = 1;
 1173|  2.93k|#endif
 1174|  2.93k|  char buffer[STRERROR_LEN];
 1175|  2.93k|  curl_socket_t *sockp = &conn->tempsock[tempindex];
 1176|  2.93k|  *sockp = CURL_SOCKET_BAD;
 1177|       |
 1178|  2.93k|  result = Curl_socket(data, ai, &addr, &sockfd);
 1179|  2.93k|  if(result)
 1180|      9|    return result;
 1181|       |
 1182|       |  /* store remote address and port used in this connection attempt */
 1183|  2.92k|  if(!Curl_addr2string((struct sockaddr*)&addr.sa_addr, addr.addrlen,
 1184|  2.92k|                       ipaddress, &port)) {
 1185|       |    /* malformed address or bug in inet_ntop, try next address */
 1186|      0|    failf(data, "sa_addr inet_ntop() failed with errno %d: %s",
 1187|      0|          errno, Curl_strerror(errno, buffer, sizeof(buffer)));
 1188|      0|    Curl_closesocket(data, conn, sockfd);
 1189|      0|    return CURLE_OK;
 1190|      0|  }
 1191|  2.92k|  infof(data, "  Trying %s:%d...", ipaddress, port);
 1192|       |
 1193|  2.92k|#ifdef ENABLE_IPV6
 1194|  2.92k|  is_tcp = (addr.family == AF_INET || addr.family == AF_INET6) &&
 1195|  2.92k|    addr.socktype == SOCK_STREAM;
 1196|       |#else
 1197|       |  is_tcp = (addr.family == AF_INET) && addr.socktype == SOCK_STREAM;
 1198|       |#endif
 1199|  2.92k|  if(is_tcp && data->set.tcp_nodelay)
 1200|  2.91k|    tcpnodelay(data, sockfd);
 1201|       |
 1202|  2.92k|  nosigpipe(data, sockfd);
 1203|       |
 1204|  2.92k|  Curl_sndbufset(sockfd);
 1205|       |
 1206|  2.92k|  if(is_tcp && data->set.tcp_keepalive)
 1207|      0|    tcpkeepalive(data, sockfd);
 1208|       |
 1209|  2.92k|  if(data->set.fsockopt) {
 1210|       |    /* activate callback for setting socket options */
 1211|  2.92k|    Curl_set_in_callback(data, true);
 1212|  2.92k|    error = data->set.fsockopt(data->set.sockopt_client,
 1213|  2.92k|                               sockfd,
 1214|  2.92k|                               CURLSOCKTYPE_IPCXN);
 1215|  2.92k|    Curl_set_in_callback(data, false);
 1216|       |
 1217|  2.92k|    if(error == CURL_SOCKOPT_ALREADY_CONNECTED)
 1218|  2.92k|      isconnected = TRUE;
 1219|      0|    else if(error) {
 1220|      0|      Curl_closesocket(data, conn, sockfd); /* close the socket and bail out */
 1221|      0|      return CURLE_ABORTED_BY_CALLBACK;
 1222|      0|    }
 1223|  2.92k|  }
 1224|       |
 1225|       |  /* possibly bind the local end to an IP, interface or port */
 1226|  2.92k|  if(addr.family == AF_INET
 1227|  2.92k|#ifdef ENABLE_IPV6
 1228|  2.92k|     || addr.family == AF_INET6
 1229|  2.92k|#endif
 1230|  2.92k|    ) {
 1231|  2.92k|    result = bindlocal(data, sockfd, addr.family,
 1232|  2.92k|                       Curl_ipv6_scope((struct sockaddr*)&addr.sa_addr));
 1233|  2.92k|    if(result) {
 1234|      0|      Curl_closesocket(data, conn, sockfd); /* close socket and bail out */
 1235|      0|      if(result == CURLE_UNSUPPORTED_PROTOCOL) {
 1236|       |        /* The address family is not supported on this interface.
 1237|       |           We can continue trying addresses */
 1238|      0|        return CURLE_COULDNT_CONNECT;
 1239|      0|      }
 1240|      0|      return result;
 1241|      0|    }
 1242|  2.92k|  }
 1243|       |
 1244|       |  /* set socket non-blocking */
 1245|  2.92k|  (void)curlx_nonblock(sockfd, TRUE);
 1246|       |
 1247|  2.92k|  conn->connecttime = Curl_now();
 1248|  2.92k|  if(conn->num_addr > 1) {
 1249|      0|    Curl_expire(data, conn->timeoutms_per_addr[0], EXPIRE_DNS_PER_NAME);
 1250|      0|    Curl_expire(data, conn->timeoutms_per_addr[1], EXPIRE_DNS_PER_NAME2);
 1251|      0|  }
 1252|       |
 1253|       |  /* Connect TCP and QUIC sockets */
 1254|  2.92k|  if(!isconnected && (conn->transport != TRNSPRT_UDP)) {
 1255|      0|    if(conn->bits.tcp_fastopen) {
 1256|       |#if defined(CONNECT_DATA_IDEMPOTENT) /* Darwin */
 1257|       |#  if defined(HAVE_BUILTIN_AVAILABLE)
 1258|       |      /* while connectx function is available since macOS 10.11 / iOS 9,
 1259|       |         it did not have the interface declared correctly until
 1260|       |         Xcode 9 / macOS SDK 10.13 */
 1261|       |      if(__builtin_available(macOS 10.11, iOS 9.0, tvOS 9.0, watchOS 2.0, *)) {
 1262|       |        sa_endpoints_t endpoints;
 1263|       |        endpoints.sae_srcif = 0;
 1264|       |        endpoints.sae_srcaddr = NULL;
 1265|       |        endpoints.sae_srcaddrlen = 0;
 1266|       |        endpoints.sae_dstaddr = &addr.sa_addr;
 1267|       |        endpoints.sae_dstaddrlen = addr.addrlen;
 1268|       |
 1269|       |        rc = connectx(sockfd, &endpoints, SAE_ASSOCID_ANY,
 1270|       |                      CONNECT_RESUME_ON_READ_WRITE | CONNECT_DATA_IDEMPOTENT,
 1271|       |                      NULL, 0, NULL, NULL);
 1272|       |      }
 1273|       |      else {
 1274|       |        rc = connect(sockfd, &addr.sa_addr, addr.addrlen);
 1275|       |      }
 1276|       |#  else
 1277|       |      rc = connect(sockfd, &addr.sa_addr, addr.addrlen);
 1278|       |#  endif /* HAVE_BUILTIN_AVAILABLE */
 1279|       |#elif defined(TCP_FASTOPEN_CONNECT) /* Linux >= 4.11 */
 1280|      0|      if(setsockopt(sockfd, IPPROTO_TCP, TCP_FASTOPEN_CONNECT,
 1281|      0|                    (void *)&optval, sizeof(optval)) < 0)
 1282|      0|        infof(data, "Failed to enable TCP Fast Open on fd %d", sockfd);
 1283|       |
 1284|      0|      rc = connect(sockfd, &addr.sa_addr, addr.addrlen);
 1285|       |#elif defined(MSG_FASTOPEN) /* old Linux */
 1286|       |      if(conn->given->flags & PROTOPT_SSL)
 1287|       |        rc = connect(sockfd, &addr.sa_addr, addr.addrlen);
 1288|       |      else
 1289|       |        rc = 0; /* Do nothing */
 1290|       |#endif
 1291|      0|    }
 1292|      0|    else {
 1293|      0|      rc = connect(sockfd, &addr.sa_addr, addr.addrlen);
 1294|      0|    }
 1295|       |
 1296|      0|    if(-1 == rc)
 1297|      0|      error = SOCKERRNO;
 1298|       |#ifdef ENABLE_QUIC
 1299|       |    else if(conn->transport == TRNSPRT_QUIC) {
 1300|       |      /* pass in 'sockfd' separately since it hasn't been put into the
 1301|       |         tempsock array at this point */
 1302|       |      result = Curl_quic_connect(data, conn, sockfd, tempindex,
 1303|       |                                 &addr.sa_addr, addr.addrlen);
 1304|       |      if(result)
 1305|       |        error = SOCKERRNO;
 1306|       |    }
 1307|       |#endif
 1308|      0|  }
 1309|  2.92k|  else {
 1310|  2.92k|    *sockp = sockfd;
 1311|  2.92k|    return CURLE_OK;
 1312|  2.92k|  }
 1313|       |
 1314|      0|  if(-1 == rc) {
 1315|      0|    switch(error) {
 1316|      0|    case EINPROGRESS:
 1317|      0|    case EWOULDBLOCK:
 1318|      0|#if defined(EAGAIN)
 1319|       |#if (EAGAIN) != (EWOULDBLOCK)
 1320|       |      /* On some platforms EAGAIN and EWOULDBLOCK are the
 1321|       |       * same value, and on others they are different, hence
 1322|       |       * the odd #if
 1323|       |       */
 1324|       |    case EAGAIN:
 1325|       |#endif
 1326|      0|#endif
 1327|      0|      result = CURLE_OK;
 1328|      0|      break;
 1329|       |
 1330|      0|    default:
 1331|       |      /* unknown error, fallthrough and try another address! */
 1332|      0|      infof(data, "Immediate connect fail for %s: %s",
 1333|      0|            ipaddress, Curl_strerror(error, buffer, sizeof(buffer)));
 1334|      0|      data->state.os_errno = error;
 1335|       |
 1336|       |      /* connect failed */
 1337|      0|      Curl_closesocket(data, conn, sockfd);
 1338|      0|      result = CURLE_COULDNT_CONNECT;
 1339|      0|    }
 1340|      0|  }
 1341|       |
 1342|      0|  if(!result)
 1343|      0|    *sockp = sockfd;
 1344|       |
 1345|      0|  return result;
 1346|      0|}
connect.c:tcpnodelay:
 1062|  2.91k|{
 1063|  2.91k|#if defined(TCP_NODELAY)
 1064|  2.91k|  curl_socklen_t onoff = (curl_socklen_t) 1;
 1065|  2.91k|  int level = IPPROTO_TCP;
 1066|  2.91k|#if !defined(CURL_DISABLE_VERBOSE_STRINGS)
 1067|  2.91k|  char buffer[STRERROR_LEN];
 1068|       |#else
 1069|       |  (void) data;
 1070|       |#endif
 1071|       |
 1072|  2.91k|  if(setsockopt(sockfd, level, TCP_NODELAY, (void *)&onoff,
 1073|  2.91k|                sizeof(onoff)) < 0)
 1074|  2.91k|    infof(data, "Could not set TCP_NODELAY: %s",
 1075|  2.91k|          Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));
 1076|       |#else
 1077|       |  (void)data;
 1078|       |  (void)sockfd;
 1079|       |#endif
 1080|  2.91k|}
connect.c:bindlocal:
  240|  2.92k|{
  241|  2.92k|  struct connectdata *conn = data->conn;
  242|  2.92k|  struct Curl_sockaddr_storage sa;
  243|  2.92k|  struct sockaddr *sock = (struct sockaddr *)&sa;  /* bind to this address */
  244|  2.92k|  curl_socklen_t sizeof_sa = 0; /* size of the data sock points to */
  245|  2.92k|  struct sockaddr_in *si4 = (struct sockaddr_in *)&sa;
  246|  2.92k|#ifdef ENABLE_IPV6
  247|  2.92k|  struct sockaddr_in6 *si6 = (struct sockaddr_in6 *)&sa;
  248|  2.92k|#endif
  249|       |
  250|  2.92k|  struct Curl_dns_entry *h = NULL;
  251|  2.92k|  unsigned short port = data->set.localport; /* use this port number, 0 for
  252|       |                                                "random" */
  253|       |  /* how many port numbers to try to bind to, increasing one at a time */
  254|  2.92k|  int portnum = data->set.localportrange;
  255|  2.92k|  const char *dev = data->set.str[STRING_DEVICE];
  256|  2.92k|  int error;
  257|  2.92k|#ifdef IP_BIND_ADDRESS_NO_PORT
  258|  2.92k|  int on = 1;
  259|  2.92k|#endif
  260|       |
  261|       |  /*************************************************************
  262|       |   * Select device to bind socket to
  263|       |   *************************************************************/
  264|  2.92k|  if(!dev && !port)
  265|       |    /* no local kind of binding was requested */
  266|  2.92k|    return CURLE_OK;
  267|       |
  268|      0|  memset(&sa, 0, sizeof(struct Curl_sockaddr_storage));
  269|       |
  270|      0|  if(dev && (strlen(dev)<255) ) {
  271|      0|    char myhost[256] = "";
  272|      0|    int done = 0; /* -1 for error, 1 for address found */
  273|      0|    bool is_interface = FALSE;
  274|      0|    bool is_host = FALSE;
  275|      0|    static const char *if_prefix = "if!";
  276|      0|    static const char *host_prefix = "host!";
  277|       |
  278|      0|    if(strncmp(if_prefix, dev, strlen(if_prefix)) == 0) {
  279|      0|      dev += strlen(if_prefix);
  280|      0|      is_interface = TRUE;
  281|      0|    }
  282|      0|    else if(strncmp(host_prefix, dev, strlen(host_prefix)) == 0) {
  283|      0|      dev += strlen(host_prefix);
  284|      0|      is_host = TRUE;
  285|      0|    }
  286|       |
  287|       |    /* interface */
  288|      0|    if(!is_host) {
  289|      0|#ifdef SO_BINDTODEVICE
  290|       |      /* I am not sure any other OSs than Linux that provide this feature,
  291|       |       * and at the least I cannot test. --Ben
  292|       |       *
  293|       |       * This feature allows one to tightly bind the local socket to a
  294|       |       * particular interface.  This will force even requests to other
  295|       |       * local interfaces to go out the external interface.
  296|       |       *
  297|       |       *
  298|       |       * Only bind to the interface when specified as interface, not just
  299|       |       * as a hostname or ip address.
  300|       |       *
  301|       |       * interface might be a VRF, eg: vrf-blue, which means it cannot be
  302|       |       * converted to an IP address and would fail Curl_if2ip. Simply try
  303|       |       * to use it straight away.
  304|       |       */
  305|      0|      if(setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
  306|      0|                    dev, (curl_socklen_t)strlen(dev) + 1) == 0) {
  307|       |        /* This is typically "errno 1, error: Operation not permitted" if
  308|       |         * you're not running as root or another suitable privileged
  309|       |         * user.
  310|       |         * If it succeeds it means the parameter was a valid interface and
  311|       |         * not an IP address. Return immediately.
  312|       |         */
  313|      0|        return CURLE_OK;
  314|      0|      }
  315|      0|#endif
  316|       |
  317|      0|      switch(Curl_if2ip(af, scope, conn->scope_id, dev,
  318|      0|                        myhost, sizeof(myhost))) {
  319|      0|        case IF2IP_NOT_FOUND:
  320|      0|          if(is_interface) {
  321|       |            /* Do not fall back to treating it as a host name */
  322|      0|            failf(data, "Couldn't bind to interface '%s'", dev);
  323|      0|            return CURLE_INTERFACE_FAILED;
  324|      0|          }
  325|      0|          break;
  326|      0|        case IF2IP_AF_NOT_SUPPORTED:
  327|       |          /* Signal the caller to try another address family if available */
  328|      0|          return CURLE_UNSUPPORTED_PROTOCOL;
  329|      0|        case IF2IP_FOUND:
  330|      0|          is_interface = TRUE;
  331|       |          /*
  332|       |           * We now have the numerical IP address in the 'myhost' buffer
  333|       |           */
  334|      0|          infof(data, "Local Interface %s is ip %s using address family %i",
  335|      0|                dev, myhost, af);
  336|      0|          done = 1;
  337|      0|          break;
  338|      0|      }
  339|      0|    }
  340|      0|    if(!is_interface) {
  341|       |      /*
  342|       |       * This was not an interface, resolve the name as a host name
  343|       |       * or IP number
  344|       |       *
  345|       |       * Temporarily force name resolution to use only the address type
  346|       |       * of the connection. The resolve functions should really be changed
  347|       |       * to take a type parameter instead.
  348|       |       */
  349|      0|      unsigned char ipver = conn->ip_version;
  350|      0|      int rc;
  351|       |
  352|      0|      if(af == AF_INET)
  353|      0|        conn->ip_version = CURL_IPRESOLVE_V4;
  354|      0|#ifdef ENABLE_IPV6
  355|      0|      else if(af == AF_INET6)
  356|      0|        conn->ip_version = CURL_IPRESOLVE_V6;
  357|      0|#endif
  358|       |
  359|      0|      rc = Curl_resolv(data, dev, 0, FALSE, &h);
  360|      0|      if(rc == CURLRESOLV_PENDING)
  361|      0|        (void)Curl_resolver_wait_resolv(data, &h);
  362|      0|      conn->ip_version = ipver;
  363|       |
  364|      0|      if(h) {
  365|       |        /* convert the resolved address, sizeof myhost >= INET_ADDRSTRLEN */
  366|      0|        Curl_printable_address(h->addr, myhost, sizeof(myhost));
  367|      0|        infof(data, "Name '%s' family %i resolved to '%s' family %i",
  368|      0|              dev, af, myhost, h->addr->ai_family);
  369|      0|        Curl_resolv_unlock(data, h);
  370|      0|        if(af != h->addr->ai_family) {
  371|       |          /* bad IP version combo, signal the caller to try another address
  372|       |             family if available */
  373|      0|          return CURLE_UNSUPPORTED_PROTOCOL;
  374|      0|        }
  375|      0|        done = 1;
  376|      0|      }
  377|      0|      else {
  378|       |        /*
  379|       |         * provided dev was no interface (or interfaces are not supported
  380|       |         * e.g. solaris) no ip address and no domain we fail here
  381|       |         */
  382|      0|        done = -1;
  383|      0|      }
  384|      0|    }
  385|       |
  386|      0|    if(done > 0) {
  387|      0|#ifdef ENABLE_IPV6
  388|       |      /* IPv6 address */
  389|      0|      if(af == AF_INET6) {
  390|      0|#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
  391|      0|        char *scope_ptr = strchr(myhost, '%');
  392|      0|        if(scope_ptr)
  393|      0|          *(scope_ptr++) = 0;
  394|      0|#endif
  395|      0|        if(Curl_inet_pton(AF_INET6, myhost, &si6->sin6_addr) > 0) {
  396|      0|          si6->sin6_family = AF_INET6;
  397|      0|          si6->sin6_port = htons(port);
  398|      0|#ifdef HAVE_SOCKADDR_IN6_SIN6_SCOPE_ID
  399|      0|          if(scope_ptr)
  400|       |            /* The "myhost" string either comes from Curl_if2ip or from
  401|       |               Curl_printable_address. The latter returns only numeric scope
  402|       |               IDs and the former returns none at all.  So the scope ID, if
  403|       |               present, is known to be numeric */
  404|      0|            si6->sin6_scope_id = atoi(scope_ptr);
  405|      0|#endif
  406|      0|        }
  407|      0|        sizeof_sa = sizeof(struct sockaddr_in6);
  408|      0|      }
  409|      0|      else
  410|      0|#endif
  411|       |      /* IPv4 address */
  412|      0|      if((af == AF_INET) &&
  413|      0|         (Curl_inet_pton(AF_INET, myhost, &si4->sin_addr) > 0)) {
  414|      0|        si4->sin_family = AF_INET;
  415|      0|        si4->sin_port = htons(port);
  416|      0|        sizeof_sa = sizeof(struct sockaddr_in);
  417|      0|      }
  418|      0|    }
  419|       |
  420|      0|    if(done < 1) {
  421|       |      /* errorbuf is set false so failf will overwrite any message already in
  422|       |         the error buffer, so the user receives this error message instead of a
  423|       |         generic resolve error. */
  424|      0|      data->state.errorbuf = FALSE;
  425|      0|      failf(data, "Couldn't bind to '%s'", dev);
  426|      0|      return CURLE_INTERFACE_FAILED;
  427|      0|    }
  428|      0|  }
  429|      0|  else {
  430|       |    /* no device was given, prepare sa to match af's needs */
  431|      0|#ifdef ENABLE_IPV6
  432|      0|    if(af == AF_INET6) {
  433|      0|      si6->sin6_family = AF_INET6;
  434|      0|      si6->sin6_port = htons(port);
  435|      0|      sizeof_sa = sizeof(struct sockaddr_in6);
  436|      0|    }
  437|      0|    else
  438|      0|#endif
  439|      0|    if(af == AF_INET) {
  440|      0|      si4->sin_family = AF_INET;
  441|      0|      si4->sin_port = htons(port);
  442|      0|      sizeof_sa = sizeof(struct sockaddr_in);
  443|      0|    }
  444|      0|  }
  445|      0|#ifdef IP_BIND_ADDRESS_NO_PORT
  446|      0|  (void)setsockopt(sockfd, SOL_IP, IP_BIND_ADDRESS_NO_PORT, &on, sizeof(on));
  447|      0|#endif
  448|      0|  for(;;) {
  449|      0|    if(bind(sockfd, sock, sizeof_sa) >= 0) {
  450|       |      /* we succeeded to bind */
  451|      0|      struct Curl_sockaddr_storage add;
  452|      0|      curl_socklen_t size = sizeof(add);
  453|      0|      memset(&add, 0, sizeof(struct Curl_sockaddr_storage));
  454|      0|      if(getsockname(sockfd, (struct sockaddr *) &add, &size) < 0) {
  455|      0|        char buffer[STRERROR_LEN];
  456|      0|        data->state.os_errno = error = SOCKERRNO;
  457|      0|        failf(data, "getsockname() failed with errno %d: %s",
  458|      0|              error, Curl_strerror(error, buffer, sizeof(buffer)));
  459|      0|        return CURLE_INTERFACE_FAILED;
  460|      0|      }
  461|      0|      infof(data, "Local port: %hu", port);
  462|      0|      conn->bits.bound = TRUE;
  463|      0|      return CURLE_OK;
  464|      0|    }
  465|       |
  466|      0|    if(--portnum > 0) {
  467|      0|      infof(data, "Bind to local port %hu failed, trying next", port);
  468|      0|      port++; /* try next port */
  469|       |      /* We re-use/clobber the port variable here below */
  470|      0|      if(sock->sa_family == AF_INET)
  471|      0|        si4->sin_port = ntohs(port);
  472|      0|#ifdef ENABLE_IPV6
  473|      0|      else
  474|      0|        si6->sin6_port = ntohs(port);
  475|      0|#endif
  476|      0|    }
  477|      0|    else
  478|      0|      break;
  479|      0|  }
  480|      0|  {
  481|      0|    char buffer[STRERROR_LEN];
  482|      0|    data->state.os_errno = error = SOCKERRNO;
  483|      0|    failf(data, "bind failed with errno %d: %s",
  484|      0|          error, Curl_strerror(error, buffer, sizeof(buffer)));
  485|      0|  }
  486|       |
  487|      0|  return CURLE_INTERFACE_FAILED;
  488|      0|}

Curl_all_content_encodings:
  853|    132|{
  854|    132|  size_t len = 0;
  855|    132|  const struct content_encoding * const *cep;
  856|    132|  const struct content_encoding *ce;
  857|    132|  char *ace;
  858|       |
  859|    528|  for(cep = encodings; *cep; cep++) {
  860|    396|    ce = *cep;
  861|    396|    if(!strcasecompare(ce->name, CONTENT_ENCODING_DEFAULT))
  862|    264|      len += strlen(ce->name) + 2;
  863|    396|  }
  864|       |
  865|    132|  if(!len)
  866|      0|    return strdup(CONTENT_ENCODING_DEFAULT);
  867|       |
  868|    132|  ace = malloc(len);
  869|    132|  if(ace) {
  870|    132|    char *p = ace;
  871|    528|    for(cep = encodings; *cep; cep++) {
  872|    396|      ce = *cep;
  873|    396|      if(!strcasecompare(ce->name, CONTENT_ENCODING_DEFAULT)) {
  874|    264|        strcpy(p, ce->name);
  875|    264|        p += strlen(p);
  876|    264|        *p++ = ',';
  877|    264|        *p++ = ' ';
  878|    264|      }
  879|    396|    }
  880|    132|    p[-2] = '\0';
  881|    132|  }
  882|       |
  883|    132|  return ace;
  884|    132|}
Curl_unencode_write:
  994|    226|{
  995|    226|  if(!nbytes)
  996|      0|    return CURLE_OK;
  997|    226|  return writer->handler->unencode_write(data, writer, buf, nbytes);
  998|    226|}
Curl_unencode_cleanup:
 1002|  1.38k|{
 1003|  1.38k|  struct SingleRequest *k = &data->req;
 1004|  1.38k|  struct contenc_writer *writer = k->writer_stack;
 1005|       |
 1006|  2.39k|  while(writer) {
 1007|  1.00k|    k->writer_stack = writer->downstream;
 1008|  1.00k|    writer->handler->close_writer(data, writer);
 1009|  1.00k|    free(writer);
 1010|  1.00k|    writer = k->writer_stack;
 1011|  1.00k|  }
 1012|  1.38k|}
Curl_build_unencoding_stack:
 1033|    891|{
 1034|    891|  struct SingleRequest *k = &data->req;
 1035|       |
 1036|    911|  do {
 1037|    911|    const char *name;
 1038|    911|    size_t namelen;
 1039|       |
 1040|       |    /* Parse a single encoding name. */
 1041|  2.20k|    while(ISSPACE(*enclist) || *enclist == ',')
 1042|  1.29k|      enclist++;
 1043|       |
 1044|    911|    name = enclist;
 1045|       |
 1046|  17.4k|    for(namelen = 0; *enclist && *enclist != ','; enclist++)
 1047|  16.5k|      if(!ISSPACE(*enclist))
 1048|  13.1k|        namelen = enclist - name + 1;
 1049|       |
 1050|       |    /* Special case: chunked encoding is handled at the reader level. */
 1051|    911|    if(maybechunked && namelen == 7 && strncasecompare(name, "chunked", 7)) {
 1052|     27|      k->chunk = TRUE;             /* chunks coming our way. */
 1053|     27|      Curl_httpchunk_init(data);   /* init our chunky engine. */
 1054|     27|    }
 1055|    884|    else if(namelen) {
 1056|    833|      const struct content_encoding *encoding = find_encoding(name, namelen);
 1057|    833|      struct contenc_writer *writer;
 1058|       |
 1059|    833|      if(!k->writer_stack) {
 1060|    171|        k->writer_stack = new_unencoding_writer(data, &client_encoding, NULL);
 1061|       |
 1062|    171|        if(!k->writer_stack)
 1063|      0|          return CURLE_OUT_OF_MEMORY;
 1064|    171|      }
 1065|       |
 1066|    833|      if(!encoding)
 1067|    420|        encoding = &error_encoding;  /* Defer error at stack use. */
 1068|       |
 1069|       |      /* Stack the unencoding stage. */
 1070|    833|      writer = new_unencoding_writer(data, encoding, k->writer_stack);
 1071|    833|      if(!writer)
 1072|      0|        return CURLE_OUT_OF_MEMORY;
 1073|    833|      k->writer_stack = writer;
 1074|    833|    }
 1075|    911|  } while(*enclist);
 1076|       |
 1077|    891|  return CURLE_OK;
 1078|    891|}
content_encoding.c:identity_init_writer:
  805|    293|{
  806|    293|  (void) data;
  807|    293|  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;
  808|    293|}
content_encoding.c:identity_unencode_write:
  813|     53|{
  814|     53|  return Curl_unencode_write(data, writer->downstream, buf, nbytes);
  815|     53|}
content_encoding.c:identity_close_writer:
  819|    293|{
  820|    293|  (void) data;
  821|    293|  (void) writer;
  822|    293|}
content_encoding.c:deflate_init_writer:
  265|     15|{
  266|     15|  struct zlib_params *zp = (struct zlib_params *) &writer->params;
  267|     15|  z_stream *z = &zp->z;     /* zlib state structure */
  268|       |
  269|     15|  if(!writer->downstream)
  270|      0|    return CURLE_WRITE_ERROR;
  271|       |
  272|       |  /* Initialize zlib */
  273|     15|  z->zalloc = (alloc_func) zalloc_cb;
  274|     15|  z->zfree = (free_func) zfree_cb;
  275|       |
  276|     15|  if(inflateInit(z) != Z_OK)
  277|      0|    return process_zlib_error(data, z);
  278|     15|  zp->zlib_init = ZLIB_INIT;
  279|     15|  return CURLE_OK;
  280|     15|}
content_encoding.c:zalloc_cb:
   93|    163|{
   94|    163|  (void) opaque;
   95|       |  /* not a typo, keep it calloc() */
   96|    163|  return (voidpf) calloc(items, size);
   97|    163|}
content_encoding.c:zfree_cb:
  101|    163|{
  102|    163|  (void) opaque;
  103|    163|  free(ptr);
  104|    163|}
content_encoding.c:process_zlib_error:
  108|     61|{
  109|     61|  if(z->msg)
  110|     60|    failf(data, "Error while processing content unencoding: %s",
  111|     60|          z->msg);
  112|      1|  else
  113|      1|    failf(data, "Error while processing content unencoding: "
  114|      1|          "Unknown failure within decompression software.");
  115|       |
  116|     61|  return CURLE_BAD_CONTENT_ENCODING;
  117|     61|}
content_encoding.c:deflate_unencode_write:
  285|      7|{
  286|      7|  struct zlib_params *zp = (struct zlib_params *) &writer->params;
  287|      7|  z_stream *z = &zp->z;     /* zlib state structure */
  288|       |
  289|       |  /* Set the compressed input when this function is called */
  290|      7|  z->next_in = (Bytef *) buf;
  291|      7|  z->avail_in = (uInt) nbytes;
  292|       |
  293|      7|  if(zp->zlib_init == ZLIB_EXTERNAL_TRAILER)
  294|      0|    return process_trailer(data, zp);
  295|       |
  296|       |  /* Now uncompress the data */
  297|      7|  return inflate_stream(data, writer, ZLIB_INFLATING);
  298|      7|}
content_encoding.c:process_trailer:
  137|      1|{
  138|      1|  z_stream *z = &zp->z;
  139|      1|  CURLcode result = CURLE_OK;
  140|      1|  uInt len = z->avail_in < zp->trailerlen? z->avail_in: zp->trailerlen;
  141|       |
  142|       |  /* Consume expected trailer bytes. Terminate stream if exhausted.
  143|       |     Issue an error if unexpected bytes follow. */
  144|       |
  145|      1|  zp->trailerlen -= len;
  146|      1|  z->avail_in -= len;
  147|      1|  z->next_in += len;
  148|      1|  if(z->avail_in)
  149|      0|    result = CURLE_WRITE_ERROR;
  150|      1|  if(result || !zp->trailerlen)
  151|      1|    result = exit_zlib(data, z, &zp->zlib_init, result);
  152|      0|  else {
  153|       |    /* Only occurs for gzip with zlib < 1.2.0.4 or raw deflate. */
  154|      0|    zp->zlib_init = ZLIB_EXTERNAL_TRAILER;
  155|      0|  }
  156|      1|  return result;
  157|      1|}
content_encoding.c:exit_zlib:
  122|    183|{
  123|    183|  if(*zlib_init == ZLIB_GZIP_HEADER)
  124|      0|    Curl_safefree(z->next_in);
  125|       |
  126|    183|  if(*zlib_init != ZLIB_UNINIT) {
  127|    120|    if(inflateEnd(z) != Z_OK && result == CURLE_OK)
  128|      0|      result = process_zlib_error(data, z);
  129|    120|    *zlib_init = ZLIB_UNINIT;
  130|    120|  }
  131|       |
  132|    183|  return result;
  133|    183|}
content_encoding.c:inflate_stream:
  162|    108|{
  163|    108|  struct zlib_params *zp = (struct zlib_params *) &writer->params;
  164|    108|  z_stream *z = &zp->z;         /* zlib state structure */
  165|    108|  uInt nread = z->avail_in;
  166|    108|  Bytef *orig_in = z->next_in;
  167|    108|  bool done = FALSE;
  168|    108|  CURLcode result = CURLE_OK;   /* Curl_client_write status */
  169|    108|  char *decomp;                 /* Put the decompressed data here. */
  170|       |
  171|       |  /* Check state. */
  172|    108|  if(zp->zlib_init != ZLIB_INIT &&
  173|    108|     zp->zlib_init != ZLIB_INFLATING &&
  174|    108|     zp->zlib_init != ZLIB_INIT_GZIP &&
  175|    108|     zp->zlib_init != ZLIB_GZIP_INFLATING)
  176|      0|    return exit_zlib(data, z, &zp->zlib_init, CURLE_WRITE_ERROR);
  177|       |
  178|       |  /* Dynamically allocate a buffer for decompression because it's uncommonly
  179|       |     large to hold on the stack */
  180|    108|  decomp = malloc(DSIZ);
  181|    108|  if(!decomp)
  182|      0|    return exit_zlib(data, z, &zp->zlib_init, CURLE_OUT_OF_MEMORY);
  183|       |
  184|       |  /* because the buffer size is fixed, iteratively decompress and transfer to
  185|       |     the client via downstream_write function. */
  186|    379|  while(!done) {
  187|    272|    int status;                   /* zlib status */
  188|    272|    done = TRUE;
  189|       |
  190|       |    /* (re)set buffer for decompressed output for every iteration */
  191|    272|    z->next_out = (Bytef *) decomp;
  192|    272|    z->avail_out = DSIZ;
  193|       |
  194|    272|#ifdef Z_BLOCK
  195|       |    /* Z_BLOCK is only available in zlib ver. >= 1.2.0.5 */
  196|    272|    status = inflate(z, Z_BLOCK);
  197|       |#else
  198|       |    /* fallback for zlib ver. < 1.2.0.5 */
  199|       |    status = inflate(z, Z_SYNC_FLUSH);
  200|       |#endif
  201|       |
  202|       |    /* Flush output data if some. */
  203|    272|    if(z->avail_out != DSIZ) {
  204|     61|      if(status == Z_OK || status == Z_STREAM_END) {
  205|     50|        zp->zlib_init = started;      /* Data started. */
  206|     50|        result = Curl_unencode_write(data, writer->downstream, decomp,
  207|     50|                                     DSIZ - z->avail_out);
  208|     50|        if(result) {
  209|      1|          exit_zlib(data, z, &zp->zlib_init, result);
  210|      1|          break;
  211|      1|        }
  212|     50|      }
  213|     61|    }
  214|       |
  215|       |    /* Dispatch by inflate() status. */
  216|    271|    switch(status) {
  217|    158|    case Z_OK:
  218|       |      /* Always loop: there may be unflushed latched data in zlib state. */
  219|    158|      done = FALSE;
  220|    158|      break;
  221|     45|    case Z_BUF_ERROR:
  222|       |      /* No more data to flush: just exit loop. */
  223|     45|      break;
  224|      1|    case Z_STREAM_END:
  225|      1|      result = process_trailer(data, zp);
  226|      1|      break;
  227|     66|    case Z_DATA_ERROR:
  228|       |      /* some servers seem to not generate zlib headers, so this is an attempt
  229|       |         to fix and continue anyway */
  230|     66|      if(zp->zlib_init == ZLIB_INIT) {
  231|       |        /* Do not use inflateReset2(): only available since zlib 1.2.3.4. */
  232|      6|        (void) inflateEnd(z);     /* don't care about the return code */
  233|      6|        if(inflateInit2(z, -MAX_WBITS) == Z_OK) {
  234|      6|          z->next_in = orig_in;
  235|      6|          z->avail_in = nread;
  236|      6|          zp->zlib_init = ZLIB_INFLATING;
  237|      6|          zp->trailerlen = 4; /* Tolerate up to 4 unknown trailer bytes. */
  238|      6|          done = FALSE;
  239|      6|          break;
  240|      6|        }
  241|      0|        zp->zlib_init = ZLIB_UNINIT;    /* inflateEnd() already called. */
  242|      0|      }
  243|     60|      result = exit_zlib(data, z, &zp->zlib_init, process_zlib_error(data, z));
  244|     60|      break;
  245|      1|    default:
  246|      1|      result = exit_zlib(data, z, &zp->zlib_init, process_zlib_error(data, z));
  247|      1|      break;
  248|    271|    }
  249|    271|  }
  250|    108|  free(decomp);
  251|       |
  252|       |  /* We're about to leave this call so the `nread' data bytes won't be seen
  253|       |     again. If we are in a state that would wrongly allow restart in raw mode
  254|       |     at the next call, assume output has already started. */
  255|    108|  if(nread && zp->zlib_init == ZLIB_INIT)
  256|      1|    zp->zlib_init = started;      /* Cannot restart anymore. */
  257|       |
  258|    108|  return result;
  259|    108|}
content_encoding.c:deflate_close_writer:
  302|     15|{
  303|     15|  struct zlib_params *zp = (struct zlib_params *) &writer->params;
  304|     15|  z_stream *z = &zp->z;     /* zlib state structure */
  305|       |
  306|     15|  exit_zlib(data, z, &zp->zlib_init, CURLE_OK);
  307|     15|}
content_encoding.c:gzip_init_writer:
  322|    105|{
  323|    105|  struct zlib_params *zp = (struct zlib_params *) &writer->params;
  324|    105|  z_stream *z = &zp->z;     /* zlib state structure */
  325|       |
  326|    105|  if(!writer->downstream)
  327|      0|    return CURLE_WRITE_ERROR;
  328|       |
  329|       |  /* Initialize zlib */
  330|    105|  z->zalloc = (alloc_func) zalloc_cb;
  331|    105|  z->zfree = (free_func) zfree_cb;
  332|       |
  333|    105|  if(strcmp(zlibVersion(), "1.2.0.4") >= 0) {
  334|       |    /* zlib ver. >= 1.2.0.4 supports transparent gzip decompressing */
  335|    105|    if(inflateInit2(z, MAX_WBITS + 32) != Z_OK) {
  336|      0|      return process_zlib_error(data, z);
  337|      0|    }
  338|    105|    zp->zlib_init = ZLIB_INIT_GZIP; /* Transparent gzip decompress state */
  339|    105|  }
  340|      0|  else {
  341|       |    /* we must parse the gzip header and trailer ourselves */
  342|      0|    if(inflateInit2(z, -MAX_WBITS) != Z_OK) {
  343|      0|      return process_zlib_error(data, z);
  344|      0|    }
  345|      0|    zp->trailerlen = 8; /* A CRC-32 and a 32-bit input size (RFC 1952, 2.2) */
  346|      0|    zp->zlib_init = ZLIB_INIT; /* Initial call state */
  347|      0|  }
  348|       |
  349|    105|  return CURLE_OK;
  350|    105|}
content_encoding.c:gzip_unencode_write:
  439|    101|{
  440|    101|  struct zlib_params *zp = (struct zlib_params *) &writer->params;
  441|    101|  z_stream *z = &zp->z;     /* zlib state structure */
  442|       |
  443|    101|  if(zp->zlib_init == ZLIB_INIT_GZIP) {
  444|       |    /* Let zlib handle the gzip decompression entirely */
  445|    101|    z->next_in = (Bytef *) buf;
  446|    101|    z->avail_in = (uInt) nbytes;
  447|       |    /* Now uncompress the data */
  448|    101|    return inflate_stream(data, writer, ZLIB_INIT_GZIP);
  449|    101|  }
  450|       |
  451|       |#ifndef OLD_ZLIB_SUPPORT
  452|       |  /* Support for old zlib versions is compiled away and we are running with
  453|       |     an old version, so return an error. */
  454|       |  return exit_zlib(data, z, &zp->zlib_init, CURLE_WRITE_ERROR);
  455|       |
  456|       |#else
  457|       |  /* This next mess is to get around the potential case where there isn't
  458|       |   * enough data passed in to skip over the gzip header.  If that happens, we
  459|       |   * malloc a block and copy what we have then wait for the next call.  If
  460|       |   * there still isn't enough (this is definitely a worst-case scenario), we
  461|       |   * make the block bigger, copy the next part in and keep waiting.
  462|       |   *
  463|       |   * This is only required with zlib versions < 1.2.0.4 as newer versions
  464|       |   * can handle the gzip header themselves.
  465|       |   */
  466|       |
  467|      0|  switch(zp->zlib_init) {
  468|       |  /* Skip over gzip header? */
  469|      0|  case ZLIB_INIT:
  470|      0|  {
  471|       |    /* Initial call state */
  472|      0|    ssize_t hlen;
  473|       |
  474|      0|    switch(check_gzip_header((unsigned char *) buf, nbytes, &hlen)) {
  475|      0|    case GZIP_OK:
  476|      0|      z->next_in = (Bytef *) buf + hlen;
  477|      0|      z->avail_in = (uInt) (nbytes - hlen);
  478|      0|      zp->zlib_init = ZLIB_GZIP_INFLATING; /* Inflating stream state */
  479|      0|      break;
  480|       |
  481|      0|    case GZIP_UNDERFLOW:
  482|       |      /* We need more data so we can find the end of the gzip header.  It's
  483|       |       * possible that the memory block we malloc here will never be freed if
  484|       |       * the transfer abruptly aborts after this point.  Since it's unlikely
  485|       |       * that circumstances will be right for this code path to be followed in
  486|       |       * the first place, and it's even more unlikely for a transfer to fail
  487|       |       * immediately afterwards, it should seldom be a problem.
  488|       |       */
  489|      0|      z->avail_in = (uInt) nbytes;
  490|      0|      z->next_in = malloc(z->avail_in);
  491|      0|      if(!z->next_in) {
  492|      0|        return exit_zlib(data, z, &zp->zlib_init, CURLE_OUT_OF_MEMORY);
  493|      0|      }
  494|      0|      memcpy(z->next_in, buf, z->avail_in);
  495|      0|      zp->zlib_init = ZLIB_GZIP_HEADER;  /* Need more gzip header data state */
  496|       |      /* We don't have any data to inflate yet */
  497|      0|      return CURLE_OK;
  498|       |
  499|      0|    case GZIP_BAD:
  500|      0|    default:
  501|      0|      return exit_zlib(data, z, &zp->zlib_init, process_zlib_error(data, z));
  502|      0|    }
  503|       |
  504|      0|  }
  505|      0|  break;
  506|       |
  507|      0|  case ZLIB_GZIP_HEADER:
  508|      0|  {
  509|       |    /* Need more gzip header data state */
  510|      0|    ssize_t hlen;
  511|      0|    z->avail_in += (uInt) nbytes;
  512|      0|    z->next_in = Curl_saferealloc(z->next_in, z->avail_in);
  513|      0|    if(!z->next_in) {
  514|      0|      return exit_zlib(data, z, &zp->zlib_init, CURLE_OUT_OF_MEMORY);
  515|      0|    }
  516|       |    /* Append the new block of data to the previous one */
  517|      0|    memcpy(z->next_in + z->avail_in - nbytes, buf, nbytes);
  518|       |
  519|      0|    switch(check_gzip_header(z->next_in, z->avail_in, &hlen)) {
  520|      0|    case GZIP_OK:
  521|       |      /* This is the zlib stream data */
  522|      0|      free(z->next_in);
  523|       |      /* Don't point into the malloced block since we just freed it */
  524|      0|      z->next_in = (Bytef *) buf + hlen + nbytes - z->avail_in;
  525|      0|      z->avail_in = (uInt) (z->avail_in - hlen);
  526|      0|      zp->zlib_init = ZLIB_GZIP_INFLATING;   /* Inflating stream state */
  527|      0|      break;
  528|       |
  529|      0|    case GZIP_UNDERFLOW:
  530|       |      /* We still don't have any data to inflate! */
  531|      0|      return CURLE_OK;
  532|       |
  533|      0|    case GZIP_BAD:
  534|      0|    default:
  535|      0|      return exit_zlib(data, z, &zp->zlib_init, process_zlib_error(data, z));
  536|      0|    }
  537|       |
  538|      0|  }
  539|      0|  break;
  540|       |
  541|      0|  case ZLIB_EXTERNAL_TRAILER:
  542|      0|    z->next_in = (Bytef *) buf;
  543|      0|    z->avail_in = (uInt) nbytes;
  544|      0|    return process_trailer(data, zp);
  545|       |
  546|      0|  case ZLIB_GZIP_INFLATING:
  547|      0|  default:
  548|       |    /* Inflating stream state */
  549|      0|    z->next_in = (Bytef *) buf;
  550|      0|    z->avail_in = (uInt) nbytes;
  551|      0|    break;
  552|      0|  }
  553|       |
  554|      0|  if(z->avail_in == 0) {
  555|       |    /* We don't have any data to inflate; wait until next time */
  556|      0|    return CURLE_OK;
  557|      0|  }
  558|       |
  559|       |  /* We've parsed the header, now uncompress the data */
  560|      0|  return inflate_stream(data, writer, ZLIB_GZIP_INFLATING);
  561|      0|#endif
  562|      0|}
content_encoding.c:gzip_close_writer:
  566|    105|{
  567|    105|  struct zlib_params *zp = (struct zlib_params *) &writer->params;
  568|    105|  z_stream *z = &zp->z;     /* zlib state structure */
  569|       |
  570|    105|  exit_zlib(data, z, &zp->zlib_init, CURLE_OK);
  571|    105|}
content_encoding.c:find_encoding:
 1017|    833|{
 1018|    833|  const struct content_encoding * const *cep;
 1019|       |
 1020|  2.31k|  for(cep = encodings; *cep; cep++) {
 1021|  1.89k|    const struct content_encoding *ce = *cep;
 1022|  1.89k|    if((strncasecompare(name, ce->name, len) && !ce->name[len]) ||
 1023|  1.89k|       (ce->alias && strncasecompare(name, ce->alias, len) && !ce->alias[len]))
 1024|    413|      return ce;
 1025|  1.89k|  }
 1026|    420|  return NULL;
 1027|    833|}
content_encoding.c:new_unencoding_writer:
  973|  1.00k|{
  974|  1.00k|  size_t sz = offsetof(struct contenc_writer, params) + handler->paramsize;
  975|  1.00k|  struct contenc_writer *writer = (struct contenc_writer *)calloc(1, sz);
  976|       |
  977|  1.00k|  if(writer) {
  978|  1.00k|    writer->handler = handler;
  979|  1.00k|    writer->downstream = downstream;
  980|  1.00k|    if(handler->init_writer(data, writer)) {
  981|      0|      free(writer);
  982|      0|      writer = NULL;
  983|      0|    }
  984|  1.00k|  }
  985|       |
  986|  1.00k|  return writer;
  987|  1.00k|}
content_encoding.c:client_init_writer:
  890|    171|{
  891|    171|  (void) data;
  892|    171|  return writer->downstream? CURLE_WRITE_ERROR: CURLE_OK;
  893|    171|}
content_encoding.c:client_unencode_write:
  898|     47|{
  899|     47|  struct SingleRequest *k = &data->req;
  900|       |
  901|     47|  (void) writer;
  902|       |
  903|     47|  if(!nbytes || k->ignorebody)
  904|      0|    return CURLE_OK;
  905|       |
  906|     47|  return Curl_client_write(data, CLIENTWRITE_BODY, (char *) buf, nbytes);
  907|     47|}
content_encoding.c:client_close_writer:
  911|    171|{
  912|    171|  (void) data;
  913|    171|  (void) writer;
  914|    171|}
content_encoding.c:error_init_writer:
  929|    420|{
  930|    420|  (void) data;
  931|    420|  return writer->downstream? CURLE_OK: CURLE_WRITE_ERROR;
  932|    420|}
content_encoding.c:error_unencode_write:
  937|     18|{
  938|     18|  char *all = Curl_all_content_encodings();
  939|       |
  940|     18|  (void) writer;
  941|     18|  (void) buf;
  942|     18|  (void) nbytes;
  943|       |
  944|     18|  if(!all)
  945|      0|    return CURLE_OUT_OF_MEMORY;
  946|     18|  failf(data, "Unrecognized content encoding type. "
  947|     18|        "libcurl understands %s content encodings.", all);
  948|     18|  free(all);
  949|     18|  return CURLE_BAD_CONTENT_ENCODING;
  950|     18|}
content_encoding.c:error_close_writer:
  954|    420|{
  955|    420|  (void) data;
  956|    420|  (void) writer;
  957|    420|}

Curl_cookie_add:
  459|  8.14k|{
  460|  8.14k|  struct Cookie *clist;
  461|  8.14k|  struct Cookie *co;
  462|  8.14k|  struct Cookie *lastc = NULL;
  463|  8.14k|  time_t now = time(NULL);
  464|  8.14k|  bool replace_old = FALSE;
  465|  8.14k|  bool badcookie = FALSE; /* cookies are good by default. mmmmm yummy */
  466|  8.14k|  size_t myhash;
  467|       |
  468|       |#ifdef CURL_DISABLE_VERBOSE_STRINGS
  469|       |  (void)data;
  470|       |#endif
  471|       |
  472|       |  /* First, alloc and init a new struct for it */
  473|  8.14k|  co = calloc(1, sizeof(struct Cookie));
  474|  8.14k|  if(!co)
  475|      0|    return NULL; /* bail out if we're this low on memory */
  476|       |
  477|  8.14k|  if(httpheader) {
  478|       |    /* This line was read off a HTTP-header */
  479|  8.14k|    char name[MAX_NAME];
  480|  8.14k|    char what[MAX_NAME];
  481|  8.14k|    const char *ptr;
  482|  8.14k|    const char *semiptr;
  483|       |
  484|  8.14k|    size_t linelength = strlen(lineptr);
  485|  8.14k|    if(linelength > MAX_COOKIE_LINE) {
  486|       |      /* discard overly long lines at once */
  487|      1|      free(co);
  488|      1|      return NULL;
  489|      1|    }
  490|       |
  491|  8.14k|    semiptr = strchr(lineptr, ';'); /* first, find a semicolon */
  492|       |
  493|  16.8k|    while(*lineptr && ISBLANK(*lineptr))
  494|  8.73k|      lineptr++;
  495|       |
  496|  8.14k|    ptr = lineptr;
  497|  17.6k|    do {
  498|       |      /* we have a <what>=<this> pair or a stand-alone word here */
  499|  17.6k|      name[0] = what[0] = 0; /* init the buffers */
  500|  17.6k|      if(1 <= sscanf(ptr, "%" MAX_NAME_TXT "[^;\r\n=] =%"
  501|  17.6k|                     MAX_NAME_TXT "[^;\r\n]",
  502|  17.6k|                     name, what)) {
  503|       |        /*
  504|       |         * Use strstore() below to properly deal with received cookie
  505|       |         * headers that have the same string property set more than once,
  506|       |         * and then we use the last one.
  507|       |         */
  508|  16.4k|        const char *whatptr;
  509|  16.4k|        bool done = FALSE;
  510|  16.4k|        bool sep;
  511|  16.4k|        size_t len = strlen(what);
  512|  16.4k|        size_t nlen = strlen(name);
  513|  16.4k|        const char *endofn = &ptr[ nlen ];
  514|       |
  515|       |        /*
  516|       |         * Check for too long individual name or contents, or too long
  517|       |         * combination of name + contents. Chrome and Firefox support 4095 or
  518|       |         * 4096 bytes combo
  519|       |         */
  520|  16.4k|        if(nlen >= (MAX_NAME-1) || len >= (MAX_NAME-1) ||
  521|  16.4k|           ((nlen + len) > MAX_NAME)) {
  522|      3|          freecookie(co);
  523|      3|          infof(data, "oversized cookie dropped, name/val %zu + %zu bytes",
  524|      3|                nlen, len);
  525|      3|          return NULL;
  526|      3|        }
  527|       |
  528|       |        /* name ends with a '=' ? */
  529|  16.4k|        sep = (*endofn == '=')?TRUE:FALSE;
  530|       |
  531|  16.4k|        if(nlen) {
  532|  16.4k|          endofn--; /* move to the last character */
  533|  16.4k|          if(ISBLANK(*endofn)) {
  534|       |            /* skip trailing spaces in name */
  535|    605|            while(*endofn && ISBLANK(*endofn) && nlen) {
  536|    407|              endofn--;
  537|    407|              nlen--;
  538|    407|            }
  539|    198|            name[nlen] = 0; /* new end of name */
  540|    198|          }
  541|  16.4k|        }
  542|       |
  543|       |        /* Strip off trailing whitespace from the 'what' */
  544|  16.9k|        while(len && ISBLANK(what[len-1])) {
  545|    469|          what[len-1] = 0;
  546|    469|          len--;
  547|    469|        }
  548|       |
  549|       |        /* Skip leading whitespace from the 'what' */
  550|  16.4k|        whatptr = what;
  551|  16.9k|        while(*whatptr && ISBLANK(*whatptr))
  552|    465|          whatptr++;
  553|       |
  554|       |        /*
  555|       |         * Check if we have a reserved prefix set before anything else, as we
  556|       |         * otherwise have to test for the prefix in both the cookie name and
  557|       |         * "the rest". Prefixes must start with '__' and end with a '-', so
  558|       |         * only test for names where that can possibly be true.
  559|       |         */
  560|  16.4k|        if(nlen > 3 && name[0] == '_' && name[1] == '_') {
  561|      0|          if(!strncmp("__Secure-", name, 9))
  562|      0|            co->prefix |= COOKIE_PREFIX__SECURE;
  563|      0|          else if(!strncmp("__Host-", name, 7))
  564|      0|            co->prefix |= COOKIE_PREFIX__HOST;
  565|      0|        }
  566|       |
  567|  16.4k|        if(!co->name) {
  568|       |          /* The very first name/value pair is the actual cookie name */
  569|  8.12k|          if(!sep) {
  570|       |            /* Bad name/value pair. */
  571|  1.48k|            badcookie = TRUE;
  572|  1.48k|            break;
  573|  1.48k|          }
  574|  6.64k|          co->name = strdup(name);
  575|  6.64k|          co->value = strdup(whatptr);
  576|  6.64k|          done = TRUE;
  577|  6.64k|          if(!co->name || !co->value) {
  578|      0|            badcookie = TRUE;
  579|      0|            break;
  580|      0|          }
  581|  6.64k|        }
  582|  8.35k|        else if(!len) {
  583|       |          /*
  584|       |           * this was a "<name>=" with no content, and we must allow
  585|       |           * 'secure' and 'httponly' specified this weirdly
  586|       |           */
  587|    914|          done = TRUE;
  588|       |          /*
  589|       |           * secure cookies are only allowed to be set when the connection is
  590|       |           * using a secure protocol, or when the cookie is being set by
  591|       |           * reading from file
  592|       |           */
  593|    914|          if(strcasecompare("secure", name)) {
  594|      0|            if(secure || !c->running) {
  595|      0|              co->secure = TRUE;
  596|      0|            }
  597|      0|            else {
  598|      0|              badcookie = TRUE;
  599|      0|              break;
  600|      0|            }
  601|      0|          }
  602|    914|          else if(strcasecompare("httponly", name))
  603|      0|            co->httponly = TRUE;
  604|    914|          else if(sep)
  605|       |            /* there was a '=' so we're not done parsing this field */
  606|    163|            done = FALSE;
  607|    914|        }
  608|  15.0k|        if(done)
  609|  7.39k|          ;
  610|  7.60k|        else if(strcasecompare("path", name)) {
  611|  4.15k|          strstore(&co->path, whatptr);
  612|  4.15k|          if(!co->path) {
  613|      0|            badcookie = TRUE; /* out of memory bad */
  614|      0|            break;
  615|      0|          }
  616|  4.15k|          free(co->spath); /* if this is set again */
  617|  4.15k|          co->spath = sanitize_cookie_path(co->path);
  618|  4.15k|          if(!co->spath) {
  619|      0|            badcookie = TRUE; /* out of memory bad */
  620|      0|            break;
  621|      0|          }
  622|  4.15k|        }
  623|  3.45k|        else if(strcasecompare("domain", name)) {
  624|      0|          bool is_ip;
  625|       |
  626|       |          /*
  627|       |           * Now, we make sure that our host is within the given domain, or
  628|       |           * the given domain is not valid and thus cannot be set.
  629|       |           */
  630|       |
  631|      0|          if('.' == whatptr[0])
  632|      0|            whatptr++; /* ignore preceding dot */
  633|       |
  634|      0|#ifndef USE_LIBPSL
  635|       |          /*
  636|       |           * Without PSL we don't know when the incoming cookie is set on a
  637|       |           * TLD or otherwise "protected" suffix. To reduce risk, we require a
  638|       |           * dot OR the exact host name being "localhost".
  639|       |           */
  640|      0|          if(bad_domain(whatptr))
  641|      0|            domain = ":";
  642|      0|#endif
  643|       |
  644|      0|          is_ip = Curl_host_is_ipnum(domain ? domain : whatptr);
  645|       |
  646|      0|          if(!domain
  647|      0|             || (is_ip && !strcmp(whatptr, domain))
  648|      0|             || (!is_ip && tailmatch(whatptr, domain))) {
  649|      0|            strstore(&co->domain, whatptr);
  650|      0|            if(!co->domain) {
  651|      0|              badcookie = TRUE;
  652|      0|              break;
  653|      0|            }
  654|      0|            if(!is_ip)
  655|      0|              co->tailmatch = TRUE; /* we always do that if the domain name was
  656|       |                                       given */
  657|      0|          }
  658|      0|          else {
  659|       |            /*
  660|       |             * We did not get a tailmatch and then the attempted set domain is
  661|       |             * not a domain to which the current host belongs. Mark as bad.
  662|       |             */
  663|      0|            badcookie = TRUE;
  664|      0|            infof(data, "skipped cookie with bad tailmatch domain: %s",
  665|      0|                  whatptr);
  666|      0|          }
  667|      0|        }
  668|  3.45k|        else if(strcasecompare("version", name)) {
  669|      0|          strstore(&co->version, whatptr);
  670|      0|          if(!co->version) {
  671|      0|            badcookie = TRUE;
  672|      0|            break;
  673|      0|          }
  674|      0|        }
  675|  3.45k|        else if(strcasecompare("max-age", name)) {
  676|       |          /*
  677|       |           * Defined in RFC2109:
  678|       |           *
  679|       |           * Optional.  The Max-Age attribute defines the lifetime of the
  680|       |           * cookie, in seconds.  The delta-seconds value is a decimal non-
  681|       |           * negative integer.  After delta-seconds seconds elapse, the
  682|       |           * client should discard the cookie.  A value of zero means the
  683|       |           * cookie should be discarded immediately.
  684|       |           */
  685|      0|          strstore(&co->maxage, whatptr);
  686|      0|          if(!co->maxage) {
  687|      0|            badcookie = TRUE;
  688|      0|            break;
  689|      0|          }
  690|      0|        }
  691|  3.45k|        else if(strcasecompare("expires", name)) {
  692|  3.08k|          strstore(&co->expirestr, whatptr);
  693|  3.08k|          if(!co->expirestr) {
  694|      0|            badcookie = TRUE;
  695|      0|            break;
  696|      0|          }
  697|  3.08k|        }
  698|       |
  699|       |        /*
  700|       |         * Else, this is the second (or more) name we don't know about!
  701|       |         */
  702|  15.0k|      }
  703|  1.13k|      else {
  704|       |        /* this is an "illegal" <what>=<this> pair */
  705|  1.13k|      }
  706|       |
  707|  16.1k|      if(!semiptr || !*semiptr) {
  708|       |        /* we already know there are no more cookies */
  709|  6.58k|        semiptr = NULL;
  710|  6.58k|        continue;
  711|  6.58k|      }
  712|       |
  713|  9.54k|      ptr = semiptr + 1;
  714|  17.4k|      while(*ptr && ISBLANK(*ptr))
  715|  7.88k|        ptr++;
  716|  9.54k|      semiptr = strchr(ptr, ';'); /* now, find the next semicolon */
  717|       |
  718|  9.54k|      if(!semiptr && *ptr)
  719|       |        /*
  720|       |         * There are no more semicolons, but there's a final name=value pair
  721|       |         * coming up
  722|       |         */
  723|  5.96k|        semiptr = strchr(ptr, '\0');
  724|  16.1k|    } while(semiptr);
  725|       |
  726|  8.13k|    if(co->maxage) {
  727|      0|      CURLofft offt;
  728|      0|      offt = curlx_strtoofft((*co->maxage == '\"')?
  729|      0|                             &co->maxage[1]:&co->maxage[0], NULL, 10,
  730|      0|                             &co->expires);
  731|      0|      if(offt == CURL_OFFT_FLOW)
  732|       |        /* overflow, used max value */
  733|      0|        co->expires = CURL_OFF_T_MAX;
  734|      0|      else if(!offt) {
  735|      0|        if(!co->expires)
  736|       |          /* already expired */
  737|      0|          co->expires = 1;
  738|      0|        else if(CURL_OFF_T_MAX - now < co->expires)
  739|       |          /* would overflow */
  740|      0|          co->expires = CURL_OFF_T_MAX;
  741|      0|        else
  742|      0|          co->expires += now;
  743|      0|      }
  744|      0|    }
  745|  8.13k|    else if(co->expirestr) {
  746|       |      /*
  747|       |       * Note that if the date couldn't get parsed for whatever reason, the
  748|       |       * cookie will be treated as a session cookie
  749|       |       */
  750|  2.99k|      co->expires = Curl_getdate_capped(co->expirestr);
  751|       |
  752|       |      /*
  753|       |       * Session cookies have expires set to 0 so if we get that back from the
  754|       |       * date parser let's add a second to make it a non-session cookie
  755|       |       */
  756|  2.99k|      if(co->expires == 0)
  757|      0|        co->expires = 1;
  758|  2.99k|      else if(co->expires < 0)
  759|  2.08k|        co->expires = 0;
  760|  2.99k|    }
  761|       |
  762|  8.13k|    if(!badcookie && !co->domain) {
  763|  6.65k|      if(domain) {
  764|       |        /* no domain was given in the header line, set the default */
  765|  6.65k|        co->domain = strdup(domain);
  766|  6.65k|        if(!co->domain)
  767|      0|          badcookie = TRUE;
  768|  6.65k|      }
  769|  6.65k|    }
  770|       |
  771|  8.13k|    if(!badcookie && !co->path && path) {
  772|       |      /*
  773|       |       * No path was given in the header line, set the default.  Note that the
  774|       |       * passed-in path to this function MAY have a '?' and following part that
  775|       |       * MUST NOT be stored as part of the path.
  776|       |       */
  777|  2.61k|      char *queryp = strchr(path, '?');
  778|       |
  779|       |      /*
  780|       |       * queryp is where the interesting part of the path ends, so now we
  781|       |       * want to the find the last
  782|       |       */
  783|  2.61k|      char *endslash;
  784|  2.61k|      if(!queryp)
  785|  2.61k|        endslash = strrchr(path, '/');
  786|      0|      else
  787|      0|        endslash = memrchr(path, '/', (queryp - path));
  788|  2.61k|      if(endslash) {
  789|  2.61k|        size_t pathlen = (endslash-path + 1); /* include end slash */
  790|  2.61k|        co->path = malloc(pathlen + 1); /* one extra for the zero byte */
  791|  2.61k|        if(co->path) {
  792|  2.61k|          memcpy(co->path, path, pathlen);
  793|  2.61k|          co->path[pathlen] = 0; /* null-terminate */
  794|  2.61k|          co->spath = sanitize_cookie_path(co->path);
  795|  2.61k|          if(!co->spath)
  796|      0|            badcookie = TRUE; /* out of memory bad */
  797|  2.61k|        }
  798|      0|        else
  799|      0|          badcookie = TRUE;
  800|  2.61k|      }
  801|  2.61k|    }
  802|       |
  803|       |    /*
  804|       |     * If we didn't get a cookie name, or a bad one, the this is an illegal
  805|       |     * line so bail out.
  806|       |     */
  807|  8.13k|    if(badcookie || !co->name) {
  808|  1.49k|      freecookie(co);
  809|  1.49k|      return NULL;
  810|  1.49k|    }
  811|       |
  812|  8.13k|  }
  813|      0|  else {
  814|       |    /*
  815|       |     * This line is NOT a HTTP header style line, we do offer support for
  816|       |     * reading the odd netscape cookies-file format here
  817|       |     */
  818|      0|    char *ptr;
  819|      0|    char *firstptr;
  820|      0|    char *tok_buf = NULL;
  821|      0|    int fields;
  822|       |
  823|       |    /*
  824|       |     * IE introduced HTTP-only cookies to prevent XSS attacks. Cookies marked
  825|       |     * with httpOnly after the domain name are not accessible from javascripts,
  826|       |     * but since curl does not operate at javascript level, we include them
  827|       |     * anyway. In Firefox's cookie files, these lines are preceded with
  828|       |     * #HttpOnly_ and then everything is as usual, so we skip 10 characters of
  829|       |     * the line..
  830|       |     */
  831|      0|    if(strncmp(lineptr, "#HttpOnly_", 10) == 0) {
  832|      0|      lineptr += 10;
  833|      0|      co->httponly = TRUE;
  834|      0|    }
  835|       |
  836|      0|    if(lineptr[0]=='#') {
  837|       |      /* don't even try the comments */
  838|      0|      free(co);
  839|      0|      return NULL;
  840|      0|    }
  841|       |    /* strip off the possible end-of-line characters */
  842|      0|    ptr = strchr(lineptr, '\r');
  843|      0|    if(ptr)
  844|      0|      *ptr = 0; /* clear it */
  845|      0|    ptr = strchr(lineptr, '\n');
  846|      0|    if(ptr)
  847|      0|      *ptr = 0; /* clear it */
  848|       |
  849|      0|    firstptr = strtok_r(lineptr, "\t", &tok_buf); /* tokenize it on the TAB */
  850|       |
  851|       |    /*
  852|       |     * Now loop through the fields and init the struct we already have
  853|       |     * allocated
  854|       |     */
  855|      0|    for(ptr = firstptr, fields = 0; ptr && !badcookie;
  856|      0|        ptr = strtok_r(NULL, "\t", &tok_buf), fields++) {
  857|      0|      switch(fields) {
  858|      0|      case 0:
  859|      0|        if(ptr[0]=='.') /* skip preceding dots */
  860|      0|          ptr++;
  861|      0|        co->domain = strdup(ptr);
  862|      0|        if(!co->domain)
  863|      0|          badcookie = TRUE;
  864|      0|        break;
  865|      0|      case 1:
  866|       |        /*
  867|       |         * flag: A TRUE/FALSE value indicating if all machines within a given
  868|       |         * domain can access the variable. Set TRUE when the cookie says
  869|       |         * .domain.com and to false when the domain is complete www.domain.com
  870|       |         */
  871|      0|        co->tailmatch = strcasecompare(ptr, "TRUE")?TRUE:FALSE;
  872|      0|        break;
  873|      0|      case 2:
  874|       |        /* The file format allows the path field to remain not filled in */
  875|      0|        if(strcmp("TRUE", ptr) && strcmp("FALSE", ptr)) {
  876|       |          /* only if the path doesn't look like a boolean option! */
  877|      0|          co->path = strdup(ptr);
  878|      0|          if(!co->path)
  879|      0|            badcookie = TRUE;
  880|      0|          else {
  881|      0|            co->spath = sanitize_cookie_path(co->path);
  882|      0|            if(!co->spath) {
  883|      0|              badcookie = TRUE; /* out of memory bad */
  884|      0|            }
  885|      0|          }
  886|      0|          break;
  887|      0|        }
  888|       |        /* this doesn't look like a path, make one up! */
  889|      0|        co->path = strdup("/");
  890|      0|        if(!co->path)
  891|      0|          badcookie = TRUE;
  892|      0|        co->spath = strdup("/");
  893|      0|        if(!co->spath)
  894|      0|          badcookie = TRUE;
  895|      0|        fields++; /* add a field and fall down to secure */
  896|       |        /* FALLTHROUGH */
  897|      0|      case 3:
  898|      0|        co->secure = FALSE;
  899|      0|        if(strcasecompare(ptr, "TRUE")) {
  900|      0|          if(secure || c->running)
  901|      0|            co->secure = TRUE;
  902|      0|          else
  903|      0|            badcookie = TRUE;
  904|      0|        }
  905|      0|        break;
  906|      0|      case 4:
  907|      0|        if(curlx_strtoofft(ptr, NULL, 10, &co->expires))
  908|      0|          badcookie = TRUE;
  909|      0|        break;
  910|      0|      case 5:
  911|      0|        co->name = strdup(ptr);
  912|      0|        if(!co->name)
  913|      0|          badcookie = TRUE;
  914|      0|        else {
  915|       |          /* For Netscape file format cookies we check prefix on the name */
  916|      0|          if(strncasecompare("__Secure-", co->name, 9))
  917|      0|            co->prefix |= COOKIE_PREFIX__SECURE;
  918|      0|          else if(strncasecompare("__Host-", co->name, 7))
  919|      0|            co->prefix |= COOKIE_PREFIX__HOST;
  920|      0|        }
  921|      0|        break;
  922|      0|      case 6:
  923|      0|        co->value = strdup(ptr);
  924|      0|        if(!co->value)
  925|      0|          badcookie = TRUE;
  926|      0|        break;
  927|      0|      }
  928|      0|    }
  929|      0|    if(6 == fields) {
  930|       |      /* we got a cookie with blank contents, fix it */
  931|      0|      co->value = strdup("");
  932|      0|      if(!co->value)
  933|      0|        badcookie = TRUE;
  934|      0|      else
  935|      0|        fields++;
  936|      0|    }
  937|       |
  938|      0|    if(!badcookie && (7 != fields))
  939|       |      /* we did not find the sufficient number of fields */
  940|      0|      badcookie = TRUE;
  941|       |
  942|      0|    if(badcookie) {
  943|      0|      freecookie(co);
  944|      0|      return NULL;
  945|      0|    }
  946|       |
  947|      0|  }
  948|       |
  949|  6.64k|  if(co->prefix & COOKIE_PREFIX__SECURE) {
  950|       |    /* The __Secure- prefix only requires that the cookie be set secure */
  951|      0|    if(!co->secure) {
  952|      0|      freecookie(co);
  953|      0|      return NULL;
  954|      0|    }
  955|      0|  }
  956|  6.64k|  if(co->prefix & COOKIE_PREFIX__HOST) {
  957|       |    /*
  958|       |     * The __Host- prefix requires the cookie to be secure, have a "/" path
  959|       |     * and not have a domain set.
  960|       |     */
  961|      0|    if(co->secure && co->path && strcmp(co->path, "/") == 0 && !co->tailmatch)
  962|      0|      ;
  963|      0|    else {
  964|      0|      freecookie(co);
  965|      0|      return NULL;
  966|      0|    }
  967|      0|  }
  968|       |
  969|  6.64k|  if(!c->running &&    /* read from a file */
  970|  6.64k|     c->newsession &&  /* clean session cookies */
  971|  6.64k|     !co->expires) {   /* this is a session cookie since it doesn't expire! */
  972|      0|    freecookie(co);
  973|      0|    return NULL;
  974|      0|  }
  975|       |
  976|  6.64k|  co->livecookie = c->running;
  977|  6.64k|  co->creationtime = ++c->lastct;
  978|       |
  979|       |  /*
  980|       |   * Now we have parsed the incoming line, we must now check if this supersedes
  981|       |   * an already existing cookie, which it may if the previous have the same
  982|       |   * domain and path as this.
  983|       |   */
  984|       |
  985|       |  /* at first, remove expired cookies */
  986|  6.64k|  if(!noexpire)
  987|  6.64k|    remove_expired(c);
  988|       |
  989|       |#ifdef USE_LIBPSL
  990|       |  /*
  991|       |   * Check if the domain is a Public Suffix and if yes, ignore the cookie. We
  992|       |   * must also check that the data handle isn't NULL since the psl code will
  993|       |   * dereference it.
  994|       |   */
  995|       |  if(data && (domain && co->domain && !Curl_host_is_ipnum(co->domain))) {
  996|       |    const psl_ctx_t *psl = Curl_psl_use(data);
  997|       |    int acceptable;
  998|       |
  999|       |    if(psl) {
 1000|       |      acceptable = psl_is_cookie_domain_acceptable(psl, domain, co->domain);
 1001|       |      Curl_psl_release(data);
 1002|       |    }
 1003|       |    else
 1004|       |      acceptable = !bad_domain(domain);
 1005|       |
 1006|       |    if(!acceptable) {
 1007|       |      infof(data, "cookie '%s' dropped, domain '%s' must not "
 1008|       |                  "set cookies for '%s'", co->name, domain, co->domain);
 1009|       |      freecookie(co);
 1010|       |      return NULL;
 1011|       |    }
 1012|       |  }
 1013|       |#endif
 1014|       |
 1015|  6.64k|  myhash = cookiehash(co->domain);
 1016|  6.64k|  clist = c->cookies[myhash];
 1017|  6.64k|  replace_old = FALSE;
 1018|  26.9k|  while(clist) {
 1019|  24.9k|    if(strcasecompare(clist->name, co->name)) {
 1020|       |      /* the names are identical */
 1021|       |
 1022|  6.70k|      if(clist->domain && co->domain) {
 1023|  6.70k|        if(strcasecompare(clist->domain, co->domain) &&
 1024|  6.70k|          (clist->tailmatch == co->tailmatch))
 1025|       |          /* The domains are identical */
 1026|  6.70k|          replace_old = TRUE;
 1027|  6.70k|      }
 1028|      0|      else if(!clist->domain && !co->domain)
 1029|      0|        replace_old = TRUE;
 1030|       |
 1031|  6.70k|      if(replace_old) {
 1032|       |        /* the domains were identical */
 1033|       |
 1034|  6.70k|        if(clist->spath && co->spath) {
 1035|  6.70k|          if(clist->secure && !co->secure && !secure) {
 1036|      0|            size_t cllen;
 1037|      0|            const char *sep;
 1038|       |
 1039|       |            /*
 1040|       |             * A non-secure cookie may not overlay an existing secure cookie.
 1041|       |             * For an existing cookie "a" with path "/login", refuse a new
 1042|       |             * cookie "a" with for example path "/login/en", while the path
 1043|       |             * "/loginhelper" is ok.
 1044|       |             */
 1045|       |
 1046|      0|            sep = strchr(clist->spath + 1, '/');
 1047|       |
 1048|      0|            if(sep)
 1049|      0|              cllen = sep - clist->spath;
 1050|      0|            else
 1051|      0|              cllen = strlen(clist->spath);
 1052|       |
 1053|      0|            if(strncasecompare(clist->spath, co->spath, cllen)) {
 1054|      0|              freecookie(co);
 1055|      0|              return NULL;
 1056|      0|            }
 1057|      0|          }
 1058|  6.70k|          else if(strcasecompare(clist->spath, co->spath))
 1059|  4.59k|            replace_old = TRUE;
 1060|  2.10k|          else
 1061|  2.10k|            replace_old = FALSE;
 1062|  6.70k|        }
 1063|      0|        else if(!clist->spath && !co->spath)
 1064|      0|          replace_old = TRUE;
 1065|      0|        else
 1066|      0|          replace_old = FALSE;
 1067|       |
 1068|  6.70k|      }
 1069|       |
 1070|  6.70k|      if(replace_old && !co->livecookie && clist->livecookie) {
 1071|       |        /*
 1072|       |         * Both cookies matched fine, except that the already present cookie is
 1073|       |         * "live", which means it was set from a header, while the new one was
 1074|       |         * read from a file and thus isn't "live". "live" cookies are preferred
 1075|       |         * so the new cookie is freed.
 1076|       |         */
 1077|      0|        freecookie(co);
 1078|      0|        return NULL;
 1079|      0|      }
 1080|       |
 1081|  6.70k|      if(replace_old) {
 1082|  4.59k|        co->next = clist->next; /* get the next-pointer first */
 1083|       |
 1084|       |        /* when replacing, creationtime is kept from old */
 1085|  4.59k|        co->creationtime = clist->creationtime;
 1086|       |
 1087|       |        /* then free all the old pointers */
 1088|  4.59k|        free(clist->name);
 1089|  4.59k|        free(clist->value);
 1090|  4.59k|        free(clist->domain);
 1091|  4.59k|        free(clist->path);
 1092|  4.59k|        free(clist->spath);
 1093|  4.59k|        free(clist->expirestr);
 1094|  4.59k|        free(clist->version);
 1095|  4.59k|        free(clist->maxage);
 1096|       |
 1097|  4.59k|        *clist = *co;  /* then store all the new data */
 1098|       |
 1099|  4.59k|        free(co);   /* free the newly allocated memory */
 1100|  4.59k|        co = clist; /* point to the previous struct instead */
 1101|       |
 1102|       |        /*
 1103|       |         * We have replaced a cookie, now skip the rest of the list but make
 1104|       |         * sure the 'lastc' pointer is properly set
 1105|       |         */
 1106|  20.6k|        do {
 1107|  20.6k|          lastc = clist;
 1108|  20.6k|          clist = clist->next;
 1109|  20.6k|        } while(clist);
 1110|  4.59k|        break;
 1111|  4.59k|      }
 1112|  6.70k|    }
 1113|  20.3k|    lastc = clist;
 1114|  20.3k|    clist = clist->next;
 1115|  20.3k|  }
 1116|       |
 1117|  6.64k|  if(c->running)
 1118|       |    /* Only show this when NOT reading the cookies from a file */
 1119|  6.64k|    infof(data, "%s cookie %s=\"%s\" for domain %s, path %s, "
 1120|  6.64k|          "expire %" CURL_FORMAT_CURL_OFF_T,
 1121|  6.64k|          replace_old?"Replaced":"Added", co->name, co->value,
 1122|  6.64k|          co->domain, co->path, co->expires);
 1123|       |
 1124|  6.64k|  if(!replace_old) {
 1125|       |    /* then make the last item point on this new one */
 1126|  2.04k|    if(lastc)
 1127|  1.71k|      lastc->next = co;
 1128|    329|    else
 1129|    329|      c->cookies[myhash] = co;
 1130|  2.04k|    c->numcookies++; /* one more cookie in the jar */
 1131|  2.04k|  }
 1132|       |
 1133|       |  /*
 1134|       |   * Now that we've added a new cookie to the jar, update the expiration
 1135|       |   * tracker in case it is the next one to expire.
 1136|       |   */
 1137|  6.64k|  if(co->expires && (co->expires < c->next_expiration))
 1138|    403|    c->next_expiration = co->expires;
 1139|       |
 1140|  6.64k|  return co;
 1141|  6.64k|}
Curl_cookie_init:
 1161|  3.09k|{
 1162|  3.09k|  struct CookieInfo *c;
 1163|  3.09k|  FILE *fp = NULL;
 1164|  3.09k|  bool fromfile = TRUE;
 1165|  3.09k|  char *line = NULL;
 1166|       |
 1167|  3.09k|  if(NULL == inc) {
 1168|       |    /* we didn't get a struct, create one */
 1169|  3.09k|    c = calloc(1, sizeof(struct CookieInfo));
 1170|  3.09k|    if(!c)
 1171|      0|      return NULL; /* failed to get memory */
 1172|  3.09k|    c->filename = strdup(file?file:"none"); /* copy the name just in case */
 1173|  3.09k|    if(!c->filename)
 1174|      0|      goto fail; /* failed to get memory */
 1175|       |    /*
 1176|       |     * Initialize the next_expiration time to signal that we don't have enough
 1177|       |     * information yet.
 1178|       |     */
 1179|  3.09k|    c->next_expiration = CURL_OFF_T_MAX;
 1180|  3.09k|  }
 1181|      0|  else {
 1182|       |    /* we got an already existing one, use that */
 1183|      0|    c = inc;
 1184|      0|  }
 1185|  3.09k|  c->running = FALSE; /* this is not running, this is init */
 1186|       |
 1187|  3.09k|  if(file && !strcmp(file, "-")) {
 1188|      0|    fp = stdin;
 1189|      0|    fromfile = FALSE;
 1190|      0|  }
 1191|  3.09k|  else if(file && !*file) {
 1192|       |    /* points to a "" string */
 1193|      0|    fp = NULL;
 1194|      0|  }
 1195|  3.09k|  else
 1196|  3.09k|    fp = file?fopen(file, FOPEN_READTEXT):NULL;
 1197|       |
 1198|  3.09k|  c->newsession = newsession; /* new session? */
 1199|       |
 1200|  3.09k|  if(fp) {
 1201|      0|    char *lineptr;
 1202|      0|    bool headerline;
 1203|       |
 1204|      0|    line = malloc(MAX_COOKIE_LINE);
 1205|      0|    if(!line)
 1206|      0|      goto fail;
 1207|      0|    while(Curl_get_line(line, MAX_COOKIE_LINE, fp)) {
 1208|      0|      if(checkprefix("Set-Cookie:", line)) {
 1209|       |        /* This is a cookie line, get it! */
 1210|      0|        lineptr = &line[11];
 1211|      0|        headerline = TRUE;
 1212|      0|      }
 1213|      0|      else {
 1214|      0|        lineptr = line;
 1215|      0|        headerline = FALSE;
 1216|      0|      }
 1217|      0|      while(*lineptr && ISBLANK(*lineptr))
 1218|      0|        lineptr++;
 1219|       |
 1220|      0|      Curl_cookie_add(data, c, headerline, TRUE, lineptr, NULL, NULL, TRUE);
 1221|      0|    }
 1222|      0|    free(line); /* free the line buffer */
 1223|       |
 1224|       |    /*
 1225|       |     * Remove expired cookies from the hash. We must make sure to run this
 1226|       |     * after reading the file, and not on every cookie.
 1227|       |     */
 1228|      0|    remove_expired(c);
 1229|       |
 1230|      0|    if(fromfile)
 1231|      0|      fclose(fp);
 1232|      0|  }
 1233|       |
 1234|  3.09k|  c->running = TRUE;          /* now, we're running */
 1235|  3.09k|  if(data)
 1236|  3.09k|    data->state.cookie_engine = TRUE;
 1237|       |
 1238|  3.09k|  return c;
 1239|       |
 1240|      0|fail:
 1241|      0|  free(line);
 1242|       |  /*
 1243|       |   * Only clean up if we allocated it here, as the original could still be in
 1244|       |   * use by a share handle.
 1245|       |   */
 1246|      0|  if(!inc)
 1247|      0|    Curl_cookie_cleanup(c);
 1248|      0|  if(fromfile && fp)
 1249|      0|    fclose(fp);
 1250|      0|  return NULL; /* out of memory */
 1251|  3.09k|}
Curl_cookie_getlist:
 1352|  1.22k|{
 1353|  1.22k|  struct Cookie *newco;
 1354|  1.22k|  struct Cookie *co;
 1355|  1.22k|  struct Cookie *mainco = NULL;
 1356|  1.22k|  size_t matches = 0;
 1357|  1.22k|  bool is_ip;
 1358|  1.22k|  const size_t myhash = cookiehash(host);
 1359|       |
 1360|  1.22k|  if(!c || !c->cookies[myhash])
 1361|  1.18k|    return NULL; /* no cookie struct or no cookies in the struct */
 1362|       |
 1363|       |  /* at first, remove expired cookies */
 1364|     31|  remove_expired(c);
 1365|       |
 1366|       |  /* check if host is an IP(v4|v6) address */
 1367|     31|  is_ip = Curl_host_is_ipnum(host);
 1368|       |
 1369|     31|  co = c->cookies[myhash];
 1370|       |
 1371|     97|  while(co) {
 1372|       |    /* if the cookie requires we're secure we must only continue if we are! */
 1373|     66|    if(co->secure?secure:TRUE) {
 1374|       |
 1375|       |      /* now check if the domain is correct */
 1376|     66|      if(!co->domain ||
 1377|     66|         (co->tailmatch && !is_ip && tailmatch(co->domain, host)) ||
 1378|     66|         ((!co->tailmatch || is_ip) && strcasecompare(host, co->domain)) ) {
 1379|       |        /*
 1380|       |         * the right part of the host matches the domain stuff in the
 1381|       |         * cookie data
 1382|       |         */
 1383|       |
 1384|       |        /*
 1385|       |         * now check the left part of the path with the cookies path
 1386|       |         * requirement
 1387|       |         */
 1388|     65|        if(!co->spath || pathmatch(co->spath, path) ) {
 1389|       |
 1390|       |          /*
 1391|       |           * and now, we know this is a match and we should create an
 1392|       |           * entry for the return-linked-list
 1393|       |           */
 1394|       |
 1395|     48|          newco = dup_cookie(co);
 1396|     48|          if(newco) {
 1397|       |            /* then modify our next */
 1398|     48|            newco->next = mainco;
 1399|       |
 1400|       |            /* point the main to us */
 1401|     48|            mainco = newco;
 1402|       |
 1403|     48|            matches++;
 1404|     48|          }
 1405|      0|          else
 1406|      0|            goto fail;
 1407|     48|        }
 1408|     65|      }
 1409|     66|    }
 1410|     66|    co = co->next;
 1411|     66|  }
 1412|       |
 1413|     31|  if(matches) {
 1414|       |    /*
 1415|       |     * Now we need to make sure that if there is a name appearing more than
 1416|       |     * once, the longest specified path version comes first. To make this
 1417|       |     * the swiftest way, we just sort them all based on path length.
 1418|       |     */
 1419|     23|    struct Cookie **array;
 1420|     23|    size_t i;
 1421|       |
 1422|       |    /* alloc an array and store all cookie pointers */
 1423|     23|    array = malloc(sizeof(struct Cookie *) * matches);
 1424|     23|    if(!array)
 1425|      0|      goto fail;
 1426|       |
 1427|     23|    co = mainco;
 1428|       |
 1429|     71|    for(i = 0; co; co = co->next)
 1430|     48|      array[i++] = co;
 1431|       |
 1432|       |    /* now sort the cookie pointers in path length order */
 1433|     23|    qsort(array, matches, sizeof(struct Cookie *), cookie_sort);
 1434|       |
 1435|       |    /* remake the linked list order according to the new order */
 1436|       |
 1437|     23|    mainco = array[0]; /* start here */
 1438|     48|    for(i = 0; i<matches-1; i++)
 1439|     25|      array[i]->next = array[i + 1];
 1440|     23|    array[matches-1]->next = NULL; /* terminate the list */
 1441|       |
 1442|     23|    free(array); /* remove the temporary data again */
 1443|     23|  }
 1444|       |
 1445|     31|  return mainco; /* return the new list */
 1446|       |
 1447|      0|fail:
 1448|       |  /* failure, clear up the allocated chain and return NULL */
 1449|      0|  Curl_cookie_freelist(mainco);
 1450|      0|  return NULL;
 1451|     31|}
Curl_cookie_freelist:
 1476|   791k|{
 1477|   791k|  struct Cookie *next;
 1478|   793k|  while(co) {
 1479|  1.89k|    next = co->next;
 1480|  1.89k|    freecookie(co);
 1481|  1.89k|    co = next;
 1482|  1.89k|  }
 1483|   791k|}
Curl_cookie_cleanup:
 1532|  6.25k|{
 1533|  6.25k|  if(c) {
 1534|  3.09k|    unsigned int i;
 1535|  3.09k|    free(c->filename);
 1536|   794k|    for(i = 0; i < COOKIE_HASH_SIZE; i++)
 1537|   791k|      Curl_cookie_freelist(c->cookies[i]);
 1538|  3.09k|    free(c); /* free the base struct as well */
 1539|  3.09k|  }
 1540|  6.25k|}
Curl_flush_cookies:
 1730|  6.25k|{
 1731|  6.25k|  CURLcode res;
 1732|       |
 1733|  6.25k|  if(data->set.str[STRING_COOKIEJAR]) {
 1734|  3.09k|    if(data->state.cookielist) {
 1735|       |      /* If there is a list of cookie files to read, do it first so that
 1736|       |         we have all the told files read before we write the new jar.
 1737|       |         Curl_cookie_loadfiles() LOCKS and UNLOCKS the share itself! */
 1738|      0|      Curl_cookie_loadfiles(data);
 1739|      0|    }
 1740|       |
 1741|  3.09k|    Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
 1742|       |
 1743|       |    /* if we have a destination file for all the cookies to get dumped to */
 1744|  3.09k|    res = cookie_output(data, data->cookies, data->set.str[STRING_COOKIEJAR]);
 1745|  3.09k|    if(res)
 1746|      0|      infof(data, "WARNING: failed to save cookies in %s: %s",
 1747|      0|            data->set.str[STRING_COOKIEJAR], curl_easy_strerror(res));
 1748|  3.09k|  }
 1749|  3.16k|  else {
 1750|  3.16k|    if(cleanup && data->state.cookielist) {
 1751|       |      /* since nothing is written, we can just free the list of cookie file
 1752|       |         names */
 1753|      0|      curl_slist_free_all(data->state.cookielist); /* clean up list */
 1754|      0|      data->state.cookielist = NULL;
 1755|      0|    }
 1756|  3.16k|    Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
 1757|  3.16k|  }
 1758|       |
 1759|  6.25k|  if(cleanup && (!data->share || (data->cookies != data->share->cookies))) {
 1760|  6.25k|    Curl_cookie_cleanup(data->cookies);
 1761|  6.25k|    data->cookies = NULL;
 1762|  6.25k|  }
 1763|  6.25k|  Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
 1764|  6.25k|}
cookie.c:freecookie:
  110|  3.59k|{
  111|  3.59k|  free(co->expirestr);
  112|  3.59k|  free(co->domain);
  113|  3.59k|  free(co->path);
  114|  3.59k|  free(co->spath);
  115|  3.59k|  free(co->name);
  116|  3.59k|  free(co->value);
  117|  3.59k|  free(co->maxage);
  118|  3.59k|  free(co->version);
  119|  3.59k|  free(co);
  120|  3.59k|}
cookie.c:strstore:
  364|  7.56k|{
  365|  7.56k|  free(*str);
  366|  7.56k|  *str = strdup(newstr);
  367|  7.56k|}
cookie.c:sanitize_cookie_path:
  291|  6.76k|{
  292|  6.76k|  size_t len;
  293|  6.76k|  char *new_path = strdup(cookie_path);
  294|  6.76k|  if(!new_path)
  295|      0|    return NULL;
  296|       |
  297|       |  /* some stupid site sends path attribute with '"'. */
  298|  6.76k|  len = strlen(new_path);
  299|  6.76k|  if(new_path[0] == '\"') {
  300|     53|    memmove((void *)new_path, (const void *)(new_path + 1), len);
  301|     53|    len--;
  302|     53|  }
  303|  6.76k|  if(len && (new_path[len - 1] == '\"')) {
  304|     35|    new_path[len - 1] = 0x0;
  305|     35|    len--;
  306|     35|  }
  307|       |
  308|       |  /* RFC6265 5.2.4 The Path Attribute */
  309|  6.76k|  if(new_path[0] != '/') {
  310|       |    /* Let cookie-path be the default-path. */
  311|    329|    strstore(&new_path, "/");
  312|    329|    return new_path;
  313|    329|  }
  314|       |
  315|       |  /* convert /hoge/ to /hoge */
  316|  6.43k|  if(len && new_path[len - 1] == '/') {
  317|  6.20k|    new_path[len - 1] = 0x0;
  318|  6.20k|  }
  319|       |
  320|  6.43k|  return new_path;
  321|  6.76k|}
cookie.c:remove_expired:
  379|  9.76k|{
  380|  9.76k|  struct Cookie *co, *nx;
  381|  9.76k|  curl_off_t now = (curl_off_t)time(NULL);
  382|  9.76k|  unsigned int i;
  383|       |
  384|       |  /*
  385|       |   * If the earliest expiration timestamp in the jar is in the future we can
  386|       |   * skip scanning the whole jar and instead exit early as there won't be any
  387|       |   * cookies to evict.  If we need to evict however, reset the next_expiration
  388|       |   * counter in order to track the next one. In case the recorded first
  389|       |   * expiration is the max offset, then perform the safe fallback of checking
  390|       |   * all cookies.
  391|       |   */
  392|  9.76k|  if(now < cookies->next_expiration &&
  393|  9.76k|      cookies->next_expiration != CURL_OFF_T_MAX)
  394|  3.64k|    return;
  395|  6.11k|  else
  396|  6.11k|    cookies->next_expiration = CURL_OFF_T_MAX;
  397|       |
  398|  1.57M|  for(i = 0; i < COOKIE_HASH_SIZE; i++) {
  399|  1.56M|    struct Cookie *pv = NULL;
  400|  1.56M|    co = cookies->cookies[i];
  401|  1.58M|    while(co) {
  402|  16.9k|      nx = co->next;
  403|  16.9k|      if(co->expires && co->expires < now) {
  404|    198|        if(!pv) {
  405|     39|          cookies->cookies[i] = co->next;
  406|     39|        }
  407|    159|        else {
  408|    159|          pv->next = co->next;
  409|    159|        }
  410|    198|        cookies->numcookies--;
  411|    198|        freecookie(co);
  412|    198|      }
  413|  16.7k|      else {
  414|       |        /*
  415|       |         * If this cookie has an expiration timestamp earlier than what we've
  416|       |         * seen so far then record it for the next round of expirations.
  417|       |         */
  418|  16.7k|        if(co->expires && co->expires < cookies->next_expiration)
  419|     88|          cookies->next_expiration = co->expires;
  420|  16.7k|        pv = co;
  421|  16.7k|      }
  422|  16.9k|      co = nx;
  423|  16.9k|    }
  424|  1.56M|  }
  425|  6.11k|}
cookie.c:cookiehash:
  276|  7.86k|{
  277|  7.86k|  const char *top;
  278|  7.86k|  size_t len;
  279|       |
  280|  7.86k|  if(!domain || Curl_host_is_ipnum(domain))
  281|  6.25k|    return 0;
  282|       |
  283|  1.61k|  top = get_top_domain(domain, &len);
  284|  1.61k|  return cookie_hash_domain(top, len);
  285|  7.86k|}
cookie.c:get_top_domain:
  227|  1.61k|{
  228|  1.61k|  size_t len = 0;
  229|  1.61k|  const char *first = NULL, *last;
  230|       |
  231|  1.61k|  if(domain) {
  232|  1.61k|    len = strlen(domain);
  233|  1.61k|    last = memrchr(domain, '.', len);
  234|  1.61k|    if(last) {
  235|    474|      first = memrchr(domain, '.', (last - domain));
  236|    474|      if(first)
  237|    344|        len -= (++first - domain);
  238|    474|    }
  239|  1.61k|  }
  240|       |
  241|  1.61k|  if(outlen)
  242|  1.61k|    *outlen = len;
  243|       |
  244|  1.61k|  return first? first: domain;
  245|  1.61k|}
cookie.c:cookie_hash_domain:
  256|  1.61k|{
  257|  1.61k|  const char *end = domain + len;
  258|  1.61k|  size_t h = 5381;
  259|       |
  260|  8.86k|  while(domain < end) {
  261|  7.25k|    h += h << 5;
  262|  7.25k|    h ^= Curl_raw_toupper(*domain++);
  263|  7.25k|  }
  264|       |
  265|  1.61k|  return (h % COOKIE_HASH_SIZE);
  266|  1.61k|}
cookie.c:pathmatch:
  153|     65|{
  154|     65|  size_t cookie_path_len;
  155|     65|  size_t uri_path_len;
  156|     65|  char *uri_path = NULL;
  157|     65|  char *pos;
  158|     65|  bool ret = FALSE;
  159|       |
  160|       |  /* cookie_path must not have last '/' separator. ex: /sample */
  161|     65|  cookie_path_len = strlen(cookie_path);
  162|     65|  if(1 == cookie_path_len) {
  163|       |    /* cookie_path must be '/' */
  164|     18|    return TRUE;
  165|     18|  }
  166|       |
  167|     47|  uri_path = strdup(request_uri);
  168|     47|  if(!uri_path)
  169|      0|    return FALSE;
  170|     47|  pos = strchr(uri_path, '?');
  171|     47|  if(pos)
  172|      0|    *pos = 0x0;
  173|       |
  174|       |  /* #-fragments are already cut off! */
  175|     47|  if(0 == strlen(uri_path) || uri_path[0] != '/') {
  176|      0|    strstore(&uri_path, "/");
  177|      0|    if(!uri_path)
  178|      0|      return FALSE;
  179|      0|  }
  180|       |
  181|       |  /*
  182|       |   * here, RFC6265 5.1.4 says
  183|       |   *  4. Output the characters of the uri-path from the first character up
  184|       |   *     to, but not including, the right-most %x2F ("/").
  185|       |   *  but URL path /hoge?fuga=xxx means /hoge/index.cgi?fuga=xxx in some site
  186|       |   *  without redirect.
  187|       |   *  Ignore this algorithm because /hoge is uri path for this case
  188|       |   *  (uri path is not /).
  189|       |   */
  190|       |
  191|     47|  uri_path_len = strlen(uri_path);
  192|       |
  193|     47|  if(uri_path_len < cookie_path_len) {
  194|      3|    ret = FALSE;
  195|      3|    goto pathmatched;
  196|      3|  }
  197|       |
  198|       |  /* not using checkprefix() because matching should be case-sensitive */
  199|     44|  if(strncmp(cookie_path, uri_path, cookie_path_len)) {
  200|     13|    ret = FALSE;
  201|     13|    goto pathmatched;
  202|     13|  }
  203|       |
  204|       |  /* The cookie-path and the uri-path are identical. */
  205|     31|  if(cookie_path_len == uri_path_len) {
  206|      1|    ret = TRUE;
  207|      1|    goto pathmatched;
  208|      1|  }
  209|       |
  210|       |  /* here, cookie_path_len < uri_path_len */
  211|     30|  if(uri_path[cookie_path_len] == '/') {
  212|     29|    ret = TRUE;
  213|     29|    goto pathmatched;
  214|     29|  }
  215|       |
  216|      1|  ret = FALSE;
  217|       |
  218|     47|pathmatched:
  219|     47|  free(uri_path);
  220|     47|  return ret;
  221|      1|}
cookie.c:dup_cookie:
 1315|     48|{
 1316|     48|  struct Cookie *d = calloc(sizeof(struct Cookie), 1);
 1317|     48|  if(d) {
 1318|     48|    CLONE(expirestr);
 1319|     48|    CLONE(domain);
 1320|     48|    CLONE(path);
 1321|     48|    CLONE(spath);
 1322|     48|    CLONE(name);
 1323|     48|    CLONE(value);
 1324|     48|    CLONE(maxage);
 1325|     48|    CLONE(version);
 1326|     48|    d->expires = src->expires;
 1327|     48|    d->tailmatch = src->tailmatch;
 1328|     48|    d->secure = src->secure;
 1329|     48|    d->livecookie = src->livecookie;
 1330|     48|    d->httponly = src->httponly;
 1331|     48|    d->creationtime = src->creationtime;
 1332|     48|  }
 1333|     48|  return d;
 1334|       |
 1335|      0|  fail:
 1336|      0|  freecookie(d);
 1337|      0|  return NULL;
 1338|     48|}
cookie.c:cookie_sort:
 1262|     35|{
 1263|     35|  struct Cookie *c1 = *(struct Cookie **)p1;
 1264|     35|  struct Cookie *c2 = *(struct Cookie **)p2;
 1265|     35|  size_t l1, l2;
 1266|       |
 1267|       |  /* 1 - compare cookie path lengths */
 1268|     35|  l1 = c1->path ? strlen(c1->path) : 0;
 1269|     35|  l2 = c2->path ? strlen(c2->path) : 0;
 1270|       |
 1271|     35|  if(l1 != l2)
 1272|      8|    return (l2 > l1) ? 1 : -1 ; /* avoid size_t <=> int conversions */
 1273|       |
 1274|       |  /* 2 - compare cookie domain lengths */
 1275|     27|  l1 = c1->domain ? strlen(c1->domain) : 0;
 1276|     27|  l2 = c2->domain ? strlen(c2->domain) : 0;
 1277|       |
 1278|     27|  if(l1 != l2)
 1279|      0|    return (l2 > l1) ? 1 : -1 ;  /* avoid size_t <=> int conversions */
 1280|       |
 1281|       |  /* 3 - compare cookie name lengths */
 1282|     27|  l1 = c1->name ? strlen(c1->name) : 0;
 1283|     27|  l2 = c2->name ? strlen(c2->name) : 0;
 1284|       |
 1285|     27|  if(l1 != l2)
 1286|     20|    return (l2 > l1) ? 1 : -1;
 1287|       |
 1288|       |  /* 4 - compare cookie creation time */
 1289|      7|  return (c2->creationtime > c1->creationtime) ? 1 : -1;
 1290|     27|}
cookie.c:get_netscape_format:
 1550|  1.84k|{
 1551|  1.84k|  return aprintf(
 1552|  1.84k|    "%s"     /* httponly preamble */
 1553|  1.84k|    "%s%s\t" /* domain */
 1554|  1.84k|    "%s\t"   /* tailmatch */
 1555|  1.84k|    "%s\t"   /* path */
 1556|  1.84k|    "%s\t"   /* secure */
 1557|  1.84k|    "%" CURL_FORMAT_CURL_OFF_T "\t"   /* expires */
 1558|  1.84k|    "%s\t"   /* name */
 1559|  1.84k|    "%s",    /* value */
 1560|  1.84k|    co->httponly?"#HttpOnly_":"",
 1561|       |    /*
 1562|       |     * Make sure all domains are prefixed with a dot if they allow
 1563|       |     * tailmatching. This is Mozilla-style.
 1564|       |     */
 1565|  1.84k|    (co->tailmatch && co->domain && co->domain[0] != '.')? ".":"",
 1566|  1.84k|    co->domain?co->domain:"unknown",
 1567|  1.84k|    co->tailmatch?"TRUE":"FALSE",
 1568|  1.84k|    co->path?co->path:"/",
 1569|  1.84k|    co->secure?"TRUE":"FALSE",
 1570|  1.84k|    co->expires,
 1571|  1.84k|    co->name,
 1572|  1.84k|    co->value?co->value:"");
 1573|  1.84k|}
cookie.c:cookie_output:
 1585|  3.09k|{
 1586|  3.09k|  struct Cookie *co;
 1587|  3.09k|  FILE *out = NULL;
 1588|  3.09k|  bool use_stdout = FALSE;
 1589|  3.09k|  char *tempstore = NULL;
 1590|  3.09k|  CURLcode error = CURLE_OK;
 1591|       |
 1592|  3.09k|  if(!c)
 1593|       |    /* no cookie engine alive */
 1594|      0|    return CURLE_OK;
 1595|       |
 1596|       |  /* at first, remove expired cookies */
 1597|  3.09k|  remove_expired(c);
 1598|       |
 1599|  3.09k|  if(!strcmp("-", filename)) {
 1600|       |    /* use stdout */
 1601|      0|    out = stdout;
 1602|      0|    use_stdout = TRUE;
 1603|      0|  }
 1604|  3.09k|  else {
 1605|  3.09k|    unsigned char randsuffix[9];
 1606|       |
 1607|  3.09k|    if(Curl_rand_hex(data, randsuffix, sizeof(randsuffix)))
 1608|      0|      return 2;
 1609|       |
 1610|  3.09k|    tempstore = aprintf("%s.%s.tmp", filename, randsuffix);
 1611|  3.09k|    if(!tempstore)
 1612|      0|      return CURLE_OUT_OF_MEMORY;
 1613|       |
 1614|  3.09k|    out = fopen(tempstore, FOPEN_WRITETEXT);
 1615|  3.09k|    if(!out) {
 1616|      0|      error = CURLE_WRITE_ERROR;
 1617|      0|      goto error;
 1618|      0|    }
 1619|  3.09k|  }
 1620|       |
 1621|  3.09k|  fputs("# Netscape HTTP Cookie File\n"
 1622|  3.09k|        "# https://curl.se/docs/http-cookies.html\n"
 1623|  3.09k|        "# This file was generated by libcurl! Edit at your own risk.\n\n",
 1624|  3.09k|        out);
 1625|       |
 1626|  3.09k|  if(c->numcookies) {
 1627|    304|    unsigned int i;
 1628|    304|    size_t nvalid = 0;
 1629|    304|    struct Cookie **array;
 1630|       |
 1631|    304|    array = calloc(1, sizeof(struct Cookie *) * c->numcookies);
 1632|    304|    if(!array) {
 1633|      0|      error = CURLE_OUT_OF_MEMORY;
 1634|      0|      goto error;
 1635|      0|    }
 1636|       |
 1637|       |    /* only sort the cookies with a domain property */
 1638|  78.1k|    for(i = 0; i < COOKIE_HASH_SIZE; i++) {
 1639|  79.6k|      for(co = c->cookies[i]; co; co = co->next) {
 1640|  1.84k|        if(!co->domain)
 1641|      0|          continue;
 1642|  1.84k|        array[nvalid++] = co;
 1643|  1.84k|      }
 1644|  77.8k|    }
 1645|       |
 1646|    304|    qsort(array, nvalid, sizeof(struct Cookie *), cookie_sort_ct);
 1647|       |
 1648|  2.14k|    for(i = 0; i < nvalid; i++) {
 1649|  1.84k|      char *format_ptr = get_netscape_format(array[i]);
 1650|  1.84k|      if(!format_ptr) {
 1651|      0|        free(array);
 1652|      0|        error = CURLE_OUT_OF_MEMORY;
 1653|      0|        goto error;
 1654|      0|      }
 1655|  1.84k|      fprintf(out, "%s\n", format_ptr);
 1656|  1.84k|      free(format_ptr);
 1657|  1.84k|    }
 1658|       |
 1659|    304|    free(array);
 1660|    304|  }
 1661|       |
 1662|  3.09k|  if(!use_stdout) {
 1663|  3.09k|    fclose(out);
 1664|  3.09k|    out = NULL;
 1665|  3.09k|    if(Curl_rename(tempstore, filename)) {
 1666|      0|      unlink(tempstore);
 1667|      0|      error = CURLE_WRITE_ERROR;
 1668|      0|      goto error;
 1669|      0|    }
 1670|  3.09k|  }
 1671|       |
 1672|       |  /*
 1673|       |   * If we reach here we have successfully written a cookie file so theree is
 1674|       |   * no need to inspect the error, any error case should have jumped into the
 1675|       |   * error block below.
 1676|       |   */
 1677|  3.09k|  free(tempstore);
 1678|  3.09k|  return CURLE_OK;
 1679|       |
 1680|      0|error:
 1681|      0|  if(out && !use_stdout)
 1682|      0|    fclose(out);
 1683|      0|  free(tempstore);
 1684|      0|  return error;
 1685|  3.09k|}
cookie.c:cookie_sort_ct:
 1298|  3.00k|{
 1299|  3.00k|  struct Cookie *c1 = *(struct Cookie **)p1;
 1300|  3.00k|  struct Cookie *c2 = *(struct Cookie **)p2;
 1301|       |
 1302|  3.00k|  return (c2->creationtime > c1->creationtime) ? 1 : -1;
 1303|  3.00k|}

Curl_freeaddrinfo:
   82|  2.82k|{
   83|  2.82k|  struct Curl_addrinfo *vqualifier canext;
   84|  2.82k|  struct Curl_addrinfo *ca;
   85|       |
   86|  5.64k|  for(ca = cahead; ca; ca = canext) {
   87|  2.82k|    canext = ca->ai_next;
   88|  2.82k|    free(ca);
   89|  2.82k|  }
   90|  2.82k|}
Curl_getaddrinfo_ex:
  113|      7|{
  114|      7|  const struct addrinfo *ai;
  115|      7|  struct addrinfo *aihead;
  116|      7|  struct Curl_addrinfo *cafirst = NULL;
  117|      7|  struct Curl_addrinfo *calast = NULL;
  118|      7|  struct Curl_addrinfo *ca;
  119|      7|  size_t ss_size;
  120|      7|  int error;
  121|       |
  122|      7|  *result = NULL; /* assume failure */
  123|       |
  124|      7|  error = getaddrinfo(nodename, servname, hints, &aihead);
  125|      7|  if(error)
  126|      7|    return error;
  127|       |
  128|       |  /* traverse the addrinfo list */
  129|       |
  130|      0|  for(ai = aihead; ai != NULL; ai = ai->ai_next) {
  131|      0|    size_t namelen = ai->ai_canonname ? strlen(ai->ai_canonname) + 1 : 0;
  132|       |    /* ignore elements with unsupported address family, */
  133|       |    /* settle family-specific sockaddr structure size.  */
  134|      0|    if(ai->ai_family == AF_INET)
  135|      0|      ss_size = sizeof(struct sockaddr_in);
  136|      0|#ifdef ENABLE_IPV6
  137|      0|    else if(ai->ai_family == AF_INET6)
  138|      0|      ss_size = sizeof(struct sockaddr_in6);
  139|      0|#endif
  140|      0|    else
  141|      0|      continue;
  142|       |
  143|       |    /* ignore elements without required address info */
  144|      0|    if(!ai->ai_addr || !(ai->ai_addrlen > 0))
  145|      0|      continue;
  146|       |
  147|       |    /* ignore elements with bogus address size */
  148|      0|    if((size_t)ai->ai_addrlen < ss_size)
  149|      0|      continue;
  150|       |
  151|      0|    ca = malloc(sizeof(struct Curl_addrinfo) + ss_size + namelen);
  152|      0|    if(!ca) {
  153|      0|      error = EAI_MEMORY;
  154|      0|      break;
  155|      0|    }
  156|       |
  157|       |    /* copy each structure member individually, member ordering, */
  158|       |    /* size, or padding might be different for each platform.    */
  159|       |
  160|      0|    ca->ai_flags     = ai->ai_flags;
  161|      0|    ca->ai_family    = ai->ai_family;
  162|      0|    ca->ai_socktype  = ai->ai_socktype;
  163|      0|    ca->ai_protocol  = ai->ai_protocol;
  164|      0|    ca->ai_addrlen   = (curl_socklen_t)ss_size;
  165|      0|    ca->ai_addr      = NULL;
  166|      0|    ca->ai_canonname = NULL;
  167|      0|    ca->ai_next      = NULL;
  168|       |
  169|      0|    ca->ai_addr = (void *)((char *)ca + sizeof(struct Curl_addrinfo));
  170|      0|    memcpy(ca->ai_addr, ai->ai_addr, ss_size);
  171|       |
  172|      0|    if(namelen) {
  173|      0|      ca->ai_canonname = (void *)((char *)ca->ai_addr + ss_size);
  174|      0|      memcpy(ca->ai_canonname, ai->ai_canonname, namelen);
  175|      0|    }
  176|       |
  177|       |    /* if the return list is empty, this becomes the first element */
  178|      0|    if(!cafirst)
  179|      0|      cafirst = ca;
  180|       |
  181|       |    /* add this element last in the return list */
  182|      0|    if(calast)
  183|      0|      calast->ai_next = ca;
  184|      0|    calast = ca;
  185|       |
  186|      0|  }
  187|       |
  188|       |  /* destroy the addrinfo list */
  189|      0|  if(aihead)
  190|      0|    freeaddrinfo(aihead);
  191|       |
  192|       |  /* if we failed, also destroy the Curl_addrinfo list */
  193|      0|  if(error) {
  194|      0|    Curl_freeaddrinfo(cafirst);
  195|      0|    cafirst = NULL;
  196|      0|  }
  197|      0|  else if(!cafirst) {
  198|      0|#ifdef EAI_NONAME
  199|       |    /* rfc3493 conformant */
  200|      0|    error = EAI_NONAME;
  201|       |#else
  202|       |    /* rfc3493 obsoleted */
  203|       |    error = EAI_NODATA;
  204|       |#endif
  205|       |#ifdef USE_WINSOCK
  206|       |    SET_SOCKERRNO(error);
  207|       |#endif
  208|      0|  }
  209|       |
  210|      0|  *result = cafirst;
  211|       |
  212|       |  /* This is not a CURLcode */
  213|      0|  return error;
  214|      7|}
Curl_he2ai:
  260|  2.82k|{
  261|  2.82k|  struct Curl_addrinfo *ai;
  262|  2.82k|  struct Curl_addrinfo *prevai = NULL;
  263|  2.82k|  struct Curl_addrinfo *firstai = NULL;
  264|  2.82k|  struct sockaddr_in *addr;
  265|  2.82k|#ifdef ENABLE_IPV6
  266|  2.82k|  struct sockaddr_in6 *addr6;
  267|  2.82k|#endif
  268|  2.82k|  CURLcode result = CURLE_OK;
  269|  2.82k|  int i;
  270|  2.82k|  char *curr;
  271|       |
  272|  2.82k|  if(!he)
  273|       |    /* no input == no output! */
  274|      0|    return NULL;
  275|       |
  276|  2.82k|  DEBUGASSERT((he->h_name != NULL) && (he->h_addr_list != NULL));
  277|       |
  278|  5.64k|  for(i = 0; (curr = he->h_addr_list[i]) != NULL; i++) {
  279|  2.82k|    size_t ss_size;
  280|  2.82k|    size_t namelen = strlen(he->h_name) + 1; /* include zero termination */
  281|  2.82k|#ifdef ENABLE_IPV6
  282|  2.82k|    if(he->h_addrtype == AF_INET6)
  283|      0|      ss_size = sizeof(struct sockaddr_in6);
  284|  2.82k|    else
  285|  2.82k|#endif
  286|  2.82k|      ss_size = sizeof(struct sockaddr_in);
  287|       |
  288|       |    /* allocate memory to hold the struct, the address and the name */
  289|  2.82k|    ai = calloc(1, sizeof(struct Curl_addrinfo) + ss_size + namelen);
  290|  2.82k|    if(!ai) {
  291|      0|      result = CURLE_OUT_OF_MEMORY;
  292|      0|      break;
  293|      0|    }
  294|       |    /* put the address after the struct */
  295|  2.82k|    ai->ai_addr = (void *)((char *)ai + sizeof(struct Curl_addrinfo));
  296|       |    /* then put the name after the address */
  297|  2.82k|    ai->ai_canonname = (char *)ai->ai_addr + ss_size;
  298|  2.82k|    memcpy(ai->ai_canonname, he->h_name, namelen);
  299|       |
  300|  2.82k|    if(!firstai)
  301|       |      /* store the pointer we want to return from this function */
  302|  2.82k|      firstai = ai;
  303|       |
  304|  2.82k|    if(prevai)
  305|       |      /* make the previous entry point to this */
  306|      0|      prevai->ai_next = ai;
  307|       |
  308|  2.82k|    ai->ai_family = he->h_addrtype;
  309|       |
  310|       |    /* we return all names as STREAM, so when using this address for TFTP
  311|       |       the type must be ignored and conn->socktype be used instead! */
  312|  2.82k|    ai->ai_socktype = SOCK_STREAM;
  313|       |
  314|  2.82k|    ai->ai_addrlen = (curl_socklen_t)ss_size;
  315|       |
  316|       |    /* leave the rest of the struct filled with zero */
  317|       |
  318|  2.82k|    switch(ai->ai_family) {
  319|  2.82k|    case AF_INET:
  320|  2.82k|      addr = (void *)ai->ai_addr; /* storage area for this info */
  321|       |
  322|  2.82k|      memcpy(&addr->sin_addr, curr, sizeof(struct in_addr));
  323|  2.82k|      addr->sin_family = (CURL_SA_FAMILY_T)(he->h_addrtype);
  324|  2.82k|      addr->sin_port = htons((unsigned short)port);
  325|  2.82k|      break;
  326|       |
  327|      0|#ifdef ENABLE_IPV6
  328|      0|    case AF_INET6:
  329|      0|      addr6 = (void *)ai->ai_addr; /* storage area for this info */
  330|       |
  331|      0|      memcpy(&addr6->sin6_addr, curr, sizeof(struct in6_addr));
  332|      0|      addr6->sin6_family = (CURL_SA_FAMILY_T)(he->h_addrtype);
  333|      0|      addr6->sin6_port = htons((unsigned short)port);
  334|      0|      break;
  335|  2.82k|#endif
  336|  2.82k|    }
  337|       |
  338|  2.82k|    prevai = ai;
  339|  2.82k|  }
  340|       |
  341|  2.82k|  if(result) {
  342|      0|    Curl_freeaddrinfo(firstai);
  343|      0|    firstai = NULL;
  344|      0|  }
  345|       |
  346|  2.82k|  return firstai;
  347|  2.82k|}
Curl_ip2addr:
  373|  2.82k|{
  374|  2.82k|  struct Curl_addrinfo *ai;
  375|       |
  376|       |#if defined(__VMS) && \
  377|       |    defined(__INITIAL_POINTER_SIZE) && (__INITIAL_POINTER_SIZE == 64)
  378|       |#pragma pointer_size save
  379|       |#pragma pointer_size short
  380|       |#pragma message disable PTRMISMATCH
  381|       |#endif
  382|       |
  383|  2.82k|  struct hostent  *h;
  384|  2.82k|  struct namebuff *buf;
  385|  2.82k|  char  *addrentry;
  386|  2.82k|  char  *hoststr;
  387|  2.82k|  size_t addrsize;
  388|       |
  389|  2.82k|  DEBUGASSERT(inaddr && hostname);
  390|       |
  391|  2.82k|  buf = malloc(sizeof(struct namebuff));
  392|  2.82k|  if(!buf)
  393|      0|    return NULL;
  394|       |
  395|  2.82k|  hoststr = strdup(hostname);
  396|  2.82k|  if(!hoststr) {
  397|      0|    free(buf);
  398|      0|    return NULL;
  399|      0|  }
  400|       |
  401|  2.82k|  switch(af) {
  402|  2.82k|  case AF_INET:
  403|  2.82k|    addrsize = sizeof(struct in_addr);
  404|  2.82k|    addrentry = (void *)&buf->addrentry.ina4;
  405|  2.82k|    memcpy(addrentry, inaddr, sizeof(struct in_addr));
  406|  2.82k|    break;
  407|      0|#ifdef ENABLE_IPV6
  408|      0|  case AF_INET6:
  409|      0|    addrsize = sizeof(struct in6_addr);
  410|      0|    addrentry = (void *)&buf->addrentry.ina6;
  411|      0|    memcpy(addrentry, inaddr, sizeof(struct in6_addr));
  412|      0|    break;
  413|      0|#endif
  414|      0|  default:
  415|      0|    free(hoststr);
  416|      0|    free(buf);
  417|      0|    return NULL;
  418|  2.82k|  }
  419|       |
  420|  2.82k|  h = &buf->hostentry;
  421|  2.82k|  h->h_name = hoststr;
  422|  2.82k|  h->h_aliases = NULL;
  423|  2.82k|  h->h_addrtype = (short)af;
  424|  2.82k|  h->h_length = (short)addrsize;
  425|  2.82k|  h->h_addr_list = &buf->h_addr_list[0];
  426|  2.82k|  h->h_addr_list[0] = addrentry;
  427|  2.82k|  h->h_addr_list[1] = NULL; /* terminate list of entries */
  428|       |
  429|       |#if defined(__VMS) && \
  430|       |    defined(__INITIAL_POINTER_SIZE) && (__INITIAL_POINTER_SIZE == 64)
  431|       |#pragma pointer_size restore
  432|       |#pragma message enable PTRMISMATCH
  433|       |#endif
  434|       |
  435|  2.82k|  ai = Curl_he2ai(h, port);
  436|       |
  437|  2.82k|  free(hoststr);
  438|  2.82k|  free(buf);
  439|       |
  440|  2.82k|  return ai;
  441|  2.82k|}
curl_dbg_getaddrinfo:
  550|      7|{
  551|       |#ifdef USE_LWIPSOCK
  552|       |  int res = lwip_getaddrinfo(hostname, service, hints, result);
  553|       |#else
  554|      7|  int res = (getaddrinfo)(hostname, service, hints, result);
  555|      7|#endif
  556|      7|  if(0 == res)
  557|       |    /* success */
  558|      0|    curl_dbg_log("ADDR %s:%d getaddrinfo() = %p\n",
  559|      0|                 source, line, (void *)*result);
  560|      7|  else
  561|      7|    curl_dbg_log("ADDR %s:%d getaddrinfo() failed\n",
  562|      7|                 source, line);
  563|      7|  return res;
  564|      7|}

Curl_isspace:
   64|  48.0k|{
   65|  48.0k|  if((c < 0) || (c >= 0x80))
   66|  1.40k|    return FALSE;
   67|  46.6k|  return (ascii[c] & _S);
   68|  48.0k|}
Curl_isdigit:
   71|   610k|{
   72|   610k|  if((c < 0) || (c >= 0x80))
   73|    538|    return FALSE;
   74|   609k|  return (ascii[c] & _N);
   75|   610k|}
Curl_isalnum:
   78|  56.5k|{
   79|  56.5k|  if((c < 0) || (c >= 0x80))
   80|  1.56k|    return FALSE;
   81|  54.9k|  return (ascii[c] & (_N|_U|_L));
   82|  56.5k|}
Curl_isxdigit:
   85|  3.04k|{
   86|  3.04k|  if((c < 0) || (c >= 0x80))
   87|     41|    return FALSE;
   88|  3.00k|  return (ascii[c] & (_N|_X));
   89|  3.04k|}
Curl_isgraph:
   92|  9.70k|{
   93|  9.70k|  if((c < 0) || (c >= 0x80) || (c == ' '))
   94|  1.17k|    return FALSE;
   95|  8.52k|  return (ascii[c] & (_N|_X|_U|_L|_P|_S));
   96|  9.70k|}
Curl_isalpha:
  106|  14.5k|{
  107|  14.5k|  if((c < 0) || (c >= 0x80))
  108|      0|    return FALSE;
  109|  14.5k|  return (ascii[c] & (_U|_L));
  110|  14.5k|}
Curl_isupper:
  113|    419|{
  114|    419|  if((c < 0) || (c >= 0x80))
  115|      3|    return FALSE;
  116|    416|  return (ascii[c] & (_U));
  117|    419|}
Curl_iscntrl:
  127|  9.98k|{
  128|  9.98k|  if((c < 0) || (c >= 0x80))
  129|  1.17k|    return FALSE;
  130|  8.81k|  return (ascii[c] & (_C));
  131|  9.98k|}

Curl_gethostname:
   52|     21|{
   53|       |#ifndef HAVE_GETHOSTNAME
   54|       |
   55|       |  /* Allow compilation and return failure when unavailable */
   56|       |  (void) name;
   57|       |  (void) namelen;
   58|       |  return -1;
   59|       |
   60|       |#else
   61|     21|  int err;
   62|     21|  char *dot;
   63|       |
   64|     21|#ifdef DEBUGBUILD
   65|       |
   66|       |  /* Override host name when environment variable CURL_GETHOSTNAME is set */
   67|     21|  const char *force_hostname = getenv("CURL_GETHOSTNAME");
   68|     21|  if(force_hostname) {
   69|      0|    strncpy(name, force_hostname, namelen);
   70|      0|    err = 0;
   71|      0|  }
   72|     21|  else {
   73|     21|    name[0] = '\0';
   74|     21|    err = gethostname(name, namelen);
   75|     21|  }
   76|       |
   77|       |#else /* DEBUGBUILD */
   78|       |
   79|       |  /* The call to system's gethostname() might get intercepted by the
   80|       |     libhostname library when libcurl is built as a non-debug shared
   81|       |     library when running the test suite. */
   82|       |  name[0] = '\0';
   83|       |  err = gethostname(name, namelen);
   84|       |
   85|       |#endif
   86|       |
   87|     21|  name[namelen - 1] = '\0';
   88|       |
   89|     21|  if(err)
   90|      0|    return err;
   91|       |
   92|       |  /* Truncate domain, leave only machine name */
   93|     21|  dot = strchr(name, '.');
   94|     21|  if(dot)
   95|      0|    *dot = '\0';
   96|       |
   97|     21|  return 0;
   98|     21|#endif
   99|       |
  100|     21|}

Curl_memrchr:
   46|  2.08k|{
   47|  2.08k|  if(n > 0) {
   48|  1.99k|    const unsigned char *p = s;
   49|  1.99k|    const unsigned char *q = s;
   50|       |
   51|  1.99k|    p += n - 1;
   52|       |
   53|  8.77k|    while(p >= q) {
   54|  7.59k|      if(*p == (unsigned char)c)
   55|    818|        return (void *)p;
   56|  6.78k|      p--;
   57|  6.78k|    }
   58|  1.99k|  }
   59|  1.26k|  return NULL;
   60|  2.08k|}

Curl_http_auth_cleanup_ntlm_wb:
  493|  3.05k|{
  494|  3.05k|  ntlm_wb_cleanup(&conn->ntlm);
  495|  3.05k|  ntlm_wb_cleanup(&conn->proxyntlm);
  496|  3.05k|}
curl_ntlm_wb.c:ntlm_wb_cleanup:
   80|  6.10k|{
   81|  6.10k|  if(ntlm->ntlm_auth_hlpr_socket != CURL_SOCKET_BAD) {
   82|      0|    sclose(ntlm->ntlm_auth_hlpr_socket);
   83|      0|    ntlm->ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;
   84|      0|  }
   85|       |
   86|  6.10k|  if(ntlm->ntlm_auth_hlpr_pid) {
   87|      0|    int i;
   88|      0|    for(i = 0; i < 4; i++) {
   89|      0|      pid_t ret = waitpid(ntlm->ntlm_auth_hlpr_pid, NULL, WNOHANG);
   90|      0|      if(ret == ntlm->ntlm_auth_hlpr_pid || errno == ECHILD)
   91|      0|        break;
   92|      0|      switch(i) {
   93|      0|      case 0:
   94|      0|        kill(ntlm->ntlm_auth_hlpr_pid, SIGTERM);
   95|      0|        break;
   96|      0|      case 1:
   97|       |        /* Give the process another moment to shut down cleanly before
   98|       |           bringing down the axe */
   99|      0|        Curl_wait_ms(1);
  100|      0|        break;
  101|      0|      case 2:
  102|      0|        kill(ntlm->ntlm_auth_hlpr_pid, SIGKILL);
  103|      0|        break;
  104|      0|      case 3:
  105|      0|        break;
  106|      0|      }
  107|      0|    }
  108|      0|    ntlm->ntlm_auth_hlpr_pid = 0;
  109|      0|  }
  110|       |
  111|  6.10k|  Curl_safefree(ntlm->challenge);
  112|  6.10k|  Curl_safefree(ntlm->response);
  113|  6.10k|}

Curl_range:
   37|     30|{
   38|     30|  curl_off_t from, to;
   39|     30|  char *ptr;
   40|     30|  char *ptr2;
   41|       |
   42|     30|  if(data->state.use_range && data->state.range) {
   43|     28|    CURLofft from_t;
   44|     28|    CURLofft to_t;
   45|     28|    from_t = curlx_strtoofft(data->state.range, &ptr, 0, &from);
   46|     28|    if(from_t == CURL_OFFT_FLOW)
   47|      1|      return CURLE_RANGE_ERROR;
   48|    290|    while(*ptr && (ISSPACE(*ptr) || (*ptr == '-')))
   49|    263|      ptr++;
   50|     27|    to_t = curlx_strtoofft(ptr, &ptr2, 0, &to);
   51|     27|    if(to_t == CURL_OFFT_FLOW)
   52|      1|      return CURLE_RANGE_ERROR;
   53|     26|    if((to_t == CURL_OFFT_INVAL) && !from_t) {
   54|       |      /* X - */
   55|      6|      data->state.resume_from = from;
   56|      6|      DEBUGF(infof(data, "RANGE %" CURL_FORMAT_CURL_OFF_T " to end of file",
   57|      6|                   from));
   58|      6|    }
   59|     20|    else if((from_t == CURL_OFFT_INVAL) && !to_t) {
   60|       |      /* -Y */
   61|      3|      data->req.maxdownload = to;
   62|      3|      data->state.resume_from = -to;
   63|      3|      DEBUGF(infof(data, "RANGE the last %" CURL_FORMAT_CURL_OFF_T " bytes",
   64|      3|                   to));
   65|      3|    }
   66|     17|    else {
   67|       |      /* X-Y */
   68|     17|      curl_off_t totalsize;
   69|       |
   70|       |      /* Ensure the range is sensible - to should follow from. */
   71|     17|      if(from > to)
   72|      1|        return CURLE_RANGE_ERROR;
   73|       |
   74|     16|      totalsize = to - from;
   75|     16|      if(totalsize == CURL_OFF_T_MAX)
   76|      1|        return CURLE_RANGE_ERROR;
   77|       |
   78|     15|      data->req.maxdownload = totalsize + 1; /* include last byte */
   79|     15|      data->state.resume_from = from;
   80|     15|      DEBUGF(infof(data, "RANGE from %" CURL_FORMAT_CURL_OFF_T
   81|     15|                   " getting %" CURL_FORMAT_CURL_OFF_T " bytes",
   82|     15|                   from, data->req.maxdownload));
   83|     15|    }
   84|     24|    DEBUGF(infof(data, "range-download from %" CURL_FORMAT_CURL_OFF_T
   85|     24|                 " to %" CURL_FORMAT_CURL_OFF_T ", totally %"
   86|     24|                 CURL_FORMAT_CURL_OFF_T " bytes",
   87|     24|                 from, to, data->req.maxdownload));
   88|     24|  }
   89|      2|  else
   90|      2|    data->req.maxdownload = -1;
   91|     26|  return CURLE_OK;
   92|     30|}

Curl_sasl_cleanup:
   89|  1.32k|{
   90|  1.32k|  (void)conn;
   91|  1.32k|  (void)authused;
   92|       |
   93|       |#if defined(USE_KERBEROS5)
   94|       |  /* Cleanup the gssapi structure */
   95|       |  if(authused == SASL_MECH_GSSAPI) {
   96|       |    Curl_auth_cleanup_gssapi(&conn->krb5);
   97|       |  }
   98|       |#endif
   99|       |
  100|       |#if defined(USE_GSASL)
  101|       |  /* Cleanup the GSASL structure */
  102|       |  if(authused & (SASL_MECH_SCRAM_SHA_1 | SASL_MECH_SCRAM_SHA_256)) {
  103|       |    Curl_auth_gsasl_cleanup(&conn->gsasl);
  104|       |  }
  105|       |#endif
  106|       |
  107|  1.32k|#if defined(USE_NTLM)
  108|       |  /* Cleanup the NTLM structure */
  109|  1.32k|  if(authused == SASL_MECH_NTLM) {
  110|      0|    Curl_auth_cleanup_ntlm(&conn->ntlm);
  111|      0|  }
  112|  1.32k|#endif
  113|  1.32k|}
Curl_sasl_decode_mech:
  130|  4.34k|{
  131|  4.34k|  unsigned int i;
  132|  4.34k|  char c;
  133|       |
  134|  47.3k|  for(i = 0; mechtable[i].name; i++) {
  135|  43.6k|    if(maxlen >= mechtable[i].len &&
  136|  43.6k|       !memcmp(ptr, mechtable[i].name, mechtable[i].len)) {
  137|    791|      if(len)
  138|    791|        *len = mechtable[i].len;
  139|       |
  140|    791|      if(maxlen == mechtable[i].len)
  141|    372|        return mechtable[i].bit;
  142|       |
  143|    419|      c = ptr[mechtable[i].len];
  144|    419|      if(!ISUPPER(c) && !ISDIGIT(c) && c != '-' && c != '_')
  145|    264|        return mechtable[i].bit;
  146|    419|    }
  147|  43.6k|  }
  148|       |
  149|  3.70k|  return 0;
  150|  4.34k|}
Curl_sasl_parse_url_auth_option:
  159|     33|{
  160|     33|  CURLcode result = CURLE_OK;
  161|     33|  size_t mechlen;
  162|       |
  163|     33|  if(!len)
  164|      4|    return CURLE_URL_MALFORMAT;
  165|       |
  166|     29|  if(sasl->resetprefs) {
  167|     20|    sasl->resetprefs = FALSE;
  168|     20|    sasl->prefmech = SASL_AUTH_NONE;
  169|     20|  }
  170|       |
  171|     29|  if(!strncmp(value, "*", len))
  172|     16|    sasl->prefmech = SASL_AUTH_DEFAULT;
  173|     13|  else {
  174|     13|    unsigned short mechbit = Curl_sasl_decode_mech(value, len, &mechlen);
  175|     13|    if(mechbit && mechlen == len)
  176|      1|      sasl->prefmech |= mechbit;
  177|     12|    else
  178|     12|      result = CURLE_URL_MALFORMAT;
  179|     13|  }
  180|       |
  181|     29|  return result;
  182|     33|}
Curl_sasl_init:
  191|  1.32k|{
  192|  1.32k|  unsigned long auth = data->set.httpauth;
  193|       |
  194|  1.32k|  sasl->params = params;           /* Set protocol dependent parameters */
  195|  1.32k|  sasl->state = SASL_STOP;         /* Not yet running */
  196|  1.32k|  sasl->curmech = NULL;            /* No mechanism yet. */
  197|  1.32k|  sasl->authmechs = SASL_AUTH_NONE; /* No known authentication mechanism yet */
  198|  1.32k|  sasl->prefmech = params->defmechs; /* Default preferred mechanisms */
  199|  1.32k|  sasl->authused = SASL_AUTH_NONE; /* The authentication mechanism used */
  200|  1.32k|  sasl->resetprefs = TRUE;         /* Reset prefmech upon AUTH parsing. */
  201|  1.32k|  sasl->mutual_auth = FALSE;       /* No mutual authentication (GSSAPI only) */
  202|  1.32k|  sasl->force_ir = FALSE;          /* Respect external option */
  203|       |
  204|  1.32k|  if(auth != CURLAUTH_BASIC) {
  205|      3|    sasl->resetprefs = FALSE;
  206|      3|    sasl->prefmech = SASL_AUTH_NONE;
  207|      3|    if(auth & CURLAUTH_BASIC)
  208|      2|      sasl->prefmech |= SASL_MECH_PLAIN | SASL_MECH_LOGIN;
  209|      3|    if(auth & CURLAUTH_DIGEST)
  210|      2|      sasl->prefmech |= SASL_MECH_DIGEST_MD5;
  211|      3|    if(auth & CURLAUTH_NTLM)
  212|      1|      sasl->prefmech |= SASL_MECH_NTLM;
  213|      3|    if(auth & CURLAUTH_BEARER)
  214|      1|      sasl->prefmech |= SASL_MECH_OAUTHBEARER | SASL_MECH_XOAUTH2;
  215|      3|    if(auth & CURLAUTH_GSSAPI)
  216|      0|      sasl->prefmech |= SASL_MECH_GSSAPI;
  217|      3|  }
  218|  1.32k|}
Curl_sasl_can_authenticate:
  316|    845|{
  317|       |  /* Have credentials been provided? */
  318|    845|  if(conn->bits.user_passwd)
  319|    115|    return TRUE;
  320|       |
  321|       |  /* EXTERNAL can authenticate without a user name and/or password */
  322|    730|  if(sasl->authmechs & sasl->prefmech & SASL_MECH_EXTERNAL)
  323|      0|    return TRUE;
  324|       |
  325|    730|  return FALSE;
  326|    730|}
Curl_sasl_start:
  335|    131|{
  336|    131|  CURLcode result = CURLE_OK;
  337|    131|  struct connectdata *conn = data->conn;
  338|    131|  unsigned short enabledmechs;
  339|    131|  const char *mech = NULL;
  340|    131|  struct bufref resp;
  341|    131|  saslstate state1 = SASL_STOP;
  342|    131|  saslstate state2 = SASL_FINAL;
  343|    131|  const char * const hostname = SSL_HOST_NAME();
  344|    131|  const long int port = SSL_HOST_PORT();
  345|    131|#if defined(USE_KERBEROS5) || defined(USE_NTLM)
  346|    131|  const char *service = data->set.str[STRING_SERVICE_NAME] ?
  347|      0|    data->set.str[STRING_SERVICE_NAME] :
  348|    131|    sasl->params->service;
  349|    131|#endif
  350|    131|  const char *oauth_bearer = data->set.str[STRING_BEARER];
  351|    131|  struct bufref nullmsg;
  352|       |
  353|    131|  Curl_bufref_init(&nullmsg);
  354|    131|  Curl_bufref_init(&resp);
  355|    131|  sasl->force_ir = force_ir;    /* Latch for future use */
  356|    131|  sasl->authused = 0;           /* No mechanism used yet */
  357|    131|  enabledmechs = sasl->authmechs & sasl->prefmech;
  358|    131|  *progress = SASL_IDLE;
  359|       |
  360|       |  /* Calculate the supported authentication mechanism, by decreasing order of
  361|       |     security, as well as the initial response where appropriate */
  362|    131|  if((enabledmechs & SASL_MECH_EXTERNAL) && !conn->passwd[0]) {
  363|      0|    mech = SASL_MECH_STRING_EXTERNAL;
  364|      0|    state1 = SASL_EXTERNAL;
  365|      0|    sasl->authused = SASL_MECH_EXTERNAL;
  366|       |
  367|      0|    if(force_ir || data->set.sasl_ir)
  368|      0|      result = Curl_auth_create_external_message(conn->user, &resp);
  369|      0|  }
  370|    131|  else if(conn->bits.user_passwd) {
  371|       |#if defined(USE_KERBEROS5)
  372|       |    if((enabledmechs & SASL_MECH_GSSAPI) && Curl_auth_is_gssapi_supported() &&
  373|       |       Curl_auth_user_contains_domain(conn->user)) {
  374|       |      sasl->mutual_auth = FALSE;
  375|       |      mech = SASL_MECH_STRING_GSSAPI;
  376|       |      state1 = SASL_GSSAPI;
  377|       |      state2 = SASL_GSSAPI_TOKEN;
  378|       |      sasl->authused = SASL_MECH_GSSAPI;
  379|       |
  380|       |      if(force_ir || data->set.sasl_ir)
  381|       |        result = Curl_auth_create_gssapi_user_message(data, conn->user,
  382|       |                                                      conn->passwd,
  383|       |                                                      service,
  384|       |                                                      conn->host.name,
  385|       |                                                      sasl->mutual_auth,
  386|       |                                                      NULL, &conn->krb5,
  387|       |                                                      &resp);
  388|       |    }
  389|       |    else
  390|       |#endif
  391|       |#ifdef USE_GSASL
  392|       |    if((enabledmechs & SASL_MECH_SCRAM_SHA_256) &&
  393|       |       Curl_auth_gsasl_is_supported(data, SASL_MECH_STRING_SCRAM_SHA_256,
  394|       |                                    &conn->gsasl)) {
  395|       |      mech = SASL_MECH_STRING_SCRAM_SHA_256;
  396|       |      sasl->authused = SASL_MECH_SCRAM_SHA_256;
  397|       |      state1 = SASL_GSASL;
  398|       |      state2 = SASL_GSASL;
  399|       |
  400|       |      result = Curl_auth_gsasl_start(data, conn->user,
  401|       |                                     conn->passwd, &conn->gsasl);
  402|       |      if(result == CURLE_OK && (force_ir || data->set.sasl_ir))
  403|       |        result = Curl_auth_gsasl_token(data, &nullmsg, &conn->gsasl, &resp);
  404|       |    }
  405|       |    else if((enabledmechs & SASL_MECH_SCRAM_SHA_1) &&
  406|       |            Curl_auth_gsasl_is_supported(data, SASL_MECH_STRING_SCRAM_SHA_1,
  407|       |                                         &conn->gsasl)) {
  408|       |      mech = SASL_MECH_STRING_SCRAM_SHA_1;
  409|       |      sasl->authused = SASL_MECH_SCRAM_SHA_1;
  410|       |      state1 = SASL_GSASL;
  411|       |      state2 = SASL_GSASL;
  412|       |
  413|       |      result = Curl_auth_gsasl_start(data, conn->user,
  414|       |                                     conn->passwd, &conn->gsasl);
  415|       |      if(result == CURLE_OK && (force_ir || data->set.sasl_ir))
  416|       |        result = Curl_auth_gsasl_token(data, &nullmsg, &conn->gsasl, &resp);
  417|       |    }
  418|       |    else
  419|       |#endif
  420|    131|#ifndef CURL_DISABLE_CRYPTO_AUTH
  421|    131|    if((enabledmechs & SASL_MECH_DIGEST_MD5) &&
  422|    131|       Curl_auth_is_digest_supported()) {
  423|     12|      mech = SASL_MECH_STRING_DIGEST_MD5;
  424|     12|      state1 = SASL_DIGESTMD5;
  425|     12|      sasl->authused = SASL_MECH_DIGEST_MD5;
  426|     12|    }
  427|    119|    else if(enabledmechs & SASL_MECH_CRAM_MD5) {
  428|     67|      mech = SASL_MECH_STRING_CRAM_MD5;
  429|     67|      state1 = SASL_CRAMMD5;
  430|     67|      sasl->authused = SASL_MECH_CRAM_MD5;
  431|     67|    }
  432|     52|    else
  433|     52|#endif
  434|     52|#ifdef USE_NTLM
  435|     52|    if((enabledmechs & SASL_MECH_NTLM) && Curl_auth_is_ntlm_supported()) {
  436|      0|      mech = SASL_MECH_STRING_NTLM;
  437|      0|      state1 = SASL_NTLM;
  438|      0|      state2 = SASL_NTLM_TYPE2MSG;
  439|      0|      sasl->authused = SASL_MECH_NTLM;
  440|       |
  441|      0|      if(force_ir || data->set.sasl_ir)
  442|      0|        result = Curl_auth_create_ntlm_type1_message(data,
  443|      0|                                                     conn->user, conn->passwd,
  444|      0|                                                     service,
  445|      0|                                                     hostname,
  446|      0|                                                     &conn->ntlm, &resp);
  447|      0|      }
  448|     52|    else
  449|     52|#endif
  450|     52|    if((enabledmechs & SASL_MECH_OAUTHBEARER) && oauth_bearer) {
  451|      0|      mech = SASL_MECH_STRING_OAUTHBEARER;
  452|      0|      state1 = SASL_OAUTH2;
  453|      0|      state2 = SASL_OAUTH2_RESP;
  454|      0|      sasl->authused = SASL_MECH_OAUTHBEARER;
  455|       |
  456|      0|      if(force_ir || data->set.sasl_ir)
  457|      0|        result = Curl_auth_create_oauth_bearer_message(conn->user,
  458|      0|                                                       hostname,
  459|      0|                                                       port,
  460|      0|                                                       oauth_bearer,
  461|      0|                                                       &resp);
  462|      0|    }
  463|     52|    else if((enabledmechs & SASL_MECH_XOAUTH2) && oauth_bearer) {
  464|      0|      mech = SASL_MECH_STRING_XOAUTH2;
  465|      0|      state1 = SASL_OAUTH2;
  466|      0|      sasl->authused = SASL_MECH_XOAUTH2;
  467|       |
  468|      0|      if(force_ir || data->set.sasl_ir)
  469|      0|        result = Curl_auth_create_xoauth_bearer_message(conn->user,
  470|      0|                                                        oauth_bearer,
  471|      0|                                                        &resp);
  472|      0|    }
  473|     52|    else if(enabledmechs & SASL_MECH_PLAIN) {
  474|      2|      mech = SASL_MECH_STRING_PLAIN;
  475|      2|      state1 = SASL_PLAIN;
  476|      2|      sasl->authused = SASL_MECH_PLAIN;
  477|       |
  478|      2|      if(force_ir || data->set.sasl_ir)
  479|      0|        result = Curl_auth_create_plain_message(conn->sasl_authzid,
  480|      0|                                                conn->user, conn->passwd,
  481|      0|                                                &resp);
  482|      2|    }
  483|     50|    else if(enabledmechs & SASL_MECH_LOGIN) {
  484|     10|      mech = SASL_MECH_STRING_LOGIN;
  485|     10|      state1 = SASL_LOGIN;
  486|     10|      state2 = SASL_LOGIN_PASSWD;
  487|     10|      sasl->authused = SASL_MECH_LOGIN;
  488|       |
  489|     10|      if(force_ir || data->set.sasl_ir)
  490|      0|        result = Curl_auth_create_login_message(conn->user, &resp);
  491|     10|    }
  492|    131|  }
  493|       |
  494|    131|  if(!result && mech) {
  495|     91|    sasl->curmech = mech;
  496|     91|    if(Curl_bufref_ptr(&resp))
  497|      0|      result = build_message(sasl, data, &resp);
  498|       |
  499|     91|    if(sasl->params->maxirlen &&
  500|     91|       strlen(mech) + Curl_bufref_len(&resp) > sasl->params->maxirlen)
  501|      0|      Curl_bufref_free(&resp);
  502|       |
  503|     91|    if(!result)
  504|     91|      result = sasl->params->sendauth(data, mech, &resp);
  505|       |
  506|     91|    if(!result) {
  507|     91|      *progress = SASL_INPROGRESS;
  508|     91|      state(sasl, data, Curl_bufref_ptr(&resp) ? state2 : state1);
  509|     91|    }
  510|     91|  }
  511|       |
  512|    131|  Curl_bufref_free(&resp);
  513|    131|  return result;
  514|    131|}
Curl_sasl_continue:
  523|    137|{
  524|    137|  CURLcode result = CURLE_OK;
  525|    137|  struct connectdata *conn = data->conn;
  526|    137|  saslstate newstate = SASL_FINAL;
  527|    137|  struct bufref resp;
  528|    137|  const char * const hostname = SSL_HOST_NAME();
  529|    137|  const long int port = SSL_HOST_PORT();
  530|    137|#if !defined(CURL_DISABLE_CRYPTO_AUTH) || defined(USE_KERBEROS5) ||     \
  531|    137|  defined(USE_NTLM)
  532|    137|  const char *service = data->set.str[STRING_SERVICE_NAME] ?
  533|      0|    data->set.str[STRING_SERVICE_NAME] :
  534|    137|    sasl->params->service;
  535|    137|#endif
  536|    137|  const char *oauth_bearer = data->set.str[STRING_BEARER];
  537|    137|  struct bufref serverdata;
  538|       |
  539|    137|  Curl_bufref_init(&serverdata);
  540|    137|  Curl_bufref_init(&resp);
  541|    137|  *progress = SASL_INPROGRESS;
  542|       |
  543|    137|  if(sasl->state == SASL_FINAL) {
  544|     14|    if(code != sasl->params->finalcode)
  545|     13|      result = CURLE_LOGIN_DENIED;
  546|     14|    *progress = SASL_DONE;
  547|     14|    state(sasl, data, SASL_STOP);
  548|     14|    return result;
  549|     14|  }
  550|       |
  551|    123|  if(sasl->state != SASL_CANCEL && sasl->state != SASL_OAUTH2_RESP &&
  552|    123|     code != sasl->params->contcode) {
  553|      1|    *progress = SASL_DONE;
  554|      1|    state(sasl, data, SASL_STOP);
  555|      1|    return CURLE_LOGIN_DENIED;
  556|      1|  }
  557|       |
  558|    122|  switch(sasl->state) {
  559|      0|  case SASL_STOP:
  560|      0|    *progress = SASL_DONE;
  561|      0|    return result;
  562|      1|  case SASL_PLAIN:
  563|      1|    result = Curl_auth_create_plain_message(conn->sasl_authzid,
  564|      1|                                            conn->user, conn->passwd, &resp);
  565|      1|    break;
  566|      9|  case SASL_LOGIN:
  567|      9|    result = Curl_auth_create_login_message(conn->user, &resp);
  568|      9|    newstate = SASL_LOGIN_PASSWD;
  569|      9|    break;
  570|      7|  case SASL_LOGIN_PASSWD:
  571|      7|    result = Curl_auth_create_login_message(conn->passwd, &resp);
  572|      7|    break;
  573|      0|  case SASL_EXTERNAL:
  574|      0|    result = Curl_auth_create_external_message(conn->user, &resp);
  575|      0|    break;
  576|      0|#ifndef CURL_DISABLE_CRYPTO_AUTH
  577|       |#ifdef USE_GSASL
  578|       |  case SASL_GSASL:
  579|       |    result = get_server_message(sasl, data, &serverdata);
  580|       |    if(!result)
  581|       |      result = Curl_auth_gsasl_token(data, &serverdata, &conn->gsasl, &resp);
  582|       |    if(!result && Curl_bufref_len(&resp) > 0)
  583|       |      newstate = SASL_GSASL;
  584|       |    break;
  585|       |#endif
  586|     66|  case SASL_CRAMMD5:
  587|     66|    result = get_server_message(sasl, data, &serverdata);
  588|     66|    if(!result)
  589|     29|      result = Curl_auth_create_cram_md5_message(&serverdata, conn->user,
  590|     29|                                                 conn->passwd, &resp);
  591|     66|    break;
  592|     12|  case SASL_DIGESTMD5:
  593|     12|    result = get_server_message(sasl, data, &serverdata);
  594|     12|    if(!result)
  595|      6|      result = Curl_auth_create_digest_md5_message(data, &serverdata,
  596|      6|                                                   conn->user, conn->passwd,
  597|      6|                                                   service, &resp);
  598|     12|    if(!result && (sasl->params->flags & SASL_FLAG_BASE64))
  599|      0|      newstate = SASL_DIGESTMD5_RESP;
  600|     12|    break;
  601|      0|  case SASL_DIGESTMD5_RESP:
  602|       |    /* Keep response NULL to output an empty line. */
  603|      0|    break;
  604|      0|#endif
  605|       |
  606|      0|#ifdef USE_NTLM
  607|      0|  case SASL_NTLM:
  608|       |    /* Create the type-1 message */
  609|      0|    result = Curl_auth_create_ntlm_type1_message(data,
  610|      0|                                                 conn->user, conn->passwd,
  611|      0|                                                 service, hostname,
  612|      0|                                                 &conn->ntlm, &resp);
  613|      0|    newstate = SASL_NTLM_TYPE2MSG;
  614|      0|    break;
  615|      0|  case SASL_NTLM_TYPE2MSG:
  616|       |    /* Decode the type-2 message */
  617|      0|    result = get_server_message(sasl, data, &serverdata);
  618|      0|    if(!result)
  619|      0|      result = Curl_auth_decode_ntlm_type2_message(data, &serverdata,
  620|      0|                                                   &conn->ntlm);
  621|      0|    if(!result)
  622|      0|      result = Curl_auth_create_ntlm_type3_message(data, conn->user,
  623|      0|                                                   conn->passwd, &conn->ntlm,
  624|      0|                                                   &resp);
  625|      0|    break;
  626|      0|#endif
  627|       |
  628|       |#if defined(USE_KERBEROS5)
  629|       |  case SASL_GSSAPI:
  630|       |    result = Curl_auth_create_gssapi_user_message(data, conn->user,
  631|       |                                                  conn->passwd,
  632|       |                                                  service,
  633|       |                                                  conn->host.name,
  634|       |                                                  sasl->mutual_auth, NULL,
  635|       |                                                  &conn->krb5,
  636|       |                                                  &resp);
  637|       |    newstate = SASL_GSSAPI_TOKEN;
  638|       |    break;
  639|       |  case SASL_GSSAPI_TOKEN:
  640|       |    result = get_server_message(sasl, data, &serverdata);
  641|       |    if(!result) {
  642|       |      if(sasl->mutual_auth) {
  643|       |        /* Decode the user token challenge and create the optional response
  644|       |           message */
  645|       |        result = Curl_auth_create_gssapi_user_message(data, NULL, NULL,
  646|       |                                                      NULL, NULL,
  647|       |                                                      sasl->mutual_auth,
  648|       |                                                      &serverdata,
  649|       |                                                      &conn->krb5,
  650|       |                                                      &resp);
  651|       |        newstate = SASL_GSSAPI_NO_DATA;
  652|       |      }
  653|       |      else
  654|       |        /* Decode the security challenge and create the response message */
  655|       |        result = Curl_auth_create_gssapi_security_message(data,
  656|       |                                                          conn->sasl_authzid,
  657|       |                                                          &serverdata,
  658|       |                                                          &conn->krb5,
  659|       |                                                          &resp);
  660|       |    }
  661|       |    break;
  662|       |  case SASL_GSSAPI_NO_DATA:
  663|       |    /* Decode the security challenge and create the response message */
  664|       |    result = get_server_message(sasl, data, &serverdata);
  665|       |    if(!result)
  666|       |      result = Curl_auth_create_gssapi_security_message(data,
  667|       |                                                        conn->sasl_authzid,
  668|       |                                                        &serverdata,
  669|       |                                                        &conn->krb5,
  670|       |                                                        &resp);
  671|       |    break;
  672|       |#endif
  673|       |
  674|      0|  case SASL_OAUTH2:
  675|       |    /* Create the authorisation message */
  676|      0|    if(sasl->authused == SASL_MECH_OAUTHBEARER) {
  677|      0|      result = Curl_auth_create_oauth_bearer_message(conn->user,
  678|      0|                                                     hostname,
  679|      0|                                                     port,
  680|      0|                                                     oauth_bearer,
  681|      0|                                                     &resp);
  682|       |
  683|       |      /* Failures maybe sent by the server as continuations for OAUTHBEARER */
  684|      0|      newstate = SASL_OAUTH2_RESP;
  685|      0|    }
  686|      0|    else
  687|      0|      result = Curl_auth_create_xoauth_bearer_message(conn->user,
  688|      0|                                                      oauth_bearer,
  689|      0|                                                      &resp);
  690|      0|    break;
  691|       |
  692|      0|  case SASL_OAUTH2_RESP:
  693|       |    /* The continuation is optional so check the response code */
  694|      0|    if(code == sasl->params->finalcode) {
  695|       |      /* Final response was received so we are done */
  696|      0|      *progress = SASL_DONE;
  697|      0|      state(sasl, data, SASL_STOP);
  698|      0|      return result;
  699|      0|    }
  700|      0|    else if(code == sasl->params->contcode) {
  701|       |      /* Acknowledge the continuation by sending a 0x01 response. */
  702|      0|      Curl_bufref_set(&resp, "\x01", 1, NULL);
  703|      0|      break;
  704|      0|    }
  705|      0|    else {
  706|      0|      *progress = SASL_DONE;
  707|      0|      state(sasl, data, SASL_STOP);
  708|      0|      return CURLE_LOGIN_DENIED;
  709|      0|    }
  710|       |
  711|     27|  case SASL_CANCEL:
  712|       |    /* Remove the offending mechanism from the supported list */
  713|     27|    sasl->authmechs ^= sasl->authused;
  714|       |
  715|       |    /* Start an alternative SASL authentication */
  716|     27|    return Curl_sasl_start(sasl, data, sasl->force_ir, progress);
  717|      0|  default:
  718|      0|    failf(data, "Unsupported SASL authentication mechanism");
  719|      0|    result = CURLE_UNSUPPORTED_PROTOCOL;  /* Should not happen */
  720|      0|    break;
  721|    122|  }
  722|       |
  723|     95|  Curl_bufref_free(&serverdata);
  724|       |
  725|     95|  switch(result) {
  726|     49|  case CURLE_BAD_CONTENT_ENCODING:
  727|       |    /* Cancel dialog */
  728|     49|    result = sasl->params->cancelauth(data, sasl->curmech);
  729|     49|    newstate = SASL_CANCEL;
  730|     49|    break;
  731|     46|  case CURLE_OK:
  732|     46|    result = build_message(sasl, data, &resp);
  733|     46|    if(!result)
  734|     46|      result = sasl->params->contauth(data, sasl->curmech, &resp);
  735|     46|    break;
  736|      0|  default:
  737|      0|    newstate = SASL_STOP;    /* Stop on error */
  738|      0|    *progress = SASL_DONE;
  739|      0|    break;
  740|     95|  }
  741|       |
  742|     95|  Curl_bufref_free(&resp);
  743|       |
  744|     95|  state(sasl, data, newstate);
  745|       |
  746|     95|  return result;
  747|     95|}
curl_sasl.c:build_message:
  288|     46|{
  289|     46|  CURLcode result = CURLE_OK;
  290|       |
  291|     46|  if(sasl->params->flags & SASL_FLAG_BASE64) {
  292|     46|    if(!Curl_bufref_ptr(msg))                   /* Empty message. */
  293|      0|      Curl_bufref_set(msg, "", 0, NULL);
  294|     46|    else if(!Curl_bufref_len(msg))              /* Explicit empty response. */
  295|      4|      Curl_bufref_set(msg, "=", 1, NULL);
  296|     42|    else {
  297|     42|      char *base64;
  298|     42|      size_t base64len;
  299|       |
  300|     42|      result = Curl_base64_encode(data, (const char *) Curl_bufref_ptr(msg),
  301|     42|                                  Curl_bufref_len(msg), &base64, &base64len);
  302|     42|      if(!result)
  303|     42|        Curl_bufref_set(msg, base64, base64len, curl_free);
  304|     42|    }
  305|     46|  }
  306|       |
  307|     46|  return result;
  308|     46|}
curl_sasl.c:state:
  227|    201|{
  228|    201|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
  229|       |  /* for debug purposes */
  230|    201|  static const char * const names[]={
  231|    201|    "STOP",
  232|    201|    "PLAIN",
  233|    201|    "LOGIN",
  234|    201|    "LOGIN_PASSWD",
  235|    201|    "EXTERNAL",
  236|    201|    "CRAMMD5",
  237|    201|    "DIGESTMD5",
  238|    201|    "DIGESTMD5_RESP",
  239|    201|    "NTLM",
  240|    201|    "NTLM_TYPE2MSG",
  241|    201|    "GSSAPI",
  242|    201|    "GSSAPI_TOKEN",
  243|    201|    "GSSAPI_NO_DATA",
  244|    201|    "OAUTH2",
  245|    201|    "OAUTH2_RESP",
  246|    201|    "GSASL",
  247|    201|    "CANCEL",
  248|    201|    "FINAL",
  249|       |    /* LAST */
  250|    201|  };
  251|       |
  252|    201|  if(sasl->state != newstate)
  253|    201|    infof(data, "SASL %p state change from %s to %s",
  254|    201|          (void *)sasl, names[sasl->state], names[newstate]);
  255|       |#else
  256|       |  (void) data;
  257|       |#endif
  258|       |
  259|    201|  sasl->state = newstate;
  260|    201|}
curl_sasl.c:get_server_message:
  265|     78|{
  266|     78|  CURLcode result = CURLE_OK;
  267|       |
  268|     78|  result = sasl->params->getmessage(data, out);
  269|     78|  if(!result && (sasl->params->flags & SASL_FLAG_BASE64)) {
  270|     78|    unsigned char *msg;
  271|     78|    size_t msglen;
  272|     78|    const char *serverdata = (const char *) Curl_bufref_ptr(out);
  273|       |
  274|     78|    if(!*serverdata || *serverdata == '=')
  275|     16|      Curl_bufref_set(out, NULL, 0, NULL);
  276|     62|    else {
  277|     62|      result = Curl_base64_decode(serverdata, &msg, &msglen);
  278|     62|      if(!result)
  279|     19|        Curl_bufref_set(out, msg, msglen, curl_free);
  280|     62|    }
  281|     78|  }
  282|     78|  return result;
  283|     78|}

Curl_thread_create:
   63|      7|{
   64|      7|  curl_thread_t t = malloc(sizeof(pthread_t));
   65|      7|  struct Curl_actual_call *ac = malloc(sizeof(struct Curl_actual_call));
   66|      7|  if(!(ac && t))
   67|      0|    goto err;
   68|       |
   69|      7|  ac->func = func;
   70|      7|  ac->arg = arg;
   71|       |
   72|      7|  if(pthread_create(t, NULL, curl_thread_create_thunk, ac) != 0)
   73|      0|    goto err;
   74|       |
   75|      7|  return t;
   76|       |
   77|      0|err:
   78|      0|  free(t);
   79|      0|  free(ac);
   80|      0|  return curl_thread_t_null;
   81|      7|}
Curl_thread_join:
   92|      7|{
   93|      7|  int ret = (pthread_join(**hnd, NULL) == 0);
   94|       |
   95|      7|  free(*hnd);
   96|      7|  *hnd = curl_thread_t_null;
   97|       |
   98|      7|  return ret;
   99|      7|}
curl_threads.c:curl_thread_create_thunk:
   50|      7|{
   51|      7|  struct Curl_actual_call *ac = arg;
   52|      7|  unsigned int (*func)(void *) = ac->func;
   53|      7|  void *real_arg = ac->arg;
   54|       |
   55|      7|  free(ac);
   56|       |
   57|      7|  (*func)(real_arg);
   58|       |
   59|      7|  return 0;
   60|      7|}

dict.c:dict_do:
  177|     43|{
  178|     43|  char *word;
  179|     43|  char *eword;
  180|     43|  char *ppath;
  181|     43|  char *database = NULL;
  182|     43|  char *strategy = NULL;
  183|     43|  char *nthdef = NULL; /* This is not part of the protocol, but required
  184|       |                          by RFC 2229 */
  185|     43|  CURLcode result = CURLE_OK;
  186|     43|  struct connectdata *conn = data->conn;
  187|     43|  curl_socket_t sockfd = conn->sock[FIRSTSOCKET];
  188|       |
  189|     43|  char *path = data->state.up.path;
  190|       |
  191|     43|  *done = TRUE; /* unconditionally */
  192|       |
  193|     43|  if(conn->bits.user_passwd) {
  194|       |    /* AUTH is missing */
  195|      1|  }
  196|       |
  197|     43|  if(strncasecompare(path, DICT_MATCH, sizeof(DICT_MATCH)-1) ||
  198|     43|     strncasecompare(path, DICT_MATCH2, sizeof(DICT_MATCH2)-1) ||
  199|     43|     strncasecompare(path, DICT_MATCH3, sizeof(DICT_MATCH3)-1)) {
  200|       |
  201|      6|    word = strchr(path, ':');
  202|      6|    if(word) {
  203|      6|      word++;
  204|      6|      database = strchr(word, ':');
  205|      6|      if(database) {
  206|      3|        *database++ = (char)0;
  207|      3|        strategy = strchr(database, ':');
  208|      3|        if(strategy) {
  209|      2|          *strategy++ = (char)0;
  210|      2|          nthdef = strchr(strategy, ':');
  211|      2|          if(nthdef) {
  212|      1|            *nthdef = (char)0;
  213|      1|          }
  214|      2|        }
  215|      3|      }
  216|      6|    }
  217|       |
  218|      6|    if(!word || (*word == (char)0)) {
  219|      1|      infof(data, "lookup word is missing");
  220|      1|      word = (char *)"default";
  221|      1|    }
  222|      6|    if(!database || (*database == (char)0)) {
  223|      5|      database = (char *)"!";
  224|      5|    }
  225|      6|    if(!strategy || (*strategy == (char)0)) {
  226|      5|      strategy = (char *)".";
  227|      5|    }
  228|       |
  229|      6|    eword = unescape_word(data, word);
  230|      6|    if(!eword)
  231|      0|      return CURLE_OUT_OF_MEMORY;
  232|       |
  233|      6|    result = sendf(sockfd, data,
  234|      6|                   "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\r\n"
  235|      6|                   "MATCH "
  236|      6|                   "%s "    /* database */
  237|      6|                   "%s "    /* strategy */
  238|      6|                   "%s\r\n" /* word */
  239|      6|                   "QUIT\r\n",
  240|      6|                   database,
  241|      6|                   strategy,
  242|      6|                   eword);
  243|       |
  244|      6|    free(eword);
  245|       |
  246|      6|    if(result) {
  247|      0|      failf(data, "Failed sending DICT request");
  248|      0|      return result;
  249|      0|    }
  250|      6|    Curl_setup_transfer(data, FIRSTSOCKET, -1, FALSE, -1); /* no upload */
  251|      6|  }
  252|     37|  else if(strncasecompare(path, DICT_DEFINE, sizeof(DICT_DEFINE)-1) ||
  253|     37|          strncasecompare(path, DICT_DEFINE2, sizeof(DICT_DEFINE2)-1) ||
  254|     37|          strncasecompare(path, DICT_DEFINE3, sizeof(DICT_DEFINE3)-1)) {
  255|       |
  256|     21|    word = strchr(path, ':');
  257|     21|    if(word) {
  258|     21|      word++;
  259|     21|      database = strchr(word, ':');
  260|     21|      if(database) {
  261|      3|        *database++ = (char)0;
  262|      3|        nthdef = strchr(database, ':');
  263|      3|        if(nthdef) {
  264|      1|          *nthdef = (char)0;
  265|      1|        }
  266|      3|      }
  267|     21|    }
  268|       |
  269|     21|    if(!word || (*word == (char)0)) {
  270|      1|      infof(data, "lookup word is missing");
  271|      1|      word = (char *)"default";
  272|      1|    }
  273|     21|    if(!database || (*database == (char)0)) {
  274|     20|      database = (char *)"!";
  275|     20|    }
  276|       |
  277|     21|    eword = unescape_word(data, word);
  278|     21|    if(!eword)
  279|      0|      return CURLE_OUT_OF_MEMORY;
  280|       |
  281|     21|    result = sendf(sockfd, data,
  282|     21|                   "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\r\n"
  283|     21|                   "DEFINE "
  284|     21|                   "%s "     /* database */
  285|     21|                   "%s\r\n"  /* word */
  286|     21|                   "QUIT\r\n",
  287|     21|                   database,
  288|     21|                   eword);
  289|       |
  290|     21|    free(eword);
  291|       |
  292|     21|    if(result) {
  293|      0|      failf(data, "Failed sending DICT request");
  294|      0|      return result;
  295|      0|    }
  296|     21|    Curl_setup_transfer(data, FIRSTSOCKET, -1, FALSE, -1);
  297|     21|  }
  298|     16|  else {
  299|       |
  300|     16|    ppath = strchr(path, '/');
  301|     16|    if(ppath) {
  302|     16|      int i;
  303|       |
  304|     16|      ppath++;
  305|    343|      for(i = 0; ppath[i]; i++) {
  306|    327|        if(ppath[i] == ':')
  307|     14|          ppath[i] = ' ';
  308|    327|      }
  309|     16|      result = sendf(sockfd, data,
  310|     16|                     "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\r\n"
  311|     16|                     "%s\r\n"
  312|     16|                     "QUIT\r\n", ppath);
  313|     16|      if(result) {
  314|      0|        failf(data, "Failed sending DICT request");
  315|      0|        return result;
  316|      0|      }
  317|       |
  318|     16|      Curl_setup_transfer(data, FIRSTSOCKET, -1, FALSE, -1);
  319|     16|    }
  320|     16|  }
  321|       |
  322|     43|  return CURLE_OK;
  323|     43|}
dict.c:unescape_word:
  100|     27|{
  101|     27|  char *newp = NULL;
  102|     27|  char *dictp;
  103|     27|  size_t len;
  104|       |
  105|     27|  CURLcode result = Curl_urldecode(data, inputbuff, 0, &newp, &len,
  106|     27|                                   REJECT_NADA);
  107|     27|  if(!newp || result)
  108|      0|    return NULL;
  109|       |
  110|     27|  dictp = malloc(len*2 + 1); /* add one for terminating zero */
  111|     27|  if(dictp) {
  112|     27|    char *ptr;
  113|     27|    char ch;
  114|     27|    int olen = 0;
  115|       |    /* According to RFC2229 section 2.2, these letters need to be escaped with
  116|       |       \[letter] */
  117|     27|    for(ptr = newp;
  118|    696|        (ch = *ptr) != 0;
  119|    669|        ptr++) {
  120|    669|      if((ch <= 32) || (ch == 127) ||
  121|    669|          (ch == '\'') || (ch == '\"') || (ch == '\\')) {
  122|    271|        dictp[olen++] = '\\';
  123|    271|      }
  124|    669|      dictp[olen++] = ch;
  125|    669|    }
  126|     27|    dictp[olen] = 0;
  127|     27|  }
  128|     27|  free(newp);
  129|     27|  return dictp;
  130|     27|}
dict.c:sendf:
  135|     43|{
  136|     43|  ssize_t bytes_written;
  137|     43|  size_t write_len;
  138|     43|  CURLcode result = CURLE_OK;
  139|     43|  char *s;
  140|     43|  char *sptr;
  141|     43|  va_list ap;
  142|     43|  va_start(ap, fmt);
  143|     43|  s = vaprintf(fmt, ap); /* returns an allocated string */
  144|     43|  va_end(ap);
  145|     43|  if(!s)
  146|      0|    return CURLE_OUT_OF_MEMORY; /* failure */
  147|       |
  148|     43|  bytes_written = 0;
  149|     43|  write_len = strlen(s);
  150|     43|  sptr = s;
  151|       |
  152|     43|  for(;;) {
  153|       |    /* Write the buffer to the socket */
  154|     43|    result = Curl_write(data, sockfd, sptr, write_len, &bytes_written);
  155|       |
  156|     43|    if(result)
  157|      0|      break;
  158|       |
  159|     43|    Curl_debug(data, CURLINFO_DATA_OUT, sptr, (size_t)bytes_written);
  160|       |
  161|     43|    if((size_t)bytes_written != write_len) {
  162|       |      /* if not all was written at once, we must advance the pointer, decrease
  163|       |         the size left and try again! */
  164|      0|      write_len -= bytes_written;
  165|      0|      sptr += bytes_written;
  166|      0|    }
  167|     43|    else
  168|     43|      break;
  169|     43|  }
  170|       |
  171|     43|  free(s); /* free the output string */
  172|       |
  173|     43|  return result;
  174|     43|}

Curl_dedotdotify:
   54|  2.54k|{
   55|  2.54k|  size_t inlen = strlen(input);
   56|  2.54k|  char *clone;
   57|  2.54k|  size_t clen = inlen; /* the length of the cloned input */
   58|  2.54k|  char *out = malloc(inlen + 1);
   59|  2.54k|  char *outptr;
   60|  2.54k|  char *orgclone;
   61|  2.54k|  char *queryp;
   62|  2.54k|  if(!out)
   63|      0|    return NULL; /* out of memory */
   64|       |
   65|  2.54k|  *out = 0; /* null-terminates, for inputs like "./" */
   66|       |
   67|       |  /* get a cloned copy of the input */
   68|  2.54k|  clone = strdup(input);
   69|  2.54k|  if(!clone) {
   70|      0|    free(out);
   71|      0|    return NULL;
   72|      0|  }
   73|  2.54k|  orgclone = clone;
   74|  2.54k|  outptr = out;
   75|       |
   76|  2.54k|  if(!*clone) {
   77|       |    /* zero length string, return that */
   78|      0|    free(out);
   79|      0|    return clone;
   80|      0|  }
   81|       |
   82|       |  /*
   83|       |   * To handle query-parts properly, we must find it and remove it during the
   84|       |   * dotdot-operation and then append it again at the end to the output
   85|       |   * string.
   86|       |   */
   87|  2.54k|  queryp = strchr(clone, '?');
   88|  2.54k|  if(queryp)
   89|      0|    *queryp = 0;
   90|       |
   91|  4.98k|  do {
   92|       |
   93|       |    /*  A.  If the input buffer begins with a prefix of "../" or "./", then
   94|       |        remove that prefix from the input buffer; otherwise, */
   95|       |
   96|  4.98k|    if(!strncmp("./", clone, 2)) {
   97|      0|      clone += 2;
   98|      0|      clen -= 2;
   99|      0|    }
  100|  4.98k|    else if(!strncmp("../", clone, 3)) {
  101|      0|      clone += 3;
  102|      0|      clen -= 3;
  103|      0|    }
  104|       |
  105|       |    /*  B.  if the input buffer begins with a prefix of "/./" or "/.", where
  106|       |        "."  is a complete path segment, then replace that prefix with "/" in
  107|       |        the input buffer; otherwise, */
  108|  4.98k|    else if(!strncmp("/./", clone, 3)) {
  109|     90|      clone += 2;
  110|     90|      clen -= 2;
  111|     90|    }
  112|  4.89k|    else if(!strcmp("/.", clone)) {
  113|     20|      clone[1]='/';
  114|     20|      clone++;
  115|     20|      clen -= 1;
  116|     20|    }
  117|       |
  118|       |    /*  C.  if the input buffer begins with a prefix of "/../" or "/..", where
  119|       |        ".." is a complete path segment, then replace that prefix with "/" in
  120|       |        the input buffer and remove the last segment and its preceding "/" (if
  121|       |        any) from the output buffer; otherwise, */
  122|       |
  123|  4.87k|    else if(!strncmp("/../", clone, 4)) {
  124|     87|      clone += 3;
  125|     87|      clen -= 3;
  126|       |      /* remove the last segment from the output buffer */
  127|    630|      while(outptr > out) {
  128|    610|        outptr--;
  129|    610|        if(*outptr == '/')
  130|     67|          break;
  131|    610|      }
  132|     87|      *outptr = 0; /* null-terminate where it stops */
  133|     87|    }
  134|  4.78k|    else if(!strcmp("/..", clone)) {
  135|     17|      clone[2]='/';
  136|     17|      clone += 2;
  137|     17|      clen -= 2;
  138|       |      /* remove the last segment from the output buffer */
  139|    257|      while(outptr > out) {
  140|    254|        outptr--;
  141|    254|        if(*outptr == '/')
  142|     14|          break;
  143|    254|      }
  144|     17|      *outptr = 0; /* null-terminate where it stops */
  145|     17|    }
  146|       |
  147|       |    /*  D.  if the input buffer consists only of "." or "..", then remove
  148|       |        that from the input buffer; otherwise, */
  149|       |
  150|  4.76k|    else if(!strcmp(".", clone) || !strcmp("..", clone)) {
  151|      0|      *clone = 0;
  152|      0|      *out = 0;
  153|      0|    }
  154|       |
  155|  4.76k|    else {
  156|       |      /*  E.  move the first path segment in the input buffer to the end of
  157|       |          the output buffer, including the initial "/" character (if any) and
  158|       |          any subsequent characters up to, but not including, the next "/"
  159|       |          character or the end of the input buffer. */
  160|       |
  161|  56.3k|      do {
  162|  56.3k|        *outptr++ = *clone++;
  163|  56.3k|        clen--;
  164|  56.3k|      } while(*clone && (*clone != '/'));
  165|  4.76k|      *outptr = 0;
  166|  4.76k|    }
  167|       |
  168|  4.98k|  } while(*clone);
  169|       |
  170|  2.54k|  if(queryp) {
  171|      0|    size_t qlen;
  172|       |    /* There was a query part, append that to the output. The 'clone' string
  173|       |       may now have been altered so we copy from the original input string
  174|       |       from the correct index. */
  175|      0|    size_t oindex = queryp - orgclone;
  176|      0|    qlen = strlen(&input[oindex]);
  177|      0|    memcpy(outptr, &input[oindex], qlen + 1); /* include the end zero byte */
  178|      0|  }
  179|       |
  180|  2.54k|  free(orgclone);
  181|  2.54k|  return out;
  182|  2.54k|}

Curl_dyn_init:
   39|  23.9k|{
   40|  23.9k|  DEBUGASSERT(s);
   41|  23.9k|  DEBUGASSERT(toobig);
   42|  23.9k|  s->bufr = NULL;
   43|  23.9k|  s->leng = 0;
   44|  23.9k|  s->allc = 0;
   45|  23.9k|  s->toobig = toobig;
   46|  23.9k|#ifdef DEBUGBUILD
   47|  23.9k|  s->init = DYNINIT;
   48|  23.9k|#endif
   49|  23.9k|}
Curl_dyn_free:
   56|  17.0k|{
   57|  17.0k|  DEBUGASSERT(s);
   58|  17.0k|  Curl_safefree(s->bufr);
   59|  17.0k|  s->leng = s->allc = 0;
   60|  17.0k|}
Curl_dyn_reset:
  120|  28.7k|{
  121|  28.7k|  DEBUGASSERT(s);
  122|  28.7k|  DEBUGASSERT(s->init == DYNINIT);
  123|  28.7k|  DEBUGASSERT(!s->leng || s->bufr);
  124|  28.7k|  if(s->leng)
  125|  24.9k|    s->bufr[0] = 0;
  126|  28.7k|  s->leng = 0;
  127|  28.7k|}
Curl_dyn_addn:
  160|   880k|{
  161|   880k|  DEBUGASSERT(s);
  162|   880k|  DEBUGASSERT(s->init == DYNINIT);
  163|   880k|  DEBUGASSERT(!s->leng || s->bufr);
  164|   880k|  return dyn_nappend(s, mem, len);
  165|   880k|}
Curl_dyn_add:
  171|  2.85k|{
  172|  2.85k|  size_t n = strlen(str);
  173|  2.85k|  DEBUGASSERT(s);
  174|  2.85k|  DEBUGASSERT(s->init == DYNINIT);
  175|  2.85k|  DEBUGASSERT(!s->leng || s->bufr);
  176|  2.85k|  return dyn_nappend(s, (unsigned char *)str, n);
  177|  2.85k|}
Curl_dyn_vaddf:
  183|  10.2k|{
  184|  10.2k|#ifdef BUILDING_LIBCURL
  185|  10.2k|  int rc;
  186|  10.2k|  DEBUGASSERT(s);
  187|  10.2k|  DEBUGASSERT(s->init == DYNINIT);
  188|  10.2k|  DEBUGASSERT(!s->leng || s->bufr);
  189|  10.2k|  rc = Curl_dyn_vprintf(s, fmt, ap);
  190|       |
  191|  10.2k|  if(!rc)
  192|  10.2k|    return CURLE_OK;
  193|       |#else
  194|       |  char *str;
  195|       |  str = vaprintf(fmt, ap); /* this allocs a new string to append */
  196|       |
  197|       |  if(str) {
  198|       |    CURLcode result = dyn_nappend(s, (unsigned char *)str, strlen(str));
  199|       |    free(str);
  200|       |    return result;
  201|       |  }
  202|       |  /* If we failed, we cleanup the whole buffer and return error */
  203|       |  Curl_dyn_free(s);
  204|       |#endif
  205|      0|  return CURLE_OUT_OF_MEMORY;
  206|  10.2k|}
Curl_dyn_addf:
  212|  6.29k|{
  213|  6.29k|  CURLcode result;
  214|  6.29k|  va_list ap;
  215|  6.29k|  DEBUGASSERT(s);
  216|  6.29k|  DEBUGASSERT(s->init == DYNINIT);
  217|  6.29k|  DEBUGASSERT(!s->leng || s->bufr);
  218|  6.29k|  va_start(ap, fmt);
  219|  6.29k|  result = Curl_dyn_vaddf(s, fmt, ap);
  220|  6.29k|  va_end(ap);
  221|  6.29k|  return result;
  222|  6.29k|}
Curl_dyn_ptr:
  228|  44.1k|{
  229|  44.1k|  DEBUGASSERT(s);
  230|  44.1k|  DEBUGASSERT(s->init == DYNINIT);
  231|  44.1k|  DEBUGASSERT(!s->leng || s->bufr);
  232|  44.1k|  return s->bufr;
  233|  44.1k|}
Curl_dyn_len:
  250|   102k|{
  251|   102k|  DEBUGASSERT(s);
  252|   102k|  DEBUGASSERT(s->init == DYNINIT);
  253|   102k|  DEBUGASSERT(!s->leng || s->bufr);
  254|   102k|  return s->leng;
  255|   102k|}
dynbuf.c:dyn_nappend:
   67|   883k|{
   68|   883k|  size_t indx = s->leng;
   69|   883k|  size_t a = s->allc;
   70|   883k|  size_t fit = len + indx + 1; /* new string + old string + zero byte */
   71|       |
   72|       |  /* try to detect if there's rubbish in the struct */
   73|   883k|  DEBUGASSERT(s->init == DYNINIT);
   74|   883k|  DEBUGASSERT(s->toobig);
   75|   883k|  DEBUGASSERT(indx < s->toobig);
   76|   883k|  DEBUGASSERT(!s->leng || s->bufr);
   77|       |
   78|   883k|  if(fit > s->toobig) {
   79|      0|    Curl_dyn_free(s);
   80|      0|    return CURLE_OUT_OF_MEMORY;
   81|      0|  }
   82|   883k|  else if(!a) {
   83|  18.5k|    DEBUGASSERT(!indx);
   84|       |    /* first invoke */
   85|  18.5k|    if(fit < MIN_FIRST_ALLOC)
   86|  18.3k|      a = MIN_FIRST_ALLOC;
   87|    243|    else
   88|    243|      a = fit;
   89|  18.5k|  }
   90|   864k|  else {
   91|   876k|    while(a < fit)
   92|  11.5k|      a *= 2;
   93|   864k|  }
   94|       |
   95|   883k|  if(a != s->allc) {
   96|       |    /* this logic is not using Curl_saferealloc() to make the tool not have to
   97|       |       include that as well when it uses this code */
   98|  29.6k|    void *p = realloc(s->bufr, a);
   99|  29.6k|    if(!p) {
  100|      0|      Curl_safefree(s->bufr);
  101|      0|      s->leng = s->allc = 0;
  102|      0|      return CURLE_OUT_OF_MEMORY;
  103|      0|    }
  104|  29.6k|    s->bufr = p;
  105|  29.6k|    s->allc = a;
  106|  29.6k|  }
  107|       |
  108|   883k|  if(len)
  109|   880k|    memcpy(&s->bufr[indx], mem, len);
  110|   883k|  s->leng = indx + len;
  111|   883k|  s->bufr[s->leng] = 0;
  112|   883k|  return CURLE_OK;
  113|   883k|}

curl_global_init:
  216|      1|{
  217|      1|  return global_init(flags, TRUE);
  218|      1|}
curl_easy_init:
  290|  6.25k|{
  291|  6.25k|  CURLcode result;
  292|  6.25k|  struct Curl_easy *data;
  293|       |
  294|       |  /* Make sure we inited the global SSL stuff */
  295|  6.25k|  if(!initialized) {
  296|      1|    result = curl_global_init(CURL_GLOBAL_DEFAULT);
  297|      1|    if(result) {
  298|       |      /* something in the global init failed, return nothing */
  299|      0|      DEBUGF(fprintf(stderr, "Error: curl_global_init failed\n"));
  300|      0|      return NULL;
  301|      0|    }
  302|      1|  }
  303|       |
  304|       |  /* We use curl_open() with undefined URL so far */
  305|  6.25k|  result = Curl_open(&data);
  306|  6.25k|  if(result) {
  307|      0|    DEBUGF(fprintf(stderr, "Error: Curl_open failed\n"));
  308|      0|    return NULL;
  309|      0|  }
  310|       |
  311|  6.25k|  return data;
  312|  6.25k|}
curl_easy_cleanup:
  735|  3.16k|{
  736|  3.16k|  SIGPIPE_VARIABLE(pipe_st);
  737|       |
  738|  3.16k|  if(!data)
  739|      0|    return;
  740|       |
  741|  3.16k|  sigpipe_ignore(data, &pipe_st);
  742|  3.16k|  Curl_close(&data);
  743|  3.16k|  sigpipe_restore(&pipe_st);
  744|  3.16k|}
easy.c:global_init:
  136|      1|{
  137|      1|  if(initialized++)
  138|      0|    return CURLE_OK;
  139|       |
  140|      1|  if(memoryfuncs) {
  141|       |    /* Setup the default memory functions here (again) */
  142|      1|    Curl_cmalloc = (curl_malloc_callback)malloc;
  143|      1|    Curl_cfree = (curl_free_callback)free;
  144|      1|    Curl_crealloc = (curl_realloc_callback)realloc;
  145|      1|    Curl_cstrdup = (curl_strdup_callback)system_strdup;
  146|      1|    Curl_ccalloc = (curl_calloc_callback)calloc;
  147|       |#if defined(WIN32) && defined(UNICODE)
  148|       |    Curl_cwcsdup = (curl_wcsdup_callback)_wcsdup;
  149|       |#endif
  150|      1|  }
  151|       |
  152|      1|  if(!Curl_ssl_init()) {
  153|      0|    DEBUGF(fprintf(stderr, "Error: Curl_ssl_init failed\n"));
  154|      0|    goto fail;
  155|      0|  }
  156|       |
  157|       |#ifdef WIN32
  158|       |  if(Curl_win32_init(flags)) {
  159|       |    DEBUGF(fprintf(stderr, "Error: win32_init failed\n"));
  160|       |    goto fail;
  161|       |  }
  162|       |#endif
  163|       |
  164|       |#ifdef __AMIGA__
  165|       |  if(!Curl_amiga_init()) {
  166|       |    DEBUGF(fprintf(stderr, "Error: Curl_amiga_init failed\n"));
  167|       |    goto fail;
  168|       |  }
  169|       |#endif
  170|       |
  171|       |#ifdef NETWARE
  172|       |  if(netware_init()) {
  173|       |    DEBUGF(fprintf(stderr, "Warning: LONG namespace not available\n"));
  174|       |  }
  175|       |#endif
  176|       |
  177|      1|  if(Curl_resolver_global_init()) {
  178|      0|    DEBUGF(fprintf(stderr, "Error: resolver_global_init failed\n"));
  179|      0|    goto fail;
  180|      0|  }
  181|       |
  182|       |#if defined(USE_SSH)
  183|       |  if(Curl_ssh_init()) {
  184|       |    goto fail;
  185|       |  }
  186|       |#endif
  187|       |
  188|       |#ifdef USE_WOLFSSH
  189|       |  if(WS_SUCCESS != wolfSSH_Init()) {
  190|       |    DEBUGF(fprintf(stderr, "Error: wolfSSH_Init failed\n"));
  191|       |    return CURLE_FAILED_INIT;
  192|       |  }
  193|       |#endif
  194|       |
  195|      1|  init_flags = flags;
  196|       |
  197|      1|#ifdef DEBUGBUILD
  198|      1|  if(getenv("CURL_GLOBAL_INIT"))
  199|       |    /* alloc data that will leak if *cleanup() is not called! */
  200|      0|    leakpointer = malloc(1);
  201|      1|#endif
  202|       |
  203|      1|  return CURLE_OK;
  204|       |
  205|      0|  fail:
  206|      0|  initialized--; /* undo the increase */
  207|      0|  return CURLE_FAILED_INIT;
  208|      1|}

Curl_isunreserved:
   45|  64.2k|{
   46|  64.2k|  switch(in) {
   47|  5.57k|    case '0': case '1': case '2': case '3': case '4':
   48|  7.99k|    case '5': case '6': case '7': case '8': case '9':
   49|  14.9k|    case 'a': case 'b': case 'c': case 'd': case 'e':
   50|  17.6k|    case 'f': case 'g': case 'h': case 'i': case 'j':
   51|  22.5k|    case 'k': case 'l': case 'm': case 'n': case 'o':
   52|  28.6k|    case 'p': case 'q': case 'r': case 's': case 't':
   53|  38.2k|    case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':
   54|  40.4k|    case 'A': case 'B': case 'C': case 'D': case 'E':
   55|  41.9k|    case 'F': case 'G': case 'H': case 'I': case 'J':
   56|  43.1k|    case 'K': case 'L': case 'M': case 'N': case 'O':
   57|  45.8k|    case 'P': case 'Q': case 'R': case 'S': case 'T':
   58|  47.0k|    case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
   59|  49.3k|    case '-': case '.': case '_': case '~':
   60|  49.3k|      return TRUE;
   61|  14.8k|    default:
   62|  14.8k|      break;
   63|  64.2k|  }
   64|  14.8k|  return FALSE;
   65|  64.2k|}
curl_easy_escape:
   81|     64|{
   82|     64|  size_t length;
   83|     64|  CURLcode result;
   84|     64|  struct dynbuf d;
   85|       |
   86|     64|  if(inlength < 0)
   87|      0|    return NULL;
   88|       |
   89|     64|  Curl_dyn_init(&d, CURL_MAX_INPUT_LENGTH * 3);
   90|       |
   91|     64|  length = (inlength?(size_t)inlength:strlen(string));
   92|     64|  if(!length)
   93|      0|    return strdup("");
   94|       |
   95|    640|  while(length--) {
   96|    576|    unsigned char in = *string; /* we need to treat the characters unsigned */
   97|       |
   98|    576|    if(Curl_isunreserved(in)) {
   99|       |      /* append this */
  100|    406|      if(Curl_dyn_addn(&d, &in, 1))
  101|      0|        return NULL;
  102|    406|    }
  103|    170|    else {
  104|       |      /* encode it */
  105|    170|      char encoded[4];
  106|    170|      result = Curl_convert_to_network(data, (char *)&in, 1);
  107|    170|      if(result) {
  108|       |        /* Curl_convert_to_network calls failf if unsuccessful */
  109|      0|        Curl_dyn_free(&d);
  110|      0|        return NULL;
  111|      0|      }
  112|       |
  113|    170|      msnprintf(encoded, sizeof(encoded), "%%%02X", in);
  114|    170|      if(Curl_dyn_add(&d, encoded))
  115|      0|        return NULL;
  116|    170|    }
  117|    576|    string++;
  118|    576|  }
  119|       |
  120|     64|  return Curl_dyn_ptr(&d);
  121|     64|}
Curl_urldecode:
  146|  1.95k|{
  147|  1.95k|  size_t alloc;
  148|  1.95k|  char *ns;
  149|  1.95k|  size_t strindex = 0;
  150|  1.95k|  unsigned long hex;
  151|  1.95k|  CURLcode result = CURLE_OK;
  152|       |
  153|  1.95k|  DEBUGASSERT(string);
  154|  1.95k|  DEBUGASSERT(ctrl >= REJECT_NADA); /* crash on TRUE/FALSE */
  155|       |
  156|  1.95k|  alloc = (length?length:strlen(string)) + 1;
  157|  1.95k|  ns = malloc(alloc);
  158|       |
  159|  1.95k|  if(!ns)
  160|      0|    return CURLE_OUT_OF_MEMORY;
  161|       |
  162|  50.7k|  while(--alloc > 0) {
  163|  48.7k|    unsigned char in = *string;
  164|  48.7k|    if(('%' == in) && (alloc > 2) &&
  165|  48.7k|       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
  166|       |      /* this is two hexadecimal digits following a '%' */
  167|    437|      char hexstr[3];
  168|    437|      char *ptr;
  169|    437|      hexstr[0] = string[1];
  170|    437|      hexstr[1] = string[2];
  171|    437|      hexstr[2] = 0;
  172|       |
  173|    437|      hex = strtoul(hexstr, &ptr, 16);
  174|       |
  175|    437|      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
  176|       |
  177|    437|      if(data) {
  178|     18|        result = Curl_convert_from_network(data, (char *)&in, 1);
  179|     18|        if(result) {
  180|       |          /* Curl_convert_from_network calls failf if unsuccessful */
  181|      0|          free(ns);
  182|      0|          return result;
  183|      0|        }
  184|     18|      }
  185|       |
  186|    437|      string += 2;
  187|    437|      alloc -= 2;
  188|    437|    }
  189|       |
  190|  48.7k|    if(((ctrl == REJECT_CTRL) && (in < 0x20)) ||
  191|  48.7k|       ((ctrl == REJECT_ZERO) && (in == 0))) {
  192|     13|      free(ns);
  193|     13|      return CURLE_URL_MALFORMAT;
  194|     13|    }
  195|       |
  196|  48.7k|    ns[strindex++] = in;
  197|  48.7k|    string++;
  198|  48.7k|  }
  199|  1.94k|  ns[strindex] = 0; /* terminate it */
  200|       |
  201|  1.94k|  if(olen)
  202|       |    /* store output size */
  203|    482|    *olen = strindex;
  204|       |
  205|       |  /* store output string */
  206|  1.94k|  *ostring = ns;
  207|       |
  208|  1.94k|  return CURLE_OK;
  209|  1.95k|}
curl_free:
  244|     92|{
  245|     92|  free(p);
  246|     92|}

file.c:file_setup_connection:
  124|     43|{
  125|     43|  (void)conn;
  126|       |  /* allocate the FILE specific struct */
  127|     43|  data->req.p.file = calloc(1, sizeof(struct FILEPROTO));
  128|     43|  if(!data->req.p.file)
  129|      0|    return CURLE_OUT_OF_MEMORY;
  130|       |
  131|     43|  return CURLE_OK;
  132|     43|}
file.c:file_connect:
  140|     43|{
  141|     43|  char *real_path;
  142|     43|  struct FILEPROTO *file = data->req.p.file;
  143|     43|  int fd;
  144|       |#ifdef DOS_FILESYSTEM
  145|       |  size_t i;
  146|       |  char *actual_path;
  147|       |#endif
  148|     43|  size_t real_path_len;
  149|       |
  150|     43|  CURLcode result = Curl_urldecode(data, data->state.up.path, 0, &real_path,
  151|     43|                                   &real_path_len, REJECT_ZERO);
  152|     43|  if(result)
  153|      1|    return result;
  154|       |
  155|       |#ifdef DOS_FILESYSTEM
  156|       |  /* If the first character is a slash, and there's
  157|       |     something that looks like a drive at the beginning of
  158|       |     the path, skip the slash.  If we remove the initial
  159|       |     slash in all cases, paths without drive letters end up
  160|       |     relative to the current directory which isn't how
  161|       |     browsers work.
  162|       |
  163|       |     Some browsers accept | instead of : as the drive letter
  164|       |     separator, so we do too.
  165|       |
  166|       |     On other platforms, we need the slash to indicate an
  167|       |     absolute pathname.  On Windows, absolute paths start
  168|       |     with a drive letter.
  169|       |  */
  170|       |  actual_path = real_path;
  171|       |  if((actual_path[0] == '/') &&
  172|       |      actual_path[1] &&
  173|       |     (actual_path[2] == ':' || actual_path[2] == '|')) {
  174|       |    actual_path[2] = ':';
  175|       |    actual_path++;
  176|       |    real_path_len--;
  177|       |  }
  178|       |
  179|       |  /* change path separators from '/' to '\\' for DOS, Windows and OS/2 */
  180|       |  for(i = 0; i < real_path_len; ++i)
  181|       |    if(actual_path[i] == '/')
  182|       |      actual_path[i] = '\\';
  183|       |    else if(!actual_path[i]) { /* binary zero */
  184|       |      Curl_safefree(real_path);
  185|       |      return CURLE_URL_MALFORMAT;
  186|       |    }
  187|       |
  188|       |  fd = open_readonly(actual_path, O_RDONLY|O_BINARY);
  189|       |  file->path = actual_path;
  190|       |#else
  191|     42|  if(memchr(real_path, 0, real_path_len)) {
  192|       |    /* binary zeroes indicate foul play */
  193|      0|    Curl_safefree(real_path);
  194|      0|    return CURLE_URL_MALFORMAT;
  195|      0|  }
  196|       |
  197|     42|  fd = open_readonly(real_path, O_RDONLY);
  198|     42|  file->path = real_path;
  199|     42|#endif
  200|     42|  file->freepath = real_path; /* free this when done */
  201|       |
  202|     42|  file->fd = fd;
  203|     42|  if(!data->set.upload && (fd == -1)) {
  204|      6|    failf(data, "Couldn't open file %s", data->state.up.path);
  205|      6|    file_done(data, CURLE_FILE_COULDNT_READ_FILE, FALSE);
  206|      6|    return CURLE_FILE_COULDNT_READ_FILE;
  207|      6|  }
  208|     36|  *done = TRUE;
  209|       |
  210|     36|  return CURLE_OK;
  211|     42|}
file.c:file_done:
  215|     85|{
  216|     85|  struct FILEPROTO *file = data->req.p.file;
  217|     85|  (void)status; /* not used */
  218|     85|  (void)premature; /* not used */
  219|       |
  220|     85|  if(file) {
  221|     85|    Curl_safefree(file->freepath);
  222|     85|    file->path = NULL;
  223|     85|    if(file->fd != -1)
  224|     33|      close(file->fd);
  225|     85|    file->fd = -1;
  226|     85|  }
  227|       |
  228|     85|  return CURLE_OK;
  229|     85|}
file.c:file_disconnect:
  234|     43|{
  235|     43|  (void)dead_connection; /* not used */
  236|     43|  (void)conn;
  237|     43|  return file_done(data, 0, 0);
  238|     43|}
file.c:file_do:
  363|     36|{
  364|       |  /* This implementation ignores the host name in conformance with
  365|       |     RFC 1738. Only local files (reachable via the standard file system)
  366|       |     are supported. This means that files on remotely mounted directories
  367|       |     (via NFS, Samba, NT sharing) can be accessed through a file:// URL
  368|       |  */
  369|     36|  CURLcode result = CURLE_OK;
  370|     36|  struct_stat statbuf; /* struct_stat instead of struct stat just to allow the
  371|       |                          Windows version to have a different struct without
  372|       |                          having to redefine the simple word 'stat' */
  373|     36|  curl_off_t expected_size = -1;
  374|     36|  bool size_known;
  375|     36|  bool fstated = FALSE;
  376|     36|  char *buf = data->state.buffer;
  377|     36|  curl_off_t bytecount = 0;
  378|     36|  int fd;
  379|     36|  struct FILEPROTO *file;
  380|       |
  381|     36|  *done = TRUE; /* unconditionally */
  382|       |
  383|     36|  Curl_pgrsStartNow(data);
  384|       |
  385|     36|  if(data->set.upload)
  386|      5|    return file_upload(data);
  387|       |
  388|     31|  file = data->req.p.file;
  389|       |
  390|       |  /* get the fd from the connection phase */
  391|     31|  fd = file->fd;
  392|       |
  393|       |  /* VMS: This only works reliable for STREAMLF files */
  394|     31|  if(-1 != fstat(fd, &statbuf)) {
  395|     31|    if(!S_ISDIR(statbuf.st_mode))
  396|      5|      expected_size = statbuf.st_size;
  397|       |    /* and store the modification time */
  398|     31|    data->info.filetime = statbuf.st_mtime;
  399|     31|    fstated = TRUE;
  400|     31|  }
  401|       |
  402|     31|  if(fstated && !data->state.range && data->set.timecondition) {
  403|      0|    if(!Curl_meets_timecondition(data, data->info.filetime)) {
  404|      0|      *done = TRUE;
  405|      0|      return CURLE_OK;
  406|      0|    }
  407|      0|  }
  408|       |
  409|     31|  if(fstated) {
  410|     31|    time_t filetime;
  411|     31|    struct tm buffer;
  412|     31|    const struct tm *tm = &buffer;
  413|     31|    char header[80];
  414|     31|    int headerlen;
  415|     31|    char accept_ranges[24]= { "Accept-ranges: bytes\r\n" };
  416|     31|    if(expected_size >= 0) {
  417|      5|      headerlen = msnprintf(header, sizeof(header),
  418|      5|                "Content-Length: %" CURL_FORMAT_CURL_OFF_T "\r\n",
  419|      5|                expected_size);
  420|      5|      result = Curl_client_write(data, CLIENTWRITE_HEADER, header, headerlen);
  421|      5|      if(result)
  422|      0|        return result;
  423|       |
  424|      5|      result = Curl_client_write(data, CLIENTWRITE_HEADER,
  425|      5|                                 accept_ranges, strlen(accept_ranges));
  426|      5|      if(result != CURLE_OK)
  427|      0|        return result;
  428|      5|    }
  429|       |
  430|     31|    filetime = (time_t)statbuf.st_mtime;
  431|     31|    result = Curl_gmtime(filetime, &buffer);
  432|     31|    if(result)
  433|      0|      return result;
  434|       |
  435|       |    /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
  436|     31|    headerlen = msnprintf(header, sizeof(header),
  437|     31|              "Last-Modified: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n%s",
  438|     31|              Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
  439|     31|              tm->tm_mday,
  440|     31|              Curl_month[tm->tm_mon],
  441|     31|              tm->tm_year + 1900,
  442|     31|              tm->tm_hour,
  443|     31|              tm->tm_min,
  444|     31|              tm->tm_sec,
  445|     31|              data->set.opt_no_body ? "": "\r\n");
  446|     31|    result = Curl_client_write(data, CLIENTWRITE_HEADER, header, headerlen);
  447|     31|    if(result)
  448|      0|      return result;
  449|       |    /* set the file size to make it available post transfer */
  450|     31|    Curl_pgrsSetDownloadSize(data, expected_size);
  451|     31|    if(data->set.opt_no_body)
  452|      1|      return result;
  453|     31|  }
  454|       |
  455|       |  /* Check whether file range has been specified */
  456|     30|  result = Curl_range(data);
  457|     30|  if(result)
  458|      4|    return result;
  459|       |
  460|       |  /* Adjust the start offset in case we want to get the N last bytes
  461|       |   * of the stream if the filesize could be determined */
  462|     26|  if(data->state.resume_from < 0) {
  463|      3|    if(!fstated) {
  464|      0|      failf(data, "Can't get the size of file.");
  465|      0|      return CURLE_READ_ERROR;
  466|      0|    }
  467|      3|    data->state.resume_from += (curl_off_t)statbuf.st_size;
  468|      3|  }
  469|       |
  470|     26|  if(data->state.resume_from > 0) {
  471|       |    /* We check explicitly if we have a start offset, because
  472|       |     * expected_size may be -1 if we don't know how large the file is,
  473|       |     * in which case we should not adjust it. */
  474|      8|    if(data->state.resume_from <= expected_size)
  475|      1|      expected_size -= data->state.resume_from;
  476|      7|    else {
  477|      7|      failf(data, "failed to resume file:// transfer");
  478|      7|      return CURLE_BAD_DOWNLOAD_RESUME;
  479|      7|    }
  480|      8|  }
  481|       |
  482|       |  /* A high water mark has been specified so we obey... */
  483|     19|  if(data->req.maxdownload > 0)
  484|     15|    expected_size = data->req.maxdownload;
  485|       |
  486|     19|  if(!fstated || (expected_size <= 0))
  487|      4|    size_known = FALSE;
  488|     15|  else
  489|     15|    size_known = TRUE;
  490|       |
  491|       |  /* The following is a shortcut implementation of file reading
  492|       |     this is both more efficient than the former call to download() and
  493|       |     it avoids problems with select() and recv() on file descriptors
  494|       |     in Winsock */
  495|     19|  if(size_known)
  496|     15|    Curl_pgrsSetDownloadSize(data, expected_size);
  497|       |
  498|     19|  if(data->state.resume_from) {
  499|      2|    if(data->state.resume_from !=
  500|      2|       lseek(fd, data->state.resume_from, SEEK_SET))
  501|      1|      return CURLE_BAD_DOWNLOAD_RESUME;
  502|      2|  }
  503|       |
  504|     18|  Curl_pgrsTime(data, TIMER_STARTTRANSFER);
  505|       |
  506|     21|  while(!result) {
  507|     21|    ssize_t nread;
  508|       |    /* Don't fill a whole buffer if we want less than all data */
  509|     21|    size_t bytestoread;
  510|       |
  511|     21|    if(size_known) {
  512|     16|      bytestoread = (expected_size < data->set.buffer_size) ?
  513|     10|        curlx_sotouz(expected_size) : (size_t)data->set.buffer_size;
  514|     16|    }
  515|      5|    else
  516|      5|      bytestoread = data->set.buffer_size-1;
  517|       |
  518|     21|    nread = read(fd, buf, bytestoread);
  519|       |
  520|     21|    if(nread > 0)
  521|      3|      buf[nread] = 0;
  522|       |
  523|     21|    if(nread <= 0 || (size_known && (expected_size == 0)))
  524|     18|      break;
  525|       |
  526|      3|    bytecount += nread;
  527|      3|    if(size_known)
  528|      2|      expected_size -= nread;
  529|       |
  530|      3|    result = Curl_client_write(data, CLIENTWRITE_BODY, buf, nread);
  531|      3|    if(result)
  532|      0|      return result;
  533|       |
  534|      3|    Curl_pgrsSetDownloadCounter(data, bytecount);
  535|       |
  536|      3|    if(Curl_pgrsUpdate(data))
  537|      0|      result = CURLE_ABORTED_BY_CALLBACK;
  538|      3|    else
  539|      3|      result = Curl_speedcheck(data, Curl_now());
  540|      3|  }
  541|     18|  if(Curl_pgrsUpdate(data))
  542|      0|    result = CURLE_ABORTED_BY_CALLBACK;
  543|       |
  544|     18|  return result;
  545|     18|}
file.c:file_upload:
  247|      5|{
  248|      5|  struct FILEPROTO *file = data->req.p.file;
  249|      5|  const char *dir = strchr(file->path, DIRSEP);
  250|      5|  int fd;
  251|      5|  int mode;
  252|      5|  CURLcode result = CURLE_OK;
  253|      5|  char *buf = data->state.buffer;
  254|      5|  curl_off_t bytecount = 0;
  255|      5|  struct_stat file_stat;
  256|      5|  const char *buf2;
  257|       |
  258|       |  /*
  259|       |   * Since FILE: doesn't do the full init, we need to provide some extra
  260|       |   * assignments here.
  261|       |   */
  262|      5|  data->req.upload_fromhere = buf;
  263|       |
  264|      5|  if(!dir)
  265|      0|    return CURLE_FILE_COULDNT_READ_FILE; /* fix: better error code */
  266|       |
  267|      5|  if(!dir[1])
  268|      1|    return CURLE_FILE_COULDNT_READ_FILE; /* fix: better error code */
  269|       |
  270|       |#ifdef O_BINARY
  271|       |#define MODE_DEFAULT O_WRONLY|O_CREAT|O_BINARY
  272|       |#else
  273|      4|#define MODE_DEFAULT O_WRONLY|O_CREAT
  274|      4|#endif
  275|       |
  276|      4|  if(data->state.resume_from)
  277|      0|    mode = MODE_DEFAULT|O_APPEND;
  278|      4|  else
  279|      4|    mode = MODE_DEFAULT|O_TRUNC;
  280|       |
  281|      4|  fd = open(file->path, mode, data->set.new_file_perms);
  282|      4|  if(fd < 0) {
  283|      1|    failf(data, "Can't open %s for writing", file->path);
  284|      1|    return CURLE_WRITE_ERROR;
  285|      1|  }
  286|       |
  287|      3|  if(-1 != data->state.infilesize)
  288|       |    /* known size of data to "upload" */
  289|      2|    Curl_pgrsSetUploadSize(data, data->state.infilesize);
  290|       |
  291|       |  /* treat the negative resume offset value as the case of "-" */
  292|      3|  if(data->state.resume_from < 0) {
  293|      0|    if(fstat(fd, &file_stat)) {
  294|      0|      close(fd);
  295|      0|      failf(data, "Can't get the size of %s", file->path);
  296|      0|      return CURLE_WRITE_ERROR;
  297|      0|    }
  298|      0|    data->state.resume_from = (curl_off_t)file_stat.st_size;
  299|      0|  }
  300|       |
  301|      4|  while(!result) {
  302|      4|    size_t nread;
  303|      4|    size_t nwrite;
  304|      4|    size_t readcount;
  305|      4|    result = Curl_fillreadbuffer(data, data->set.buffer_size, &readcount);
  306|      4|    if(result)
  307|      2|      break;
  308|       |
  309|      2|    if(!readcount)
  310|      1|      break;
  311|       |
  312|      1|    nread = readcount;
  313|       |
  314|       |    /*skip bytes before resume point*/
  315|      1|    if(data->state.resume_from) {
  316|      0|      if((curl_off_t)nread <= data->state.resume_from) {
  317|      0|        data->state.resume_from -= nread;
  318|      0|        nread = 0;
  319|      0|        buf2 = buf;
  320|      0|      }
  321|      0|      else {
  322|      0|        buf2 = buf + data->state.resume_from;
  323|      0|        nread -= (size_t)data->state.resume_from;
  324|      0|        data->state.resume_from = 0;
  325|      0|      }
  326|      0|    }
  327|      1|    else
  328|      1|      buf2 = buf;
  329|       |
  330|       |    /* write the data to the target */
  331|      1|    nwrite = write(fd, buf2, nread);
  332|      1|    if(nwrite != nread) {
  333|      0|      result = CURLE_SEND_ERROR;
  334|      0|      break;
  335|      0|    }
  336|       |
  337|      1|    bytecount += nread;
  338|       |
  339|      1|    Curl_pgrsSetUploadCounter(data, bytecount);
  340|       |
  341|      1|    if(Curl_pgrsUpdate(data))
  342|      0|      result = CURLE_ABORTED_BY_CALLBACK;
  343|      1|    else
  344|      1|      result = Curl_speedcheck(data, Curl_now());
  345|      1|  }
  346|      3|  if(!result && Curl_pgrsUpdate(data))
  347|      0|    result = CURLE_ABORTED_BY_CALLBACK;
  348|       |
  349|      3|  close(fd);
  350|       |
  351|      3|  return result;
  352|      3|}

Curl_fileinfo_cleanup:
   37|      4|{
   38|      4|  if(!finfo)
   39|      4|    return;
   40|       |
   41|      0|  Curl_safefree(finfo->info.b_data);
   42|      0|  free(finfo);
   43|      0|}

ftp.c:ftp_readresp:
  554|  1.25k|{
  555|  1.25k|  int code;
  556|  1.25k|  CURLcode result = Curl_pp_readresp(data, sockfd, pp, &code, size);
  557|       |
  558|       |#ifdef HAVE_GSSAPI
  559|       |  {
  560|       |    struct connectdata *conn = data->conn;
  561|       |    char * const buf = data->state.buffer;
  562|       |
  563|       |    /* handle the security-oriented responses 6xx ***/
  564|       |    switch(code) {
  565|       |    case 631:
  566|       |      code = Curl_sec_read_msg(data, conn, buf, PROT_SAFE);
  567|       |      break;
  568|       |    case 632:
  569|       |      code = Curl_sec_read_msg(data, conn, buf, PROT_PRIVATE);
  570|       |      break;
  571|       |    case 633:
  572|       |      code = Curl_sec_read_msg(data, conn, buf, PROT_CONFIDENTIAL);
  573|       |      break;
  574|       |    default:
  575|       |      /* normal ftp stuff we pass through! */
  576|       |      break;
  577|       |    }
  578|       |  }
  579|       |#endif
  580|       |
  581|       |  /* store the latest code for later retrieval */
  582|  1.25k|  data->info.httpcode = code;
  583|       |
  584|  1.25k|  if(ftpcode)
  585|  1.25k|    *ftpcode = code;
  586|       |
  587|  1.25k|  if(421 == code) {
  588|       |    /* 421 means "Service not available, closing control connection." and FTP
  589|       |     * servers use it to signal that idle session timeout has been exceeded.
  590|       |     * If we ignored the response, it could end up hanging in some cases.
  591|       |     *
  592|       |     * This response code can come at any point so having it treated
  593|       |     * generically is a good idea.
  594|       |     */
  595|      2|    infof(data, "We got a 421 - timeout!");
  596|      2|    state(data, FTP_STOP);
  597|      2|    return CURLE_OPERATION_TIMEDOUT;
  598|      2|  }
  599|       |
  600|  1.25k|  return result;
  601|  1.25k|}
ftp.c:_state:
  761|    709|{
  762|    709|  struct connectdata *conn = data->conn;
  763|    709|  struct ftp_conn *ftpc = &conn->proto.ftpc;
  764|       |
  765|    709|#if defined(DEBUGBUILD)
  766|       |
  767|       |#if defined(CURL_DISABLE_VERBOSE_STRINGS)
  768|       |  (void) lineno;
  769|       |#else
  770|    709|  if(ftpc->state != newstate)
  771|    672|    infof(data, "FTP %p (line %d) state change from %s to %s",
  772|    672|          (void *)ftpc, lineno, ftp_state_names[ftpc->state],
  773|    672|          ftp_state_names[newstate]);
  774|    709|#endif
  775|    709|#endif
  776|       |
  777|    709|  ftpc->state = newstate;
  778|    709|}
ftp.c:ftp_getsock:
  807|    901|{
  808|    901|  return Curl_pp_getsock(data, &conn->proto.ftpc.pp, socks);
  809|    901|}
ftp.c:ftp_multi_statemach:
 3108|  1.15k|{
 3109|  1.15k|  struct connectdata *conn = data->conn;
 3110|  1.15k|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 3111|  1.15k|  CURLcode result = Curl_pp_statemach(data, &ftpc->pp, FALSE, FALSE);
 3112|       |
 3113|       |  /* Check for the state outside of the Curl_socket_check() return code checks
 3114|       |     since at times we are in fact already in this state when this function
 3115|       |     gets called. */
 3116|  1.15k|  *done = (ftpc->state == FTP_STOP) ? TRUE : FALSE;
 3117|       |
 3118|  1.15k|  return result;
 3119|  1.15k|}
ftp.c:ftp_connect:
 3147|    164|{
 3148|    164|  CURLcode result;
 3149|    164|  struct connectdata *conn = data->conn;
 3150|    164|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 3151|    164|  struct pingpong *pp = &ftpc->pp;
 3152|       |
 3153|    164|  *done = FALSE; /* default to not done yet */
 3154|       |
 3155|       |  /* We always support persistent connections on ftp */
 3156|    164|  connkeep(conn, "FTP default");
 3157|       |
 3158|    164|  PINGPONG_SETUP(pp, ftp_statemachine, ftp_endofresp);
 3159|       |
 3160|    164|  if(conn->handler->flags & PROTOPT_SSL) {
 3161|       |    /* BLOCKING */
 3162|      0|    result = Curl_ssl_connect(data, conn, FIRSTSOCKET);
 3163|      0|    if(result)
 3164|      0|      return result;
 3165|      0|    conn->bits.ftp_use_control_ssl = TRUE;
 3166|      0|  }
 3167|       |
 3168|    164|  Curl_pp_setup(pp); /* once per transfer */
 3169|    164|  Curl_pp_init(data, pp); /* init the generic pingpong data */
 3170|       |
 3171|       |  /* When we connect, we start in the state where we await the 220
 3172|       |     response */
 3173|    164|  state(data, FTP_WAIT220);
 3174|       |
 3175|    164|  result = ftp_multi_statemach(data, done);
 3176|       |
 3177|    164|  return result;
 3178|    164|}
ftp.c:ftp_statemachine:
 2664|  1.25k|{
 2665|  1.25k|  CURLcode result;
 2666|  1.25k|  curl_socket_t sock = conn->sock[FIRSTSOCKET];
 2667|  1.25k|  int ftpcode;
 2668|  1.25k|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 2669|  1.25k|  struct pingpong *pp = &ftpc->pp;
 2670|  1.25k|  static const char ftpauth[][4]  = { "SSL", "TLS" };
 2671|  1.25k|  size_t nread = 0;
 2672|       |
 2673|  1.25k|  if(pp->sendleft)
 2674|      0|    return Curl_pp_flushsend(data, pp);
 2675|       |
 2676|  1.25k|  result = ftp_readresp(data, sock, pp, &ftpcode, &nread);
 2677|  1.25k|  if(result)
 2678|     94|    return result;
 2679|       |
 2680|  1.15k|  if(ftpcode) {
 2681|       |    /* we have now received a full FTP server response */
 2682|    480|    switch(ftpc->state) {
 2683|    130|    case FTP_WAIT220:
 2684|    130|      if(ftpcode == 230) {
 2685|       |        /* 230 User logged in - already! Take as 220 if TLS required. */
 2686|     76|        if(data->set.use_ssl <= CURLUSESSL_TRY ||
 2687|     76|           conn->bits.ftp_use_control_ssl)
 2688|     76|          return ftp_state_user_resp(data, ftpcode, ftpc->state);
 2689|     76|      }
 2690|     54|      else if(ftpcode != 220) {
 2691|      2|        failf(data, "Got a %03d ftp-server response when 220 was expected",
 2692|      2|              ftpcode);
 2693|      2|        return CURLE_WEIRD_SERVER_REPLY;
 2694|      2|      }
 2695|       |
 2696|       |      /* We have received a 220 response fine, now we proceed. */
 2697|       |#ifdef HAVE_GSSAPI
 2698|       |      if(data->set.krb) {
 2699|       |        /* If not anonymous login, try a secure login. Note that this
 2700|       |           procedure is still BLOCKING. */
 2701|       |
 2702|       |        Curl_sec_request_prot(conn, "private");
 2703|       |        /* We set private first as default, in case the line below fails to
 2704|       |           set a valid level */
 2705|       |        Curl_sec_request_prot(conn, data->set.str[STRING_KRB_LEVEL]);
 2706|       |
 2707|       |        if(Curl_sec_login(data, conn))
 2708|       |          infof(data, "Logging in with password in cleartext!");
 2709|       |        else
 2710|       |          infof(data, "Authentication successful");
 2711|       |      }
 2712|       |#endif
 2713|       |
 2714|     52|      if(data->set.use_ssl && !conn->bits.ftp_use_control_ssl) {
 2715|       |        /* We don't have a SSL/TLS control connection yet, but FTPS is
 2716|       |           requested. Try a FTPS connection now */
 2717|       |
 2718|      0|        ftpc->count3 = 0;
 2719|      0|        switch(data->set.ftpsslauth) {
 2720|      0|        case CURLFTPAUTH_DEFAULT:
 2721|      0|        case CURLFTPAUTH_SSL:
 2722|      0|          ftpc->count2 = 1; /* add one to get next */
 2723|      0|          ftpc->count1 = 0;
 2724|      0|          break;
 2725|      0|        case CURLFTPAUTH_TLS:
 2726|      0|          ftpc->count2 = -1; /* subtract one to get next */
 2727|      0|          ftpc->count1 = 1;
 2728|      0|          break;
 2729|      0|        default:
 2730|      0|          failf(data, "unsupported parameter to CURLOPT_FTPSSLAUTH: %d",
 2731|      0|                (int)data->set.ftpsslauth);
 2732|      0|          return CURLE_UNKNOWN_OPTION; /* we don't know what to do */
 2733|      0|        }
 2734|      0|        result = Curl_pp_sendf(data, &ftpc->pp, "AUTH %s",
 2735|      0|                               ftpauth[ftpc->count1]);
 2736|      0|        if(!result)
 2737|      0|          state(data, FTP_AUTH);
 2738|      0|      }
 2739|     52|      else
 2740|     52|        result = ftp_state_user(data, conn);
 2741|     52|      break;
 2742|       |
 2743|     52|    case FTP_AUTH:
 2744|       |      /* we have gotten the response to a previous AUTH command */
 2745|       |
 2746|      0|      if(pp->cache_size)
 2747|      0|        return CURLE_WEIRD_SERVER_REPLY; /* Forbid pipelining in response. */
 2748|       |
 2749|       |      /* RFC2228 (page 5) says:
 2750|       |       *
 2751|       |       * If the server is willing to accept the named security mechanism,
 2752|       |       * and does not require any security data, it must respond with
 2753|       |       * reply code 234/334.
 2754|       |       */
 2755|       |
 2756|      0|      if((ftpcode == 234) || (ftpcode == 334)) {
 2757|       |        /* Curl_ssl_connect is BLOCKING */
 2758|      0|        result = Curl_ssl_connect(data, conn, FIRSTSOCKET);
 2759|      0|        if(!result) {
 2760|      0|          conn->bits.ftp_use_data_ssl = FALSE; /* clear-text data */
 2761|      0|          conn->bits.ftp_use_control_ssl = TRUE; /* SSL on control */
 2762|      0|          result = ftp_state_user(data, conn);
 2763|      0|        }
 2764|      0|      }
 2765|      0|      else if(ftpc->count3 < 1) {
 2766|      0|        ftpc->count3++;
 2767|      0|        ftpc->count1 += ftpc->count2; /* get next attempt */
 2768|      0|        result = Curl_pp_sendf(data, &ftpc->pp, "AUTH %s",
 2769|      0|                               ftpauth[ftpc->count1]);
 2770|       |        /* remain in this same state */
 2771|      0|      }
 2772|      0|      else {
 2773|      0|        if(data->set.use_ssl > CURLUSESSL_TRY)
 2774|       |          /* we failed and CURLUSESSL_CONTROL or CURLUSESSL_ALL is set */
 2775|      0|          result = CURLE_USE_SSL_FAILED;
 2776|      0|        else
 2777|       |          /* ignore the failure and continue */
 2778|      0|          result = ftp_state_user(data, conn);
 2779|      0|      }
 2780|      0|      break;
 2781|       |
 2782|     50|    case FTP_USER:
 2783|     52|    case FTP_PASS:
 2784|     52|      result = ftp_state_user_resp(data, ftpcode, ftpc->state);
 2785|     52|      break;
 2786|       |
 2787|      0|    case FTP_ACCT:
 2788|      0|      result = ftp_state_acct_resp(data, ftpcode);
 2789|      0|      break;
 2790|       |
 2791|      0|    case FTP_PBSZ:
 2792|      0|      result =
 2793|      0|        Curl_pp_sendf(data, &ftpc->pp, "PROT %c",
 2794|      0|                      data->set.use_ssl == CURLUSESSL_CONTROL ? 'C' : 'P');
 2795|      0|      if(!result)
 2796|      0|        state(data, FTP_PROT);
 2797|      0|      break;
 2798|       |
 2799|      0|    case FTP_PROT:
 2800|      0|      if(ftpcode/100 == 2)
 2801|       |        /* We have enabled SSL for the data connection! */
 2802|      0|        conn->bits.ftp_use_data_ssl =
 2803|      0|          (data->set.use_ssl != CURLUSESSL_CONTROL) ? TRUE : FALSE;
 2804|       |      /* FTP servers typically responds with 500 if they decide to reject
 2805|       |         our 'P' request */
 2806|      0|      else if(data->set.use_ssl > CURLUSESSL_CONTROL)
 2807|       |        /* we failed and bails out */
 2808|      0|        return CURLE_USE_SSL_FAILED;
 2809|       |
 2810|      0|      if(data->set.ftp_ccc) {
 2811|       |        /* CCC - Clear Command Channel
 2812|       |         */
 2813|      0|        result = Curl_pp_sendf(data, &ftpc->pp, "%s", "CCC");
 2814|      0|        if(!result)
 2815|      0|          state(data, FTP_CCC);
 2816|      0|      }
 2817|      0|      else
 2818|      0|        result = ftp_state_pwd(data, conn);
 2819|      0|      break;
 2820|       |
 2821|      0|    case FTP_CCC:
 2822|      0|      if(ftpcode < 500) {
 2823|       |        /* First shut down the SSL layer (note: this call will block) */
 2824|      0|        result = Curl_ssl_shutdown(data, conn, FIRSTSOCKET);
 2825|       |
 2826|      0|        if(result)
 2827|      0|          failf(data, "Failed to clear the command channel (CCC)");
 2828|      0|      }
 2829|      0|      if(!result)
 2830|       |        /* Then continue as normal */
 2831|      0|        result = ftp_state_pwd(data, conn);
 2832|      0|      break;
 2833|       |
 2834|    117|    case FTP_PWD:
 2835|    117|      if(ftpcode == 257) {
 2836|     39|        char *ptr = &data->state.buffer[4];  /* start on the first letter */
 2837|     39|        const size_t buf_size = data->set.buffer_size;
 2838|     39|        char *dir;
 2839|     39|        bool entry_extracted = FALSE;
 2840|       |
 2841|     39|        dir = malloc(nread + 1);
 2842|     39|        if(!dir)
 2843|      0|          return CURLE_OUT_OF_MEMORY;
 2844|       |
 2845|       |        /* Reply format is like
 2846|       |           257<space>[rubbish]"<directory-name>"<space><commentary> and the
 2847|       |           RFC959 says
 2848|       |
 2849|       |           The directory name can contain any character; embedded
 2850|       |           double-quotes should be escaped by double-quotes (the
 2851|       |           "quote-doubling" convention).
 2852|       |        */
 2853|       |
 2854|       |        /* scan for the first double-quote for non-standard responses */
 2855|    588|        while(ptr < &data->state.buffer[buf_size]
 2856|    588|              && *ptr != '\n' && *ptr != '\0' && *ptr != '"')
 2857|    549|          ptr++;
 2858|       |
 2859|     39|        if('\"' == *ptr) {
 2860|       |          /* it started good */
 2861|     30|          char *store;
 2862|     30|          ptr++;
 2863|    340|          for(store = dir; *ptr;) {
 2864|    330|            if('\"' == *ptr) {
 2865|     87|              if('\"' == ptr[1]) {
 2866|       |                /* "quote-doubling" */
 2867|     67|                *store = ptr[1];
 2868|     67|                ptr++;
 2869|     67|              }
 2870|     20|              else {
 2871|       |                /* end of path */
 2872|     20|                entry_extracted = TRUE;
 2873|     20|                break; /* get out of this loop */
 2874|     20|              }
 2875|     87|            }
 2876|    243|            else
 2877|    243|              *store = *ptr;
 2878|    310|            store++;
 2879|    310|            ptr++;
 2880|    310|          }
 2881|     30|          *store = '\0'; /* null-terminate */
 2882|     30|        }
 2883|     39|        if(entry_extracted) {
 2884|       |          /* If the path name does not look like an absolute path (i.e.: it
 2885|       |             does not start with a '/'), we probably need some server-dependent
 2886|       |             adjustments. For example, this is the case when connecting to
 2887|       |             an OS400 FTP server: this server supports two name syntaxes,
 2888|       |             the default one being incompatible with standard paths. In
 2889|       |             addition, this server switches automatically to the regular path
 2890|       |             syntax when one is encountered in a command: this results in
 2891|       |             having an entrypath in the wrong syntax when later used in CWD.
 2892|       |               The method used here is to check the server OS: we do it only
 2893|       |             if the path name looks strange to minimize overhead on other
 2894|       |             systems. */
 2895|       |
 2896|     20|          if(!ftpc->server_os && dir[0] != '/') {
 2897|     20|            result = Curl_pp_sendf(data, &ftpc->pp, "%s", "SYST");
 2898|     20|            if(result) {
 2899|      0|              free(dir);
 2900|      0|              return result;
 2901|      0|            }
 2902|     20|            Curl_safefree(ftpc->entrypath);
 2903|     20|            ftpc->entrypath = dir; /* remember this */
 2904|     20|            infof(data, "Entry path is '%s'", ftpc->entrypath);
 2905|       |            /* also save it where getinfo can access it: */
 2906|     20|            data->state.most_recent_ftp_entrypath = ftpc->entrypath;
 2907|     20|            state(data, FTP_SYST);
 2908|     20|            break;
 2909|     20|          }
 2910|       |
 2911|      0|          Curl_safefree(ftpc->entrypath);
 2912|      0|          ftpc->entrypath = dir; /* remember this */
 2913|      0|          infof(data, "Entry path is '%s'", ftpc->entrypath);
 2914|       |          /* also save it where getinfo can access it: */
 2915|      0|          data->state.most_recent_ftp_entrypath = ftpc->entrypath;
 2916|      0|        }
 2917|     19|        else {
 2918|       |          /* couldn't get the path */
 2919|     19|          free(dir);
 2920|     19|          infof(data, "Failed to figure out path");
 2921|     19|        }
 2922|     39|      }
 2923|     97|      state(data, FTP_STOP); /* we are done with the CONNECT phase! */
 2924|     97|      DEBUGF(infof(data, "protocol connect phase DONE"));
 2925|     97|      break;
 2926|       |
 2927|     16|    case FTP_SYST:
 2928|     16|      if(ftpcode == 215) {
 2929|     11|        char *ptr = &data->state.buffer[4];  /* start on the first letter */
 2930|     11|        char *os;
 2931|     11|        char *store;
 2932|       |
 2933|     11|        os = malloc(nread + 1);
 2934|     11|        if(!os)
 2935|      0|          return CURLE_OUT_OF_MEMORY;
 2936|       |
 2937|       |        /* Reply format is like
 2938|       |           215<space><OS-name><space><commentary>
 2939|       |        */
 2940|     92|        while(*ptr == ' ')
 2941|     81|          ptr++;
 2942|    279|        for(store = os; *ptr && *ptr != ' ';)
 2943|    268|          *store++ = *ptr++;
 2944|     11|        *store = '\0'; /* null-terminate */
 2945|       |
 2946|       |        /* Check for special servers here. */
 2947|       |
 2948|     11|        if(strcasecompare(os, "OS/400")) {
 2949|       |          /* Force OS400 name format 1. */
 2950|      0|          result = Curl_pp_sendf(data, &ftpc->pp, "%s", "SITE NAMEFMT 1");
 2951|      0|          if(result) {
 2952|      0|            free(os);
 2953|      0|            return result;
 2954|      0|          }
 2955|       |          /* remember target server OS */
 2956|      0|          Curl_safefree(ftpc->server_os);
 2957|      0|          ftpc->server_os = os;
 2958|      0|          state(data, FTP_NAMEFMT);
 2959|      0|          break;
 2960|      0|        }
 2961|       |        /* Nothing special for the target server. */
 2962|       |        /* remember target server OS */
 2963|     11|        Curl_safefree(ftpc->server_os);
 2964|     11|        ftpc->server_os = os;
 2965|     11|      }
 2966|      5|      else {
 2967|       |        /* Cannot identify server OS. Continue anyway and cross fingers. */
 2968|      5|      }
 2969|       |
 2970|     16|      state(data, FTP_STOP); /* we are done with the CONNECT phase! */
 2971|     16|      DEBUGF(infof(data, "protocol connect phase DONE"));
 2972|     16|      break;
 2973|       |
 2974|      0|    case FTP_NAMEFMT:
 2975|      0|      if(ftpcode == 250) {
 2976|       |        /* Name format change successful: reload initial path. */
 2977|      0|        ftp_state_pwd(data, conn);
 2978|      0|        break;
 2979|      0|      }
 2980|       |
 2981|      0|      state(data, FTP_STOP); /* we are done with the CONNECT phase! */
 2982|      0|      DEBUGF(infof(data, "protocol connect phase DONE"));
 2983|      0|      break;
 2984|       |
 2985|      0|    case FTP_QUOTE:
 2986|      0|    case FTP_POSTQUOTE:
 2987|      0|    case FTP_RETR_PREQUOTE:
 2988|      0|    case FTP_STOR_PREQUOTE:
 2989|      0|      if((ftpcode >= 400) && !ftpc->count2) {
 2990|       |        /* failure response code, and not allowed to fail */
 2991|      0|        failf(data, "QUOT command failed with %03d", ftpcode);
 2992|      0|        result = CURLE_QUOTE_ERROR;
 2993|      0|      }
 2994|      0|      else
 2995|      0|        result = ftp_state_quote(data, FALSE, ftpc->state);
 2996|      0|      break;
 2997|       |
 2998|     62|    case FTP_CWD:
 2999|     62|      if(ftpcode/100 != 2) {
 3000|       |        /* failure to CWD there */
 3001|     17|        if(data->set.ftp_create_missing_dirs &&
 3002|     17|           ftpc->cwdcount && !ftpc->count2) {
 3003|       |          /* try making it */
 3004|      0|          ftpc->count2++; /* counter to prevent CWD-MKD loops */
 3005|      0|          result = Curl_pp_sendf(data, &ftpc->pp, "MKD %s",
 3006|      0|                                 ftpc->dirs[ftpc->cwdcount - 1]);
 3007|      0|          if(!result)
 3008|      0|            state(data, FTP_MKD);
 3009|      0|        }
 3010|     17|        else {
 3011|       |          /* return failure */
 3012|     17|          failf(data, "Server denied you to change to the given directory");
 3013|     17|          ftpc->cwdfail = TRUE; /* don't remember this path as we failed
 3014|       |                                   to enter it */
 3015|     17|          result = CURLE_REMOTE_ACCESS_DENIED;
 3016|     17|        }
 3017|     17|      }
 3018|     45|      else {
 3019|       |        /* success */
 3020|     45|        ftpc->count2 = 0;
 3021|     45|        if(++ftpc->cwdcount <= ftpc->dirdepth)
 3022|       |          /* send next CWD */
 3023|     28|          result = Curl_pp_sendf(data, &ftpc->pp, "CWD %s",
 3024|     28|                                 ftpc->dirs[ftpc->cwdcount - 1]);
 3025|     17|        else
 3026|     17|          result = ftp_state_mdtm(data);
 3027|     45|      }
 3028|     62|      break;
 3029|       |
 3030|      0|    case FTP_MKD:
 3031|      0|      if((ftpcode/100 != 2) && !ftpc->count3--) {
 3032|       |        /* failure to MKD the dir */
 3033|      0|        failf(data, "Failed to MKD dir: %03d", ftpcode);
 3034|      0|        result = CURLE_REMOTE_ACCESS_DENIED;
 3035|      0|      }
 3036|      0|      else {
 3037|      0|        state(data, FTP_CWD);
 3038|       |        /* send CWD */
 3039|      0|        result = Curl_pp_sendf(data, &ftpc->pp, "CWD %s",
 3040|      0|                               ftpc->dirs[ftpc->cwdcount - 1]);
 3041|      0|      }
 3042|      0|      break;
 3043|       |
 3044|      0|    case FTP_MDTM:
 3045|      0|      result = ftp_state_mdtm_resp(data, ftpcode);
 3046|      0|      break;
 3047|       |
 3048|      5|    case FTP_TYPE:
 3049|      5|    case FTP_LIST_TYPE:
 3050|      5|    case FTP_RETR_TYPE:
 3051|      5|    case FTP_STOR_TYPE:
 3052|      5|      result = ftp_state_type_resp(data, ftpcode, ftpc->state);
 3053|      5|      break;
 3054|       |
 3055|      3|    case FTP_SIZE:
 3056|      3|    case FTP_RETR_SIZE:
 3057|      3|    case FTP_STOR_SIZE:
 3058|      3|      result = ftp_state_size_resp(data, ftpcode, ftpc->state);
 3059|      3|      break;
 3060|       |
 3061|      1|    case FTP_REST:
 3062|      1|    case FTP_RETR_REST:
 3063|      1|      result = ftp_state_rest_resp(data, conn, ftpcode, ftpc->state);
 3064|      1|      break;
 3065|       |
 3066|      0|    case FTP_PRET:
 3067|      0|      if(ftpcode != 200) {
 3068|       |        /* there only is this one standard OK return code. */
 3069|      0|        failf(data, "PRET command not accepted: %03d", ftpcode);
 3070|      0|        return CURLE_FTP_PRET_FAILED;
 3071|      0|      }
 3072|      0|      result = ftp_state_use_pasv(data, conn);
 3073|      0|      break;
 3074|       |
 3075|     77|    case FTP_PASV:
 3076|     77|      result = ftp_state_pasv_resp(data, ftpcode);
 3077|     77|      break;
 3078|       |
 3079|      0|    case FTP_PORT:
 3080|      0|      result = ftp_state_port_resp(data, ftpcode);
 3081|      0|      break;
 3082|       |
 3083|      0|    case FTP_LIST:
 3084|      0|    case FTP_RETR:
 3085|      0|      result = ftp_state_get_resp(data, ftpcode, ftpc->state);
 3086|      0|      break;
 3087|       |
 3088|      0|    case FTP_STOR:
 3089|      0|      result = ftp_state_stor_resp(data, ftpcode, ftpc->state);
 3090|      0|      break;
 3091|       |
 3092|     16|    case FTP_QUIT:
 3093|       |      /* fallthrough, just stop! */
 3094|     17|    default:
 3095|       |      /* internal error */
 3096|     17|      state(data, FTP_STOP);
 3097|     17|      break;
 3098|    480|    }
 3099|    480|  } /* if(ftpcode) */
 3100|       |
 3101|  1.08k|  return result;
 3102|  1.15k|}
ftp.c:ftp_state_user_resp:
 2589|    128|{
 2590|    128|  CURLcode result = CURLE_OK;
 2591|    128|  struct connectdata *conn = data->conn;
 2592|    128|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 2593|    128|  (void)instate; /* no use for this yet */
 2594|       |
 2595|       |  /* some need password anyway, and others just return 2xx ignored */
 2596|    128|  if((ftpcode == 331) && (ftpc->state == FTP_USER)) {
 2597|       |    /* 331 Password required for ...
 2598|       |       (the server requires to send the user's password too) */
 2599|      2|    result = Curl_pp_sendf(data, &ftpc->pp, "PASS %s",
 2600|      2|                           conn->passwd?conn->passwd:"");
 2601|      2|    if(!result)
 2602|      2|      state(data, FTP_PASS);
 2603|      2|  }
 2604|    126|  else if(ftpcode/100 == 2) {
 2605|       |    /* 230 User ... logged in.
 2606|       |       (the user logged in with or without password) */
 2607|    123|    result = ftp_state_loggedin(data);
 2608|    123|  }
 2609|      3|  else if(ftpcode == 332) {
 2610|      1|    if(data->set.str[STRING_FTP_ACCOUNT]) {
 2611|      0|      result = Curl_pp_sendf(data, &ftpc->pp, "ACCT %s",
 2612|      0|                             data->set.str[STRING_FTP_ACCOUNT]);
 2613|      0|      if(!result)
 2614|      0|        state(data, FTP_ACCT);
 2615|      0|    }
 2616|      1|    else {
 2617|      1|      failf(data, "ACCT requested but none available");
 2618|      1|      result = CURLE_LOGIN_DENIED;
 2619|      1|    }
 2620|      1|  }
 2621|      2|  else {
 2622|       |    /* All other response codes, like:
 2623|       |
 2624|       |    530 User ... access denied
 2625|       |    (the server denies to log the specified user) */
 2626|       |
 2627|      2|    if(data->set.str[STRING_FTP_ALTERNATIVE_TO_USER] &&
 2628|      2|        !data->state.ftp_trying_alternative) {
 2629|       |      /* Ok, USER failed.  Let's try the supplied command. */
 2630|      0|      result =
 2631|      0|        Curl_pp_sendf(data, &ftpc->pp, "%s",
 2632|      0|                      data->set.str[STRING_FTP_ALTERNATIVE_TO_USER]);
 2633|      0|      if(!result) {
 2634|      0|        data->state.ftp_trying_alternative = TRUE;
 2635|      0|        state(data, FTP_USER);
 2636|      0|      }
 2637|      0|    }
 2638|      2|    else {
 2639|      2|      failf(data, "Access denied: %03d", ftpcode);
 2640|      2|      result = CURLE_LOGIN_DENIED;
 2641|      2|    }
 2642|      2|  }
 2643|    128|  return result;
 2644|    128|}
ftp.c:ftp_state_loggedin:
 2556|    123|{
 2557|    123|  CURLcode result = CURLE_OK;
 2558|    123|  struct connectdata *conn = data->conn;
 2559|       |
 2560|    123|  if(conn->bits.ftp_use_control_ssl) {
 2561|       |    /* PBSZ = PROTECTION BUFFER SIZE.
 2562|       |
 2563|       |    The 'draft-murray-auth-ftp-ssl' (draft 12, page 7) says:
 2564|       |
 2565|       |    Specifically, the PROT command MUST be preceded by a PBSZ
 2566|       |    command and a PBSZ command MUST be preceded by a successful
 2567|       |    security data exchange (the TLS negotiation in this case)
 2568|       |
 2569|       |    ... (and on page 8):
 2570|       |
 2571|       |    Thus the PBSZ command must still be issued, but must have a
 2572|       |    parameter of '0' to indicate that no buffering is taking place
 2573|       |    and the data connection should not be encapsulated.
 2574|       |    */
 2575|      0|    result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, "PBSZ %d", 0);
 2576|      0|    if(!result)
 2577|      0|      state(data, FTP_PBSZ);
 2578|      0|  }
 2579|    123|  else {
 2580|    123|    result = ftp_state_pwd(data, conn);
 2581|    123|  }
 2582|    123|  return result;
 2583|    123|}
ftp.c:ftp_state_user:
  782|     52|{
  783|     52|  CURLcode result = Curl_pp_sendf(data,
  784|     52|                                  &conn->proto.ftpc.pp, "USER %s",
  785|     52|                                  conn->user?conn->user:"");
  786|     52|  if(!result) {
  787|     52|    state(data, FTP_USER);
  788|     52|    data->state.ftp_trying_alternative = FALSE;
  789|     52|  }
  790|     52|  return result;
  791|     52|}
ftp.c:ftp_state_pwd:
  795|    123|{
  796|    123|  CURLcode result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, "%s", "PWD");
  797|    123|  if(!result)
  798|    123|    state(data, FTP_PWD);
  799|       |
  800|    123|  return result;
  801|    123|}
ftp.c:ftp_state_quote:
 1678|    115|{
 1679|    115|  CURLcode result = CURLE_OK;
 1680|    115|  struct FTP *ftp = data->req.p.ftp;
 1681|    115|  struct connectdata *conn = data->conn;
 1682|    115|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 1683|    115|  bool quote = FALSE;
 1684|    115|  struct curl_slist *item;
 1685|       |
 1686|    115|  switch(instate) {
 1687|    109|  case FTP_QUOTE:
 1688|    109|  default:
 1689|    109|    item = data->set.quote;
 1690|    109|    break;
 1691|      6|  case FTP_RETR_PREQUOTE:
 1692|      6|  case FTP_STOR_PREQUOTE:
 1693|      6|    item = data->set.prequote;
 1694|      6|    break;
 1695|      0|  case FTP_POSTQUOTE:
 1696|      0|    item = data->set.postquote;
 1697|      0|    break;
 1698|    115|  }
 1699|       |
 1700|       |  /*
 1701|       |   * This state uses:
 1702|       |   * 'count1' to iterate over the commands to send
 1703|       |   * 'count2' to store whether to allow commands to fail
 1704|       |   */
 1705|       |
 1706|    115|  if(init)
 1707|    115|    ftpc->count1 = 0;
 1708|      0|  else
 1709|      0|    ftpc->count1++;
 1710|       |
 1711|    115|  if(item) {
 1712|      0|    int i = 0;
 1713|       |
 1714|       |    /* Skip count1 items in the linked list */
 1715|      0|    while((i< ftpc->count1) && item) {
 1716|      0|      item = item->next;
 1717|      0|      i++;
 1718|      0|    }
 1719|      0|    if(item) {
 1720|      0|      char *cmd = item->data;
 1721|      0|      if(cmd[0] == '*') {
 1722|      0|        cmd++;
 1723|      0|        ftpc->count2 = 1; /* the sent command is allowed to fail */
 1724|      0|      }
 1725|      0|      else
 1726|      0|        ftpc->count2 = 0; /* failure means cancel operation */
 1727|       |
 1728|      0|      result = Curl_pp_sendf(data, &ftpc->pp, "%s", cmd);
 1729|      0|      if(result)
 1730|      0|        return result;
 1731|      0|      state(data, instate);
 1732|      0|      quote = TRUE;
 1733|      0|    }
 1734|      0|  }
 1735|       |
 1736|    115|  if(!quote) {
 1737|       |    /* No more quote to send, continue to ... */
 1738|    115|    switch(instate) {
 1739|    109|    case FTP_QUOTE:
 1740|    109|    default:
 1741|    109|      result = ftp_state_cwd(data, conn);
 1742|    109|      break;
 1743|      6|    case FTP_RETR_PREQUOTE:
 1744|      6|      if(ftp->transfer != PPTRANSFER_BODY)
 1745|      6|        state(data, FTP_STOP);
 1746|      0|      else {
 1747|      0|        if(ftpc->known_filesize != -1) {
 1748|      0|          Curl_pgrsSetDownloadSize(data, ftpc->known_filesize);
 1749|      0|          result = ftp_state_retr(data, ftpc->known_filesize);
 1750|      0|        }
 1751|      0|        else {
 1752|      0|          if(data->set.ignorecl || data->state.prefer_ascii) {
 1753|       |            /* 'ignorecl' is used to support download of growing files.  It
 1754|       |               prevents the state machine from requesting the file size from
 1755|       |               the server.  With an unknown file size the download continues
 1756|       |               until the server terminates it, otherwise the client stops if
 1757|       |               the received byte count exceeds the reported file size.  Set
 1758|       |               option CURLOPT_IGNORE_CONTENT_LENGTH to 1 to enable this
 1759|       |               behavior.
 1760|       |
 1761|       |               In addition: asking for the size for 'TYPE A' transfers is not
 1762|       |               constructive since servers don't report the converted size. So
 1763|       |               skip it.
 1764|       |            */
 1765|      0|            result = Curl_pp_sendf(data, &ftpc->pp, "RETR %s", ftpc->file);
 1766|      0|            if(!result)
 1767|      0|              state(data, FTP_RETR);
 1768|      0|          }
 1769|      0|          else {
 1770|      0|            result = Curl_pp_sendf(data, &ftpc->pp, "SIZE %s", ftpc->file);
 1771|      0|            if(!result)
 1772|      0|              state(data, FTP_RETR_SIZE);
 1773|      0|          }
 1774|      0|        }
 1775|      0|      }
 1776|      6|      break;
 1777|      0|    case FTP_STOR_PREQUOTE:
 1778|      0|      result = ftp_state_ul_setup(data, FALSE);
 1779|      0|      break;
 1780|      0|    case FTP_POSTQUOTE:
 1781|      0|      break;
 1782|    115|    }
 1783|    115|  }
 1784|       |
 1785|    115|  return result;
 1786|    115|}
ftp.c:ftp_state_cwd:
  865|    109|{
  866|    109|  CURLcode result = CURLE_OK;
  867|    109|  struct ftp_conn *ftpc = &conn->proto.ftpc;
  868|       |
  869|    109|  if(ftpc->cwddone)
  870|       |    /* already done and fine */
  871|     57|    result = ftp_state_mdtm(data);
  872|     52|  else {
  873|       |    /* FTPFILE_NOCWD with full path: expect ftpc->cwddone! */
  874|     52|    DEBUGASSERT((data->set.ftp_filemethod != FTPFILE_NOCWD) ||
  875|     52|                !(ftpc->dirdepth && ftpc->dirs[0][0] == '/'));
  876|       |
  877|     52|    ftpc->count2 = 0; /* count2 counts failed CWDs */
  878|       |
  879|       |    /* count3 is set to allow a MKD to fail once. In the case when first CWD
  880|       |       fails and then MKD fails (due to another session raced it to create the
  881|       |       dir) this then allows for a second try to CWD to it */
  882|     52|    ftpc->count3 = (data->set.ftp_create_missing_dirs == 2)?1:0;
  883|       |
  884|     52|    if(conn->bits.reuse && ftpc->entrypath &&
  885|       |       /* no need to go to entrypath when we have an absolute path */
  886|     52|       !(ftpc->dirdepth && ftpc->dirs[0][0] == '/')) {
  887|       |      /* This is a re-used connection. Since we change directory to where the
  888|       |         transfer is taking place, we must first get back to the original dir
  889|       |         where we ended up after login: */
  890|      0|      ftpc->cwdcount = 0; /* we count this as the first path, then we add one
  891|       |                             for all upcoming ones in the ftp->dirs[] array */
  892|      0|      result = Curl_pp_sendf(data, &ftpc->pp, "CWD %s", ftpc->entrypath);
  893|      0|      if(!result)
  894|      0|        state(data, FTP_CWD);
  895|      0|    }
  896|     52|    else {
  897|     52|      if(ftpc->dirdepth) {
  898|     52|        ftpc->cwdcount = 1;
  899|       |        /* issue the first CWD, the rest is sent when the CWD responses are
  900|       |           received... */
  901|     52|        result = Curl_pp_sendf(data, &ftpc->pp, "CWD %s",
  902|     52|                               ftpc->dirs[ftpc->cwdcount -1]);
  903|     52|        if(!result)
  904|     52|          state(data, FTP_CWD);
  905|     52|      }
  906|      0|      else {
  907|       |        /* No CWD necessary */
  908|      0|        result = ftp_state_mdtm(data);
  909|      0|      }
  910|     52|    }
  911|     52|  }
  912|    109|  return result;
  913|    109|}
ftp.c:ftp_state_mdtm:
 1553|     74|{
 1554|     74|  CURLcode result = CURLE_OK;
 1555|     74|  struct connectdata *conn = data->conn;
 1556|     74|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 1557|       |
 1558|       |  /* Requested time of file or time-depended transfer? */
 1559|     74|  if((data->set.get_filetime || data->set.timecondition) && ftpc->file) {
 1560|       |
 1561|       |    /* we have requested to get the modified-time of the file, this is a white
 1562|       |       spot as the MDTM is not mentioned in RFC959 */
 1563|      0|    result = Curl_pp_sendf(data, &ftpc->pp, "MDTM %s", ftpc->file);
 1564|       |
 1565|      0|    if(!result)
 1566|      0|      state(data, FTP_MDTM);
 1567|      0|  }
 1568|     74|  else
 1569|     74|    result = ftp_state_type(data);
 1570|       |
 1571|     74|  return result;
 1572|     74|}
ftp.c:ftp_state_type:
 1520|     74|{
 1521|     74|  CURLcode result = CURLE_OK;
 1522|     74|  struct FTP *ftp = data->req.p.ftp;
 1523|     74|  struct connectdata *conn = data->conn;
 1524|     74|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 1525|       |
 1526|       |  /* If we have selected NOBODY and HEADER, it means that we only want file
 1527|       |     information. Which in FTP can't be much more than the file size and
 1528|       |     date. */
 1529|     74|  if(data->set.opt_no_body && ftpc->file &&
 1530|     74|     ftp_need_type(conn, data->state.prefer_ascii)) {
 1531|       |    /* The SIZE command is _not_ RFC 959 specified, and therefore many servers
 1532|       |       may not support it! It is however the only way we have to get a file's
 1533|       |       size! */
 1534|       |
 1535|      5|    ftp->transfer = PPTRANSFER_INFO;
 1536|       |    /* this means no actual transfer will be made */
 1537|       |
 1538|       |    /* Some servers return different sizes for different modes, and thus we
 1539|       |       must set the proper type before we check the size */
 1540|      5|    result = ftp_nb_type(data, conn, data->state.prefer_ascii, FTP_TYPE);
 1541|      5|    if(result)
 1542|      0|      return result;
 1543|      5|  }
 1544|     69|  else
 1545|     69|    result = ftp_state_size(data, conn);
 1546|       |
 1547|     74|  return result;
 1548|     74|}
ftp.c:ftp_need_type:
 3485|      5|{
 3486|      5|  return conn->proto.ftpc.transfertype != (ascii_wanted?'A':'I');
 3487|      5|}
ftp.c:ftp_nb_type:
 3500|      5|{
 3501|      5|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 3502|      5|  CURLcode result;
 3503|      5|  char want = (char)(ascii?'A':'I');
 3504|       |
 3505|      5|  if(ftpc->transfertype == want) {
 3506|      0|    state(data, newstate);
 3507|      0|    return ftp_state_type_resp(data, 200, newstate);
 3508|      0|  }
 3509|       |
 3510|      5|  result = Curl_pp_sendf(data, &ftpc->pp, "TYPE %c", want);
 3511|      5|  if(!result) {
 3512|      5|    state(data, newstate);
 3513|       |
 3514|       |    /* keep track of our current transfer type */
 3515|      5|    ftpc->transfertype = want;
 3516|      5|  }
 3517|      5|  return result;
 3518|      5|}
ftp.c:ftp_state_size:
 1423|     73|{
 1424|     73|  CURLcode result = CURLE_OK;
 1425|     73|  struct FTP *ftp = data->req.p.ftp;
 1426|     73|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 1427|       |
 1428|     73|  if((ftp->transfer == PPTRANSFER_INFO) && ftpc->file) {
 1429|       |    /* if a "head"-like request is being made (on a file) */
 1430|       |
 1431|       |    /* we know ftpc->file is a valid pointer to a file name */
 1432|      4|    result = Curl_pp_sendf(data, &ftpc->pp, "SIZE %s", ftpc->file);
 1433|      4|    if(!result)
 1434|      4|      state(data, FTP_SIZE);
 1435|      4|  }
 1436|     69|  else
 1437|     69|    result = ftp_state_rest(data, conn);
 1438|       |
 1439|     73|  return result;
 1440|     73|}
ftp.c:ftp_state_rest:
 1401|     72|{
 1402|     72|  CURLcode result = CURLE_OK;
 1403|     72|  struct FTP *ftp = data->req.p.ftp;
 1404|     72|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 1405|       |
 1406|     72|  if((ftp->transfer != PPTRANSFER_BODY) && ftpc->file) {
 1407|       |    /* if a "head"-like request is being made (on a file) */
 1408|       |
 1409|       |    /* Determine if server can respond to REST command and therefore
 1410|       |       whether it supports range */
 1411|      3|    result = Curl_pp_sendf(data, &ftpc->pp, "REST %d", 0);
 1412|      3|    if(!result)
 1413|      3|      state(data, FTP_REST);
 1414|      3|  }
 1415|     69|  else
 1416|     69|    result = ftp_state_prepare_transfer(data);
 1417|       |
 1418|     72|  return result;
 1419|     72|}
ftp.c:ftp_state_prepare_transfer:
 1357|     70|{
 1358|     70|  CURLcode result = CURLE_OK;
 1359|     70|  struct FTP *ftp = data->req.p.ftp;
 1360|     70|  struct connectdata *conn = data->conn;
 1361|       |
 1362|     70|  if(ftp->transfer != PPTRANSFER_BODY) {
 1363|       |    /* doesn't transfer any data */
 1364|       |
 1365|       |    /* still possibly do PRE QUOTE jobs */
 1366|      6|    state(data, FTP_RETR_PREQUOTE);
 1367|      6|    result = ftp_state_quote(data, TRUE, FTP_RETR_PREQUOTE);
 1368|      6|  }
 1369|     64|  else if(data->set.ftp_use_port) {
 1370|       |    /* We have chosen to use the PORT (or similar) command */
 1371|      0|    result = ftp_state_use_port(data, EPRT);
 1372|      0|  }
 1373|     64|  else {
 1374|       |    /* We have chosen (this is default) to use the PASV (or similar) command */
 1375|     64|    if(data->set.ftp_use_pret) {
 1376|       |      /* The user has requested that we send a PRET command
 1377|       |         to prepare the server for the upcoming PASV */
 1378|      0|      struct ftp_conn *ftpc = &conn->proto.ftpc;
 1379|      0|      if(!conn->proto.ftpc.file)
 1380|      0|        result = Curl_pp_sendf(data, &ftpc->pp, "PRET %s",
 1381|      0|                               data->set.str[STRING_CUSTOMREQUEST]?
 1382|      0|                               data->set.str[STRING_CUSTOMREQUEST]:
 1383|      0|                               (data->state.list_only?"NLST":"LIST"));
 1384|      0|      else if(data->set.upload)
 1385|      0|        result = Curl_pp_sendf(data, &ftpc->pp, "PRET STOR %s",
 1386|      0|                               conn->proto.ftpc.file);
 1387|      0|      else
 1388|      0|        result = Curl_pp_sendf(data, &ftpc->pp, "PRET RETR %s",
 1389|      0|                               conn->proto.ftpc.file);
 1390|      0|      if(!result)
 1391|      0|        state(data, FTP_PRET);
 1392|      0|    }
 1393|     64|    else
 1394|     64|      result = ftp_state_use_pasv(data, conn);
 1395|     64|  }
 1396|     70|  return result;
 1397|     70|}
ftp.c:ftp_state_type_resp:
 2177|      5|{
 2178|      5|  CURLcode result = CURLE_OK;
 2179|      5|  struct connectdata *conn = data->conn;
 2180|       |
 2181|      5|  if(ftpcode/100 != 2) {
 2182|       |    /* "sasserftpd" and "(u)r(x)bot ftpd" both responds with 226 after a
 2183|       |       successful 'TYPE I'. While that is not as RFC959 says, it is still a
 2184|       |       positive response code and we allow that. */
 2185|      1|    failf(data, "Couldn't set desired mode");
 2186|      1|    return CURLE_FTP_COULDNT_SET_TYPE;
 2187|      1|  }
 2188|      4|  if(ftpcode != 200)
 2189|      2|    infof(data, "Got a %03d response code instead of the assumed 200",
 2190|      2|          ftpcode);
 2191|       |
 2192|      4|  if(instate == FTP_TYPE)
 2193|      4|    result = ftp_state_size(data, conn);
 2194|      0|  else if(instate == FTP_LIST_TYPE)
 2195|      0|    result = ftp_state_list(data);
 2196|      0|  else if(instate == FTP_RETR_TYPE)
 2197|      0|    result = ftp_state_retr_prequote(data);
 2198|      0|  else if(instate == FTP_STOR_TYPE)
 2199|      0|    result = ftp_state_stor_prequote(data);
 2200|       |
 2201|      4|  return result;
 2202|      5|}
ftp.c:ftp_state_size_resp:
 2290|      3|{
 2291|      3|  CURLcode result = CURLE_OK;
 2292|      3|  curl_off_t filesize = -1;
 2293|      3|  char *buf = data->state.buffer;
 2294|       |
 2295|       |  /* get the size from the ascii string: */
 2296|      3|  if(ftpcode == 213) {
 2297|       |    /* To allow servers to prepend "rubbish" in the response string, we scan
 2298|       |       for all the digits at the end of the response and parse only those as a
 2299|       |       number. */
 2300|      2|    char *start = &buf[4];
 2301|      2|    char *fdigit = strchr(start, '\r');
 2302|      2|    if(fdigit) {
 2303|      1|      do
 2304|      1|        fdigit--;
 2305|      1|      while(ISDIGIT(*fdigit) && (fdigit > start));
 2306|      1|      if(!ISDIGIT(*fdigit))
 2307|      1|        fdigit++;
 2308|      1|    }
 2309|      1|    else
 2310|      1|      fdigit = start;
 2311|       |    /* ignores parsing errors, which will make the size remain unknown */
 2312|      2|    (void)curlx_strtoofft(fdigit, NULL, 0, &filesize);
 2313|       |
 2314|      2|  }
 2315|      1|  else if(ftpcode == 550) { /* "No such file or directory" */
 2316|       |    /* allow a SIZE failure for (resumed) uploads, when probing what command
 2317|       |       to use */
 2318|      0|    if(instate != FTP_STOR_SIZE) {
 2319|      0|      failf(data, "The file does not exist");
 2320|      0|      return CURLE_REMOTE_FILE_NOT_FOUND;
 2321|      0|    }
 2322|      0|  }
 2323|       |
 2324|      3|  if(instate == FTP_SIZE) {
 2325|      3|#ifdef CURL_FTP_HTTPSTYLE_HEAD
 2326|      3|    if(-1 != filesize) {
 2327|      2|      char clbuf[128];
 2328|      2|      int clbuflen = msnprintf(clbuf, sizeof(clbuf),
 2329|      2|                "Content-Length: %" CURL_FORMAT_CURL_OFF_T "\r\n", filesize);
 2330|      2|      result = Curl_client_write(data, CLIENTWRITE_BOTH, clbuf, clbuflen);
 2331|      2|      if(result)
 2332|      0|        return result;
 2333|      2|    }
 2334|      3|#endif
 2335|      3|    Curl_pgrsSetDownloadSize(data, filesize);
 2336|      3|    result = ftp_state_rest(data, data->conn);
 2337|      3|  }
 2338|      0|  else if(instate == FTP_RETR_SIZE) {
 2339|      0|    Curl_pgrsSetDownloadSize(data, filesize);
 2340|      0|    result = ftp_state_retr(data, filesize);
 2341|      0|  }
 2342|      0|  else if(instate == FTP_STOR_SIZE) {
 2343|      0|    data->state.resume_from = filesize;
 2344|      0|    result = ftp_state_ul_setup(data, TRUE);
 2345|      0|  }
 2346|       |
 2347|      3|  return result;
 2348|      3|}
ftp.c:ftp_state_rest_resp:
 2354|      1|{
 2355|      1|  CURLcode result = CURLE_OK;
 2356|      1|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 2357|       |
 2358|      1|  switch(instate) {
 2359|      1|  case FTP_REST:
 2360|      1|  default:
 2361|      1|#ifdef CURL_FTP_HTTPSTYLE_HEAD
 2362|      1|    if(ftpcode == 350) {
 2363|      0|      char buffer[24]= { "Accept-ranges: bytes\r\n" };
 2364|      0|      result = Curl_client_write(data, CLIENTWRITE_BOTH, buffer,
 2365|      0|                                 strlen(buffer));
 2366|      0|      if(result)
 2367|      0|        return result;
 2368|      0|    }
 2369|      1|#endif
 2370|      1|    result = ftp_state_prepare_transfer(data);
 2371|      1|    break;
 2372|       |
 2373|      0|  case FTP_RETR_REST:
 2374|      0|    if(ftpcode != 350) {
 2375|      0|      failf(data, "Couldn't use REST");
 2376|      0|      result = CURLE_FTP_COULDNT_USE_REST;
 2377|      0|    }
 2378|      0|    else {
 2379|      0|      result = Curl_pp_sendf(data, &ftpc->pp, "RETR %s", ftpc->file);
 2380|      0|      if(!result)
 2381|      0|        state(data, FTP_RETR);
 2382|      0|    }
 2383|      0|    break;
 2384|      1|  }
 2385|       |
 2386|      1|  return result;
 2387|      1|}
ftp.c:ftp_state_use_pasv:
 1311|     64|{
 1312|     64|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 1313|     64|  CURLcode result = CURLE_OK;
 1314|       |  /*
 1315|       |    Here's the executive summary on what to do:
 1316|       |
 1317|       |    PASV is RFC959, expect:
 1318|       |    227 Entering Passive Mode (a1,a2,a3,a4,p1,p2)
 1319|       |
 1320|       |    LPSV is RFC1639, expect:
 1321|       |    228 Entering Long Passive Mode (4,4,a1,a2,a3,a4,2,p1,p2)
 1322|       |
 1323|       |    EPSV is RFC2428, expect:
 1324|       |    229 Entering Extended Passive Mode (|||port|)
 1325|       |
 1326|       |  */
 1327|       |
 1328|     64|  static const char mode[][5] = { "EPSV", "PASV" };
 1329|     64|  int modeoff;
 1330|       |
 1331|     64|#ifdef PF_INET6
 1332|     64|  if(!conn->bits.ftp_use_epsv && conn->bits.ipv6)
 1333|       |    /* EPSV is disabled but we are connected to a IPv6 host, so we ignore the
 1334|       |       request and enable EPSV again! */
 1335|      0|    conn->bits.ftp_use_epsv = TRUE;
 1336|     64|#endif
 1337|       |
 1338|     64|  modeoff = conn->bits.ftp_use_epsv?0:1;
 1339|       |
 1340|     64|  result = Curl_pp_sendf(data, &ftpc->pp, "%s", mode[modeoff]);
 1341|     64|  if(!result) {
 1342|     64|    ftpc->count1 = modeoff;
 1343|     64|    state(data, FTP_PASV);
 1344|     64|    infof(data, "Connect data stream passively");
 1345|     64|  }
 1346|     64|  return result;
 1347|     64|}
ftp.c:ftp_state_pasv_resp:
 1835|     77|{
 1836|     77|  struct connectdata *conn = data->conn;
 1837|     77|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 1838|     77|  CURLcode result;
 1839|     77|  struct Curl_dns_entry *addr = NULL;
 1840|     77|  enum resolve_t rc;
 1841|     77|  unsigned short connectport; /* the local port connect() should use! */
 1842|     77|  char *str = &data->state.buffer[4];  /* start on the first letter */
 1843|       |
 1844|       |  /* if we come here again, make sure the former name is cleared */
 1845|     77|  Curl_safefree(ftpc->newhost);
 1846|       |
 1847|     77|  if((ftpc->count1 == 0) &&
 1848|     77|     (ftpcode == 229)) {
 1849|       |    /* positive EPSV response */
 1850|     10|    char *ptr = strchr(str, '(');
 1851|     10|    if(ptr) {
 1852|      8|      unsigned int num;
 1853|      8|      char separator[4];
 1854|      8|      ptr++;
 1855|      8|      if(5 == sscanf(ptr, "%c%c%c%u%c",
 1856|      8|                     &separator[0],
 1857|      8|                     &separator[1],
 1858|      8|                     &separator[2],
 1859|      8|                     &num,
 1860|      8|                     &separator[3])) {
 1861|      6|        const char sep1 = separator[0];
 1862|      6|        int i;
 1863|       |
 1864|       |        /* The four separators should be identical, or else this is an oddly
 1865|       |           formatted reply and we bail out immediately. */
 1866|     22|        for(i = 1; i<4; i++) {
 1867|     17|          if(separator[i] != sep1) {
 1868|      1|            ptr = NULL; /* set to NULL to signal error */
 1869|      1|            break;
 1870|      1|          }
 1871|     17|        }
 1872|      6|        if(num > 0xffff) {
 1873|      1|          failf(data, "Illegal port number in EPSV reply");
 1874|      1|          return CURLE_FTP_WEIRD_PASV_REPLY;
 1875|      1|        }
 1876|      5|        if(ptr) {
 1877|      4|          ftpc->newport = (unsigned short)(num & 0xffff);
 1878|      4|          ftpc->newhost = strdup(control_address(conn));
 1879|      4|          if(!ftpc->newhost)
 1880|      0|            return CURLE_OUT_OF_MEMORY;
 1881|      4|        }
 1882|      5|      }
 1883|      2|      else
 1884|      2|        ptr = NULL;
 1885|      8|    }
 1886|      9|    if(!ptr) {
 1887|      5|      failf(data, "Weirdly formatted EPSV reply");
 1888|      5|      return CURLE_FTP_WEIRD_PASV_REPLY;
 1889|      5|    }
 1890|      9|  }
 1891|     67|  else if((ftpc->count1 == 1) &&
 1892|     67|          (ftpcode == 227)) {
 1893|       |    /* positive PASV response */
 1894|     19|    unsigned int ip[4] = {0, 0, 0, 0};
 1895|     19|    unsigned int port[2] = {0, 0};
 1896|       |
 1897|       |    /*
 1898|       |     * Scan for a sequence of six comma-separated numbers and use them as
 1899|       |     * IP+port indicators.
 1900|       |     *
 1901|       |     * Found reply-strings include:
 1902|       |     * "227 Entering Passive Mode (127,0,0,1,4,51)"
 1903|       |     * "227 Data transfer will passively listen to 127,0,0,1,4,51"
 1904|       |     * "227 Entering passive mode. 127,0,0,1,4,51"
 1905|       |     */
 1906|    507|    while(*str) {
 1907|    499|      if(6 == sscanf(str, "%u,%u,%u,%u,%u,%u",
 1908|    499|                     &ip[0], &ip[1], &ip[2], &ip[3],
 1909|    499|                     &port[0], &port[1]))
 1910|     11|        break;
 1911|    488|      str++;
 1912|    488|    }
 1913|       |
 1914|     19|    if(!*str || (ip[0] > 255) || (ip[1] > 255)  || (ip[2] > 255)  ||
 1915|     19|       (ip[3] > 255) || (port[0] > 255)  || (port[1] > 255) ) {
 1916|     16|      failf(data, "Couldn't interpret the 227-response");
 1917|     16|      return CURLE_FTP_WEIRD_227_FORMAT;
 1918|     16|    }
 1919|       |
 1920|       |    /* we got OK from server */
 1921|      3|    if(data->set.ftp_skip_ip) {
 1922|       |      /* told to ignore the remotely given IP but instead use the host we used
 1923|       |         for the control connection */
 1924|      3|      infof(data, "Skip %u.%u.%u.%u for data connection, re-use %s instead",
 1925|      3|            ip[0], ip[1], ip[2], ip[3],
 1926|      3|            conn->host.name);
 1927|      3|      ftpc->newhost = strdup(control_address(conn));
 1928|      3|    }
 1929|      0|    else
 1930|      0|      ftpc->newhost = aprintf("%u.%u.%u.%u", ip[0], ip[1], ip[2], ip[3]);
 1931|       |
 1932|      3|    if(!ftpc->newhost)
 1933|      0|      return CURLE_OUT_OF_MEMORY;
 1934|       |
 1935|      3|    ftpc->newport = (unsigned short)(((port[0]<<8) + port[1]) & 0xffff);
 1936|      3|  }
 1937|     48|  else if(ftpc->count1 == 0) {
 1938|       |    /* EPSV failed, move on to PASV */
 1939|     36|    return ftp_epsv_disable(data, conn);
 1940|     36|  }
 1941|     12|  else {
 1942|     12|    failf(data, "Bad PASV/EPSV response: %03d", ftpcode);
 1943|     12|    return CURLE_FTP_WEIRD_PASV_REPLY;
 1944|     12|  }
 1945|       |
 1946|      7|#ifndef CURL_DISABLE_PROXY
 1947|      7|  if(conn->bits.proxy) {
 1948|       |    /*
 1949|       |     * This connection uses a proxy and we need to connect to the proxy again
 1950|       |     * here. We don't want to rely on a former host lookup that might've
 1951|       |     * expired now, instead we remake the lookup here and now!
 1952|       |     */
 1953|      0|    const char * const host_name = conn->bits.socksproxy ?
 1954|      0|      conn->socks_proxy.host.name : conn->http_proxy.host.name;
 1955|      0|    rc = Curl_resolv(data, host_name, (int)conn->port, FALSE, &addr);
 1956|      0|    if(rc == CURLRESOLV_PENDING)
 1957|       |      /* BLOCKING, ignores the return code but 'addr' will be NULL in
 1958|       |         case of failure */
 1959|      0|      (void)Curl_resolver_wait_resolv(data, &addr);
 1960|       |
 1961|      0|    connectport =
 1962|      0|      (unsigned short)conn->port; /* we connect to the proxy's port */
 1963|       |
 1964|      0|    if(!addr) {
 1965|      0|      failf(data, "Can't resolve proxy host %s:%hu", host_name, connectport);
 1966|      0|      return CURLE_COULDNT_RESOLVE_PROXY;
 1967|      0|    }
 1968|      0|  }
 1969|      7|  else
 1970|      7|#endif
 1971|      7|  {
 1972|       |    /* normal, direct, ftp connection */
 1973|      7|    DEBUGASSERT(ftpc->newhost);
 1974|       |
 1975|       |    /* postponed address resolution in case of tcp fastopen */
 1976|      7|    if(conn->bits.tcp_fastopen && !conn->bits.reuse && !ftpc->newhost[0]) {
 1977|      0|      Curl_conninfo_remote(data, conn, conn->sock[FIRSTSOCKET]);
 1978|      0|      Curl_safefree(ftpc->newhost);
 1979|      0|      ftpc->newhost = strdup(control_address(conn));
 1980|      0|      if(!ftpc->newhost)
 1981|      0|        return CURLE_OUT_OF_MEMORY;
 1982|      0|    }
 1983|       |
 1984|      7|    rc = Curl_resolv(data, ftpc->newhost, ftpc->newport, FALSE, &addr);
 1985|      7|    if(rc == CURLRESOLV_PENDING)
 1986|       |      /* BLOCKING */
 1987|      7|      (void)Curl_resolver_wait_resolv(data, &addr);
 1988|       |
 1989|      7|    connectport = ftpc->newport; /* we connect to the remote port */
 1990|       |
 1991|      7|    if(!addr) {
 1992|      7|      failf(data, "Can't resolve new host %s:%hu", ftpc->newhost, connectport);
 1993|      7|      return CURLE_FTP_CANT_GET_HOST;
 1994|      7|    }
 1995|      7|  }
 1996|       |
 1997|      0|  conn->bits.tcpconnect[SECONDARYSOCKET] = FALSE;
 1998|      0|  result = Curl_connecthost(data, conn, addr);
 1999|       |
 2000|      0|  if(result) {
 2001|      0|    Curl_resolv_unlock(data, addr); /* we're done using this address */
 2002|      0|    if(ftpc->count1 == 0 && ftpcode == 229)
 2003|      0|      return ftp_epsv_disable(data, conn);
 2004|       |
 2005|      0|    return result;
 2006|      0|  }
 2007|       |
 2008|       |
 2009|       |  /*
 2010|       |   * When this is used from the multi interface, this might've returned with
 2011|       |   * the 'connected' set to FALSE and thus we are now awaiting a non-blocking
 2012|       |   * connect to connect.
 2013|       |   */
 2014|       |
 2015|      0|  if(data->set.verbose)
 2016|       |    /* this just dumps information about this second connection */
 2017|      0|    ftp_pasv_verbose(data, addr->addr, ftpc->newhost, connectport);
 2018|       |
 2019|      0|  Curl_resolv_unlock(data, addr); /* we're done using this address */
 2020|       |
 2021|      0|  Curl_safefree(conn->secondaryhostname);
 2022|      0|  conn->secondary_port = ftpc->newport;
 2023|      0|  conn->secondaryhostname = strdup(ftpc->newhost);
 2024|      0|  if(!conn->secondaryhostname)
 2025|      0|    return CURLE_OUT_OF_MEMORY;
 2026|       |
 2027|      0|  conn->bits.do_more = TRUE;
 2028|      0|  state(data, FTP_STOP); /* this phase is completed */
 2029|       |
 2030|      0|  return result;
 2031|      0|}
ftp.c:control_address:
 1821|      7|{
 1822|       |  /* Returns the control connection IP address.
 1823|       |     If a proxy tunnel is used, returns the original host name instead, because
 1824|       |     the effective control connection address is the proxy address,
 1825|       |     not the ftp host. */
 1826|      7|#ifndef CURL_DISABLE_PROXY
 1827|      7|  if(conn->bits.tunnel_proxy || conn->bits.socksproxy)
 1828|      0|    return conn->host.name;
 1829|      7|#endif
 1830|      7|  return conn->primary_ip;
 1831|      7|}
ftp.c:ftp_epsv_disable:
 1792|     36|{
 1793|     36|  CURLcode result = CURLE_OK;
 1794|       |
 1795|     36|  if(conn->bits.ipv6
 1796|     36|#ifndef CURL_DISABLE_PROXY
 1797|     36|     && !(conn->bits.tunnel_proxy || conn->bits.socksproxy)
 1798|     36|#endif
 1799|     36|    ) {
 1800|       |    /* We can't disable EPSV when doing IPv6, so this is instead a fail */
 1801|      0|    failf(data, "Failed EPSV attempt, exiting");
 1802|      0|    return CURLE_WEIRD_SERVER_REPLY;
 1803|      0|  }
 1804|       |
 1805|     36|  infof(data, "Failed EPSV attempt. Disabling EPSV");
 1806|       |  /* disable it for next transfer */
 1807|     36|  conn->bits.ftp_use_epsv = FALSE;
 1808|     36|  data->state.errorbuf = FALSE; /* allow error message to get
 1809|       |                                         rewritten */
 1810|     36|  result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, "%s", "PASV");
 1811|     36|  if(!result) {
 1812|     36|    conn->proto.ftpc.count1++;
 1813|       |    /* remain in/go to the FTP_PASV state */
 1814|     36|    state(data, FTP_PASV);
 1815|     36|  }
 1816|     36|  return result;
 1817|     36|}
ftp.c:ftp_dophase_done:
 4259|      6|{
 4260|      6|  struct connectdata *conn = data->conn;
 4261|      6|  struct FTP *ftp = data->req.p.ftp;
 4262|      6|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 4263|       |
 4264|      6|  if(connected) {
 4265|      0|    int completed;
 4266|      0|    CURLcode result = ftp_do_more(data, &completed);
 4267|       |
 4268|      0|    if(result) {
 4269|      0|      close_secondarysocket(data, conn);
 4270|      0|      return result;
 4271|      0|    }
 4272|      0|  }
 4273|       |
 4274|      6|  if(ftp->transfer != PPTRANSFER_BODY)
 4275|       |    /* no data to transfer */
 4276|      6|    Curl_setup_transfer(data, -1, -1, FALSE, -1);
 4277|      0|  else if(!connected)
 4278|       |    /* since we didn't connect now, we want do_more to get called */
 4279|      0|    conn->bits.do_more = TRUE;
 4280|       |
 4281|      6|  ftpc->ctl_valid = TRUE; /* seems good */
 4282|       |
 4283|      6|  return CURLE_OK;
 4284|      6|}
ftp.c:ftp_endofresp:
  537|  3.51k|{
  538|  3.51k|  (void)data;
  539|  3.51k|  (void)conn;
  540|       |
  541|  3.51k|  if((len > 3) && LASTLINE(line)) {
  542|  1.14k|    *code = curlx_sltosi(strtol(line, NULL, 10));
  543|  1.14k|    return TRUE;
  544|  1.14k|  }
  545|       |
  546|  2.37k|  return FALSE;
  547|  3.51k|}
ftp.c:ftp_done:
 3191|    164|{
 3192|    164|  struct connectdata *conn = data->conn;
 3193|    164|  struct FTP *ftp = data->req.p.ftp;
 3194|    164|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 3195|    164|  struct pingpong *pp = &ftpc->pp;
 3196|    164|  ssize_t nread;
 3197|    164|  int ftpcode;
 3198|    164|  CURLcode result = CURLE_OK;
 3199|    164|  char *rawPath = NULL;
 3200|    164|  size_t pathLen = 0;
 3201|       |
 3202|    164|  if(!ftp)
 3203|      0|    return CURLE_OK;
 3204|       |
 3205|    164|  switch(status) {
 3206|      0|  case CURLE_BAD_DOWNLOAD_RESUME:
 3207|     18|  case CURLE_FTP_WEIRD_PASV_REPLY:
 3208|     18|  case CURLE_FTP_PORT_FAILED:
 3209|     18|  case CURLE_FTP_ACCEPT_FAILED:
 3210|     18|  case CURLE_FTP_ACCEPT_TIMEOUT:
 3211|     19|  case CURLE_FTP_COULDNT_SET_TYPE:
 3212|     19|  case CURLE_FTP_COULDNT_RETR_FILE:
 3213|     19|  case CURLE_PARTIAL_FILE:
 3214|     19|  case CURLE_UPLOAD_FAILED:
 3215|     36|  case CURLE_REMOTE_ACCESS_DENIED:
 3216|     36|  case CURLE_FILESIZE_EXCEEDED:
 3217|     37|  case CURLE_REMOTE_FILE_NOT_FOUND:
 3218|     37|  case CURLE_WRITE_ERROR:
 3219|       |    /* the connection stays alive fine even though this happened */
 3220|       |    /* fall-through */
 3221|     60|  case CURLE_OK: /* doesn't affect the control connection's status */
 3222|     60|    if(!premature)
 3223|     44|      break;
 3224|       |
 3225|       |    /* until we cope better with prematurely ended requests, let them
 3226|       |     * fallback as if in complete failure */
 3227|       |    /* FALLTHROUGH */
 3228|    120|  default:       /* by default, an error means the control connection is
 3229|       |                    wedged and should not be used anymore */
 3230|    120|    ftpc->ctl_valid = FALSE;
 3231|    120|    ftpc->cwdfail = TRUE; /* set this TRUE to prevent us to remember the
 3232|       |                             current path, as this connection is going */
 3233|    120|    connclose(conn, "FTP ended with bad error code");
 3234|    120|    result = status;      /* use the already set error code */
 3235|    120|    break;
 3236|    164|  }
 3237|       |
 3238|    164|  if(data->state.wildcardmatch) {
 3239|     12|    if(data->set.chunk_end && ftpc->file) {
 3240|      0|      Curl_set_in_callback(data, true);
 3241|      0|      data->set.chunk_end(data->wildcard.customptr);
 3242|      0|      Curl_set_in_callback(data, false);
 3243|      0|    }
 3244|     12|    ftpc->known_filesize = -1;
 3245|     12|  }
 3246|       |
 3247|    164|  if(!result)
 3248|       |    /* get the url-decoded "raw" path */
 3249|     60|    result = Curl_urldecode(data, ftp->path, 0, &rawPath, &pathLen,
 3250|     60|                            REJECT_CTRL);
 3251|    164|  if(result) {
 3252|       |    /* We can limp along anyway (and should try to since we may already be in
 3253|       |     * the error path) */
 3254|    104|    ftpc->ctl_valid = FALSE; /* mark control connection as bad */
 3255|    104|    connclose(conn, "FTP: out of memory!"); /* mark for connection closure */
 3256|    104|    free(ftpc->prevpath);
 3257|    104|    ftpc->prevpath = NULL; /* no path remembering */
 3258|    104|  }
 3259|     60|  else { /* remember working directory for connection reuse */
 3260|     60|    if((data->set.ftp_filemethod == FTPFILE_NOCWD) && (rawPath[0] == '/'))
 3261|      0|      free(rawPath); /* full path => no CWDs happened => keep ftpc->prevpath */
 3262|     60|    else {
 3263|     60|      free(ftpc->prevpath);
 3264|       |
 3265|     60|      if(!ftpc->cwdfail) {
 3266|     27|        if(data->set.ftp_filemethod == FTPFILE_NOCWD)
 3267|      0|          pathLen = 0; /* relative path => working directory is FTP home */
 3268|     27|        else
 3269|     27|          pathLen -= ftpc->file?strlen(ftpc->file):0; /* file is url-decoded */
 3270|       |
 3271|     27|        rawPath[pathLen] = '\0';
 3272|     27|        ftpc->prevpath = rawPath;
 3273|     27|      }
 3274|     33|      else {
 3275|     33|        free(rawPath);
 3276|     33|        ftpc->prevpath = NULL; /* no path */
 3277|     33|      }
 3278|     60|    }
 3279|       |
 3280|     60|    if(ftpc->prevpath)
 3281|     27|      infof(data, "Remembering we are in dir \"%s\"", ftpc->prevpath);
 3282|     60|  }
 3283|       |
 3284|       |  /* free the dir tree and file parts */
 3285|    164|  freedirs(ftpc);
 3286|       |
 3287|       |  /* shut down the socket to inform the server we're done */
 3288|       |
 3289|       |#ifdef _WIN32_WCE
 3290|       |  shutdown(conn->sock[SECONDARYSOCKET], 2);  /* SD_BOTH */
 3291|       |#endif
 3292|       |
 3293|    164|  if(conn->sock[SECONDARYSOCKET] != CURL_SOCKET_BAD) {
 3294|      0|    if(!result && ftpc->dont_check && data->req.maxdownload > 0) {
 3295|       |      /* partial download completed */
 3296|      0|      result = Curl_pp_sendf(data, pp, "%s", "ABOR");
 3297|      0|      if(result) {
 3298|      0|        failf(data, "Failure sending ABOR command: %s",
 3299|      0|              curl_easy_strerror(result));
 3300|      0|        ftpc->ctl_valid = FALSE; /* mark control connection as bad */
 3301|      0|        connclose(conn, "ABOR command failed"); /* connection closure */
 3302|      0|      }
 3303|      0|    }
 3304|       |
 3305|      0|    if(conn->ssl[SECONDARYSOCKET].use) {
 3306|       |      /* The secondary socket is using SSL so we must close down that part
 3307|       |         first before we close the socket for real */
 3308|      0|      Curl_ssl_close(data, conn, SECONDARYSOCKET);
 3309|       |
 3310|       |      /* Note that we keep "use" set to TRUE since that (next) connection is
 3311|       |         still requested to use SSL */
 3312|      0|    }
 3313|      0|    close_secondarysocket(data, conn);
 3314|      0|  }
 3315|       |
 3316|    164|  if(!result && (ftp->transfer == PPTRANSFER_BODY) && ftpc->ctl_valid &&
 3317|    164|     pp->pending_resp && !premature) {
 3318|       |    /*
 3319|       |     * Let's see what the server says about the transfer we just performed,
 3320|       |     * but lower the timeout as sometimes this connection has died while the
 3321|       |     * data has been transferred. This happens when doing through NATs etc that
 3322|       |     * abandon old silent connections.
 3323|       |     */
 3324|      0|    timediff_t old_time = pp->response_time;
 3325|       |
 3326|      0|    pp->response_time = 60*1000; /* give it only a minute for now */
 3327|      0|    pp->response = Curl_now(); /* timeout relative now */
 3328|       |
 3329|      0|    result = Curl_GetFTPResponse(data, &nread, &ftpcode);
 3330|       |
 3331|      0|    pp->response_time = old_time; /* set this back to previous value */
 3332|       |
 3333|      0|    if(!nread && (CURLE_OPERATION_TIMEDOUT == result)) {
 3334|      0|      failf(data, "control connection looks dead");
 3335|      0|      ftpc->ctl_valid = FALSE; /* mark control connection as bad */
 3336|      0|      connclose(conn, "Timeout or similar in FTP DONE operation"); /* close */
 3337|      0|    }
 3338|       |
 3339|      0|    if(result) {
 3340|      0|      Curl_safefree(ftp->pathalloc);
 3341|      0|      return result;
 3342|      0|    }
 3343|       |
 3344|      0|    if(ftpc->dont_check && data->req.maxdownload > 0) {
 3345|       |      /* we have just sent ABOR and there is no reliable way to check if it was
 3346|       |       * successful or not; we have to close the connection now */
 3347|      0|      infof(data, "partial download completed, closing connection");
 3348|      0|      connclose(conn, "Partial download with no ability to check");
 3349|      0|      return result;
 3350|      0|    }
 3351|       |
 3352|      0|    if(!ftpc->dont_check) {
 3353|       |      /* 226 Transfer complete, 250 Requested file action okay, completed. */
 3354|      0|      switch(ftpcode) {
 3355|      0|      case 226:
 3356|      0|      case 250:
 3357|      0|        break;
 3358|      0|      case 552:
 3359|      0|        failf(data, "Exceeded storage allocation");
 3360|      0|        result = CURLE_REMOTE_DISK_FULL;
 3361|      0|        break;
 3362|      0|      default:
 3363|      0|        failf(data, "server did not report OK, got %d", ftpcode);
 3364|      0|        result = CURLE_PARTIAL_FILE;
 3365|      0|        break;
 3366|      0|      }
 3367|      0|    }
 3368|      0|  }
 3369|       |
 3370|    164|  if(result || premature)
 3371|       |    /* the response code from the transfer showed an error already so no
 3372|       |       use checking further */
 3373|    120|    ;
 3374|     44|  else if(data->set.upload) {
 3375|      3|    if((-1 != data->state.infilesize) &&
 3376|      3|       (data->state.infilesize != data->req.writebytecount) &&
 3377|      3|       !data->set.crlf &&
 3378|      3|       (ftp->transfer == PPTRANSFER_BODY)) {
 3379|      1|      failf(data, "Uploaded unaligned file size (%" CURL_FORMAT_CURL_OFF_T
 3380|      1|            " out of %" CURL_FORMAT_CURL_OFF_T " bytes)",
 3381|      1|            data->req.bytecount, data->state.infilesize);
 3382|      1|      result = CURLE_PARTIAL_FILE;
 3383|      1|    }
 3384|      3|  }
 3385|     41|  else {
 3386|     41|    if((-1 != data->req.size) &&
 3387|     41|       (data->req.size != data->req.bytecount) &&
 3388|     41|#ifdef CURL_DO_LINEEND_CONV
 3389|       |       /* Most FTP servers don't adjust their file SIZE response for CRLFs, so
 3390|       |        * we'll check to see if the discrepancy can be explained by the number
 3391|       |        * of CRLFs we've changed to LFs.
 3392|       |        */
 3393|     41|       ((data->req.size + data->state.crlf_conversions) !=
 3394|      0|        data->req.bytecount) &&
 3395|     41|#endif /* CURL_DO_LINEEND_CONV */
 3396|     41|       (data->req.maxdownload != data->req.bytecount)) {
 3397|      0|      failf(data, "Received only partial file: %" CURL_FORMAT_CURL_OFF_T
 3398|      0|            " bytes", data->req.bytecount);
 3399|      0|      result = CURLE_PARTIAL_FILE;
 3400|      0|    }
 3401|     41|    else if(!ftpc->dont_check &&
 3402|     41|            !data->req.bytecount &&
 3403|     41|            (data->req.size>0)) {
 3404|      0|      failf(data, "No data was received!");
 3405|      0|      result = CURLE_FTP_COULDNT_RETR_FILE;
 3406|      0|    }
 3407|     41|  }
 3408|       |
 3409|       |  /* clear these for next connection */
 3410|    164|  ftp->transfer = PPTRANSFER_BODY;
 3411|    164|  ftpc->dont_check = FALSE;
 3412|       |
 3413|       |  /* Send any post-transfer QUOTE strings? */
 3414|    164|  if(!status && !result && !premature && data->set.postquote)
 3415|      0|    result = ftp_sendquote(data, conn, data->set.postquote);
 3416|    164|  Curl_safefree(ftp->pathalloc);
 3417|    164|  return result;
 3418|    164|}
ftp.c:freedirs:
  244|    344|{
  245|    344|  if(ftpc->dirs) {
  246|     53|    int i;
  247|    164|    for(i = 0; i < ftpc->dirdepth; i++) {
  248|    111|      free(ftpc->dirs[i]);
  249|    111|      ftpc->dirs[i] = NULL;
  250|    111|    }
  251|     53|    free(ftpc->dirs);
  252|     53|    ftpc->dirs = NULL;
  253|     53|    ftpc->dirdepth = 0;
  254|     53|  }
  255|    344|  Curl_safefree(ftpc->file);
  256|       |
  257|       |  /* no longer of any use */
  258|    344|  Curl_safefree(ftpc->newhost);
  259|    344|}
ftp.c:ftp_do:
 4000|    113|{
 4001|    113|  CURLcode result = CURLE_OK;
 4002|    113|  struct connectdata *conn = data->conn;
 4003|    113|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 4004|       |
 4005|    113|  *done = FALSE; /* default to false */
 4006|    113|  ftpc->wait_data_conn = FALSE; /* default to no such wait */
 4007|       |
 4008|    113|  if(data->state.wildcardmatch) {
 4009|      9|    result = wc_statemach(data);
 4010|      9|    if(data->wildcard.state == CURLWC_SKIP ||
 4011|      9|      data->wildcard.state == CURLWC_DONE) {
 4012|       |      /* do not call ftp_regular_transfer */
 4013|      1|      return CURLE_OK;
 4014|      1|    }
 4015|      8|    if(result) /* error, loop or skipping the file */
 4016|      1|      return result;
 4017|      8|  }
 4018|    104|  else { /* no wildcard FSM needed */
 4019|    104|    result = ftp_parse_url_path(data);
 4020|    104|    if(result)
 4021|      2|      return result;
 4022|    104|  }
 4023|       |
 4024|    109|  result = ftp_regular_transfer(data, done);
 4025|       |
 4026|    109|  return result;
 4027|    113|}
ftp.c:wc_statemach:
 3863|      9|{
 3864|      9|  struct WildcardData * const wildcard = &(data->wildcard);
 3865|      9|  struct connectdata *conn = data->conn;
 3866|      9|  CURLcode result = CURLE_OK;
 3867|       |
 3868|      9|  for(;;) {
 3869|      9|    switch(wildcard->state) {
 3870|      7|    case CURLWC_INIT:
 3871|      7|      result = init_wc_data(data);
 3872|      7|      if(wildcard->state == CURLWC_CLEAN)
 3873|       |        /* only listing! */
 3874|      3|        return result;
 3875|      4|      wildcard->state = result ? CURLWC_ERROR : CURLWC_MATCHING;
 3876|      4|      return result;
 3877|       |
 3878|      1|    case CURLWC_MATCHING: {
 3879|       |      /* In this state is LIST response successfully parsed, so lets restore
 3880|       |         previous WRITEFUNCTION callback and WRITEDATA pointer */
 3881|      1|      struct ftp_wc *ftpwc = wildcard->protdata;
 3882|      1|      data->set.fwrite_func = ftpwc->backup.write_function;
 3883|      1|      data->set.out = ftpwc->backup.file_descriptor;
 3884|      1|      ftpwc->backup.write_function = ZERO_NULL;
 3885|      1|      ftpwc->backup.file_descriptor = NULL;
 3886|      1|      wildcard->state = CURLWC_DOWNLOADING;
 3887|       |
 3888|      1|      if(Curl_ftp_parselist_geterror(ftpwc->parser)) {
 3889|       |        /* error found in LIST parsing */
 3890|      0|        wildcard->state = CURLWC_CLEAN;
 3891|      0|        continue;
 3892|      0|      }
 3893|      1|      if(wildcard->filelist.size == 0) {
 3894|       |        /* no corresponding file */
 3895|      1|        wildcard->state = CURLWC_CLEAN;
 3896|      1|        return CURLE_REMOTE_FILE_NOT_FOUND;
 3897|      1|      }
 3898|      0|      continue;
 3899|      1|    }
 3900|       |
 3901|      0|    case CURLWC_DOWNLOADING: {
 3902|       |      /* filelist has at least one file, lets get first one */
 3903|      0|      struct ftp_conn *ftpc = &conn->proto.ftpc;
 3904|      0|      struct curl_fileinfo *finfo = wildcard->filelist.head->ptr;
 3905|      0|      struct FTP *ftp = data->req.p.ftp;
 3906|       |
 3907|      0|      char *tmp_path = aprintf("%s%s", wildcard->path, finfo->filename);
 3908|      0|      if(!tmp_path)
 3909|      0|        return CURLE_OUT_OF_MEMORY;
 3910|       |
 3911|       |      /* switch default ftp->path and tmp_path */
 3912|      0|      free(ftp->pathalloc);
 3913|      0|      ftp->pathalloc = ftp->path = tmp_path;
 3914|       |
 3915|      0|      infof(data, "Wildcard - START of \"%s\"", finfo->filename);
 3916|      0|      if(data->set.chunk_bgn) {
 3917|      0|        long userresponse;
 3918|      0|        Curl_set_in_callback(data, true);
 3919|      0|        userresponse = data->set.chunk_bgn(
 3920|      0|          finfo, wildcard->customptr, (int)wildcard->filelist.size);
 3921|      0|        Curl_set_in_callback(data, false);
 3922|      0|        switch(userresponse) {
 3923|      0|        case CURL_CHUNK_BGN_FUNC_SKIP:
 3924|      0|          infof(data, "Wildcard - \"%s\" skipped by user",
 3925|      0|                finfo->filename);
 3926|      0|          wildcard->state = CURLWC_SKIP;
 3927|      0|          continue;
 3928|      0|        case CURL_CHUNK_BGN_FUNC_FAIL:
 3929|      0|          return CURLE_CHUNK_FAILED;
 3930|      0|        }
 3931|      0|      }
 3932|       |
 3933|      0|      if(finfo->filetype != CURLFILETYPE_FILE) {
 3934|      0|        wildcard->state = CURLWC_SKIP;
 3935|      0|        continue;
 3936|      0|      }
 3937|       |
 3938|      0|      if(finfo->flags & CURLFINFOFLAG_KNOWN_SIZE)
 3939|      0|        ftpc->known_filesize = finfo->size;
 3940|       |
 3941|      0|      result = ftp_parse_url_path(data);
 3942|      0|      if(result)
 3943|      0|        return result;
 3944|       |
 3945|       |      /* we don't need the Curl_fileinfo of first file anymore */
 3946|      0|      Curl_llist_remove(&wildcard->filelist, wildcard->filelist.head, NULL);
 3947|       |
 3948|      0|      if(wildcard->filelist.size == 0) { /* remains only one file to down. */
 3949|      0|        wildcard->state = CURLWC_CLEAN;
 3950|       |        /* after that will be ftp_do called once again and no transfer
 3951|       |           will be done because of CURLWC_CLEAN state */
 3952|      0|        return CURLE_OK;
 3953|      0|      }
 3954|      0|      return result;
 3955|      0|    }
 3956|       |
 3957|      0|    case CURLWC_SKIP: {
 3958|      0|      if(data->set.chunk_end) {
 3959|      0|        Curl_set_in_callback(data, true);
 3960|      0|        data->set.chunk_end(data->wildcard.customptr);
 3961|      0|        Curl_set_in_callback(data, false);
 3962|      0|      }
 3963|      0|      Curl_llist_remove(&wildcard->filelist, wildcard->filelist.head, NULL);
 3964|      0|      wildcard->state = (wildcard->filelist.size == 0) ?
 3965|      0|        CURLWC_CLEAN : CURLWC_DOWNLOADING;
 3966|      0|      continue;
 3967|      0|    }
 3968|       |
 3969|      1|    case CURLWC_CLEAN: {
 3970|      1|      struct ftp_wc *ftpwc = wildcard->protdata;
 3971|      1|      result = CURLE_OK;
 3972|      1|      if(ftpwc)
 3973|      0|        result = Curl_ftp_parselist_geterror(ftpwc->parser);
 3974|       |
 3975|      1|      wildcard->state = result ? CURLWC_ERROR : CURLWC_DONE;
 3976|      1|      return result;
 3977|      0|    }
 3978|       |
 3979|      0|    case CURLWC_DONE:
 3980|      0|    case CURLWC_ERROR:
 3981|      0|    case CURLWC_CLEAR:
 3982|      0|      if(wildcard->dtor)
 3983|      0|        wildcard->dtor(wildcard->protdata);
 3984|      0|      return result;
 3985|      9|    }
 3986|      9|  }
 3987|       |  /* UNREACHABLE */
 3988|      9|}
ftp.c:init_wc_data:
 3768|      7|{
 3769|      7|  char *last_slash;
 3770|      7|  struct FTP *ftp = data->req.p.ftp;
 3771|      7|  char *path = ftp->path;
 3772|      7|  struct WildcardData *wildcard = &(data->wildcard);
 3773|      7|  CURLcode result = CURLE_OK;
 3774|      7|  struct ftp_wc *ftpwc = NULL;
 3775|       |
 3776|      7|  last_slash = strrchr(ftp->path, '/');
 3777|      7|  if(last_slash) {
 3778|      4|    last_slash++;
 3779|      4|    if(last_slash[0] == '\0') {
 3780|      1|      wildcard->state = CURLWC_CLEAN;
 3781|      1|      result = ftp_parse_url_path(data);
 3782|      1|      return result;
 3783|      1|    }
 3784|      3|    wildcard->pattern = strdup(last_slash);
 3785|      3|    if(!wildcard->pattern)
 3786|      0|      return CURLE_OUT_OF_MEMORY;
 3787|      3|    last_slash[0] = '\0'; /* cut file from path */
 3788|      3|  }
 3789|      3|  else { /* there is only 'wildcard pattern' or nothing */
 3790|      3|    if(path[0]) {
 3791|      1|      wildcard->pattern = strdup(path);
 3792|      1|      if(!wildcard->pattern)
 3793|      0|        return CURLE_OUT_OF_MEMORY;
 3794|      1|      path[0] = '\0';
 3795|      1|    }
 3796|      2|    else { /* only list */
 3797|      2|      wildcard->state = CURLWC_CLEAN;
 3798|      2|      result = ftp_parse_url_path(data);
 3799|      2|      return result;
 3800|      2|    }
 3801|      3|  }
 3802|       |
 3803|       |  /* program continues only if URL is not ending with slash, allocate needed
 3804|       |     resources for wildcard transfer */
 3805|       |
 3806|       |  /* allocate ftp protocol specific wildcard data */
 3807|      4|  ftpwc = calloc(1, sizeof(struct ftp_wc));
 3808|      4|  if(!ftpwc) {
 3809|      0|    result = CURLE_OUT_OF_MEMORY;
 3810|      0|    goto fail;
 3811|      0|  }
 3812|       |
 3813|       |  /* INITIALIZE parselist structure */
 3814|      4|  ftpwc->parser = Curl_ftp_parselist_data_alloc();
 3815|      4|  if(!ftpwc->parser) {
 3816|      0|    result = CURLE_OUT_OF_MEMORY;
 3817|      0|    goto fail;
 3818|      0|  }
 3819|       |
 3820|      4|  wildcard->protdata = ftpwc; /* put it to the WildcardData tmp pointer */
 3821|      4|  wildcard->dtor = wc_data_dtor;
 3822|       |
 3823|       |  /* wildcard does not support NOCWD option (assert it?) */
 3824|      4|  if(data->set.ftp_filemethod == FTPFILE_NOCWD)
 3825|      0|    data->set.ftp_filemethod = FTPFILE_MULTICWD;
 3826|       |
 3827|       |  /* try to parse ftp url */
 3828|      4|  result = ftp_parse_url_path(data);
 3829|      4|  if(result) {
 3830|      0|    goto fail;
 3831|      0|  }
 3832|       |
 3833|      4|  wildcard->path = strdup(ftp->path);
 3834|      4|  if(!wildcard->path) {
 3835|      0|    result = CURLE_OUT_OF_MEMORY;
 3836|      0|    goto fail;
 3837|      0|  }
 3838|       |
 3839|       |  /* backup old write_function */
 3840|      4|  ftpwc->backup.write_function = data->set.fwrite_func;
 3841|       |  /* parsing write function */
 3842|      4|  data->set.fwrite_func = Curl_ftp_parselist;
 3843|       |  /* backup old file descriptor */
 3844|      4|  ftpwc->backup.file_descriptor = data->set.out;
 3845|       |  /* let the writefunc callback know the transfer */
 3846|      4|  data->set.out = data;
 3847|       |
 3848|      4|  infof(data, "Wildcard - Parsing started");
 3849|      4|  return CURLE_OK;
 3850|       |
 3851|      0|  fail:
 3852|      0|  if(ftpwc) {
 3853|      0|    Curl_ftp_parselist_data_free(&ftpwc->parser);
 3854|      0|    free(ftpwc);
 3855|      0|  }
 3856|      0|  Curl_safefree(wildcard->pattern);
 3857|      0|  wildcard->dtor = ZERO_NULL;
 3858|      0|  wildcard->protdata = NULL;
 3859|      0|  return result;
 3860|      4|}
ftp.c:wc_data_dtor:
 3760|      4|{
 3761|      4|  struct ftp_wc *ftpwc = ptr;
 3762|      4|  if(ftpwc && ftpwc->parser)
 3763|      4|    Curl_ftp_parselist_data_free(&ftpwc->parser);
 3764|      4|  free(ftpwc);
 3765|      4|}
ftp.c:ftp_parse_url_path:
 4113|    111|{
 4114|       |  /* the ftp struct is already inited in ftp_connect() */
 4115|    111|  struct FTP *ftp = data->req.p.ftp;
 4116|    111|  struct connectdata *conn = data->conn;
 4117|    111|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 4118|    111|  const char *slashPos = NULL;
 4119|    111|  const char *fileName = NULL;
 4120|    111|  CURLcode result = CURLE_OK;
 4121|    111|  char *rawPath = NULL; /* url-decoded "raw" path */
 4122|    111|  size_t pathLen = 0;
 4123|       |
 4124|    111|  ftpc->ctl_valid = FALSE;
 4125|    111|  ftpc->cwdfail = FALSE;
 4126|       |
 4127|       |  /* url-decode ftp path before further evaluation */
 4128|    111|  result = Curl_urldecode(data, ftp->path, 0, &rawPath, &pathLen, REJECT_CTRL);
 4129|    111|  if(result)
 4130|      1|    return result;
 4131|       |
 4132|    110|  switch(data->set.ftp_filemethod) {
 4133|      0|    case FTPFILE_NOCWD: /* fastest, but less standard-compliant */
 4134|       |
 4135|      0|      if((pathLen > 0) && (rawPath[pathLen - 1] != '/'))
 4136|      0|          fileName = rawPath;  /* this is a full file path */
 4137|       |      /*
 4138|       |        else: ftpc->file is not used anywhere other than for operations on
 4139|       |              a file. In other words, never for directory operations.
 4140|       |              So we can safely leave filename as NULL here and use it as a
 4141|       |              argument in dir/file decisions.
 4142|       |      */
 4143|      0|      break;
 4144|       |
 4145|      0|    case FTPFILE_SINGLECWD:
 4146|      0|      slashPos = strrchr(rawPath, '/');
 4147|      0|      if(slashPos) {
 4148|       |        /* get path before last slash, except for / */
 4149|      0|        size_t dirlen = slashPos - rawPath;
 4150|      0|        if(dirlen == 0)
 4151|      0|            dirlen++;
 4152|       |
 4153|      0|        ftpc->dirs = calloc(1, sizeof(ftpc->dirs[0]));
 4154|      0|        if(!ftpc->dirs) {
 4155|      0|          free(rawPath);
 4156|      0|          return CURLE_OUT_OF_MEMORY;
 4157|      0|        }
 4158|       |
 4159|      0|        ftpc->dirs[0] = calloc(1, dirlen + 1);
 4160|      0|        if(!ftpc->dirs[0]) {
 4161|      0|          free(rawPath);
 4162|      0|          return CURLE_OUT_OF_MEMORY;
 4163|      0|        }
 4164|       |
 4165|      0|        strncpy(ftpc->dirs[0], rawPath, dirlen);
 4166|      0|        ftpc->dirdepth = 1; /* we consider it to be a single dir */
 4167|      0|        fileName = slashPos + 1; /* rest is file name */
 4168|      0|      }
 4169|      0|      else
 4170|      0|        fileName = rawPath; /* file name only (or empty) */
 4171|      0|      break;
 4172|       |
 4173|      0|    default: /* allow pretty much anything */
 4174|    110|    case FTPFILE_MULTICWD: {
 4175|       |      /* current position: begin of next path component */
 4176|    110|      const char *curPos = rawPath;
 4177|       |
 4178|    110|      int dirAlloc = 0; /* number of entries allocated for the 'dirs' array */
 4179|    110|      const char *str = rawPath;
 4180|  1.25k|      for(; *str != 0; ++str)
 4181|  1.14k|        if (*str == '/')
 4182|    137|          ++dirAlloc;
 4183|       |
 4184|    110|      if(dirAlloc > 0) {
 4185|     53|        ftpc->dirs = calloc(dirAlloc, sizeof(ftpc->dirs[0]));
 4186|     53|        if(!ftpc->dirs) {
 4187|      0|          free(rawPath);
 4188|      0|          return CURLE_OUT_OF_MEMORY;
 4189|      0|        }
 4190|       |
 4191|       |        /* parse the URL path into separate path components */
 4192|    190|        while((slashPos = strchr(curPos, '/')) != NULL) {
 4193|    137|          size_t compLen = slashPos - curPos;
 4194|       |
 4195|       |          /* path starts with a slash: add that as a directory */
 4196|    137|          if((compLen == 0) && (ftpc->dirdepth == 0))
 4197|      1|            ++compLen;
 4198|       |
 4199|       |          /* we skip empty path components, like "x//y" since the FTP command
 4200|       |             CWD requires a parameter and a non-existent parameter a) doesn't
 4201|       |             work on many servers and b) has no effect on the others. */
 4202|    137|          if(compLen > 0) {
 4203|    111|            char *comp = calloc(1, compLen + 1);
 4204|    111|            if(!comp) {
 4205|      0|              free(rawPath);
 4206|      0|              return CURLE_OUT_OF_MEMORY;
 4207|      0|            }
 4208|    111|            strncpy(comp, curPos, compLen);
 4209|    111|            ftpc->dirs[ftpc->dirdepth++] = comp;
 4210|    111|          }
 4211|    137|          curPos = slashPos + 1;
 4212|    137|        }
 4213|     53|      }
 4214|    110|      DEBUGASSERT(ftpc->dirdepth <= dirAlloc);
 4215|    110|      fileName = curPos; /* the rest is the file name (or empty) */
 4216|    110|    }
 4217|      0|    break;
 4218|    110|  } /* switch */
 4219|       |
 4220|    110|  if(fileName && *fileName)
 4221|     63|    ftpc->file = strdup(fileName);
 4222|     47|  else
 4223|     47|    ftpc->file = NULL; /* instead of point to a zero byte,
 4224|       |                            we make it a NULL pointer */
 4225|       |
 4226|    110|  if(data->set.upload && !ftpc->file && (ftp->transfer == PPTRANSFER_BODY)) {
 4227|       |    /* We need a file name when uploading. Return error! */
 4228|      1|    failf(data, "Uploading to a URL without a file name!");
 4229|      1|    free(rawPath);
 4230|      1|    return CURLE_URL_MALFORMAT;
 4231|      1|  }
 4232|       |
 4233|    109|  ftpc->cwddone = FALSE; /* default to not done */
 4234|       |
 4235|    109|  if((data->set.ftp_filemethod == FTPFILE_NOCWD) && (rawPath[0] == '/'))
 4236|      0|    ftpc->cwddone = TRUE; /* skip CWD for absolute paths */
 4237|    109|  else { /* newly created FTP connections are already in entry path */
 4238|    109|    const char *oldPath = conn->bits.reuse ? ftpc->prevpath : "";
 4239|    109|    if(oldPath) {
 4240|    109|      size_t n = pathLen;
 4241|    109|      if(data->set.ftp_filemethod == FTPFILE_NOCWD)
 4242|      0|        n = 0; /* CWD to entry for relative paths */
 4243|    109|      else
 4244|    109|        n -= ftpc->file?strlen(ftpc->file):0;
 4245|       |
 4246|    109|      if((strlen(oldPath) == n) && !strncmp(rawPath, oldPath, n)) {
 4247|     57|        infof(data, "Request has same path as previous transfer");
 4248|     57|        ftpc->cwddone = TRUE;
 4249|     57|      }
 4250|    109|    }
 4251|    109|  }
 4252|       |
 4253|    109|  free(rawPath);
 4254|    109|  return CURLE_OK;
 4255|    110|}
ftp.c:ftp_regular_transfer:
 4317|    109|{
 4318|    109|  CURLcode result = CURLE_OK;
 4319|    109|  bool connected = FALSE;
 4320|    109|  struct connectdata *conn = data->conn;
 4321|    109|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 4322|    109|  data->req.size = -1; /* make sure this is unknown at this point */
 4323|       |
 4324|    109|  Curl_pgrsSetUploadCounter(data, 0);
 4325|    109|  Curl_pgrsSetDownloadCounter(data, 0);
 4326|    109|  Curl_pgrsSetUploadSize(data, -1);
 4327|    109|  Curl_pgrsSetDownloadSize(data, -1);
 4328|       |
 4329|    109|  ftpc->ctl_valid = TRUE; /* starts good */
 4330|       |
 4331|    109|  result = ftp_perform(data,
 4332|    109|                       &connected, /* have we connected after PASV/PORT */
 4333|    109|                       dophase_done); /* all commands in the DO-phase done? */
 4334|       |
 4335|    109|  if(!result) {
 4336|       |
 4337|     93|    if(!*dophase_done)
 4338|       |      /* the DO phase has not completed yet */
 4339|     90|      return CURLE_OK;
 4340|       |
 4341|      3|    result = ftp_dophase_done(data, connected);
 4342|       |
 4343|      3|    if(result)
 4344|      0|      return result;
 4345|      3|  }
 4346|     16|  else
 4347|     16|    freedirs(ftpc);
 4348|       |
 4349|     19|  return result;
 4350|    109|}
ftp.c:ftp_perform:
 3726|    109|{
 3727|       |  /* this is FTP and no proxy */
 3728|    109|  CURLcode result = CURLE_OK;
 3729|    109|  struct connectdata *conn = data->conn;
 3730|       |
 3731|    109|  DEBUGF(infof(data, "DO phase starts"));
 3732|       |
 3733|    109|  if(data->set.opt_no_body) {
 3734|       |    /* requested no body means no transfer... */
 3735|     10|    struct FTP *ftp = data->req.p.ftp;
 3736|     10|    ftp->transfer = PPTRANSFER_INFO;
 3737|     10|  }
 3738|       |
 3739|    109|  *dophase_done = FALSE; /* not done yet */
 3740|       |
 3741|       |  /* start the first command in the DO phase */
 3742|    109|  result = ftp_state_quote(data, TRUE, FTP_QUOTE);
 3743|    109|  if(result)
 3744|      0|    return result;
 3745|       |
 3746|       |  /* run the state-machine */
 3747|    109|  result = ftp_multi_statemach(data, dophase_done);
 3748|       |
 3749|    109|  *connected = conn->bits.tcpconnect[SECONDARYSOCKET];
 3750|       |
 3751|    109|  infof(data, "ftp_perform ends with SECONDARY: %d", *connected);
 3752|       |
 3753|    109|  if(*dophase_done)
 3754|      4|    DEBUGF(infof(data, "DO phase is complete1"));
 3755|       |
 3756|    109|  return result;
 3757|    109|}
ftp.c:ftp_disconnect:
 4072|    164|{
 4073|    164|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 4074|    164|  struct pingpong *pp = &ftpc->pp;
 4075|       |
 4076|       |  /* We cannot send quit unconditionally. If this connection is stale or
 4077|       |     bad in any way, sending quit and waiting around here will make the
 4078|       |     disconnect wait in vain and cause more problems than we need to.
 4079|       |
 4080|       |     ftp_quit() will check the state of ftp->ctl_valid. If it's ok it
 4081|       |     will try to send the QUIT command, otherwise it will just return.
 4082|       |  */
 4083|    164|  if(dead_connection)
 4084|     61|    ftpc->ctl_valid = FALSE;
 4085|       |
 4086|       |  /* The FTP session may or may not have been allocated/setup at this point! */
 4087|    164|  (void)ftp_quit(data, conn); /* ignore errors on the QUIT */
 4088|       |
 4089|    164|  if(ftpc->entrypath) {
 4090|     20|    if(data->state.most_recent_ftp_entrypath == ftpc->entrypath) {
 4091|     14|      data->state.most_recent_ftp_entrypath = NULL;
 4092|     14|    }
 4093|     20|    Curl_safefree(ftpc->entrypath);
 4094|     20|  }
 4095|       |
 4096|    164|  freedirs(ftpc);
 4097|    164|  Curl_safefree(ftpc->prevpath);
 4098|    164|  Curl_safefree(ftpc->server_os);
 4099|    164|  Curl_pp_disconnect(pp);
 4100|    164|  Curl_sec_end(conn);
 4101|    164|  return CURLE_OK;
 4102|    164|}
ftp.c:ftp_quit:
 4040|    164|{
 4041|    164|  CURLcode result = CURLE_OK;
 4042|       |
 4043|    164|  if(conn->proto.ftpc.ctl_valid) {
 4044|     40|    result = Curl_pp_sendf(data, &conn->proto.ftpc.pp, "%s", "QUIT");
 4045|     40|    if(result) {
 4046|      0|      failf(data, "Failure sending QUIT command: %s",
 4047|      0|            curl_easy_strerror(result));
 4048|      0|      conn->proto.ftpc.ctl_valid = FALSE; /* mark control connection as bad */
 4049|      0|      connclose(conn, "QUIT command failed"); /* mark for connection closure */
 4050|      0|      state(data, FTP_STOP);
 4051|      0|      return result;
 4052|      0|    }
 4053|       |
 4054|     40|    state(data, FTP_QUIT);
 4055|       |
 4056|     40|    result = ftp_block_statemach(data, conn);
 4057|     40|  }
 4058|       |
 4059|    164|  return result;
 4060|    164|}
ftp.c:ftp_block_statemach:
 3123|     40|{
 3124|     40|  struct ftp_conn *ftpc = &conn->proto.ftpc;
 3125|     40|  struct pingpong *pp = &ftpc->pp;
 3126|     40|  CURLcode result = CURLE_OK;
 3127|       |
 3128|    171|  while(ftpc->state != FTP_STOP) {
 3129|    155|    result = Curl_pp_statemach(data, pp, TRUE, TRUE /* disconnecting */);
 3130|    155|    if(result)
 3131|     24|      break;
 3132|    155|  }
 3133|       |
 3134|     40|  return result;
 3135|     40|}
ftp.c:ftp_doing:
 4289|    432|{
 4290|    432|  CURLcode result = ftp_multi_statemach(data, dophase_done);
 4291|       |
 4292|    432|  if(result)
 4293|     79|    DEBUGF(infof(data, "DO phase failed"));
 4294|    353|  else if(*dophase_done) {
 4295|      3|    result = ftp_dophase_done(data, FALSE /* not connected */);
 4296|       |
 4297|      3|    DEBUGF(infof(data, "DO phase is complete2"));
 4298|      3|  }
 4299|    432|  return result;
 4300|    432|}
ftp.c:ftp_setup_connection:
 4354|    164|{
 4355|    164|  char *type;
 4356|    164|  struct FTP *ftp;
 4357|       |
 4358|    164|  data->req.p.ftp = ftp = calloc(sizeof(struct FTP), 1);
 4359|    164|  if(NULL == ftp)
 4360|      0|    return CURLE_OUT_OF_MEMORY;
 4361|       |
 4362|    164|  ftp->path = &data->state.up.path[1]; /* don't include the initial slash */
 4363|       |
 4364|       |  /* FTP URLs support an extension like ";type=<typecode>" that
 4365|       |   * we'll try to get now! */
 4366|    164|  type = strstr(ftp->path, ";type=");
 4367|       |
 4368|    164|  if(!type)
 4369|    149|    type = strstr(conn->host.rawalloc, ";type=");
 4370|       |
 4371|    164|  if(type) {
 4372|     19|    char command;
 4373|     19|    *type = 0;                     /* it was in the middle of the hostname */
 4374|     19|    command = Curl_raw_toupper(type[6]);
 4375|       |
 4376|     19|    switch(command) {
 4377|      2|    case 'A': /* ASCII mode */
 4378|      2|      data->state.prefer_ascii = TRUE;
 4379|      2|      break;
 4380|       |
 4381|      1|    case 'D': /* directory mode */
 4382|      1|      data->state.list_only = TRUE;
 4383|      1|      break;
 4384|       |
 4385|      0|    case 'I': /* binary mode */
 4386|     16|    default:
 4387|       |      /* switch off ASCII */
 4388|     16|      data->state.prefer_ascii = FALSE;
 4389|     16|      break;
 4390|     19|    }
 4391|     19|  }
 4392|       |
 4393|       |  /* get some initial data into the ftp struct */
 4394|    164|  ftp->transfer = PPTRANSFER_BODY;
 4395|    164|  ftp->downloadsize = 0;
 4396|    164|  conn->proto.ftpc.known_filesize = -1; /* unknown size for now */
 4397|       |
 4398|    164|  return CURLE_OK;
 4399|    164|}

Curl_ftp_parselist_data_alloc:
  183|      4|{
  184|      4|  return calloc(1, sizeof(struct ftp_parselist_data));
  185|      4|}
Curl_ftp_parselist_data_free:
  189|      4|{
  190|      4|  struct ftp_parselist_data *parser = *parserp;
  191|      4|  if(parser)
  192|      4|    Curl_fileinfo_cleanup(parser->file_data);
  193|      4|  free(parser);
  194|      4|  *parserp = NULL;
  195|      4|}
Curl_ftp_parselist_geterror:
  199|      1|{
  200|      1|  return pl_data->error;
  201|      1|}

curl_getenv:
   75|  16.6k|{
   76|  16.6k|  return GetEnv(v);
   77|  16.6k|}
getenv.c:GetEnv:
   31|  16.6k|{
   32|       |#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
   33|       |  (void)variable;
   34|       |  return NULL;
   35|       |#elif defined(WIN32)
   36|       |  /* This uses Windows API instead of C runtime getenv() to get the environment
   37|       |     variable since some changes aren't always visible to the latter. #4774 */
   38|       |  char *buf = NULL;
   39|       |  char *tmp;
   40|       |  DWORD bufsize;
   41|       |  DWORD rc = 1;
   42|       |  const DWORD max = 32768; /* max env var size from MSCRT source */
   43|       |
   44|       |  for(;;) {
   45|       |    tmp = realloc(buf, rc);
   46|       |    if(!tmp) {
   47|       |      free(buf);
   48|       |      return NULL;
   49|       |    }
   50|       |
   51|       |    buf = tmp;
   52|       |    bufsize = rc;
   53|       |
   54|       |    /* It's possible for rc to be 0 if the variable was found but empty.
   55|       |       Since getenv doesn't make that distinction we ignore it as well. */
   56|       |    rc = GetEnvironmentVariableA(variable, buf, bufsize);
   57|       |    if(!rc || rc == bufsize || rc > max) {
   58|       |      free(buf);
   59|       |      return NULL;
   60|       |    }
   61|       |
   62|       |    /* if rc < bufsize then rc is bytes written not including null */
   63|       |    if(rc < bufsize)
   64|       |      return buf;
   65|       |
   66|       |    /* else rc is bytes needed, try again */
   67|       |  }
   68|       |#else
   69|  16.6k|  char *env = getenv(variable);
   70|  16.6k|  return (env && env[0])?strdup(env):NULL;
   71|  16.6k|#endif
   72|  16.6k|}

Curl_initinfo:
   46|  9.19k|{
   47|  9.19k|  struct Progress *pro = &data->progress;
   48|  9.19k|  struct PureInfo *info = &data->info;
   49|       |
   50|  9.19k|  pro->t_nslookup = 0;
   51|  9.19k|  pro->t_connect = 0;
   52|  9.19k|  pro->t_appconnect = 0;
   53|  9.19k|  pro->t_pretransfer = 0;
   54|  9.19k|  pro->t_starttransfer = 0;
   55|  9.19k|  pro->timespent = 0;
   56|  9.19k|  pro->t_redirect = 0;
   57|  9.19k|  pro->is_t_startransfer_set = false;
   58|       |
   59|  9.19k|  info->httpcode = 0;
   60|  9.19k|  info->httpproxycode = 0;
   61|  9.19k|  info->httpversion = 0;
   62|  9.19k|  info->filetime = -1; /* -1 is an illegal time and thus means unknown */
   63|  9.19k|  info->timecond = FALSE;
   64|       |
   65|  9.19k|  info->header_size = 0;
   66|  9.19k|  info->request_size = 0;
   67|  9.19k|  info->proxyauthavail = 0;
   68|  9.19k|  info->httpauthavail = 0;
   69|  9.19k|  info->numconnects = 0;
   70|       |
   71|  9.19k|  free(info->contenttype);
   72|  9.19k|  info->contenttype = NULL;
   73|       |
   74|  9.19k|  free(info->wouldredirect);
   75|  9.19k|  info->wouldredirect = NULL;
   76|       |
   77|  9.19k|  info->conn_primary_ip[0] = '\0';
   78|  9.19k|  info->conn_local_ip[0] = '\0';
   79|  9.19k|  info->conn_primary_port = 0;
   80|  9.19k|  info->conn_local_port = 0;
   81|  9.19k|  info->retry_after = 0;
   82|       |
   83|  9.19k|  info->conn_scheme = 0;
   84|  9.19k|  info->conn_protocol = 0;
   85|       |
   86|  9.19k|#ifdef USE_SSL
   87|  9.19k|  Curl_ssl_free_certinfo(data);
   88|  9.19k|#endif
   89|  9.19k|  return CURLE_OK;
   90|  9.19k|}

gopher.c:gopher_do:
  127|      2|{
  128|      2|  CURLcode result = CURLE_OK;
  129|      2|  struct connectdata *conn = data->conn;
  130|      2|  curl_socket_t sockfd = conn->sock[FIRSTSOCKET];
  131|      2|  char *gopherpath;
  132|      2|  char *path = data->state.up.path;
  133|      2|  char *query = data->state.up.query;
  134|      2|  char *sel = NULL;
  135|      2|  char *sel_org = NULL;
  136|      2|  timediff_t timeout_ms;
  137|      2|  ssize_t amount, k;
  138|      2|  size_t len;
  139|      2|  int what;
  140|       |
  141|      2|  *done = TRUE; /* unconditionally */
  142|       |
  143|       |  /* path is guaranteed non-NULL */
  144|      2|  DEBUGASSERT(path);
  145|       |
  146|      2|  if(query)
  147|      1|    gopherpath = aprintf("%s?%s", path, query);
  148|      1|  else
  149|      1|    gopherpath = strdup(path);
  150|       |
  151|      2|  if(!gopherpath)
  152|      0|    return CURLE_OUT_OF_MEMORY;
  153|       |
  154|       |  /* Create selector. Degenerate cases: / and /1 => convert to "" */
  155|      2|  if(strlen(gopherpath) <= 2) {
  156|      1|    sel = (char *)"";
  157|      1|    len = strlen(sel);
  158|      1|    free(gopherpath);
  159|      1|  }
  160|      1|  else {
  161|      1|    char *newp;
  162|       |
  163|       |    /* Otherwise, drop / and the first character (i.e., item type) ... */
  164|      1|    newp = gopherpath;
  165|      1|    newp += 2;
  166|       |
  167|       |    /* ... and finally unescape */
  168|      1|    result = Curl_urldecode(data, newp, 0, &sel, &len, REJECT_ZERO);
  169|      1|    free(gopherpath);
  170|      1|    if(result)
  171|      0|      return result;
  172|      1|    sel_org = sel;
  173|      1|  }
  174|       |
  175|      2|  k = curlx_uztosz(len);
  176|       |
  177|      2|  for(;;) {
  178|       |    /* Break out of the loop if the selector is empty because OpenSSL and/or
  179|       |       LibreSSL fail with errno 0 if this is the case. */
  180|      2|    if(strlen(sel) < 1)
  181|      1|      break;
  182|       |
  183|      1|    result = Curl_write(data, sockfd, sel, k, &amount);
  184|      1|    if(!result) { /* Which may not have written it all! */
  185|      1|      result = Curl_client_write(data, CLIENTWRITE_HEADER, sel, amount);
  186|      1|      if(result)
  187|      0|        break;
  188|       |
  189|      1|      k -= amount;
  190|      1|      sel += amount;
  191|      1|      if(k < 1)
  192|      1|        break; /* but it did write it all */
  193|      1|    }
  194|      0|    else
  195|      0|      break;
  196|       |
  197|      0|    timeout_ms = Curl_timeleft(data, NULL, FALSE);
  198|      0|    if(timeout_ms < 0) {
  199|      0|      result = CURLE_OPERATION_TIMEDOUT;
  200|      0|      break;
  201|      0|    }
  202|      0|    if(!timeout_ms)
  203|      0|      timeout_ms = TIMEDIFF_T_MAX;
  204|       |
  205|       |    /* Don't busyloop. The entire loop thing is a work-around as it causes a
  206|       |       BLOCKING behavior which is a NO-NO. This function should rather be
  207|       |       split up in a do and a doing piece where the pieces that aren't
  208|       |       possible to send now will be sent in the doing function repeatedly
  209|       |       until the entire request is sent.
  210|       |    */
  211|      0|    what = SOCKET_WRITABLE(sockfd, timeout_ms);
  212|      0|    if(what < 0) {
  213|      0|      result = CURLE_SEND_ERROR;
  214|      0|      break;
  215|      0|    }
  216|      0|    else if(!what) {
  217|      0|      result = CURLE_OPERATION_TIMEDOUT;
  218|      0|      break;
  219|      0|    }
  220|      0|  }
  221|       |
  222|      2|  free(sel_org);
  223|       |
  224|      2|  if(!result)
  225|      2|    result = Curl_write(data, sockfd, "\r\n", 2, &amount);
  226|      2|  if(result) {
  227|      0|    failf(data, "Failed sending Gopher request");
  228|      0|    return result;
  229|      0|  }
  230|      2|  result = Curl_client_write(data, CLIENTWRITE_HEADER, (char *)"\r\n", 2);
  231|      2|  if(result)
  232|      0|    return result;
  233|       |
  234|      2|  Curl_setup_transfer(data, FIRSTSOCKET, -1, FALSE, -1);
  235|      2|  return CURLE_OK;
  236|      2|}

Curl_hash_init:
   62|  9.27k|{
   63|  9.27k|  if(!slots || !hfunc || !comparator ||!dtor) {
   64|      0|    return 1; /* failure */
   65|      0|  }
   66|       |
   67|  9.27k|  h->hash_func = hfunc;
   68|  9.27k|  h->comp_func = comparator;
   69|  9.27k|  h->dtor = dtor;
   70|  9.27k|  h->size = 0;
   71|  9.27k|  h->slots = slots;
   72|       |
   73|  9.27k|  h->table = malloc(slots * sizeof(struct Curl_llist));
   74|  9.27k|  if(h->table) {
   75|  9.27k|    int i;
   76|  3.14M|    for(i = 0; i < slots; ++i)
   77|  3.13M|      Curl_llist_init(&h->table[i], (Curl_llist_dtor) hash_element_dtor);
   78|  9.27k|    return 0; /* fine */
   79|  9.27k|  }
   80|      0|  h->slots = 0;
   81|      0|  return 1; /* failure */
   82|  9.27k|}
Curl_hash_add:
  110|  5.78k|{
  111|  5.78k|  struct Curl_hash_element  *he;
  112|  5.78k|  struct Curl_llist_element *le;
  113|  5.78k|  struct Curl_llist *l = FETCH_LIST(h, key, key_len);
  114|       |
  115|  5.78k|  for(le = l->head; le; le = le->next) {
  116|      1|    he = (struct Curl_hash_element *) le->ptr;
  117|      1|    if(h->comp_func(he->key, he->key_len, key, key_len)) {
  118|      0|      Curl_llist_remove(l, le, (void *)h);
  119|      0|      --h->size;
  120|      0|      break;
  121|      0|    }
  122|      1|  }
  123|       |
  124|  5.78k|  he = mk_hash_element(key, key_len, p);
  125|  5.78k|  if(he) {
  126|  5.78k|    Curl_llist_insert_next(l, l->tail, he, &he->list);
  127|  5.78k|    ++h->size;
  128|  5.78k|    return p; /* return the new entry */
  129|  5.78k|  }
  130|       |
  131|      0|  return NULL; /* failure */
  132|  5.78k|}
Curl_hash_delete:
  140|  2.95k|{
  141|  2.95k|  struct Curl_llist_element *le;
  142|  2.95k|  struct Curl_llist *l = FETCH_LIST(h, key, key_len);
  143|       |
  144|  2.95k|  for(le = l->head; le; le = le->next) {
  145|  2.95k|    struct Curl_hash_element *he = le->ptr;
  146|  2.95k|    if(h->comp_func(he->key, he->key_len, key, key_len)) {
  147|  2.95k|      Curl_llist_remove(l, le, (void *) h);
  148|  2.95k|      --h->size;
  149|  2.95k|      return 0;
  150|  2.95k|    }
  151|  2.95k|  }
  152|      0|  return 1;
  153|  2.95k|}
Curl_hash_pick:
  161|  14.1k|{
  162|  14.1k|  struct Curl_llist_element *le;
  163|  14.1k|  struct Curl_llist *l;
  164|       |
  165|  14.1k|  if(h) {
  166|  14.1k|    l = FETCH_LIST(h, key, key_len);
  167|  14.1k|    for(le = l->head; le; le = le->next) {
  168|    200|      struct Curl_hash_element *he = le->ptr;
  169|    200|      if(h->comp_func(he->key, he->key_len, key, key_len)) {
  170|    195|        return he->ptr;
  171|    195|      }
  172|    200|    }
  173|  14.1k|  }
  174|       |
  175|  13.9k|  return NULL;
  176|  14.1k|}
Curl_hash_destroy:
  206|  9.27k|{
  207|  9.27k|  int i;
  208|       |
  209|  3.14M|  for(i = 0; i < h->slots; ++i) {
  210|  3.13M|    Curl_llist_destroy(&h->table[i], (void *) h);
  211|  3.13M|  }
  212|       |
  213|  9.27k|  Curl_safefree(h->table);
  214|  9.27k|  h->size = 0;
  215|  9.27k|  h->slots = 0;
  216|  9.27k|}
Curl_hash_clean:
  224|  3.09k|{
  225|  3.09k|  Curl_hash_clean_with_criterium(h, NULL, NULL);
  226|  3.09k|}
Curl_hash_clean_with_criterium:
  232|  6.05k|{
  233|  6.05k|  struct Curl_llist_element *le;
  234|  6.05k|  struct Curl_llist_element *lnext;
  235|  6.05k|  struct Curl_llist *list;
  236|  6.05k|  int i;
  237|       |
  238|  6.05k|  if(!h)
  239|  3.09k|    return;
  240|       |
  241|  23.6k|  for(i = 0; i < h->slots; ++i) {
  242|  20.7k|    list = &h->table[i];
  243|  20.7k|    le = list->head; /* get first list entry */
  244|  23.6k|    while(le) {
  245|  2.92k|      struct Curl_hash_element *he = le->ptr;
  246|  2.92k|      lnext = le->next;
  247|       |      /* ask the callback function if we shall remove this entry or not */
  248|  2.92k|      if(!comp || comp(user, he->ptr)) {
  249|      0|        Curl_llist_remove(list, le, (void *) h);
  250|      0|        --h->size; /* one less entry in the hash now */
  251|      0|      }
  252|  2.92k|      le = lnext;
  253|  2.92k|    }
  254|  20.7k|  }
  255|  2.95k|}
Curl_hash_str:
  258|  20.5k|{
  259|  20.5k|  const char *key_str = (const char *) key;
  260|  20.5k|  const char *end = key_str + key_length;
  261|  20.5k|  size_t h = 5381;
  262|       |
  263|   320k|  while(key_str < end) {
  264|   299k|    h += h << 5;
  265|   299k|    h ^= *key_str++;
  266|   299k|  }
  267|       |
  268|  20.5k|  return (h % slots_num);
  269|  20.5k|}
Curl_str_key_compare:
  273|  3.15k|{
  274|  3.15k|  if((key1_len == key2_len) && !memcmp(k1, k2, key1_len))
  275|  3.15k|    return 1;
  276|       |
  277|      6|  return 0;
  278|  3.15k|}
Curl_hash_start_iterate:
  282|  9.94k|{
  283|  9.94k|  iter->hash = hash;
  284|  9.94k|  iter->slot_index = 0;
  285|  9.94k|  iter->current_element = NULL;
  286|  9.94k|}
Curl_hash_next_element:
  290|  10.4k|{
  291|  10.4k|  struct Curl_hash *h = iter->hash;
  292|       |
  293|       |  /* Get the next element in the current list, if any */
  294|  10.4k|  if(iter->current_element)
  295|    516|    iter->current_element = iter->current_element->next;
  296|       |
  297|       |  /* If we have reached the end of the list, find the next one */
  298|  10.4k|  if(!iter->current_element) {
  299|  10.4k|    int i;
  300|   852k|    for(i = iter->slot_index; i < h->slots; i++) {
  301|   845k|      if(h->table[i].head) {
  302|  3.99k|        iter->current_element = h->table[i].head;
  303|  3.99k|        iter->slot_index = i + 1;
  304|  3.99k|        break;
  305|  3.99k|      }
  306|   845k|    }
  307|  10.4k|  }
  308|       |
  309|  10.4k|  if(iter->current_element) {
  310|  3.99k|    struct Curl_hash_element *he = iter->current_element->ptr;
  311|  3.99k|    return he;
  312|  3.99k|  }
  313|  6.47k|  iter->current_element = NULL;
  314|  6.47k|  return NULL;
  315|  10.4k|}
hash.c:hash_element_dtor:
   36|  5.78k|{
   37|  5.78k|  struct Curl_hash *h = (struct Curl_hash *) user;
   38|  5.78k|  struct Curl_hash_element *e = (struct Curl_hash_element *) element;
   39|       |
   40|  5.78k|  if(e->ptr) {
   41|  5.78k|    h->dtor(e->ptr);
   42|  5.78k|    e->ptr = NULL;
   43|  5.78k|  }
   44|       |
   45|  5.78k|  e->key_len = 0;
   46|       |
   47|  5.78k|  free(e);
   48|  5.78k|}
hash.c:mk_hash_element:
   86|  5.78k|{
   87|       |  /* allocate the struct plus memory after it to store the key */
   88|  5.78k|  struct Curl_hash_element *he = malloc(sizeof(struct Curl_hash_element) +
   89|  5.78k|                                        key_len);
   90|  5.78k|  if(he) {
   91|       |    /* copy the key */
   92|  5.78k|    memcpy(he->key, key, key_len);
   93|  5.78k|    he->key_len = key_len;
   94|  5.78k|    he->ptr = (void *) p;
   95|  5.78k|  }
   96|  5.78k|  return he;
   97|  5.78k|}

Curl_HMAC_init:
   55|     74|{
   56|     74|  size_t i;
   57|     74|  struct HMAC_context *ctxt;
   58|     74|  unsigned char *hkey;
   59|     74|  unsigned char b;
   60|       |
   61|       |  /* Create HMAC context. */
   62|     74|  i = sizeof(*ctxt) + 2 * hashparams->hmac_ctxtsize +
   63|     74|    hashparams->hmac_resultlen;
   64|     74|  ctxt = malloc(i);
   65|       |
   66|     74|  if(!ctxt)
   67|      0|    return ctxt;
   68|       |
   69|     74|  ctxt->hmac_hash = hashparams;
   70|     74|  ctxt->hmac_hashctxt1 = (void *) (ctxt + 1);
   71|     74|  ctxt->hmac_hashctxt2 = (void *) ((char *) ctxt->hmac_hashctxt1 +
   72|     74|      hashparams->hmac_ctxtsize);
   73|       |
   74|       |  /* If the key is too long, replace it by its hash digest. */
   75|     74|  if(keylen > hashparams->hmac_maxkeylen) {
   76|      1|    (*hashparams->hmac_hinit)(ctxt->hmac_hashctxt1);
   77|      1|    (*hashparams->hmac_hupdate)(ctxt->hmac_hashctxt1, key, keylen);
   78|      1|    hkey = (unsigned char *) ctxt->hmac_hashctxt2 + hashparams->hmac_ctxtsize;
   79|      1|    (*hashparams->hmac_hfinal)(hkey, ctxt->hmac_hashctxt1);
   80|      1|    key = hkey;
   81|      1|    keylen = hashparams->hmac_resultlen;
   82|      1|  }
   83|       |
   84|       |  /* Prime the two hash contexts with the modified key. */
   85|     74|  (*hashparams->hmac_hinit)(ctxt->hmac_hashctxt1);
   86|     74|  (*hashparams->hmac_hinit)(ctxt->hmac_hashctxt2);
   87|       |
   88|  1.75k|  for(i = 0; i < keylen; i++) {
   89|  1.68k|    b = (unsigned char)(*key ^ hmac_ipad);
   90|  1.68k|    (*hashparams->hmac_hupdate)(ctxt->hmac_hashctxt1, &b, 1);
   91|  1.68k|    b = (unsigned char)(*key++ ^ hmac_opad);
   92|  1.68k|    (*hashparams->hmac_hupdate)(ctxt->hmac_hashctxt2, &b, 1);
   93|  1.68k|  }
   94|       |
   95|  3.13k|  for(; i < hashparams->hmac_maxkeylen; i++) {
   96|  3.05k|    (*hashparams->hmac_hupdate)(ctxt->hmac_hashctxt1, &hmac_ipad, 1);
   97|  3.05k|    (*hashparams->hmac_hupdate)(ctxt->hmac_hashctxt2, &hmac_opad, 1);
   98|  3.05k|  }
   99|       |
  100|       |  /* Done, return pointer to HMAC context. */
  101|     74|  return ctxt;
  102|     74|}
Curl_HMAC_update:
  107|     60|{
  108|       |  /* Update first hash calculation. */
  109|     60|  (*ctxt->hmac_hash->hmac_hupdate)(ctxt->hmac_hashctxt1, data, len);
  110|     60|  return 0;
  111|     60|}
Curl_HMAC_final:
  115|     74|{
  116|     74|  const struct HMAC_params *hashparams = ctxt->hmac_hash;
  117|       |
  118|       |  /* Do not get result if called with a null parameter: only release
  119|       |     storage. */
  120|       |
  121|     74|  if(!result)
  122|      0|    result = (unsigned char *) ctxt->hmac_hashctxt2 +
  123|      0|     ctxt->hmac_hash->hmac_ctxtsize;
  124|       |
  125|     74|  (*hashparams->hmac_hfinal)(result, ctxt->hmac_hashctxt1);
  126|     74|  (*hashparams->hmac_hupdate)(ctxt->hmac_hashctxt2,
  127|     74|   result, hashparams->hmac_resultlen);
  128|     74|  (*hashparams->hmac_hfinal)(result, ctxt->hmac_hashctxt2);
  129|     74|  free((char *) ctxt);
  130|     74|  return 0;
  131|     74|}
Curl_hmacit:
  154|     45|{
  155|     45|  struct HMAC_context *ctxt =
  156|     45|    Curl_HMAC_init(hashparams, key, curlx_uztoui(keylen));
  157|       |
  158|     45|  if(!ctxt)
  159|      0|    return CURLE_OUT_OF_MEMORY;
  160|       |
  161|       |  /* Update the digest with the given challenge */
  162|     45|  Curl_HMAC_update(ctxt, data, curlx_uztoui(datalen));
  163|       |
  164|       |  /* Finalise the digest */
  165|     45|  Curl_HMAC_final(ctxt, output);
  166|       |
  167|     45|  return CURLE_OK;
  168|     45|}

Curl_addrinfo_callback:
   71|      7|{
   72|      7|  struct Curl_dns_entry *dns = NULL;
   73|      7|  CURLcode result = CURLE_OK;
   74|       |
   75|      7|  data->state.async.status = status;
   76|       |
   77|      7|  if(CURL_ASYNC_SUCCESS == status) {
   78|      0|    if(ai) {
   79|      0|      if(data->share)
   80|      0|        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
   81|       |
   82|      0|      dns = Curl_cache_addr(data, ai,
   83|      0|                            data->state.async.hostname,
   84|      0|                            data->state.async.port);
   85|      0|      if(data->share)
   86|      0|        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
   87|       |
   88|      0|      if(!dns) {
   89|       |        /* failed to store, cleanup and return error */
   90|      0|        Curl_freeaddrinfo(ai);
   91|      0|        result = CURLE_OUT_OF_MEMORY;
   92|      0|      }
   93|      0|    }
   94|      0|    else {
   95|      0|      result = CURLE_OUT_OF_MEMORY;
   96|      0|    }
   97|      0|  }
   98|       |
   99|      7|  data->state.async.dns = dns;
  100|       |
  101|       | /* Set async.done TRUE last in this function since it may be used multi-
  102|       |    threaded and once this is TRUE the other thread may read fields from the
  103|       |    async struct */
  104|      7|  data->state.async.done = TRUE;
  105|       |
  106|       |  /* IPv4: The input hostent struct will be freed by ares when we return from
  107|       |     this function */
  108|      7|  return result;
  109|      7|}
Curl_getaddrinfo:
  121|      7|{
  122|      7|  return Curl_resolver_getaddrinfo(data, hostname, port, waitp);
  123|      7|}

Curl_num_addresses:
  128|  2.93k|{
  129|  2.93k|  int i = 0;
  130|  5.86k|  while(addr) {
  131|  2.93k|    addr = addr->ai_next;
  132|  2.93k|    i++;
  133|  2.93k|  }
  134|  2.93k|  return i;
  135|  2.93k|}
Curl_hostcache_prune:
  230|  2.95k|{
  231|  2.95k|  time_t now;
  232|       |
  233|  2.95k|  if((data->set.dns_cache_timeout == -1) || !data->dns.hostcache)
  234|       |    /* cache forever means never prune, and NULL hostcache means
  235|       |       we can't do it */
  236|      0|    return;
  237|       |
  238|  2.95k|  if(data->share)
  239|      0|    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
  240|       |
  241|  2.95k|  time(&now);
  242|       |
  243|       |  /* Remove outdated and unused entries from the hostcache */
  244|  2.95k|  hostcache_prune(data->dns.hostcache,
  245|  2.95k|                  data->set.dns_cache_timeout,
  246|  2.95k|                  now);
  247|       |
  248|  2.95k|  if(data->share)
  249|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
  250|  2.95k|}
Curl_cache_addr:
  419|  2.82k|{
  420|  2.82k|  char entry_id[MAX_HOSTCACHE_LEN];
  421|  2.82k|  size_t entry_len;
  422|  2.82k|  struct Curl_dns_entry *dns;
  423|  2.82k|  struct Curl_dns_entry *dns2;
  424|       |
  425|  2.82k|#ifndef CURL_DISABLE_SHUFFLE_DNS
  426|       |  /* shuffle addresses if requested */
  427|  2.82k|  if(data->set.dns_shuffle_addresses) {
  428|      0|    CURLcode result = Curl_shuffle_addr(data, &addr);
  429|      0|    if(result)
  430|      0|      return NULL;
  431|      0|  }
  432|  2.82k|#endif
  433|       |
  434|       |  /* Create a new cache entry */
  435|  2.82k|  dns = calloc(1, sizeof(struct Curl_dns_entry));
  436|  2.82k|  if(!dns) {
  437|      0|    return NULL;
  438|      0|  }
  439|       |
  440|       |  /* Create an entry id, based upon the hostname and port */
  441|  2.82k|  create_hostcache_id(hostname, port, entry_id, sizeof(entry_id));
  442|  2.82k|  entry_len = strlen(entry_id);
  443|       |
  444|  2.82k|  dns->inuse = 1;   /* the cache has the first reference */
  445|  2.82k|  dns->addr = addr; /* this is the address(es) */
  446|  2.82k|  time(&dns->timestamp);
  447|  2.82k|  if(dns->timestamp == 0)
  448|      0|    dns->timestamp = 1;   /* zero indicates permanent CURLOPT_RESOLVE entry */
  449|       |
  450|       |  /* Store the resolved data in our DNS cache. */
  451|  2.82k|  dns2 = Curl_hash_add(data->dns.hostcache, entry_id, entry_len + 1,
  452|  2.82k|                       (void *)dns);
  453|  2.82k|  if(!dns2) {
  454|      0|    free(dns);
  455|      0|    return NULL;
  456|      0|  }
  457|       |
  458|  2.82k|  dns = dns2;
  459|  2.82k|  dns->inuse++;         /* mark entry as in-use */
  460|  2.82k|  return dns;
  461|  2.82k|}
Curl_ipv6works:
  540|  3.10k|{
  541|  3.10k|  if(data) {
  542|       |    /* the nature of most system is that IPv6 status doesn't come and go
  543|       |       during a program's lifetime so we only probe the first time and then we
  544|       |       have the info kept for fast re-use */
  545|      7|    DEBUGASSERT(data);
  546|      7|    DEBUGASSERT(data->multi);
  547|      7|    return data->multi->ipv6_works;
  548|      7|  }
  549|  3.09k|  else {
  550|  3.09k|    int ipv6_works = -1;
  551|       |    /* probe to see if we have a working IPv6 stack */
  552|  3.09k|    curl_socket_t s = socket(PF_INET6, SOCK_DGRAM, 0);
  553|  3.09k|    if(s == CURL_SOCKET_BAD)
  554|       |      /* an IPv6 address was requested but we can't get/use one */
  555|      0|      ipv6_works = 0;
  556|  3.09k|    else {
  557|  3.09k|      ipv6_works = 1;
  558|  3.09k|      sclose(s);
  559|  3.09k|    }
  560|  3.09k|    return (ipv6_works>0)?TRUE:FALSE;
  561|  3.09k|  }
  562|  3.10k|}
Curl_host_is_ipnum:
  570|  7.89k|{
  571|  7.89k|  struct in_addr in;
  572|  7.89k|#ifdef ENABLE_IPV6
  573|  7.89k|  struct in6_addr in6;
  574|  7.89k|#endif
  575|  7.89k|  if(Curl_inet_pton(AF_INET, hostname, &in) > 0
  576|  7.89k|#ifdef ENABLE_IPV6
  577|  7.89k|     || Curl_inet_pton(AF_INET6, hostname, &in6) > 0
  578|  7.89k|#endif
  579|  7.89k|    )
  580|  6.25k|    return TRUE;
  581|  1.63k|  return FALSE;
  582|  7.89k|}
Curl_resolv:
  606|  2.93k|{
  607|  2.93k|  struct Curl_dns_entry *dns = NULL;
  608|  2.93k|  CURLcode result;
  609|  2.93k|  enum resolve_t rc = CURLRESOLV_ERROR; /* default to failure */
  610|  2.93k|  struct connectdata *conn = data->conn;
  611|  2.93k|  *entry = NULL;
  612|  2.93k|  conn->bits.doh = FALSE; /* default is not */
  613|       |
  614|  2.93k|  if(data->share)
  615|      0|    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
  616|       |
  617|  2.93k|  dns = fetch_addr(data, hostname, port);
  618|       |
  619|  2.93k|  if(dns) {
  620|    110|    infof(data, "Hostname %s was found in DNS cache", hostname);
  621|    110|    dns->inuse++; /* we use it! */
  622|    110|    rc = CURLRESOLV_RESOLVED;
  623|    110|  }
  624|       |
  625|  2.93k|  if(data->share)
  626|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
  627|       |
  628|  2.93k|  if(!dns) {
  629|       |    /* The entry was not in the cache. Resolve it to IP address */
  630|       |
  631|  2.82k|    struct Curl_addrinfo *addr = NULL;
  632|  2.82k|    int respwait = 0;
  633|  2.82k|    struct in_addr in;
  634|  2.82k|#ifndef USE_RESOLVE_ON_IPS
  635|  2.82k|    const
  636|  2.82k|#endif
  637|  2.82k|      bool ipnum = FALSE;
  638|       |
  639|       |    /* notify the resolver start callback */
  640|  2.82k|    if(data->set.resolver_start) {
  641|      0|      int st;
  642|      0|      Curl_set_in_callback(data, true);
  643|      0|      st = data->set.resolver_start(
  644|      0|#ifdef USE_CURL_ASYNC
  645|      0|        data->state.async.resolver,
  646|       |#else
  647|       |        NULL,
  648|       |#endif
  649|      0|        NULL,
  650|      0|        data->set.resolver_start_client);
  651|      0|      Curl_set_in_callback(data, false);
  652|      0|      if(st)
  653|      0|        return CURLRESOLV_ERROR;
  654|      0|    }
  655|       |
  656|       |#if defined(ENABLE_IPV6) && defined(CURL_OSX_CALL_COPYPROXIES)
  657|       |    {
  658|       |      /*
  659|       |       * The automagic conversion from IPv4 literals to IPv6 literals only
  660|       |       * works if the SCDynamicStoreCopyProxies system function gets called
  661|       |       * first. As Curl currently doesn't support system-wide HTTP proxies, we
  662|       |       * therefore don't use any value this function might return.
  663|       |       *
  664|       |       * This function is only available on a macOS and is not needed for
  665|       |       * IPv4-only builds, hence the conditions above.
  666|       |       */
  667|       |      CFDictionaryRef dict = SCDynamicStoreCopyProxies(NULL);
  668|       |      if(dict)
  669|       |        CFRelease(dict);
  670|       |    }
  671|       |#endif
  672|       |
  673|  2.82k|#ifndef USE_RESOLVE_ON_IPS
  674|       |    /* First check if this is an IPv4 address string */
  675|  2.82k|    if(Curl_inet_pton(AF_INET, hostname, &in) > 0)
  676|       |      /* This is a dotted IP address 123.123.123.123-style */
  677|  2.82k|      addr = Curl_ip2addr(AF_INET, &in, hostname, port);
  678|  2.82k|#ifdef ENABLE_IPV6
  679|  2.82k|    if(!addr) {
  680|      7|      struct in6_addr in6;
  681|       |      /* check if this is an IPv6 address string */
  682|      7|      if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0)
  683|       |        /* This is an IPv6 address literal */
  684|      0|        addr = Curl_ip2addr(AF_INET6, &in6, hostname, port);
  685|      7|    }
  686|  2.82k|#endif /* ENABLE_IPV6 */
  687|       |
  688|       |#else /* if USE_RESOLVE_ON_IPS */
  689|       |    /* First check if this is an IPv4 address string */
  690|       |    if(Curl_inet_pton(AF_INET, hostname, &in) > 0)
  691|       |      /* This is a dotted IP address 123.123.123.123-style */
  692|       |      ipnum = TRUE;
  693|       |#ifdef ENABLE_IPV6
  694|       |    else {
  695|       |      struct in6_addr in6;
  696|       |      /* check if this is an IPv6 address string */
  697|       |      if(Curl_inet_pton(AF_INET6, hostname, &in6) > 0)
  698|       |        /* This is an IPv6 address literal */
  699|       |        ipnum = TRUE;
  700|       |    }
  701|       |#endif /* ENABLE_IPV6 */
  702|       |
  703|       |#endif /* !USE_RESOLVE_ON_IPS */
  704|       |
  705|  2.82k|    if(!addr) {
  706|      7|      if(conn->ip_version == CURL_IPRESOLVE_V6 && !Curl_ipv6works(data))
  707|      0|        return CURLRESOLV_ERROR;
  708|       |
  709|      7|      if(strcasecompare(hostname, "localhost"))
  710|      0|        addr = get_localhost(port);
  711|      7|      else if(allowDOH && data->set.doh && !ipnum)
  712|      0|        addr = Curl_doh(data, hostname, port, &respwait);
  713|      7|      else {
  714|       |        /* Check what IP specifics the app has requested and if we can provide
  715|       |         * it. If not, bail out. */
  716|      7|        if(!Curl_ipvalid(data, conn))
  717|      0|          return CURLRESOLV_ERROR;
  718|       |        /* If Curl_getaddrinfo() returns NULL, 'respwait' might be set to a
  719|       |           non-zero value indicating that we need to wait for the response to
  720|       |           the resolve call */
  721|      7|        addr = Curl_getaddrinfo(data, hostname, port, &respwait);
  722|      7|      }
  723|      7|    }
  724|  2.82k|    if(!addr) {
  725|      7|      if(respwait) {
  726|       |        /* the response to our resolve call will come asynchronously at
  727|       |           a later time, good or bad */
  728|       |        /* First, check that we haven't received the info by now */
  729|      7|        result = Curl_resolv_check(data, &dns);
  730|      7|        if(result) /* error detected */
  731|      0|          return CURLRESOLV_ERROR;
  732|      7|        if(dns)
  733|      0|          rc = CURLRESOLV_RESOLVED; /* pointer provided */
  734|      7|        else
  735|      7|          rc = CURLRESOLV_PENDING; /* no info yet */
  736|      7|      }
  737|      7|    }
  738|  2.82k|    else {
  739|  2.82k|      if(data->share)
  740|      0|        Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
  741|       |
  742|       |      /* we got a response, store it in the cache */
  743|  2.82k|      dns = Curl_cache_addr(data, addr, hostname, port);
  744|       |
  745|  2.82k|      if(data->share)
  746|      0|        Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
  747|       |
  748|  2.82k|      if(!dns)
  749|       |        /* returned failure, bail out nicely */
  750|      0|        Curl_freeaddrinfo(addr);
  751|  2.82k|      else
  752|  2.82k|        rc = CURLRESOLV_RESOLVED;
  753|  2.82k|    }
  754|  2.82k|  }
  755|       |
  756|  2.93k|  *entry = dns;
  757|       |
  758|  2.93k|  return rc;
  759|  2.93k|}
Curl_resolv_timeout:
  803|  2.93k|{
  804|       |#ifdef USE_ALARM_TIMEOUT
  805|       |#ifdef HAVE_SIGACTION
  806|       |  struct sigaction keep_sigact;   /* store the old struct here */
  807|       |  volatile bool keep_copysig = FALSE; /* whether old sigact has been saved */
  808|       |  struct sigaction sigact;
  809|       |#else
  810|       |#ifdef HAVE_SIGNAL
  811|       |  void (*keep_sigact)(int);       /* store the old handler here */
  812|       |#endif /* HAVE_SIGNAL */
  813|       |#endif /* HAVE_SIGACTION */
  814|       |  volatile long timeout;
  815|       |  volatile unsigned int prev_alarm = 0;
  816|       |#endif /* USE_ALARM_TIMEOUT */
  817|  2.93k|  enum resolve_t rc;
  818|       |
  819|  2.93k|  *entry = NULL;
  820|       |
  821|  2.93k|  if(timeoutms < 0)
  822|       |    /* got an already expired timeout */
  823|      0|    return CURLRESOLV_TIMEDOUT;
  824|       |
  825|       |#ifdef USE_ALARM_TIMEOUT
  826|       |  if(data->set.no_signal)
  827|       |    /* Ignore the timeout when signals are disabled */
  828|       |    timeout = 0;
  829|       |  else
  830|       |    timeout = (timeoutms > LONG_MAX) ? LONG_MAX : (long)timeoutms;
  831|       |
  832|       |  if(!timeout)
  833|       |    /* USE_ALARM_TIMEOUT defined, but no timeout actually requested */
  834|       |    return Curl_resolv(data, hostname, port, TRUE, entry);
  835|       |
  836|       |  if(timeout < 1000) {
  837|       |    /* The alarm() function only provides integer second resolution, so if
  838|       |       we want to wait less than one second we must bail out already now. */
  839|       |    failf(data,
  840|       |        "remaining timeout of %ld too small to resolve via SIGALRM method",
  841|       |        timeout);
  842|       |    return CURLRESOLV_TIMEDOUT;
  843|       |  }
  844|       |  /* This allows us to time-out from the name resolver, as the timeout
  845|       |     will generate a signal and we will siglongjmp() from that here.
  846|       |     This technique has problems (see alarmfunc).
  847|       |     This should be the last thing we do before calling Curl_resolv(),
  848|       |     as otherwise we'd have to worry about variables that get modified
  849|       |     before we invoke Curl_resolv() (and thus use "volatile"). */
  850|       |  if(sigsetjmp(curl_jmpenv, 1)) {
  851|       |    /* this is coming from a siglongjmp() after an alarm signal */
  852|       |    failf(data, "name lookup timed out");
  853|       |    rc = CURLRESOLV_ERROR;
  854|       |    goto clean_up;
  855|       |  }
  856|       |  else {
  857|       |    /*************************************************************
  858|       |     * Set signal handler to catch SIGALRM
  859|       |     * Store the old value to be able to set it back later!
  860|       |     *************************************************************/
  861|       |#ifdef HAVE_SIGACTION
  862|       |    sigaction(SIGALRM, NULL, &sigact);
  863|       |    keep_sigact = sigact;
  864|       |    keep_copysig = TRUE; /* yes, we have a copy */
  865|       |    sigact.sa_handler = alarmfunc;
  866|       |#ifdef SA_RESTART
  867|       |    /* HPUX doesn't have SA_RESTART but defaults to that behavior! */
  868|       |    sigact.sa_flags &= ~SA_RESTART;
  869|       |#endif
  870|       |    /* now set the new struct */
  871|       |    sigaction(SIGALRM, &sigact, NULL);
  872|       |#else /* HAVE_SIGACTION */
  873|       |    /* no sigaction(), revert to the much lamer signal() */
  874|       |#ifdef HAVE_SIGNAL
  875|       |    keep_sigact = signal(SIGALRM, alarmfunc);
  876|       |#endif
  877|       |#endif /* HAVE_SIGACTION */
  878|       |
  879|       |    /* alarm() makes a signal get sent when the timeout fires off, and that
  880|       |       will abort system calls */
  881|       |    prev_alarm = alarm(curlx_sltoui(timeout/1000L));
  882|       |  }
  883|       |
  884|       |#else
  885|       |#ifndef CURLRES_ASYNCH
  886|       |  if(timeoutms)
  887|       |    infof(data, "timeout on name lookup is not supported");
  888|       |#else
  889|  2.93k|  (void)timeoutms; /* timeoutms not used with an async resolver */
  890|  2.93k|#endif
  891|  2.93k|#endif /* USE_ALARM_TIMEOUT */
  892|       |
  893|       |  /* Perform the actual name resolution. This might be interrupted by an
  894|       |   * alarm if it takes too long.
  895|       |   */
  896|  2.93k|  rc = Curl_resolv(data, hostname, port, TRUE, entry);
  897|       |
  898|       |#ifdef USE_ALARM_TIMEOUT
  899|       |clean_up:
  900|       |
  901|       |  if(!prev_alarm)
  902|       |    /* deactivate a possibly active alarm before uninstalling the handler */
  903|       |    alarm(0);
  904|       |
  905|       |#ifdef HAVE_SIGACTION
  906|       |  if(keep_copysig) {
  907|       |    /* we got a struct as it looked before, now put that one back nice
  908|       |       and clean */
  909|       |    sigaction(SIGALRM, &keep_sigact, NULL); /* put it back */
  910|       |  }
  911|       |#else
  912|       |#ifdef HAVE_SIGNAL
  913|       |  /* restore the previous SIGALRM handler */
  914|       |  signal(SIGALRM, keep_sigact);
  915|       |#endif
  916|       |#endif /* HAVE_SIGACTION */
  917|       |
  918|       |  /* switch back the alarm() to either zero or to what it was before minus
  919|       |     the time we spent until now! */
  920|       |  if(prev_alarm) {
  921|       |    /* there was an alarm() set before us, now put it back */
  922|       |    timediff_t elapsed_secs = Curl_timediff(Curl_now(),
  923|       |                                            data->conn->created) / 1000;
  924|       |
  925|       |    /* the alarm period is counted in even number of seconds */
  926|       |    unsigned long alarm_set = (unsigned long)(prev_alarm - elapsed_secs);
  927|       |
  928|       |    if(!alarm_set ||
  929|       |       ((alarm_set >= 0x80000000) && (prev_alarm < 0x80000000)) ) {
  930|       |      /* if the alarm time-left reached zero or turned "negative" (counted
  931|       |         with unsigned values), we should fire off a SIGALRM here, but we
  932|       |         won't, and zero would be to switch it off so we never set it to
  933|       |         less than 1! */
  934|       |      alarm(1);
  935|       |      rc = CURLRESOLV_TIMEDOUT;
  936|       |      failf(data, "Previous alarm fired off!");
  937|       |    }
  938|       |    else
  939|       |      alarm((unsigned int)alarm_set);
  940|       |  }
  941|       |#endif /* USE_ALARM_TIMEOUT */
  942|       |
  943|  2.93k|  return rc;
  944|  2.93k|}
Curl_resolv_unlock:
  954|  2.93k|{
  955|  2.93k|  if(data && data->share)
  956|      0|    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
  957|       |
  958|  2.93k|  freednsentry(dns);
  959|       |
  960|  2.93k|  if(data && data->share)
  961|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
  962|  2.93k|}
Curl_mk_dnscache:
  983|  3.09k|{
  984|  3.09k|  return Curl_hash_init(hash, 7, Curl_hash_str, Curl_str_key_compare,
  985|  3.09k|                        freednsentry);
  986|  3.09k|}
Curl_hostcache_clean:
  997|  3.09k|{
  998|  3.09k|  if(data && data->share)
  999|      0|    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
 1000|       |
 1001|  3.09k|  Curl_hash_clean(hash);
 1002|       |
 1003|  3.09k|  if(data && data->share)
 1004|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
 1005|  3.09k|}
Curl_resolv_check:
 1209|      7|{
 1210|       |#if defined(CURL_DISABLE_DOH) && !defined(CURLRES_ASYNCH)
 1211|       |  (void)dns;
 1212|       |#endif
 1213|       |
 1214|      7|  if(data->conn->bits.doh)
 1215|      0|    return Curl_doh_is_resolved(data, dns);
 1216|      7|  return Curl_resolver_is_resolved(data, dns);
 1217|      7|}
Curl_resolver_error:
 1269|      7|{
 1270|      7|  const char *host_or_proxy;
 1271|      7|  CURLcode result;
 1272|       |
 1273|      7|#ifndef CURL_DISABLE_PROXY
 1274|      7|  struct connectdata *conn = data->conn;
 1275|      7|  if(conn->bits.httpproxy) {
 1276|      0|    host_or_proxy = "proxy";
 1277|      0|    result = CURLE_COULDNT_RESOLVE_PROXY;
 1278|      0|  }
 1279|      7|  else
 1280|      7|#endif
 1281|      7|  {
 1282|      7|    host_or_proxy = "host";
 1283|      7|    result = CURLE_COULDNT_RESOLVE_HOST;
 1284|      7|  }
 1285|       |
 1286|      7|  failf(data, "Could not resolve %s: %s", host_or_proxy,
 1287|      7|        data->state.async.hostname);
 1288|       |
 1289|      7|  return result;
 1290|      7|}
hostip.c:hostcache_prune:
  214|  2.95k|{
  215|  2.95k|  struct hostcache_prune_data user;
  216|       |
  217|  2.95k|  user.cache_timeout = cache_timeout;
  218|  2.95k|  user.now = now;
  219|       |
  220|  2.95k|  Curl_hash_clean_with_criterium(hostcache,
  221|  2.95k|                                 (void *) &user,
  222|  2.95k|                                 hostcache_timestamp_remove);
  223|  2.95k|}
hostip.c:hostcache_timestamp_remove:
  200|  3.03k|{
  201|  3.03k|  struct hostcache_prune_data *data =
  202|  3.03k|    (struct hostcache_prune_data *) datap;
  203|  3.03k|  struct Curl_dns_entry *c = (struct Curl_dns_entry *) hc;
  204|       |
  205|  3.03k|  return (0 != c->timestamp)
  206|  3.03k|    && (data->now - c->timestamp >= data->cache_timeout);
  207|  3.03k|}
hostip.c:fetch_addr:
  263|  2.93k|{
  264|  2.93k|  struct Curl_dns_entry *dns = NULL;
  265|  2.93k|  size_t entry_len;
  266|  2.93k|  char entry_id[MAX_HOSTCACHE_LEN];
  267|       |
  268|       |  /* Create an entry id, based upon the hostname and port */
  269|  2.93k|  create_hostcache_id(hostname, port, entry_id, sizeof(entry_id));
  270|  2.93k|  entry_len = strlen(entry_id);
  271|       |
  272|       |  /* See if its already in our dns cache */
  273|  2.93k|  dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);
  274|       |
  275|       |  /* No entry found in cache, check if we might have a wildcard entry */
  276|  2.93k|  if(!dns && data->state.wildcard_resolve) {
  277|      0|    create_hostcache_id("*", port, entry_id, sizeof(entry_id));
  278|      0|    entry_len = strlen(entry_id);
  279|       |
  280|       |    /* See if it's already in our dns cache */
  281|      0|    dns = Curl_hash_pick(data->dns.hostcache, entry_id, entry_len + 1);
  282|      0|  }
  283|       |
  284|  2.93k|  if(dns && (data->set.dns_cache_timeout != -1)) {
  285|       |    /* See whether the returned entry is stale. Done before we release lock */
  286|    110|    struct hostcache_prune_data user;
  287|       |
  288|    110|    time(&user.now);
  289|    110|    user.cache_timeout = data->set.dns_cache_timeout;
  290|       |
  291|    110|    if(hostcache_timestamp_remove(&user, dns)) {
  292|      0|      infof(data, "Hostname in DNS cache was stale, zapped");
  293|      0|      dns = NULL; /* the memory deallocation is being handled by the hash */
  294|      0|      Curl_hash_delete(data->dns.hostcache, entry_id, entry_len + 1);
  295|      0|    }
  296|    110|  }
  297|       |
  298|  2.93k|  return dns;
  299|  2.93k|}
hostip.c:create_hostcache_id:
  176|  5.76k|{
  177|  5.76k|  size_t len = strlen(name);
  178|  5.76k|  if(len > (buflen - 7))
  179|      0|    len = buflen - 7;
  180|       |  /* store and lower case the name */
  181|  69.0k|  while(len--)
  182|  63.2k|    *ptr++ = (char)TOLOWER(*name++);
  183|  5.76k|  msnprintf(ptr, 7, ":%u", port);
  184|  5.76k|}
hostip.c:freednsentry:
  968|  5.75k|{
  969|  5.75k|  struct Curl_dns_entry *dns = (struct Curl_dns_entry *) freethis;
  970|  5.75k|  DEBUGASSERT(dns && (dns->inuse>0));
  971|       |
  972|  5.75k|  dns->inuse--;
  973|  5.75k|  if(dns->inuse == 0) {
  974|  2.82k|    Curl_freeaddrinfo(dns->addr);
  975|  2.82k|    free(dns);
  976|  2.82k|  }
  977|  5.75k|}

Curl_ipvalid:
   66|      7|{
   67|      7|  if(conn->ip_version == CURL_IPRESOLVE_V6)
   68|      0|    return Curl_ipv6works(data);
   69|       |
   70|      7|  return TRUE;
   71|      7|}

Curl_hsts_cleanup:
   90|  6.25k|{
   91|  6.25k|  struct hsts *h = *hp;
   92|  6.25k|  if(h) {
   93|      0|    struct Curl_llist_element *e;
   94|      0|    struct Curl_llist_element *n;
   95|      0|    for(e = h->list.head; e; e = n) {
   96|      0|      struct stsentry *sts = e->ptr;
   97|      0|      n = e->next;
   98|      0|      hsts_free(sts);
   99|      0|    }
  100|      0|    free(h->filename);
  101|      0|    free(h);
  102|      0|    *hp = NULL;
  103|      0|  }
  104|  6.25k|}
Curl_hsts_save:
  332|  6.25k|{
  333|  6.25k|  struct Curl_llist_element *e;
  334|  6.25k|  struct Curl_llist_element *n;
  335|  6.25k|  CURLcode result = CURLE_OK;
  336|  6.25k|  FILE *out;
  337|  6.25k|  char *tempstore;
  338|  6.25k|  unsigned char randsuffix[9];
  339|       |
  340|  6.25k|  if(!h)
  341|       |    /* no cache activated */
  342|  6.25k|    return CURLE_OK;
  343|       |
  344|       |  /* if no new name is given, use the one we stored from the load */
  345|      0|  if(!file && h->filename)
  346|      0|    file = h->filename;
  347|       |
  348|      0|  if((h->flags & CURLHSTS_READONLYFILE) || !file || !file[0])
  349|       |    /* marked as read-only, no file or zero length file name */
  350|      0|    goto skipsave;
  351|       |
  352|      0|  if(Curl_rand_hex(data, randsuffix, sizeof(randsuffix)))
  353|      0|    return CURLE_FAILED_INIT;
  354|       |
  355|      0|  tempstore = aprintf("%s.%s.tmp", file, randsuffix);
  356|      0|  if(!tempstore)
  357|      0|    return CURLE_OUT_OF_MEMORY;
  358|       |
  359|      0|  out = fopen(tempstore, FOPEN_WRITETEXT);
  360|      0|  if(!out)
  361|      0|    result = CURLE_WRITE_ERROR;
  362|      0|  else {
  363|      0|    fputs("# Your HSTS cache. https://curl.se/docs/hsts.html\n"
  364|      0|          "# This file was generated by libcurl! Edit at your own risk.\n",
  365|      0|          out);
  366|      0|    for(e = h->list.head; e; e = n) {
  367|      0|      struct stsentry *sts = e->ptr;
  368|      0|      n = e->next;
  369|      0|      result = hsts_out(sts, out);
  370|      0|      if(result)
  371|      0|        break;
  372|      0|    }
  373|      0|    fclose(out);
  374|      0|    if(!result && Curl_rename(tempstore, file))
  375|      0|      result = CURLE_WRITE_ERROR;
  376|       |
  377|      0|    if(result)
  378|      0|      unlink(tempstore);
  379|      0|  }
  380|      0|  free(tempstore);
  381|      0|  skipsave:
  382|      0|  if(data->set.hsts_write) {
  383|       |    /* if there's a write callback */
  384|      0|    struct curl_index i; /* count */
  385|      0|    i.total = h->list.size;
  386|      0|    i.index = 0;
  387|      0|    for(e = h->list.head; e; e = n) {
  388|      0|      struct stsentry *sts = e->ptr;
  389|      0|      bool stop;
  390|      0|      n = e->next;
  391|      0|      result = hsts_push(data, &i, sts, &stop);
  392|      0|      if(result || stop)
  393|      0|        break;
  394|      0|      i.index++;
  395|      0|    }
  396|      0|  }
  397|      0|  return result;
  398|      0|}
Curl_hsts_loadcb:
  538|  2.94k|{
  539|  2.94k|  if(h)
  540|      0|    return hsts_pull(data, h);
  541|  2.94k|  return CURLE_OK;
  542|  2.94k|}

Curl_copy_header_value:
  246|  2.21k|{
  247|  2.21k|  const char *start;
  248|  2.21k|  const char *end;
  249|  2.21k|  char *value;
  250|  2.21k|  size_t len;
  251|       |
  252|       |  /* Find the end of the header name */
  253|  28.7k|  while(*header && (*header != ':'))
  254|  26.5k|    ++header;
  255|       |
  256|  2.21k|  if(*header)
  257|       |    /* Skip over colon */
  258|  2.21k|    ++header;
  259|       |
  260|       |  /* Find the first non-space letter */
  261|  2.21k|  start = header;
  262|  4.32k|  while(*start && ISSPACE(*start))
  263|  2.11k|    start++;
  264|       |
  265|       |  /* data is in the host encoding so
  266|       |     use '\r' and '\n' instead of 0x0d and 0x0a */
  267|  2.21k|  end = strchr(start, '\r');
  268|  2.21k|  if(!end)
  269|    327|    end = strchr(start, '\n');
  270|  2.21k|  if(!end)
  271|    207|    end = strchr(start, '\0');
  272|  2.21k|  if(!end)
  273|      0|    return NULL;
  274|       |
  275|       |  /* skip all trailing space letters */
  276|  4.27k|  while((end > start) && ISSPACE(*end))
  277|  2.05k|    end--;
  278|       |
  279|       |  /* get length of the type */
  280|  2.21k|  len = end - start + 1;
  281|       |
  282|  2.21k|  value = malloc(len + 1);
  283|  2.21k|  if(!value)
  284|      0|    return NULL;
  285|       |
  286|  2.21k|  memcpy(value, start, len);
  287|  2.21k|  value[len] = 0; /* null-terminate */
  288|       |
  289|  2.21k|  return value;
  290|  2.21k|}
Curl_http_auth_act:
  574|    532|{
  575|    532|  struct connectdata *conn = data->conn;
  576|    532|  bool pickhost = FALSE;
  577|    532|  bool pickproxy = FALSE;
  578|    532|  CURLcode result = CURLE_OK;
  579|    532|  unsigned long authmask = ~0ul;
  580|       |
  581|    532|  if(!data->set.str[STRING_BEARER])
  582|    532|    authmask &= (unsigned long)~CURLAUTH_BEARER;
  583|       |
  584|    532|  if(100 <= data->req.httpcode && 199 >= data->req.httpcode)
  585|       |    /* this is a transient response code, ignore */
  586|     53|    return CURLE_OK;
  587|       |
  588|    479|  if(data->state.authproblem)
  589|     25|    return data->set.http_fail_on_error?CURLE_HTTP_RETURNED_ERROR:CURLE_OK;
  590|       |
  591|    454|  if((conn->bits.user_passwd || data->set.str[STRING_BEARER]) &&
  592|    454|     ((data->req.httpcode == 401) ||
  593|     67|      (conn->bits.authneg && data->req.httpcode < 300))) {
  594|     59|    pickhost = pickoneauth(&data->state.authhost, authmask);
  595|     59|    if(!pickhost)
  596|     12|      data->state.authproblem = TRUE;
  597|     59|    if(data->state.authhost.picked == CURLAUTH_NTLM &&
  598|     59|       conn->httpversion > 11) {
  599|      0|      infof(data, "Forcing HTTP/1.1 for NTLM");
  600|      0|      connclose(conn, "Force HTTP/1.1 connection");
  601|      0|      data->state.httpwant = CURL_HTTP_VERSION_1_1;
  602|      0|    }
  603|     59|  }
  604|    454|#ifndef CURL_DISABLE_PROXY
  605|    454|  if(conn->bits.proxy_user_passwd &&
  606|    454|     ((data->req.httpcode == 407) ||
  607|      0|      (conn->bits.authneg && data->req.httpcode < 300))) {
  608|      0|    pickproxy = pickoneauth(&data->state.authproxy,
  609|      0|                            authmask & ~CURLAUTH_BEARER);
  610|      0|    if(!pickproxy)
  611|      0|      data->state.authproblem = TRUE;
  612|      0|  }
  613|    454|#endif
  614|       |
  615|    454|  if(pickhost || pickproxy) {
  616|     47|    if((data->state.httpreq != HTTPREQ_GET) &&
  617|     47|       (data->state.httpreq != HTTPREQ_HEAD) &&
  618|     47|       !conn->bits.rewindaftersend) {
  619|     19|      result = http_perhapsrewind(data, conn);
  620|     19|      if(result)
  621|      2|        return result;
  622|     19|    }
  623|       |    /* In case this is GSS auth, the newurl field is already allocated so
  624|       |       we must make sure to free it before allocating a new one. As figured
  625|       |       out in bug #2284386 */
  626|     45|    Curl_safefree(data->req.newurl);
  627|     45|    data->req.newurl = strdup(data->state.url); /* clone URL */
  628|     45|    if(!data->req.newurl)
  629|      0|      return CURLE_OUT_OF_MEMORY;
  630|     45|  }
  631|    407|  else if((data->req.httpcode < 300) &&
  632|    407|          (!data->state.authhost.done) &&
  633|    407|          conn->bits.authneg) {
  634|       |    /* no (known) authentication available,
  635|       |       authentication is not "done" yet and
  636|       |       no authentication seems to be required and
  637|       |       we didn't try HEAD or GET */
  638|      4|    if((data->state.httpreq != HTTPREQ_GET) &&
  639|      4|       (data->state.httpreq != HTTPREQ_HEAD)) {
  640|      4|      data->req.newurl = strdup(data->state.url); /* clone URL */
  641|      4|      if(!data->req.newurl)
  642|      0|        return CURLE_OUT_OF_MEMORY;
  643|      4|      data->state.authhost.done = TRUE;
  644|      4|    }
  645|      4|  }
  646|    452|  if(http_should_fail(data)) {
  647|      0|    failf(data, "The requested URL returned error: %d",
  648|      0|          data->req.httpcode);
  649|      0|    result = CURLE_HTTP_RETURNED_ERROR;
  650|      0|  }
  651|       |
  652|    452|  return result;
  653|    454|}
Curl_http_output_auth:
  800|  1.38k|{
  801|  1.38k|  CURLcode result = CURLE_OK;
  802|  1.38k|  struct auth *authhost;
  803|  1.38k|  struct auth *authproxy;
  804|       |
  805|  1.38k|  DEBUGASSERT(data);
  806|       |
  807|  1.38k|  authhost = &data->state.authhost;
  808|  1.38k|  authproxy = &data->state.authproxy;
  809|       |
  810|  1.38k|  if(
  811|  1.38k|#ifndef CURL_DISABLE_PROXY
  812|  1.38k|    (conn->bits.httpproxy && conn->bits.proxy_user_passwd) ||
  813|  1.38k|#endif
  814|  1.38k|     conn->bits.user_passwd || data->set.str[STRING_BEARER])
  815|    337|    /* continue please */;
  816|  1.05k|  else {
  817|  1.05k|    authhost->done = TRUE;
  818|  1.05k|    authproxy->done = TRUE;
  819|  1.05k|    return CURLE_OK; /* no authentication with no user or password */
  820|  1.05k|  }
  821|       |
  822|    337|  if(authhost->want && !authhost->picked)
  823|       |    /* The app has selected one or more methods, but none has been picked
  824|       |       so far by a server round-trip. Then we set the picked one to the
  825|       |       want one, and if this is one single bit it'll be used instantly. */
  826|    283|    authhost->picked = authhost->want;
  827|       |
  828|    337|  if(authproxy->want && !authproxy->picked)
  829|       |    /* The app has selected one or more methods, but none has been picked so
  830|       |       far by a proxy round-trip. Then we set the picked one to the want one,
  831|       |       and if this is one single bit it'll be used instantly. */
  832|    285|    authproxy->picked = authproxy->want;
  833|       |
  834|    337|#ifndef CURL_DISABLE_PROXY
  835|       |  /* Send proxy authentication header if needed */
  836|    337|  if(conn->bits.httpproxy &&
  837|    337|     (conn->bits.tunnel_proxy == (bit)proxytunnel)) {
  838|      0|    result = output_auth_headers(data, conn, authproxy, request, path, TRUE);
  839|      0|    if(result)
  840|      0|      return result;
  841|      0|  }
  842|    337|  else
  843|       |#else
  844|       |  (void)proxytunnel;
  845|       |#endif /* CURL_DISABLE_PROXY */
  846|       |    /* we have no proxy so let's pretend we're done authenticating
  847|       |       with it */
  848|    337|    authproxy->done = TRUE;
  849|       |
  850|       |  /* To prevent the user+password to get sent to other than the original
  851|       |     host due to a location-follow, we do some weirdo checks here */
  852|    337|  if(!data->state.this_is_a_follow ||
  853|    337|#ifndef CURL_DISABLE_NETRC
  854|    337|     conn->bits.netrc ||
  855|    337|#endif
  856|    337|     !data->state.first_host ||
  857|    337|     data->set.allow_auth_to_other_hosts ||
  858|    337|     strcasecompare(data->state.first_host, conn->host.name)) {
  859|    336|    result = output_auth_headers(data, conn, authhost, request, path, FALSE);
  860|    336|  }
  861|      1|  else
  862|      1|    authhost->done = TRUE;
  863|       |
  864|    337|  if(((authhost->multipass && !authhost->done) ||
  865|    337|      (authproxy->multipass && !authproxy->done)) &&
  866|    337|     (httpreq != HTTPREQ_GET) &&
  867|    337|     (httpreq != HTTPREQ_HEAD)) {
  868|       |    /* Auth is required and we are not authenticated yet. Make a PUT or POST
  869|       |       with content-length zero as a "probe". */
  870|     21|    conn->bits.authneg = TRUE;
  871|     21|  }
  872|    316|  else
  873|    316|    conn->bits.authneg = FALSE;
  874|       |
  875|    337|  return result;
  876|    337|}
Curl_http_input_auth:
  911|    180|{
  912|       |  /*
  913|       |   * This resource requires authentication
  914|       |   */
  915|    180|  struct connectdata *conn = data->conn;
  916|       |#ifdef USE_SPNEGO
  917|       |  curlnegotiate *negstate = proxy ? &conn->proxy_negotiate_state :
  918|       |                                    &conn->http_negotiate_state;
  919|       |#endif
  920|    180|  unsigned long *availp;
  921|    180|  struct auth *authp;
  922|       |
  923|    180|  (void) conn; /* In case conditionals make it unused. */
  924|       |
  925|    180|  if(proxy) {
  926|      0|    availp = &data->info.proxyauthavail;
  927|      0|    authp = &data->state.authproxy;
  928|      0|  }
  929|    180|  else {
  930|    180|    availp = &data->info.httpauthavail;
  931|    180|    authp = &data->state.authhost;
  932|    180|  }
  933|       |
  934|       |  /*
  935|       |   * Here we check if we want the specific single authentication (using ==) and
  936|       |   * if we do, we initiate usage of it.
  937|       |   *
  938|       |   * If the provided authentication is wanted as one out of several accepted
  939|       |   * types (using &), we OR this authentication type to the authavail
  940|       |   * variable.
  941|       |   *
  942|       |   * Note:
  943|       |   *
  944|       |   * ->picked is first set to the 'want' value (one or more bits) before the
  945|       |   * request is sent, and then it is again set _after_ all response 401/407
  946|       |   * headers have been received but then only to a single preferred method
  947|       |   * (bit).
  948|       |   */
  949|       |
  950|    737|  while(*auth) {
  951|       |#ifdef USE_SPNEGO
  952|       |    if(checkprefix("Negotiate", auth) && is_valid_auth_separator(auth[9])) {
  953|       |      if((authp->avail & CURLAUTH_NEGOTIATE) ||
  954|       |         Curl_auth_is_spnego_supported()) {
  955|       |        *availp |= CURLAUTH_NEGOTIATE;
  956|       |        authp->avail |= CURLAUTH_NEGOTIATE;
  957|       |
  958|       |        if(authp->picked == CURLAUTH_NEGOTIATE) {
  959|       |          CURLcode result = Curl_input_negotiate(data, conn, proxy, auth);
  960|       |          if(!result) {
  961|       |            DEBUGASSERT(!data->req.newurl);
  962|       |            data->req.newurl = strdup(data->state.url);
  963|       |            if(!data->req.newurl)
  964|       |              return CURLE_OUT_OF_MEMORY;
  965|       |            data->state.authproblem = FALSE;
  966|       |            /* we received a GSS auth token and we dealt with it fine */
  967|       |            *negstate = GSS_AUTHRECV;
  968|       |          }
  969|       |          else
  970|       |            data->state.authproblem = TRUE;
  971|       |        }
  972|       |      }
  973|       |    }
  974|       |    else
  975|       |#endif
  976|    557|#ifdef USE_NTLM
  977|       |      /* NTLM support requires the SSL crypto libs */
  978|    557|      if(checkprefix("NTLM", auth) && is_valid_auth_separator(auth[4])) {
  979|      0|        if((authp->avail & CURLAUTH_NTLM) ||
  980|      0|           (authp->avail & CURLAUTH_NTLM_WB) ||
  981|      0|           Curl_auth_is_ntlm_supported()) {
  982|      0|          *availp |= CURLAUTH_NTLM;
  983|      0|          authp->avail |= CURLAUTH_NTLM;
  984|       |
  985|      0|          if(authp->picked == CURLAUTH_NTLM ||
  986|      0|             authp->picked == CURLAUTH_NTLM_WB) {
  987|       |            /* NTLM authentication is picked and activated */
  988|      0|            CURLcode result = Curl_input_ntlm(data, proxy, auth);
  989|      0|            if(!result) {
  990|      0|              data->state.authproblem = FALSE;
  991|      0|#ifdef NTLM_WB_ENABLED
  992|      0|              if(authp->picked == CURLAUTH_NTLM_WB) {
  993|      0|                *availp &= ~CURLAUTH_NTLM;
  994|      0|                authp->avail &= ~CURLAUTH_NTLM;
  995|      0|                *availp |= CURLAUTH_NTLM_WB;
  996|      0|                authp->avail |= CURLAUTH_NTLM_WB;
  997|       |
  998|      0|                result = Curl_input_ntlm_wb(data, conn, proxy, auth);
  999|      0|                if(result) {
 1000|      0|                  infof(data, "Authentication problem. Ignoring this.");
 1001|      0|                  data->state.authproblem = TRUE;
 1002|      0|                }
 1003|      0|              }
 1004|      0|#endif
 1005|      0|            }
 1006|      0|            else {
 1007|      0|              infof(data, "Authentication problem. Ignoring this.");
 1008|      0|              data->state.authproblem = TRUE;
 1009|      0|            }
 1010|      0|          }
 1011|      0|        }
 1012|      0|      }
 1013|    557|      else
 1014|    557|#endif
 1015|    557|#ifndef CURL_DISABLE_CRYPTO_AUTH
 1016|    557|        if(checkprefix("Digest", auth) && is_valid_auth_separator(auth[6])) {
 1017|    161|          if((authp->avail & CURLAUTH_DIGEST) != 0)
 1018|     29|            infof(data, "Ignoring duplicate digest auth header.");
 1019|    132|          else if(Curl_auth_is_digest_supported()) {
 1020|    132|            CURLcode result;
 1021|       |
 1022|    132|            *availp |= CURLAUTH_DIGEST;
 1023|    132|            authp->avail |= CURLAUTH_DIGEST;
 1024|       |
 1025|       |            /* We call this function on input Digest headers even if Digest
 1026|       |             * authentication isn't activated yet, as we need to store the
 1027|       |             * incoming data from this header in case we are going to use
 1028|       |             * Digest */
 1029|    132|            result = Curl_input_digest(data, proxy, auth);
 1030|    132|            if(result) {
 1031|     52|              infof(data, "Authentication problem. Ignoring this.");
 1032|     52|              data->state.authproblem = TRUE;
 1033|     52|            }
 1034|    132|          }
 1035|    161|        }
 1036|    396|        else
 1037|    396|#endif
 1038|    396|          if(checkprefix("Basic", auth) &&
 1039|    396|             is_valid_auth_separator(auth[5])) {
 1040|      0|            *availp |= CURLAUTH_BASIC;
 1041|      0|            authp->avail |= CURLAUTH_BASIC;
 1042|      0|            if(authp->picked == CURLAUTH_BASIC) {
 1043|       |              /* We asked for Basic authentication but got a 40X back
 1044|       |                 anyway, which basically means our name+password isn't
 1045|       |                 valid. */
 1046|      0|              authp->avail = CURLAUTH_NONE;
 1047|      0|              infof(data, "Authentication problem. Ignoring this.");
 1048|      0|              data->state.authproblem = TRUE;
 1049|      0|            }
 1050|      0|          }
 1051|    396|          else
 1052|    396|            if(checkprefix("Bearer", auth) &&
 1053|    396|               is_valid_auth_separator(auth[6])) {
 1054|      0|              *availp |= CURLAUTH_BEARER;
 1055|      0|              authp->avail |= CURLAUTH_BEARER;
 1056|      0|              if(authp->picked == CURLAUTH_BEARER) {
 1057|       |                /* We asked for Bearer authentication but got a 40X back
 1058|       |                  anyway, which basically means our token isn't valid. */
 1059|      0|                authp->avail = CURLAUTH_NONE;
 1060|      0|                infof(data, "Authentication problem. Ignoring this.");
 1061|      0|                data->state.authproblem = TRUE;
 1062|      0|              }
 1063|      0|            }
 1064|       |
 1065|       |    /* there may be multiple methods on one line, so keep reading */
 1066|  13.7k|    while(*auth && *auth != ',') /* read up to the next comma */
 1067|  13.1k|      auth++;
 1068|    557|    if(*auth == ',') /* if we're on a comma, skip it */
 1069|    395|      auth++;
 1070|  1.40k|    while(*auth && ISSPACE(*auth))
 1071|    852|      auth++;
 1072|    557|  }
 1073|       |
 1074|    180|  return CURLE_OK;
 1075|    180|}
Curl_buffer_send:
 1229|  1.38k|{
 1230|  1.38k|  ssize_t amount;
 1231|  1.38k|  CURLcode result;
 1232|  1.38k|  char *ptr;
 1233|  1.38k|  size_t size;
 1234|  1.38k|  struct connectdata *conn = data->conn;
 1235|  1.38k|  struct HTTP *http = data->req.p.http;
 1236|  1.38k|  size_t sendsize;
 1237|  1.38k|  curl_socket_t sockfd;
 1238|  1.38k|  size_t headersize;
 1239|       |
 1240|  1.38k|  DEBUGASSERT(socketindex <= SECONDARYSOCKET);
 1241|       |
 1242|  1.38k|  sockfd = conn->sock[socketindex];
 1243|       |
 1244|       |  /* The looping below is required since we use non-blocking sockets, but due
 1245|       |     to the circumstances we will just loop and try again and again etc */
 1246|       |
 1247|  1.38k|  ptr = Curl_dyn_ptr(in);
 1248|  1.38k|  size = Curl_dyn_len(in);
 1249|       |
 1250|  1.38k|  headersize = size - (size_t)included_body_bytes; /* the initial part that
 1251|       |                                                      isn't body is header */
 1252|       |
 1253|  1.38k|  DEBUGASSERT(size > (size_t)included_body_bytes);
 1254|       |
 1255|  1.38k|  result = Curl_convert_to_network(data, ptr, headersize);
 1256|       |  /* Curl_convert_to_network calls failf if unsuccessful */
 1257|  1.38k|  if(result) {
 1258|       |    /* conversion failed, free memory and return to the caller */
 1259|      0|    Curl_dyn_free(in);
 1260|      0|    return result;
 1261|      0|  }
 1262|       |
 1263|  1.38k|  if((conn->handler->flags & PROTOPT_SSL
 1264|  1.38k|#ifndef CURL_DISABLE_PROXY
 1265|  1.38k|      || conn->http_proxy.proxytype == CURLPROXY_HTTPS
 1266|  1.38k|#endif
 1267|  1.38k|       )
 1268|  1.38k|     && conn->httpversion != 20) {
 1269|       |    /* Make sure this doesn't send more body bytes than what the max send
 1270|       |       speed says. The request bytes do not count to the max speed.
 1271|       |    */
 1272|      0|    if(data->set.max_send_speed &&
 1273|      0|       (included_body_bytes > data->set.max_send_speed)) {
 1274|      0|      curl_off_t overflow = included_body_bytes - data->set.max_send_speed;
 1275|      0|      DEBUGASSERT((size_t)overflow < size);
 1276|      0|      sendsize = size - (size_t)overflow;
 1277|      0|    }
 1278|      0|    else
 1279|      0|      sendsize = size;
 1280|       |
 1281|       |    /* OpenSSL is very picky and we must send the SAME buffer pointer to the
 1282|       |       library when we attempt to re-send this buffer. Sending the same data
 1283|       |       is not enough, we must use the exact same address. For this reason, we
 1284|       |       must copy the data to the uploadbuffer first, since that is the buffer
 1285|       |       we will be using if this send is retried later.
 1286|       |    */
 1287|      0|    result = Curl_get_upload_buffer(data);
 1288|      0|    if(result) {
 1289|       |      /* malloc failed, free memory and return to the caller */
 1290|      0|      Curl_dyn_free(in);
 1291|      0|      return result;
 1292|      0|    }
 1293|       |    /* We never send more than upload_buffer_size bytes in one single chunk
 1294|       |       when we speak HTTPS, as if only a fraction of it is sent now, this data
 1295|       |       needs to fit into the normal read-callback buffer later on and that
 1296|       |       buffer is using this size.
 1297|       |    */
 1298|      0|    if(sendsize > (size_t)data->set.upload_buffer_size)
 1299|      0|      sendsize = (size_t)data->set.upload_buffer_size;
 1300|       |
 1301|      0|    memcpy(data->state.ulbuf, ptr, sendsize);
 1302|      0|    ptr = data->state.ulbuf;
 1303|      0|  }
 1304|  1.38k|  else {
 1305|  1.38k|#ifdef CURLDEBUG
 1306|       |    /* Allow debug builds to override this logic to force short initial
 1307|       |       sends
 1308|       |     */
 1309|  1.38k|    char *p = getenv("CURL_SMALLREQSEND");
 1310|  1.38k|    if(p) {
 1311|      0|      size_t altsize = (size_t)strtoul(p, NULL, 10);
 1312|      0|      if(altsize)
 1313|      0|        sendsize = CURLMIN(size, altsize);
 1314|      0|      else
 1315|      0|        sendsize = size;
 1316|      0|    }
 1317|  1.38k|    else
 1318|  1.38k|#endif
 1319|  1.38k|    {
 1320|       |      /* Make sure this doesn't send more body bytes than what the max send
 1321|       |         speed says. The request bytes do not count to the max speed.
 1322|       |      */
 1323|  1.38k|      if(data->set.max_send_speed &&
 1324|  1.38k|         (included_body_bytes > data->set.max_send_speed)) {
 1325|      0|        curl_off_t overflow = included_body_bytes - data->set.max_send_speed;
 1326|      0|        DEBUGASSERT((size_t)overflow < size);
 1327|      0|        sendsize = size - (size_t)overflow;
 1328|      0|      }
 1329|  1.38k|      else
 1330|  1.38k|        sendsize = size;
 1331|  1.38k|    }
 1332|  1.38k|  }
 1333|       |
 1334|  1.38k|  result = Curl_write(data, sockfd, ptr, sendsize, &amount);
 1335|       |
 1336|  1.38k|  if(!result) {
 1337|       |    /*
 1338|       |     * Note that we may not send the entire chunk at once, and we have a set
 1339|       |     * number of data bytes at the end of the big buffer (out of which we may
 1340|       |     * only send away a part).
 1341|       |     */
 1342|       |    /* how much of the header that was sent */
 1343|  1.38k|    size_t headlen = (size_t)amount>headersize ? headersize : (size_t)amount;
 1344|  1.38k|    size_t bodylen = amount - headlen;
 1345|       |
 1346|       |    /* this data _may_ contain binary stuff */
 1347|  1.38k|    Curl_debug(data, CURLINFO_HEADER_OUT, ptr, headlen);
 1348|  1.38k|    if(bodylen)
 1349|       |      /* there was body data sent beyond the initial header part, pass that on
 1350|       |         to the debug callback too */
 1351|     13|      Curl_debug(data, CURLINFO_DATA_OUT, ptr + headlen, bodylen);
 1352|       |
 1353|       |    /* 'amount' can never be a very large value here so typecasting it so a
 1354|       |       signed 31 bit value should not cause problems even if ssize_t is
 1355|       |       64bit */
 1356|  1.38k|    *bytes_written += (long)amount;
 1357|       |
 1358|  1.38k|    if(http) {
 1359|       |      /* if we sent a piece of the body here, up the byte counter for it
 1360|       |         accordingly */
 1361|  1.38k|      data->req.writebytecount += bodylen;
 1362|  1.38k|      Curl_pgrsSetUploadCounter(data, data->req.writebytecount);
 1363|       |
 1364|  1.38k|      if((size_t)amount != size) {
 1365|       |        /* The whole request could not be sent in one system call. We must
 1366|       |           queue it up and send it later when we get the chance. We must not
 1367|       |           loop here and wait until it might work again. */
 1368|       |
 1369|      0|        size -= amount;
 1370|       |
 1371|      0|        ptr = Curl_dyn_ptr(in) + amount;
 1372|       |
 1373|       |        /* backup the currently set pointers */
 1374|      0|        http->backup.fread_func = data->state.fread_func;
 1375|      0|        http->backup.fread_in = data->state.in;
 1376|      0|        http->backup.postdata = http->postdata;
 1377|      0|        http->backup.postsize = http->postsize;
 1378|       |
 1379|       |        /* set the new pointers for the request-sending */
 1380|      0|        data->state.fread_func = (curl_read_callback)readmoredata;
 1381|      0|        data->state.in = (void *)data;
 1382|      0|        http->postdata = ptr;
 1383|      0|        http->postsize = (curl_off_t)size;
 1384|       |
 1385|       |        /* this much data is remaining header: */
 1386|      0|        data->req.pendingheader = headersize - headlen;
 1387|       |
 1388|      0|        http->send_buffer = *in; /* copy the whole struct */
 1389|      0|        http->sending = HTTPSEND_REQUEST;
 1390|       |
 1391|      0|        return CURLE_OK;
 1392|      0|      }
 1393|  1.38k|      http->sending = HTTPSEND_BODY;
 1394|       |      /* the full buffer was sent, clean up and return */
 1395|  1.38k|    }
 1396|      0|    else {
 1397|      0|      if((size_t)amount != size)
 1398|       |        /* We have no continue-send mechanism now, fail. This can only happen
 1399|       |           when this function is used from the CONNECT sending function. We
 1400|       |           currently (stupidly) assume that the whole request is always sent
 1401|       |           away in the first single chunk.
 1402|       |
 1403|       |           This needs FIXing.
 1404|       |        */
 1405|      0|        return CURLE_SEND_ERROR;
 1406|      0|    }
 1407|  1.38k|  }
 1408|  1.38k|  Curl_dyn_free(in);
 1409|       |
 1410|       |  /* no remaining header data */
 1411|  1.38k|  data->req.pendingheader = 0;
 1412|  1.38k|  return result;
 1413|  1.38k|}
Curl_compareheader:
 1432|  18.8k|{
 1433|       |  /* RFC2616, section 4.2 says: "Each header field consists of a name followed
 1434|       |   * by a colon (":") and the field value. Field names are case-insensitive.
 1435|       |   * The field value MAY be preceded by any amount of LWS, though a single SP
 1436|       |   * is preferred." */
 1437|       |
 1438|  18.8k|  size_t hlen = strlen(header);
 1439|  18.8k|  size_t clen;
 1440|  18.8k|  size_t len;
 1441|  18.8k|  const char *start;
 1442|  18.8k|  const char *end;
 1443|       |
 1444|  18.8k|  if(!strncasecompare(headerline, header, hlen))
 1445|  18.3k|    return FALSE; /* doesn't start with header */
 1446|       |
 1447|       |  /* pass the header */
 1448|    520|  start = &headerline[hlen];
 1449|       |
 1450|       |  /* pass all whitespace */
 1451|  1.09k|  while(*start && ISSPACE(*start))
 1452|    577|    start++;
 1453|       |
 1454|       |  /* find the end of the header line */
 1455|    520|  end = strchr(start, '\r'); /* lines end with CRLF */
 1456|    520|  if(!end) {
 1457|       |    /* in case there's a non-standard compliant line here */
 1458|    355|    end = strchr(start, '\n');
 1459|       |
 1460|    355|    if(!end)
 1461|       |      /* hm, there's no line ending here, use the zero byte! */
 1462|     49|      end = strchr(start, '\0');
 1463|    355|  }
 1464|       |
 1465|    520|  len = end-start; /* length of the content part of the input line */
 1466|    520|  clen = strlen(content); /* length of the word to find */
 1467|       |
 1468|       |  /* find the content string in the rest of the line */
 1469|  2.87k|  for(; len >= clen; len--, start++) {
 1470|  2.51k|    if(strncasecompare(start, content, clen))
 1471|    159|      return TRUE; /* match! */
 1472|  2.51k|  }
 1473|       |
 1474|    361|  return FALSE; /* no match */
 1475|    520|}
Curl_http_connect:
 1482|  1.38k|{
 1483|  1.38k|  CURLcode result;
 1484|  1.38k|  struct connectdata *conn = data->conn;
 1485|       |
 1486|       |  /* We default to persistent connections. We set this already in this connect
 1487|       |     function to make the re-use checks properly be able to check this bit. */
 1488|  1.38k|  connkeep(conn, "HTTP default");
 1489|       |
 1490|  1.38k|#ifndef CURL_DISABLE_PROXY
 1491|       |  /* the CONNECT procedure might not have been completed */
 1492|  1.38k|  result = Curl_proxy_connect(data, FIRSTSOCKET);
 1493|  1.38k|  if(result)
 1494|      0|    return result;
 1495|       |
 1496|  1.38k|  if(conn->bits.proxy_connect_closed)
 1497|       |    /* this is not an error, just part of the connection negotiation */
 1498|      0|    return CURLE_OK;
 1499|       |
 1500|  1.38k|  if(CONNECT_FIRSTSOCKET_PROXY_SSL())
 1501|      0|    return CURLE_OK; /* wait for HTTPS proxy SSL initialization to complete */
 1502|       |
 1503|  1.38k|  if(Curl_connect_ongoing(conn))
 1504|       |    /* nothing else to do except wait right now - we're not done here. */
 1505|      0|    return CURLE_OK;
 1506|       |
 1507|  1.38k|  if(data->set.haproxyprotocol) {
 1508|       |    /* add HAProxy PROXY protocol header */
 1509|      0|    result = add_haproxy_protocol_header(data);
 1510|      0|    if(result)
 1511|      0|      return result;
 1512|      0|  }
 1513|  1.38k|#endif
 1514|       |
 1515|  1.38k|  if(conn->given->protocol & CURLPROTO_HTTPS) {
 1516|       |    /* perform SSL initialization */
 1517|      0|    result = https_connecting(data, done);
 1518|      0|    if(result)
 1519|      0|      return result;
 1520|      0|  }
 1521|  1.38k|  else
 1522|  1.38k|    *done = TRUE;
 1523|       |
 1524|  1.38k|  return CURLE_OK;
 1525|  1.38k|}
Curl_http_done:
 1616|  1.38k|{
 1617|  1.38k|  struct connectdata *conn = data->conn;
 1618|  1.38k|  struct HTTP *http = data->req.p.http;
 1619|       |
 1620|       |  /* Clear multipass flag. If authentication isn't done yet, then it will get
 1621|       |   * a chance to be set back to true when we output the next auth header */
 1622|  1.38k|  data->state.authhost.multipass = FALSE;
 1623|  1.38k|  data->state.authproxy.multipass = FALSE;
 1624|       |
 1625|  1.38k|  Curl_unencode_cleanup(data);
 1626|       |
 1627|       |  /* set the proper values (possibly modified on POST) */
 1628|  1.38k|  conn->seek_func = data->set.seek_func; /* restore */
 1629|  1.38k|  conn->seek_client = data->set.seek_client; /* restore */
 1630|       |
 1631|  1.38k|  if(!http)
 1632|      0|    return CURLE_OK;
 1633|       |
 1634|  1.38k|  Curl_dyn_free(&http->send_buffer);
 1635|  1.38k|  Curl_http2_done(data, premature);
 1636|  1.38k|  Curl_quic_done(data, premature);
 1637|  1.38k|  Curl_mime_cleanpart(&http->form);
 1638|  1.38k|  Curl_dyn_reset(&data->state.headerb);
 1639|  1.38k|  Curl_hyper_done(data);
 1640|       |
 1641|  1.38k|  if(status)
 1642|    394|    return status;
 1643|       |
 1644|    994|  if(!premature && /* this check is pointless when DONE is called before the
 1645|       |                      entire operation is complete */
 1646|    994|     !conn->bits.retry &&
 1647|    994|     !data->set.connect_only &&
 1648|    994|     (data->req.bytecount +
 1649|    993|      data->req.headerbytecount -
 1650|    993|      data->req.deductheadercount) <= 0) {
 1651|       |    /* If this connection isn't simply closed to be retried, AND nothing was
 1652|       |       read from the HTTP server (that counts), this can't be right so we
 1653|       |       return an error here */
 1654|    353|    failf(data, "Empty reply from server");
 1655|       |    /* Mark it as closed to avoid the "left intact" message */
 1656|    353|    streamclose(conn, "Empty reply from server");
 1657|    353|    return CURLE_GOT_NOTHING;
 1658|    353|  }
 1659|       |
 1660|    641|  return CURLE_OK;
 1661|    994|}
Curl_use_http_1_1plus:
 1674|  1.24k|{
 1675|  1.24k|  if((data->state.httpversion == 10) || (conn->httpversion == 10))
 1676|      6|    return FALSE;
 1677|  1.23k|  if((data->state.httpwant == CURL_HTTP_VERSION_1_0) &&
 1678|  1.23k|     (conn->httpversion <= 10))
 1679|      0|    return FALSE;
 1680|  1.23k|  return ((data->state.httpwant == CURL_HTTP_VERSION_NONE) ||
 1681|  1.23k|          (data->state.httpwant >= CURL_HTTP_VERSION_1_1));
 1682|  1.23k|}
Curl_add_custom_headers:
 1793|  1.38k|{
 1794|  1.38k|  struct connectdata *conn = data->conn;
 1795|  1.38k|  char *ptr;
 1796|  1.38k|  struct curl_slist *h[2];
 1797|  1.38k|  struct curl_slist *headers;
 1798|  1.38k|  int numlists = 1; /* by default */
 1799|  1.38k|  int i;
 1800|       |
 1801|  1.38k|#ifndef CURL_DISABLE_PROXY
 1802|  1.38k|  enum proxy_use proxy;
 1803|       |
 1804|  1.38k|  if(is_connect)
 1805|      0|    proxy = HEADER_CONNECT;
 1806|  1.38k|  else
 1807|  1.38k|    proxy = conn->bits.httpproxy && !conn->bits.tunnel_proxy?
 1808|  1.38k|      HEADER_PROXY:HEADER_SERVER;
 1809|       |
 1810|  1.38k|  switch(proxy) {
 1811|  1.38k|  case HEADER_SERVER:
 1812|  1.38k|    h[0] = data->set.headers;
 1813|  1.38k|    break;
 1814|      0|  case HEADER_PROXY:
 1815|      0|    h[0] = data->set.headers;
 1816|      0|    if(data->set.sep_headers) {
 1817|      0|      h[1] = data->set.proxyheaders;
 1818|      0|      numlists++;
 1819|      0|    }
 1820|      0|    break;
 1821|      0|  case HEADER_CONNECT:
 1822|      0|    if(data->set.sep_headers)
 1823|      0|      h[0] = data->set.proxyheaders;
 1824|      0|    else
 1825|      0|      h[0] = data->set.headers;
 1826|      0|    break;
 1827|  1.38k|  }
 1828|       |#else
 1829|       |  (void)is_connect;
 1830|       |  h[0] = data->set.headers;
 1831|       |#endif
 1832|       |
 1833|       |  /* loop through one or two lists */
 1834|  2.76k|  for(i = 0; i < numlists; i++) {
 1835|  1.38k|    headers = h[i];
 1836|       |
 1837|  4.93k|    while(headers) {
 1838|  3.55k|      char *semicolonp = NULL;
 1839|  3.55k|      ptr = strchr(headers->data, ':');
 1840|  3.55k|      if(!ptr) {
 1841|  1.41k|        char *optr;
 1842|       |        /* no colon, semicolon? */
 1843|  1.41k|        ptr = strchr(headers->data, ';');
 1844|  1.41k|        if(ptr) {
 1845|    790|          optr = ptr;
 1846|    790|          ptr++; /* pass the semicolon */
 1847|  1.48k|          while(*ptr && ISSPACE(*ptr))
 1848|    694|            ptr++;
 1849|       |
 1850|    790|          if(*ptr) {
 1851|       |            /* this may be used for something else in the future */
 1852|    328|            optr = NULL;
 1853|    328|          }
 1854|    462|          else {
 1855|    462|            if(*(--ptr) == ';') {
 1856|       |              /* copy the source */
 1857|    127|              semicolonp = strdup(headers->data);
 1858|    127|              if(!semicolonp) {
 1859|      0|#ifndef USE_HYPER
 1860|      0|                Curl_dyn_free(req);
 1861|      0|#endif
 1862|      0|                return CURLE_OUT_OF_MEMORY;
 1863|      0|              }
 1864|       |              /* put a colon where the semicolon is */
 1865|    127|              semicolonp[ptr - headers->data] = ':';
 1866|       |              /* point at the colon */
 1867|    127|              optr = &semicolonp [ptr - headers->data];
 1868|    127|            }
 1869|    462|          }
 1870|    790|          ptr = optr;
 1871|    790|        }
 1872|  1.41k|      }
 1873|  3.55k|      if(ptr) {
 1874|       |        /* we require a colon for this to be a true header */
 1875|       |
 1876|  2.60k|        ptr++; /* pass the colon */
 1877|  5.34k|        while(*ptr && ISSPACE(*ptr))
 1878|  2.73k|          ptr++;
 1879|       |
 1880|  2.60k|        if(*ptr || semicolonp) {
 1881|       |          /* only send this if the contents was non-blank or done special */
 1882|  1.59k|          CURLcode result = CURLE_OK;
 1883|  1.59k|          char *compare = semicolonp ? semicolonp : headers->data;
 1884|       |
 1885|  1.59k|          if(data->state.aptr.host &&
 1886|       |             /* a Host: header was sent already, don't pass on any custom Host:
 1887|       |                header as that will produce *two* in the same request! */
 1888|  1.59k|             checkprefix("Host:", compare))
 1889|     72|            ;
 1890|  1.52k|          else if(data->state.httpreq == HTTPREQ_POST_FORM &&
 1891|       |                  /* this header (extended by formdata.c) is sent later */
 1892|  1.52k|                  checkprefix("Content-Type:", compare))
 1893|      0|            ;
 1894|  1.52k|          else if(data->state.httpreq == HTTPREQ_POST_MIME &&
 1895|       |                  /* this header is sent later */
 1896|  1.52k|                  checkprefix("Content-Type:", compare))
 1897|    225|            ;
 1898|  1.29k|          else if(conn->bits.authneg &&
 1899|       |                  /* while doing auth neg, don't allow the custom length since
 1900|       |                     we will force length zero then */
 1901|  1.29k|                  checkprefix("Content-Length:", compare))
 1902|     10|            ;
 1903|  1.28k|          else if(data->state.aptr.te &&
 1904|       |                  /* when asking for Transfer-Encoding, don't pass on a custom
 1905|       |                     Connection: */
 1906|  1.28k|                  checkprefix("Connection:", compare))
 1907|      0|            ;
 1908|  1.28k|          else if((conn->httpversion >= 20) &&
 1909|  1.28k|                  checkprefix("Transfer-Encoding:", compare))
 1910|       |            /* HTTP/2 doesn't support chunked requests */
 1911|      0|            ;
 1912|  1.28k|          else if((checkprefix("Authorization:", compare) ||
 1913|  1.28k|                   checkprefix("Cookie:", compare)) &&
 1914|       |                  /* be careful of sending this potentially sensitive header to
 1915|       |                     other hosts */
 1916|  1.28k|                  (data->state.this_is_a_follow &&
 1917|      0|                   data->state.first_host &&
 1918|      0|                   !data->set.allow_auth_to_other_hosts &&
 1919|      0|                   !strcasecompare(data->state.first_host, conn->host.name)))
 1920|      0|            ;
 1921|  1.28k|          else {
 1922|       |#ifdef USE_HYPER
 1923|       |            result = Curl_hyper_header(data, req, compare);
 1924|       |#else
 1925|  1.28k|            result = Curl_dyn_addf(req, "%s\r\n", compare);
 1926|  1.28k|#endif
 1927|  1.28k|          }
 1928|  1.59k|          if(semicolonp)
 1929|    127|            free(semicolonp);
 1930|  1.59k|          if(result)
 1931|      0|            return result;
 1932|  1.59k|        }
 1933|  2.60k|      }
 1934|  3.55k|      headers = headers->next;
 1935|  3.55k|    }
 1936|  1.38k|  }
 1937|       |
 1938|  1.38k|  return CURLE_OK;
 1939|  1.38k|}
Curl_add_timecondition:
 1949|  1.22k|{
 1950|  1.22k|  const struct tm *tm;
 1951|  1.22k|  struct tm keeptime;
 1952|  1.22k|  CURLcode result;
 1953|  1.22k|  char datestr[80];
 1954|  1.22k|  const char *condp;
 1955|       |
 1956|  1.22k|  if(data->set.timecondition == CURL_TIMECOND_NONE)
 1957|       |    /* no condition was asked for */
 1958|  1.22k|    return CURLE_OK;
 1959|       |
 1960|      0|  result = Curl_gmtime(data->set.timevalue, &keeptime);
 1961|      0|  if(result) {
 1962|      0|    failf(data, "Invalid TIMEVALUE");
 1963|      0|    return result;
 1964|      0|  }
 1965|      0|  tm = &keeptime;
 1966|       |
 1967|      0|  switch(data->set.timecondition) {
 1968|      0|  default:
 1969|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1970|       |
 1971|      0|  case CURL_TIMECOND_IFMODSINCE:
 1972|      0|    condp = "If-Modified-Since";
 1973|      0|    break;
 1974|      0|  case CURL_TIMECOND_IFUNMODSINCE:
 1975|      0|    condp = "If-Unmodified-Since";
 1976|      0|    break;
 1977|      0|  case CURL_TIMECOND_LASTMOD:
 1978|      0|    condp = "Last-Modified";
 1979|      0|    break;
 1980|      0|  }
 1981|       |
 1982|      0|  if(Curl_checkheaders(data, condp)) {
 1983|       |    /* A custom header was specified; it will be sent instead. */
 1984|      0|    return CURLE_OK;
 1985|      0|  }
 1986|       |
 1987|       |  /* The If-Modified-Since header family should have their times set in
 1988|       |   * GMT as RFC2616 defines: "All HTTP date/time stamps MUST be
 1989|       |   * represented in Greenwich Mean Time (GMT), without exception. For the
 1990|       |   * purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal
 1991|       |   * Time)." (see page 20 of RFC2616).
 1992|       |   */
 1993|       |
 1994|       |  /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
 1995|      0|  msnprintf(datestr, sizeof(datestr),
 1996|      0|            "%s: %s, %02d %s %4d %02d:%02d:%02d GMT\r\n",
 1997|      0|            condp,
 1998|      0|            Curl_wkday[tm->tm_wday?tm->tm_wday-1:6],
 1999|      0|            tm->tm_mday,
 2000|      0|            Curl_month[tm->tm_mon],
 2001|      0|            tm->tm_year + 1900,
 2002|      0|            tm->tm_hour,
 2003|      0|            tm->tm_min,
 2004|      0|            tm->tm_sec);
 2005|       |
 2006|      0|#ifndef USE_HYPER
 2007|      0|  result = Curl_dyn_add(req, datestr);
 2008|       |#else
 2009|       |  result = Curl_hyper_header(data, req, datestr);
 2010|       |#endif
 2011|       |
 2012|      0|  return result;
 2013|      0|}
Curl_http_method:
 2027|  1.23k|{
 2028|  1.23k|  Curl_HttpReq httpreq = data->state.httpreq;
 2029|  1.23k|  const char *request;
 2030|  1.23k|  if((conn->handler->protocol&(PROTO_FAMILY_HTTP|CURLPROTO_FTP)) &&
 2031|  1.23k|     data->set.upload)
 2032|     20|    httpreq = HTTPREQ_PUT;
 2033|       |
 2034|       |  /* Now set the 'request' pointer to the proper request string */
 2035|  1.23k|  if(data->set.str[STRING_CUSTOMREQUEST])
 2036|      6|    request = data->set.str[STRING_CUSTOMREQUEST];
 2037|  1.22k|  else {
 2038|  1.22k|    if(data->set.opt_no_body)
 2039|     13|      request = "HEAD";
 2040|  1.21k|    else {
 2041|  1.21k|      DEBUGASSERT((httpreq >= HTTPREQ_GET) && (httpreq <= HTTPREQ_HEAD));
 2042|  1.21k|      switch(httpreq) {
 2043|     14|      case HTTPREQ_POST:
 2044|     14|      case HTTPREQ_POST_FORM:
 2045|    177|      case HTTPREQ_POST_MIME:
 2046|    177|        request = "POST";
 2047|    177|        break;
 2048|     20|      case HTTPREQ_PUT:
 2049|     20|        request = "PUT";
 2050|     20|        break;
 2051|      0|      default: /* this should never happen */
 2052|  1.01k|      case HTTPREQ_GET:
 2053|  1.01k|        request = "GET";
 2054|  1.01k|        break;
 2055|      0|      case HTTPREQ_HEAD:
 2056|      0|        request = "HEAD";
 2057|      0|        break;
 2058|  1.21k|      }
 2059|  1.21k|    }
 2060|  1.22k|  }
 2061|  1.23k|  *method = request;
 2062|  1.23k|  *reqp = httpreq;
 2063|  1.23k|}
Curl_http_useragent:
 2066|  1.22k|{
 2067|       |  /* The User-Agent string might have been allocated in url.c already, because
 2068|       |     it might have been used in the proxy connect, but if we have got a header
 2069|       |     with the user-agent string specified, we erase the previously made string
 2070|       |     here. */
 2071|  1.22k|  if(Curl_checkheaders(data, "User-Agent")) {
 2072|      0|    free(data->state.aptr.uagent);
 2073|      0|    data->state.aptr.uagent = NULL;
 2074|      0|  }
 2075|  1.22k|  return CURLE_OK;
 2076|  1.22k|}
Curl_http_host:
 2080|  1.22k|{
 2081|  1.22k|  const char *ptr;
 2082|  1.22k|  if(!data->state.this_is_a_follow) {
 2083|       |    /* Free to avoid leaking memory on multiple requests*/
 2084|  1.12k|    free(data->state.first_host);
 2085|       |
 2086|  1.12k|    data->state.first_host = strdup(conn->host.name);
 2087|  1.12k|    if(!data->state.first_host)
 2088|      0|      return CURLE_OUT_OF_MEMORY;
 2089|       |
 2090|  1.12k|    data->state.first_remote_port = conn->remote_port;
 2091|  1.12k|  }
 2092|  1.22k|  Curl_safefree(data->state.aptr.host);
 2093|       |
 2094|  1.22k|  ptr = Curl_checkheaders(data, "Host");
 2095|  1.22k|  if(ptr && (!data->state.this_is_a_follow ||
 2096|     18|             strcasecompare(data->state.first_host, conn->host.name))) {
 2097|     18|#if !defined(CURL_DISABLE_COOKIES)
 2098|       |    /* If we have a given custom Host: header, we extract the host name in
 2099|       |       order to possibly use it for cookie reasons later on. We only allow the
 2100|       |       custom Host: header if this is NOT a redirect, as setting Host: in the
 2101|       |       redirected request is being out on thin ice. Except if the host name
 2102|       |       is the same as the first one! */
 2103|     18|    char *cookiehost = Curl_copy_header_value(ptr);
 2104|     18|    if(!cookiehost)
 2105|      0|      return CURLE_OUT_OF_MEMORY;
 2106|     18|    if(!*cookiehost)
 2107|       |      /* ignore empty data */
 2108|      7|      free(cookiehost);
 2109|     11|    else {
 2110|       |      /* If the host begins with '[', we start searching for the port after
 2111|       |         the bracket has been closed */
 2112|     11|      if(*cookiehost == '[') {
 2113|      4|        char *closingbracket;
 2114|       |        /* since the 'cookiehost' is an allocated memory area that will be
 2115|       |           freed later we cannot simply increment the pointer */
 2116|      4|        memmove(cookiehost, cookiehost + 1, strlen(cookiehost) - 1);
 2117|      4|        closingbracket = strchr(cookiehost, ']');
 2118|      4|        if(closingbracket)
 2119|      1|          *closingbracket = 0;
 2120|      4|      }
 2121|      7|      else {
 2122|      7|        int startsearch = 0;
 2123|      7|        char *colon = strchr(cookiehost + startsearch, ':');
 2124|      7|        if(colon)
 2125|      1|          *colon = 0; /* The host must not include an embedded port number */
 2126|      7|      }
 2127|     11|      Curl_safefree(data->state.aptr.cookiehost);
 2128|     11|      data->state.aptr.cookiehost = cookiehost;
 2129|     11|    }
 2130|     18|#endif
 2131|       |
 2132|     18|    if(strcmp("Host:", ptr)) {
 2133|     12|      data->state.aptr.host = aprintf("Host:%s\r\n", &ptr[5]);
 2134|     12|      if(!data->state.aptr.host)
 2135|      0|        return CURLE_OUT_OF_MEMORY;
 2136|     12|    }
 2137|      6|    else
 2138|       |      /* when clearing the header */
 2139|      6|      data->state.aptr.host = NULL;
 2140|     18|  }
 2141|  1.20k|  else {
 2142|       |    /* When building Host: headers, we must put the host name within
 2143|       |       [brackets] if the host name is a plain IPv6-address. RFC2732-style. */
 2144|  1.20k|    const char *host = conn->host.name;
 2145|       |
 2146|  1.20k|    if(((conn->given->protocol&CURLPROTO_HTTPS) &&
 2147|  1.20k|        (conn->remote_port == PORT_HTTPS)) ||
 2148|  1.20k|       ((conn->given->protocol&CURLPROTO_HTTP) &&
 2149|  1.20k|        (conn->remote_port == PORT_HTTP)) )
 2150|       |      /* if(HTTPS on port 443) OR (HTTP on port 80) then don't include
 2151|       |         the port number in the host string */
 2152|    568|      data->state.aptr.host = aprintf("Host: %s%s%s\r\n",
 2153|    568|                                    conn->bits.ipv6_ip?"[":"",
 2154|    568|                                    host,
 2155|    568|                                    conn->bits.ipv6_ip?"]":"");
 2156|    640|    else
 2157|    640|      data->state.aptr.host = aprintf("Host: %s%s%s:%d\r\n",
 2158|    640|                                    conn->bits.ipv6_ip?"[":"",
 2159|    640|                                    host,
 2160|    640|                                    conn->bits.ipv6_ip?"]":"",
 2161|    640|                                    conn->remote_port);
 2162|       |
 2163|  1.20k|    if(!data->state.aptr.host)
 2164|       |      /* without Host: we can't make a nice request */
 2165|      0|      return CURLE_OUT_OF_MEMORY;
 2166|  1.20k|  }
 2167|  1.22k|  return CURLE_OK;
 2168|  1.22k|}
Curl_http_target:
 2176|  1.22k|{
 2177|  1.22k|  CURLcode result = CURLE_OK;
 2178|  1.22k|  const char *path = data->state.up.path;
 2179|  1.22k|  const char *query = data->state.up.query;
 2180|       |
 2181|  1.22k|  if(data->set.str[STRING_TARGET]) {
 2182|      0|    path = data->set.str[STRING_TARGET];
 2183|      0|    query = NULL;
 2184|      0|  }
 2185|       |
 2186|  1.22k|#ifndef CURL_DISABLE_PROXY
 2187|  1.22k|  if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {
 2188|       |    /* Using a proxy but does not tunnel through it */
 2189|       |
 2190|       |    /* The path sent to the proxy is in fact the entire URL. But if the remote
 2191|       |       host is a IDN-name, we must make sure that the request we produce only
 2192|       |       uses the encoded host name! */
 2193|       |
 2194|       |    /* and no fragment part */
 2195|      0|    CURLUcode uc;
 2196|      0|    char *url;
 2197|      0|    CURLU *h = curl_url_dup(data->state.uh);
 2198|      0|    if(!h)
 2199|      0|      return CURLE_OUT_OF_MEMORY;
 2200|       |
 2201|      0|    if(conn->host.dispname != conn->host.name) {
 2202|      0|      uc = curl_url_set(h, CURLUPART_HOST, conn->host.name, 0);
 2203|      0|      if(uc) {
 2204|      0|        curl_url_cleanup(h);
 2205|      0|        return CURLE_OUT_OF_MEMORY;
 2206|      0|      }
 2207|      0|    }
 2208|      0|    uc = curl_url_set(h, CURLUPART_FRAGMENT, NULL, 0);
 2209|      0|    if(uc) {
 2210|      0|      curl_url_cleanup(h);
 2211|      0|      return CURLE_OUT_OF_MEMORY;
 2212|      0|    }
 2213|       |
 2214|      0|    if(strcasecompare("http", data->state.up.scheme)) {
 2215|       |      /* when getting HTTP, we don't want the userinfo the URL */
 2216|      0|      uc = curl_url_set(h, CURLUPART_USER, NULL, 0);
 2217|      0|      if(uc) {
 2218|      0|        curl_url_cleanup(h);
 2219|      0|        return CURLE_OUT_OF_MEMORY;
 2220|      0|      }
 2221|      0|      uc = curl_url_set(h, CURLUPART_PASSWORD, NULL, 0);
 2222|      0|      if(uc) {
 2223|      0|        curl_url_cleanup(h);
 2224|      0|        return CURLE_OUT_OF_MEMORY;
 2225|      0|      }
 2226|      0|    }
 2227|       |    /* Extract the URL to use in the request. Store in STRING_TEMP_URL for
 2228|       |       clean-up reasons if the function returns before the free() further
 2229|       |       down. */
 2230|      0|    uc = curl_url_get(h, CURLUPART_URL, &url, CURLU_NO_DEFAULT_PORT);
 2231|      0|    if(uc) {
 2232|      0|      curl_url_cleanup(h);
 2233|      0|      return CURLE_OUT_OF_MEMORY;
 2234|      0|    }
 2235|       |
 2236|      0|    curl_url_cleanup(h);
 2237|       |
 2238|       |    /* target or url */
 2239|      0|    result = Curl_dyn_add(r, data->set.str[STRING_TARGET]?
 2240|      0|      data->set.str[STRING_TARGET]:url);
 2241|      0|    free(url);
 2242|      0|    if(result)
 2243|      0|      return (result);
 2244|       |
 2245|      0|    if(strcasecompare("ftp", data->state.up.scheme)) {
 2246|      0|      if(data->set.proxy_transfer_mode) {
 2247|       |        /* when doing ftp, append ;type=<a|i> if not present */
 2248|      0|        char *type = strstr(path, ";type=");
 2249|      0|        if(type && type[6] && type[7] == 0) {
 2250|      0|          switch(Curl_raw_toupper(type[6])) {
 2251|      0|          case 'A':
 2252|      0|          case 'D':
 2253|      0|          case 'I':
 2254|      0|            break;
 2255|      0|          default:
 2256|      0|            type = NULL;
 2257|      0|          }
 2258|      0|        }
 2259|      0|        if(!type) {
 2260|      0|          result = Curl_dyn_addf(r, ";type=%c",
 2261|      0|                                 data->state.prefer_ascii ? 'a' : 'i');
 2262|      0|          if(result)
 2263|      0|            return result;
 2264|      0|        }
 2265|      0|      }
 2266|      0|    }
 2267|      0|  }
 2268|       |
 2269|  1.22k|  else
 2270|       |#else
 2271|       |    (void)conn; /* not used in disabled-proxy builds */
 2272|       |#endif
 2273|  1.22k|  {
 2274|  1.22k|    result = Curl_dyn_add(r, path);
 2275|  1.22k|    if(result)
 2276|      0|      return result;
 2277|  1.22k|    if(query)
 2278|     62|      result = Curl_dyn_addf(r, "?%s", query);
 2279|  1.22k|  }
 2280|       |
 2281|  1.22k|  return result;
 2282|  1.22k|}
Curl_http_body:
 2286|  1.22k|{
 2287|  1.22k|  CURLcode result = CURLE_OK;
 2288|  1.22k|  const char *ptr;
 2289|  1.22k|  struct HTTP *http = data->req.p.http;
 2290|  1.22k|  http->postsize = 0;
 2291|       |
 2292|  1.22k|  switch(httpreq) {
 2293|    153|  case HTTPREQ_POST_MIME:
 2294|    153|    http->sendit = &data->set.mimepost;
 2295|    153|    break;
 2296|      0|  case HTTPREQ_POST_FORM:
 2297|       |    /* Convert the form structure into a mime structure. */
 2298|      0|    Curl_mime_cleanpart(&http->form);
 2299|      0|    result = Curl_getformdata(data, &http->form, data->set.httppost,
 2300|      0|                              data->state.fread_func);
 2301|      0|    if(result)
 2302|      0|      return result;
 2303|      0|    http->sendit = &http->form;
 2304|      0|    break;
 2305|  1.07k|  default:
 2306|  1.07k|    http->sendit = NULL;
 2307|  1.22k|  }
 2308|       |
 2309|  1.22k|#ifndef CURL_DISABLE_MIME
 2310|  1.22k|  if(http->sendit) {
 2311|    153|    const char *cthdr = Curl_checkheaders(data, "Content-Type");
 2312|       |
 2313|       |    /* Read and seek body only. */
 2314|    153|    http->sendit->flags |= MIME_BODY_ONLY;
 2315|       |
 2316|       |    /* Prepare the mime structure headers & set content type. */
 2317|       |
 2318|    153|    if(cthdr)
 2319|     36|      for(cthdr += 13; *cthdr == ' '; cthdr++)
 2320|     18|        ;
 2321|    135|    else if(http->sendit->kind == MIMEKIND_MULTIPART)
 2322|    135|      cthdr = "multipart/form-data";
 2323|       |
 2324|    153|    curl_mime_headers(http->sendit, data->set.headers, 0);
 2325|    153|    result = Curl_mime_prepare_headers(http->sendit, cthdr,
 2326|    153|                                       NULL, MIMESTRATEGY_FORM);
 2327|    153|    curl_mime_headers(http->sendit, NULL, 0);
 2328|    153|    if(!result)
 2329|    153|      result = Curl_mime_rewind(http->sendit);
 2330|    153|    if(result)
 2331|      4|      return result;
 2332|    149|    http->postsize = Curl_mime_size(http->sendit);
 2333|    149|  }
 2334|  1.22k|#endif
 2335|       |
 2336|  1.22k|  ptr = Curl_checkheaders(data, "Transfer-Encoding");
 2337|  1.22k|  if(ptr) {
 2338|       |    /* Some kind of TE is requested, check if 'chunked' is chosen */
 2339|      8|    data->req.upload_chunky =
 2340|      8|      Curl_compareheader(ptr, "Transfer-Encoding:", "chunked");
 2341|      8|  }
 2342|  1.21k|  else {
 2343|  1.21k|    if((conn->handler->protocol & PROTO_FAMILY_HTTP) &&
 2344|  1.21k|       (((httpreq == HTTPREQ_POST_MIME || httpreq == HTTPREQ_POST_FORM) &&
 2345|  1.21k|         http->postsize < 0) ||
 2346|  1.21k|        ((data->set.upload || httpreq == HTTPREQ_POST) &&
 2347|  1.21k|         data->state.infilesize == -1))) {
 2348|      6|      if(conn->bits.authneg)
 2349|       |        /* don't enable chunked during auth neg */
 2350|      1|        ;
 2351|      5|      else if(Curl_use_http_1_1plus(data, conn)) {
 2352|      5|        if(conn->httpversion < 20)
 2353|       |          /* HTTP, upload, unknown file size and not HTTP 1.0 */
 2354|      5|          data->req.upload_chunky = TRUE;
 2355|      5|      }
 2356|      0|      else {
 2357|      0|        failf(data, "Chunky upload is not supported by HTTP 1.0");
 2358|      0|        return CURLE_UPLOAD_FAILED;
 2359|      0|      }
 2360|      6|    }
 2361|  1.20k|    else {
 2362|       |      /* else, no chunky upload */
 2363|  1.20k|      data->req.upload_chunky = FALSE;
 2364|  1.20k|    }
 2365|       |
 2366|  1.21k|    if(data->req.upload_chunky)
 2367|      5|      *tep = "Transfer-Encoding: chunked\r\n";
 2368|  1.21k|  }
 2369|  1.22k|  return result;
 2370|  1.22k|}
Curl_http_bodysend:
 2374|  1.22k|{
 2375|  1.22k|#ifndef USE_HYPER
 2376|       |  /* Hyper always handles the body separately */
 2377|  1.22k|  curl_off_t included_body = 0;
 2378|  1.22k|#endif
 2379|  1.22k|  CURLcode result = CURLE_OK;
 2380|  1.22k|  struct HTTP *http = data->req.p.http;
 2381|  1.22k|  const char *ptr;
 2382|       |
 2383|       |  /* If 'authdone' is FALSE, we must not set the write socket index to the
 2384|       |     Curl_transfer() call below, as we're not ready to actually upload any
 2385|       |     data yet. */
 2386|       |
 2387|  1.22k|  switch(httpreq) {
 2388|       |
 2389|     20|  case HTTPREQ_PUT: /* Let's PUT the data to the server! */
 2390|       |
 2391|     20|    if(conn->bits.authneg)
 2392|      2|      http->postsize = 0;
 2393|     18|    else
 2394|     18|      http->postsize = data->state.infilesize;
 2395|       |
 2396|     20|    if((http->postsize != -1) && !data->req.upload_chunky &&
 2397|     20|       (conn->bits.authneg || !Curl_checkheaders(data, "Content-Length"))) {
 2398|       |      /* only add Content-Length if not uploading chunked */
 2399|     11|      result = Curl_dyn_addf(r, "Content-Length: %" CURL_FORMAT_CURL_OFF_T
 2400|     11|                             "\r\n", http->postsize);
 2401|     11|      if(result)
 2402|      0|        return result;
 2403|     11|    }
 2404|       |
 2405|     20|    if(http->postsize) {
 2406|     15|      result = expect100(data, conn, r);
 2407|     15|      if(result)
 2408|      0|        return result;
 2409|     15|    }
 2410|       |
 2411|       |    /* end of headers */
 2412|     20|    result = Curl_dyn_add(r, "\r\n");
 2413|     20|    if(result)
 2414|      0|      return result;
 2415|       |
 2416|       |    /* set the upload size to the progress meter */
 2417|     20|    Curl_pgrsSetUploadSize(data, http->postsize);
 2418|       |
 2419|       |    /* this sends the buffer and frees all the buffer resources */
 2420|     20|    result = Curl_buffer_send(r, data, &data->info.request_size, 0,
 2421|     20|                              FIRSTSOCKET);
 2422|     20|    if(result)
 2423|      0|      failf(data, "Failed sending PUT request");
 2424|     20|    else
 2425|       |      /* prepare for transfer */
 2426|     20|      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE,
 2427|     20|                          http->postsize?FIRSTSOCKET:-1);
 2428|     20|    if(result)
 2429|      0|      return result;
 2430|     20|    break;
 2431|       |
 2432|     20|  case HTTPREQ_POST_FORM:
 2433|    149|  case HTTPREQ_POST_MIME:
 2434|       |    /* This is form posting using mime data. */
 2435|    149|    if(conn->bits.authneg) {
 2436|       |      /* nothing to post! */
 2437|     18|      result = Curl_dyn_add(r, "Content-Length: 0\r\n\r\n");
 2438|     18|      if(result)
 2439|      0|        return result;
 2440|       |
 2441|     18|      result = Curl_buffer_send(r, data, &data->info.request_size, 0,
 2442|     18|                                FIRSTSOCKET);
 2443|     18|      if(result)
 2444|      0|        failf(data, "Failed sending POST request");
 2445|     18|      else
 2446|       |        /* setup variables for the upcoming transfer */
 2447|     18|        Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE, -1);
 2448|     18|      break;
 2449|     18|    }
 2450|       |
 2451|    131|    data->state.infilesize = http->postsize;
 2452|       |
 2453|       |    /* We only set Content-Length and allow a custom Content-Length if
 2454|       |       we don't upload data chunked, as RFC2616 forbids us to set both
 2455|       |       kinds of headers (Transfer-Encoding: chunked and Content-Length) */
 2456|    131|    if(http->postsize != -1 && !data->req.upload_chunky &&
 2457|    131|       (conn->bits.authneg || !Curl_checkheaders(data, "Content-Length"))) {
 2458|       |      /* we allow replacing this header if not during auth negotiation,
 2459|       |         although it isn't very wise to actually set your own */
 2460|    128|      result = Curl_dyn_addf(r,
 2461|    128|                             "Content-Length: %" CURL_FORMAT_CURL_OFF_T
 2462|    128|                             "\r\n", http->postsize);
 2463|    128|      if(result)
 2464|      0|        return result;
 2465|    128|    }
 2466|       |
 2467|    131|#ifndef CURL_DISABLE_MIME
 2468|       |    /* Output mime-generated headers. */
 2469|    131|    {
 2470|    131|      struct curl_slist *hdr;
 2471|       |
 2472|    262|      for(hdr = http->sendit->curlheaders; hdr; hdr = hdr->next) {
 2473|    131|        result = Curl_dyn_addf(r, "%s\r\n", hdr->data);
 2474|    131|        if(result)
 2475|      0|          return result;
 2476|    131|      }
 2477|    131|    }
 2478|    131|#endif
 2479|       |
 2480|       |    /* For really small posts we don't use Expect: headers at all, and for
 2481|       |       the somewhat bigger ones we allow the app to disable it. Just make
 2482|       |       sure that the expect100header is always set to the preferred value
 2483|       |       here. */
 2484|    131|    ptr = Curl_checkheaders(data, "Expect");
 2485|    131|    if(ptr) {
 2486|      0|      data->state.expect100header =
 2487|      0|        Curl_compareheader(ptr, "Expect:", "100-continue");
 2488|      0|    }
 2489|    131|    else if(http->postsize > EXPECT_100_THRESHOLD || http->postsize < 0) {
 2490|      0|      result = expect100(data, conn, r);
 2491|      0|      if(result)
 2492|      0|        return result;
 2493|      0|    }
 2494|    131|    else
 2495|    131|      data->state.expect100header = FALSE;
 2496|       |
 2497|       |    /* make the request end in a true CRLF */
 2498|    131|    result = Curl_dyn_add(r, "\r\n");
 2499|    131|    if(result)
 2500|      0|      return result;
 2501|       |
 2502|       |    /* set the upload size to the progress meter */
 2503|    131|    Curl_pgrsSetUploadSize(data, http->postsize);
 2504|       |
 2505|       |    /* Read from mime structure. */
 2506|    131|    data->state.fread_func = (curl_read_callback) Curl_mime_read;
 2507|    131|    data->state.in = (void *) http->sendit;
 2508|    131|    http->sending = HTTPSEND_BODY;
 2509|       |
 2510|       |    /* this sends the buffer and frees all the buffer resources */
 2511|    131|    result = Curl_buffer_send(r, data, &data->info.request_size, 0,
 2512|    131|                              FIRSTSOCKET);
 2513|    131|    if(result)
 2514|      0|      failf(data, "Failed sending POST request");
 2515|    131|    else
 2516|       |      /* prepare for transfer */
 2517|    131|      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE,
 2518|    131|                          http->postsize?FIRSTSOCKET:-1);
 2519|    131|    if(result)
 2520|      0|      return result;
 2521|       |
 2522|    131|    break;
 2523|       |
 2524|    131|  case HTTPREQ_POST:
 2525|       |    /* this is the simple POST, using x-www-form-urlencoded style */
 2526|       |
 2527|     14|    if(conn->bits.authneg)
 2528|      1|      http->postsize = 0;
 2529|     13|    else
 2530|       |      /* the size of the post body */
 2531|     13|      http->postsize = data->state.infilesize;
 2532|       |
 2533|       |    /* We only set Content-Length and allow a custom Content-Length if
 2534|       |       we don't upload data chunked, as RFC2616 forbids us to set both
 2535|       |       kinds of headers (Transfer-Encoding: chunked and Content-Length) */
 2536|     14|    if((http->postsize != -1) && !data->req.upload_chunky &&
 2537|     14|       (conn->bits.authneg || !Curl_checkheaders(data, "Content-Length"))) {
 2538|       |      /* we allow replacing this header if not during auth negotiation,
 2539|       |         although it isn't very wise to actually set your own */
 2540|      9|      result = Curl_dyn_addf(r, "Content-Length: %" CURL_FORMAT_CURL_OFF_T
 2541|      9|                             "\r\n", http->postsize);
 2542|      9|      if(result)
 2543|      0|        return result;
 2544|      9|    }
 2545|       |
 2546|     14|    if(!Curl_checkheaders(data, "Content-Type")) {
 2547|     13|      result = Curl_dyn_add(r, "Content-Type: application/"
 2548|     13|                            "x-www-form-urlencoded\r\n");
 2549|     13|      if(result)
 2550|      0|        return result;
 2551|     13|    }
 2552|       |
 2553|       |    /* For really small posts we don't use Expect: headers at all, and for
 2554|       |       the somewhat bigger ones we allow the app to disable it. Just make
 2555|       |       sure that the expect100header is always set to the preferred value
 2556|       |       here. */
 2557|     14|    ptr = Curl_checkheaders(data, "Expect");
 2558|     14|    if(ptr) {
 2559|      0|      data->state.expect100header =
 2560|      0|        Curl_compareheader(ptr, "Expect:", "100-continue");
 2561|      0|    }
 2562|     14|    else if(http->postsize > EXPECT_100_THRESHOLD || http->postsize < 0) {
 2563|      0|      result = expect100(data, conn, r);
 2564|      0|      if(result)
 2565|      0|        return result;
 2566|      0|    }
 2567|     14|    else
 2568|     14|      data->state.expect100header = FALSE;
 2569|       |
 2570|     14|#ifndef USE_HYPER
 2571|       |    /* With Hyper the body is always passed on separately */
 2572|     14|    if(data->set.postfields) {
 2573|       |
 2574|       |      /* In HTTP2, we send request body in DATA frame regardless of
 2575|       |         its size. */
 2576|     14|      if(conn->httpversion != 20 &&
 2577|     14|         !data->state.expect100header &&
 2578|     14|         (http->postsize < MAX_INITIAL_POST_SIZE)) {
 2579|       |        /* if we don't use expect: 100  AND
 2580|       |           postsize is less than MAX_INITIAL_POST_SIZE
 2581|       |
 2582|       |           then append the post data to the HTTP request header. This limit
 2583|       |           is no magic limit but only set to prevent really huge POSTs to
 2584|       |           get the data duplicated with malloc() and family. */
 2585|       |
 2586|       |        /* end of headers! */
 2587|     14|        result = Curl_dyn_add(r, "\r\n");
 2588|     14|        if(result)
 2589|      0|          return result;
 2590|       |
 2591|     14|        if(!data->req.upload_chunky) {
 2592|       |          /* We're not sending it 'chunked', append it to the request
 2593|       |             already now to reduce the number if send() calls */
 2594|     12|          result = Curl_dyn_addn(r, data->set.postfields,
 2595|     12|                                 (size_t)http->postsize);
 2596|     12|          included_body = http->postsize;
 2597|     12|        }
 2598|      2|        else {
 2599|      2|          if(http->postsize) {
 2600|      1|            char chunk[16];
 2601|       |            /* Append the POST data chunky-style */
 2602|      1|            msnprintf(chunk, sizeof(chunk), "%x\r\n", (int)http->postsize);
 2603|      1|            result = Curl_dyn_add(r, chunk);
 2604|      1|            if(!result) {
 2605|      1|              included_body = http->postsize + strlen(chunk);
 2606|      1|              result = Curl_dyn_addn(r, data->set.postfields,
 2607|      1|                                     (size_t)http->postsize);
 2608|      1|              if(!result)
 2609|      1|                result = Curl_dyn_add(r, "\r\n");
 2610|      1|              included_body += 2;
 2611|      1|            }
 2612|      1|          }
 2613|      2|          if(!result) {
 2614|      2|            result = Curl_dyn_add(r, "\x30\x0d\x0a\x0d\x0a");
 2615|       |            /* 0  CR  LF  CR  LF */
 2616|      2|            included_body += 5;
 2617|      2|          }
 2618|      2|        }
 2619|     14|        if(result)
 2620|      0|          return result;
 2621|       |        /* Make sure the progress information is accurate */
 2622|     14|        Curl_pgrsSetUploadSize(data, http->postsize);
 2623|     14|      }
 2624|      0|      else {
 2625|       |        /* A huge POST coming up, do data separate from the request */
 2626|      0|        http->postdata = data->set.postfields;
 2627|       |
 2628|      0|        http->sending = HTTPSEND_BODY;
 2629|       |
 2630|      0|        data->state.fread_func = (curl_read_callback)readmoredata;
 2631|      0|        data->state.in = (void *)data;
 2632|       |
 2633|       |        /* set the upload size to the progress meter */
 2634|      0|        Curl_pgrsSetUploadSize(data, http->postsize);
 2635|       |
 2636|       |        /* end of headers! */
 2637|      0|        result = Curl_dyn_add(r, "\r\n");
 2638|      0|        if(result)
 2639|      0|          return result;
 2640|      0|      }
 2641|     14|    }
 2642|      0|    else
 2643|      0|#endif
 2644|      0|    {
 2645|       |       /* end of headers! */
 2646|      0|      result = Curl_dyn_add(r, "\r\n");
 2647|      0|      if(result)
 2648|      0|        return result;
 2649|       |
 2650|      0|      if(data->req.upload_chunky && conn->bits.authneg) {
 2651|       |        /* Chunky upload is selected and we're negotiating auth still, send
 2652|       |           end-of-data only */
 2653|      0|        result = Curl_dyn_add(r, (char *)"\x30\x0d\x0a\x0d\x0a");
 2654|       |        /* 0  CR  LF  CR  LF */
 2655|      0|        if(result)
 2656|      0|          return result;
 2657|      0|      }
 2658|       |
 2659|      0|      else if(data->state.infilesize) {
 2660|       |        /* set the upload size to the progress meter */
 2661|      0|        Curl_pgrsSetUploadSize(data, http->postsize?http->postsize:-1);
 2662|       |
 2663|       |        /* set the pointer to mark that we will send the post body using the
 2664|       |           read callback, but only if we're not in authenticate negotiation */
 2665|      0|        if(!conn->bits.authneg)
 2666|      0|          http->postdata = (char *)&http->postdata;
 2667|      0|      }
 2668|      0|    }
 2669|       |    /* issue the request */
 2670|     14|    result = Curl_buffer_send(r, data, &data->info.request_size, included_body,
 2671|     14|                              FIRSTSOCKET);
 2672|       |
 2673|     14|    if(result)
 2674|      0|      failf(data, "Failed sending HTTP POST request");
 2675|     14|    else
 2676|     14|      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE,
 2677|     14|                          http->postdata?FIRSTSOCKET:-1);
 2678|     14|    break;
 2679|       |
 2680|  1.03k|  default:
 2681|  1.03k|    result = Curl_dyn_add(r, "\r\n");
 2682|  1.03k|    if(result)
 2683|      0|      return result;
 2684|       |
 2685|       |    /* issue the request */
 2686|  1.03k|    result = Curl_buffer_send(r, data, &data->info.request_size, 0,
 2687|  1.03k|                              FIRSTSOCKET);
 2688|       |
 2689|  1.03k|    if(result)
 2690|      0|      failf(data, "Failed sending HTTP request");
 2691|  1.03k|    else
 2692|       |      /* HTTP GET/HEAD download: */
 2693|  1.03k|      Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE, -1);
 2694|  1.22k|  }
 2695|       |
 2696|  1.22k|  return result;
 2697|  1.22k|}
Curl_http_cookies:
 2703|  1.22k|{
 2704|  1.22k|  CURLcode result = CURLE_OK;
 2705|  1.22k|  char *addcookies = NULL;
 2706|  1.22k|  if(data->set.str[STRING_COOKIE] && !Curl_checkheaders(data, "Cookie"))
 2707|      5|    addcookies = data->set.str[STRING_COOKIE];
 2708|       |
 2709|  1.22k|  if(data->cookies || addcookies) {
 2710|  1.22k|    struct Cookie *co = NULL; /* no cookies from start */
 2711|  1.22k|    int count = 0;
 2712|       |
 2713|  1.22k|    if(data->cookies && data->state.cookie_engine) {
 2714|  1.22k|      const char *host = data->state.aptr.cookiehost ?
 2715|  1.20k|        data->state.aptr.cookiehost : conn->host.name;
 2716|  1.22k|      const bool secure_context =
 2717|  1.22k|        conn->handler->protocol&CURLPROTO_HTTPS ||
 2718|  1.22k|        strcasecompare("localhost", host) ||
 2719|  1.22k|        !strcmp(host, "127.0.0.1") ||
 2720|  1.22k|        !strcmp(host, "[::1]") ? TRUE : FALSE;
 2721|  1.22k|      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
 2722|  1.22k|      co = Curl_cookie_getlist(data->cookies, host, data->state.up.path,
 2723|  1.22k|                               secure_context);
 2724|  1.22k|      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
 2725|  1.22k|    }
 2726|  1.22k|    if(co) {
 2727|     23|      struct Cookie *store = co;
 2728|       |      /* now loop through all cookies that matched */
 2729|     71|      while(co) {
 2730|     48|        if(co->value) {
 2731|     48|          if(0 == count) {
 2732|     23|            result = Curl_dyn_add(r, "Cookie: ");
 2733|     23|            if(result)
 2734|      0|              break;
 2735|     23|          }
 2736|     48|          result = Curl_dyn_addf(r, "%s%s=%s", count?"; ":"",
 2737|     48|                                 co->name, co->value);
 2738|     48|          if(result)
 2739|      0|            break;
 2740|     48|          count++;
 2741|     48|        }
 2742|     48|        co = co->next; /* next cookie please */
 2743|     48|      }
 2744|     23|      Curl_cookie_freelist(store);
 2745|     23|    }
 2746|  1.22k|    if(addcookies && !result) {
 2747|      5|      if(!count)
 2748|      5|        result = Curl_dyn_add(r, "Cookie: ");
 2749|      5|      if(!result) {
 2750|      5|        result = Curl_dyn_addf(r, "%s%s", count?"; ":"", addcookies);
 2751|      5|        count++;
 2752|      5|      }
 2753|      5|    }
 2754|  1.22k|    if(count && !result)
 2755|     28|      result = Curl_dyn_add(r, "\r\n");
 2756|       |
 2757|  1.22k|    if(result)
 2758|      0|      return result;
 2759|  1.22k|  }
 2760|  1.22k|  return result;
 2761|  1.22k|}
Curl_http_range:
 2766|  1.22k|{
 2767|  1.22k|  if(data->state.use_range) {
 2768|       |    /*
 2769|       |     * A range is selected. We use different headers whether we're downloading
 2770|       |     * or uploading and we always let customized headers override our internal
 2771|       |     * ones if any such are specified.
 2772|       |     */
 2773|     13|    if(((httpreq == HTTPREQ_GET) || (httpreq == HTTPREQ_HEAD)) &&
 2774|     13|       !Curl_checkheaders(data, "Range")) {
 2775|       |      /* if a line like this was already allocated, free the previous one */
 2776|      3|      free(data->state.aptr.rangeline);
 2777|      3|      data->state.aptr.rangeline = aprintf("Range: bytes=%s\r\n",
 2778|      3|                                           data->state.range);
 2779|      3|    }
 2780|     10|    else if((httpreq == HTTPREQ_POST || httpreq == HTTPREQ_PUT) &&
 2781|     10|            !Curl_checkheaders(data, "Content-Range")) {
 2782|       |
 2783|       |      /* if a line like this was already allocated, free the previous one */
 2784|      5|      free(data->state.aptr.rangeline);
 2785|       |
 2786|      5|      if(data->set.set_resume_from < 0) {
 2787|       |        /* Upload resume was asked for, but we don't know the size of the
 2788|       |           remote part so we tell the server (and act accordingly) that we
 2789|       |           upload the whole file (again) */
 2790|      0|        data->state.aptr.rangeline =
 2791|      0|          aprintf("Content-Range: bytes 0-%" CURL_FORMAT_CURL_OFF_T
 2792|      0|                  "/%" CURL_FORMAT_CURL_OFF_T "\r\n",
 2793|      0|                  data->state.infilesize - 1, data->state.infilesize);
 2794|       |
 2795|      0|      }
 2796|      5|      else if(data->state.resume_from) {
 2797|       |        /* This is because "resume" was selected */
 2798|      0|        curl_off_t total_expected_size =
 2799|      0|          data->state.resume_from + data->state.infilesize;
 2800|      0|        data->state.aptr.rangeline =
 2801|      0|          aprintf("Content-Range: bytes %s%" CURL_FORMAT_CURL_OFF_T
 2802|      0|                  "/%" CURL_FORMAT_CURL_OFF_T "\r\n",
 2803|      0|                  data->state.range, total_expected_size-1,
 2804|      0|                  total_expected_size);
 2805|      0|      }
 2806|      5|      else {
 2807|       |        /* Range was selected and then we just pass the incoming range and
 2808|       |           append total size */
 2809|      5|        data->state.aptr.rangeline =
 2810|      5|          aprintf("Content-Range: bytes %s/%" CURL_FORMAT_CURL_OFF_T "\r\n",
 2811|      5|                  data->state.range, data->state.infilesize);
 2812|      5|      }
 2813|      5|      if(!data->state.aptr.rangeline)
 2814|      0|        return CURLE_OUT_OF_MEMORY;
 2815|      5|    }
 2816|     13|  }
 2817|  1.22k|  return CURLE_OK;
 2818|  1.22k|}
Curl_http_resume:
 2823|  1.22k|{
 2824|  1.22k|  if((HTTPREQ_POST == httpreq || HTTPREQ_PUT == httpreq) &&
 2825|  1.22k|     data->state.resume_from) {
 2826|       |    /**********************************************************************
 2827|       |     * Resuming upload in HTTP means that we PUT or POST and that we have
 2828|       |     * got a resume_from value set. The resume value has already created
 2829|       |     * a Range: header that will be passed along. We need to "fast forward"
 2830|       |     * the file the given number of bytes and decrease the assume upload
 2831|       |     * file size before we continue this venture in the dark lands of HTTP.
 2832|       |     * Resuming mime/form posting at an offset > 0 has no sense and is ignored.
 2833|       |     *********************************************************************/
 2834|       |
 2835|      0|    if(data->state.resume_from < 0) {
 2836|       |      /*
 2837|       |       * This is meant to get the size of the present remote-file by itself.
 2838|       |       * We don't support this now. Bail out!
 2839|       |       */
 2840|      0|      data->state.resume_from = 0;
 2841|      0|    }
 2842|       |
 2843|      0|    if(data->state.resume_from && !data->state.this_is_a_follow) {
 2844|       |      /* do we still game? */
 2845|       |
 2846|       |      /* Now, let's read off the proper amount of bytes from the
 2847|       |         input. */
 2848|      0|      int seekerr = CURL_SEEKFUNC_CANTSEEK;
 2849|      0|      if(conn->seek_func) {
 2850|      0|        Curl_set_in_callback(data, true);
 2851|      0|        seekerr = conn->seek_func(conn->seek_client, data->state.resume_from,
 2852|      0|                                  SEEK_SET);
 2853|      0|        Curl_set_in_callback(data, false);
 2854|      0|      }
 2855|       |
 2856|      0|      if(seekerr != CURL_SEEKFUNC_OK) {
 2857|      0|        curl_off_t passed = 0;
 2858|       |
 2859|      0|        if(seekerr != CURL_SEEKFUNC_CANTSEEK) {
 2860|      0|          failf(data, "Could not seek stream");
 2861|      0|          return CURLE_READ_ERROR;
 2862|      0|        }
 2863|       |        /* when seekerr == CURL_SEEKFUNC_CANTSEEK (can't seek to offset) */
 2864|      0|        do {
 2865|      0|          size_t readthisamountnow =
 2866|      0|            (data->state.resume_from - passed > data->set.buffer_size) ?
 2867|      0|            (size_t)data->set.buffer_size :
 2868|      0|            curlx_sotouz(data->state.resume_from - passed);
 2869|       |
 2870|      0|          size_t actuallyread =
 2871|      0|            data->state.fread_func(data->state.buffer, 1, readthisamountnow,
 2872|      0|                                   data->state.in);
 2873|       |
 2874|      0|          passed += actuallyread;
 2875|      0|          if((actuallyread == 0) || (actuallyread > readthisamountnow)) {
 2876|       |            /* this checks for greater-than only to make sure that the
 2877|       |               CURL_READFUNC_ABORT return code still aborts */
 2878|      0|            failf(data, "Could only read %" CURL_FORMAT_CURL_OFF_T
 2879|      0|                  " bytes from the input", passed);
 2880|      0|            return CURLE_READ_ERROR;
 2881|      0|          }
 2882|      0|        } while(passed < data->state.resume_from);
 2883|      0|      }
 2884|       |
 2885|       |      /* now, decrease the size of the read */
 2886|      0|      if(data->state.infilesize>0) {
 2887|      0|        data->state.infilesize -= data->state.resume_from;
 2888|       |
 2889|      0|        if(data->state.infilesize <= 0) {
 2890|      0|          failf(data, "File already completely uploaded");
 2891|      0|          return CURLE_PARTIAL_FILE;
 2892|      0|        }
 2893|      0|      }
 2894|       |      /* we've passed, proceed as normal */
 2895|      0|    }
 2896|      0|  }
 2897|  1.22k|  return CURLE_OK;
 2898|  1.22k|}
Curl_http_firstwrite:
 2903|    391|{
 2904|    391|  struct SingleRequest *k = &data->req;
 2905|       |
 2906|    391|  if(data->req.newurl) {
 2907|     58|    if(conn->bits.close) {
 2908|       |      /* Abort after the headers if "follow Location" is set
 2909|       |         and we're set to close anyway. */
 2910|     32|      k->keepon &= ~KEEP_RECV;
 2911|     32|      *done = TRUE;
 2912|     32|      return CURLE_OK;
 2913|     32|    }
 2914|       |    /* We have a new url to load, but since we want to be able to re-use this
 2915|       |       connection properly, we read the full response in "ignore more" */
 2916|     26|    k->ignorebody = TRUE;
 2917|     26|    infof(data, "Ignoring the response-body");
 2918|     26|  }
 2919|    359|  if(data->state.resume_from && !k->content_range &&
 2920|    359|     (data->state.httpreq == HTTPREQ_GET) &&
 2921|    359|     !k->ignorebody) {
 2922|       |
 2923|      0|    if(k->size == data->state.resume_from) {
 2924|       |      /* The resume point is at the end of file, consider this fine even if it
 2925|       |         doesn't allow resume from here. */
 2926|      0|      infof(data, "The entire document is already downloaded");
 2927|      0|      connclose(conn, "already downloaded");
 2928|       |      /* Abort download */
 2929|      0|      k->keepon &= ~KEEP_RECV;
 2930|      0|      *done = TRUE;
 2931|      0|      return CURLE_OK;
 2932|      0|    }
 2933|       |
 2934|       |    /* we wanted to resume a download, although the server doesn't seem to
 2935|       |     * support this and we did this with a GET (if it wasn't a GET we did a
 2936|       |     * POST or PUT resume) */
 2937|      0|    failf(data, "HTTP server doesn't seem to support "
 2938|      0|          "byte ranges. Cannot resume.");
 2939|      0|    return CURLE_RANGE_ERROR;
 2940|      0|  }
 2941|       |
 2942|    359|  if(data->set.timecondition && !data->state.range) {
 2943|       |    /* A time condition has been set AND no ranges have been requested. This
 2944|       |       seems to be what chapter 13.3.4 of RFC 2616 defines to be the correct
 2945|       |       action for a HTTP/1.1 client */
 2946|       |
 2947|      0|    if(!Curl_meets_timecondition(data, k->timeofdoc)) {
 2948|      0|      *done = TRUE;
 2949|       |      /* We're simulating a http 304 from server so we return
 2950|       |         what should have been returned from the server */
 2951|      0|      data->info.httpcode = 304;
 2952|      0|      infof(data, "Simulate a HTTP 304 response!");
 2953|       |      /* we abort the transfer before it is completed == we ruin the
 2954|       |         re-use ability. Close the connection */
 2955|      0|      connclose(conn, "Simulated 304 handling");
 2956|      0|      return CURLE_OK;
 2957|      0|    }
 2958|      0|  } /* we have a time condition */
 2959|       |
 2960|    359|  return CURLE_OK;
 2961|    359|}
Curl_transferencode:
 2965|  1.22k|{
 2966|  1.22k|  if(!Curl_checkheaders(data, "TE") &&
 2967|  1.22k|     data->set.http_transfer_encoding) {
 2968|       |    /* When we are to insert a TE: header in the request, we must also insert
 2969|       |       TE in a Connection: header, so we need to merge the custom provided
 2970|       |       Connection: header and prevent the original to get sent. Note that if
 2971|       |       the user has inserted his/her own TE: header we don't do this magic
 2972|       |       but then assume that the user will handle it all! */
 2973|      0|    char *cptr = Curl_checkheaders(data, "Connection");
 2974|      0|#define TE_HEADER "TE: gzip\r\n"
 2975|       |
 2976|      0|    Curl_safefree(data->state.aptr.te);
 2977|       |
 2978|      0|    if(cptr) {
 2979|      0|      cptr = Curl_copy_header_value(cptr);
 2980|      0|      if(!cptr)
 2981|      0|        return CURLE_OUT_OF_MEMORY;
 2982|      0|    }
 2983|       |
 2984|       |    /* Create the (updated) Connection: header */
 2985|      0|    data->state.aptr.te = aprintf("Connection: %s%sTE\r\n" TE_HEADER,
 2986|      0|                                cptr ? cptr : "", (cptr && *cptr) ? ", ":"");
 2987|       |
 2988|      0|    free(cptr);
 2989|      0|    if(!data->state.aptr.te)
 2990|      0|      return CURLE_OUT_OF_MEMORY;
 2991|      0|  }
 2992|  1.22k|  return CURLE_OK;
 2993|  1.22k|}
Curl_http:
 3003|  1.22k|{
 3004|  1.22k|  struct connectdata *conn = data->conn;
 3005|  1.22k|  CURLcode result = CURLE_OK;
 3006|  1.22k|  struct HTTP *http;
 3007|  1.22k|  Curl_HttpReq httpreq;
 3008|  1.22k|  const char *te = ""; /* transfer-encoding */
 3009|  1.22k|  const char *request;
 3010|  1.22k|  const char *httpstring;
 3011|  1.22k|  struct dynbuf req;
 3012|  1.22k|  char *altused = NULL;
 3013|  1.22k|  const char *p_accept;      /* Accept: string */
 3014|       |
 3015|       |  /* Always consider the DO phase done after this function call, even if there
 3016|       |     may be parts of the request that are not yet sent, since we can deal with
 3017|       |     the rest of the request in the PERFORM phase. */
 3018|  1.22k|  *done = TRUE;
 3019|       |
 3020|  1.22k|  if(conn->transport != TRNSPRT_QUIC) {
 3021|  1.22k|    if(conn->httpversion < 20) { /* unless the connection is re-used and
 3022|       |                                    already http2 */
 3023|  1.22k|      switch(conn->negnpn) {
 3024|      0|      case CURL_HTTP_VERSION_2:
 3025|      0|        conn->httpversion = 20; /* we know we're on HTTP/2 now */
 3026|       |
 3027|      0|        result = Curl_http2_switched(data, NULL, 0);
 3028|      0|        if(result)
 3029|      0|          return result;
 3030|      0|        break;
 3031|      0|      case CURL_HTTP_VERSION_1_1:
 3032|       |        /* continue with HTTP/1.1 when explicitly requested */
 3033|      0|        break;
 3034|  1.22k|      default:
 3035|       |        /* Check if user wants to use HTTP/2 with clear TCP*/
 3036|  1.22k|#ifdef USE_NGHTTP2
 3037|  1.22k|        if(data->state.httpwant == CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE) {
 3038|      0|#ifndef CURL_DISABLE_PROXY
 3039|      0|          if(conn->bits.httpproxy && !conn->bits.tunnel_proxy) {
 3040|       |            /* We don't support HTTP/2 proxies yet. Also it's debatable
 3041|       |               whether or not this setting should apply to HTTP/2 proxies. */
 3042|      0|            infof(data, "Ignoring HTTP/2 prior knowledge due to proxy");
 3043|      0|            break;
 3044|      0|          }
 3045|      0|#endif
 3046|      0|          DEBUGF(infof(data, "HTTP/2 over clean TCP"));
 3047|      0|          conn->httpversion = 20;
 3048|       |
 3049|      0|          result = Curl_http2_switched(data, NULL, 0);
 3050|      0|          if(result)
 3051|      0|            return result;
 3052|      0|        }
 3053|  1.22k|#endif
 3054|  1.22k|        break;
 3055|  1.22k|      }
 3056|  1.22k|    }
 3057|      0|    else {
 3058|       |      /* prepare for a http2 request */
 3059|      0|      result = Curl_http2_setup(data, conn);
 3060|      0|      if(result)
 3061|      0|        return result;
 3062|      0|    }
 3063|  1.22k|  }
 3064|  1.22k|  http = data->req.p.http;
 3065|  1.22k|  DEBUGASSERT(http);
 3066|       |
 3067|  1.22k|  result = Curl_http_host(data, conn);
 3068|  1.22k|  if(result)
 3069|      0|    return result;
 3070|       |
 3071|  1.22k|  result = Curl_http_useragent(data);
 3072|  1.22k|  if(result)
 3073|      0|    return result;
 3074|       |
 3075|  1.22k|  Curl_http_method(data, conn, &request, &httpreq);
 3076|       |
 3077|       |  /* setup the authentication headers */
 3078|  1.22k|  {
 3079|  1.22k|    char *pq = NULL;
 3080|  1.22k|    if(data->state.up.query) {
 3081|     62|      pq = aprintf("%s?%s", data->state.up.path, data->state.up.query);
 3082|     62|      if(!pq)
 3083|      0|        return CURLE_OUT_OF_MEMORY;
 3084|     62|    }
 3085|  1.22k|    result = Curl_http_output_auth(data, conn, request, httpreq,
 3086|  1.22k|                                   (pq ? pq : data->state.up.path), FALSE);
 3087|  1.22k|    free(pq);
 3088|  1.22k|    if(result)
 3089|      2|      return result;
 3090|  1.22k|  }
 3091|       |
 3092|  1.22k|  Curl_safefree(data->state.aptr.ref);
 3093|  1.22k|  if(data->state.referer && !Curl_checkheaders(data, "Referer")) {
 3094|      0|    data->state.aptr.ref = aprintf("Referer: %s\r\n", data->state.referer);
 3095|      0|    if(!data->state.aptr.ref)
 3096|      0|      return CURLE_OUT_OF_MEMORY;
 3097|      0|  }
 3098|       |
 3099|  1.22k|  if(!Curl_checkheaders(data, "Accept-Encoding") &&
 3100|  1.22k|     data->set.str[STRING_ENCODING]) {
 3101|    113|    Curl_safefree(data->state.aptr.accept_encoding);
 3102|    113|    data->state.aptr.accept_encoding =
 3103|    113|      aprintf("Accept-Encoding: %s\r\n", data->set.str[STRING_ENCODING]);
 3104|    113|    if(!data->state.aptr.accept_encoding)
 3105|      0|      return CURLE_OUT_OF_MEMORY;
 3106|    113|  }
 3107|  1.11k|  else
 3108|  1.11k|    Curl_safefree(data->state.aptr.accept_encoding);
 3109|       |
 3110|  1.22k|#ifdef HAVE_LIBZ
 3111|       |  /* we only consider transfer-encoding magic if libz support is built-in */
 3112|  1.22k|  result = Curl_transferencode(data);
 3113|  1.22k|  if(result)
 3114|      0|    return result;
 3115|  1.22k|#endif
 3116|       |
 3117|  1.22k|  result = Curl_http_body(data, conn, httpreq, &te);
 3118|  1.22k|  if(result)
 3119|      4|    return result;
 3120|       |
 3121|  1.22k|  p_accept = Curl_checkheaders(data, "Accept")?NULL:"Accept: */*\r\n";
 3122|       |
 3123|  1.22k|  result = Curl_http_resume(data, conn, httpreq);
 3124|  1.22k|  if(result)
 3125|      0|    return result;
 3126|       |
 3127|  1.22k|  result = Curl_http_range(data, httpreq);
 3128|  1.22k|  if(result)
 3129|      0|    return result;
 3130|       |
 3131|  1.22k|  httpstring = get_http_string(data, conn);
 3132|       |
 3133|       |  /* initialize a dynamic send-buffer */
 3134|  1.22k|  Curl_dyn_init(&req, DYN_HTTP_REQUEST);
 3135|       |
 3136|       |  /* make sure the header buffer is reset - if there are leftovers from a
 3137|       |     previous transfer */
 3138|  1.22k|  Curl_dyn_reset(&data->state.headerb);
 3139|       |
 3140|       |  /* add the main request stuff */
 3141|       |  /* GET/HEAD/POST/PUT */
 3142|  1.22k|  result = Curl_dyn_addf(&req, "%s ", request);
 3143|  1.22k|  if(!result)
 3144|  1.22k|    result = Curl_http_target(data, conn, &req);
 3145|  1.22k|  if(result) {
 3146|      0|    Curl_dyn_free(&req);
 3147|      0|    return result;
 3148|      0|  }
 3149|       |
 3150|  1.22k|#ifndef CURL_DISABLE_ALTSVC
 3151|  1.22k|  if(conn->bits.altused && !Curl_checkheaders(data, "Alt-Used")) {
 3152|      0|    altused = aprintf("Alt-Used: %s:%d\r\n",
 3153|      0|                      conn->conn_to_host.name, conn->conn_to_port);
 3154|      0|    if(!altused) {
 3155|      0|      Curl_dyn_free(&req);
 3156|      0|      return CURLE_OUT_OF_MEMORY;
 3157|      0|    }
 3158|      0|  }
 3159|  1.22k|#endif
 3160|  1.22k|  result =
 3161|  1.22k|    Curl_dyn_addf(&req,
 3162|  1.22k|                  " HTTP/%s\r\n" /* HTTP version */
 3163|  1.22k|                  "%s" /* host */
 3164|  1.22k|                  "%s" /* proxyuserpwd */
 3165|  1.22k|                  "%s" /* userpwd */
 3166|  1.22k|                  "%s" /* range */
 3167|  1.22k|                  "%s" /* user agent */
 3168|  1.22k|                  "%s" /* accept */
 3169|  1.22k|                  "%s" /* TE: */
 3170|  1.22k|                  "%s" /* accept-encoding */
 3171|  1.22k|                  "%s" /* referer */
 3172|  1.22k|                  "%s" /* Proxy-Connection */
 3173|  1.22k|                  "%s" /* transfer-encoding */
 3174|  1.22k|                  "%s",/* Alt-Used */
 3175|       |
 3176|  1.22k|                  httpstring,
 3177|  1.22k|                  (data->state.aptr.host?data->state.aptr.host:""),
 3178|  1.22k|                  data->state.aptr.proxyuserpwd?
 3179|  1.22k|                  data->state.aptr.proxyuserpwd:"",
 3180|  1.22k|                  data->state.aptr.userpwd?data->state.aptr.userpwd:"",
 3181|  1.22k|                  (data->state.use_range && data->state.aptr.rangeline)?
 3182|  1.21k|                  data->state.aptr.rangeline:"",
 3183|  1.22k|                  (data->set.str[STRING_USERAGENT] &&
 3184|  1.22k|                   *data->set.str[STRING_USERAGENT] &&
 3185|  1.22k|                   data->state.aptr.uagent)?
 3186|  1.22k|                  data->state.aptr.uagent:"",
 3187|  1.22k|                  p_accept?p_accept:"",
 3188|  1.22k|                  data->state.aptr.te?data->state.aptr.te:"",
 3189|  1.22k|                  (data->set.str[STRING_ENCODING] &&
 3190|  1.22k|                   *data->set.str[STRING_ENCODING] &&
 3191|  1.22k|                   data->state.aptr.accept_encoding)?
 3192|  1.10k|                  data->state.aptr.accept_encoding:"",
 3193|  1.22k|                  (data->state.referer && data->state.aptr.ref)?
 3194|  1.22k|                  data->state.aptr.ref:"" /* Referer: <data> */,
 3195|  1.22k|#ifndef CURL_DISABLE_PROXY
 3196|  1.22k|                  (conn->bits.httpproxy &&
 3197|  1.22k|                   !conn->bits.tunnel_proxy &&
 3198|  1.22k|                   !Curl_checkheaders(data, "Proxy-Connection") &&
 3199|  1.22k|                   !Curl_checkProxyheaders(data, conn, "Proxy-Connection"))?
 3200|  1.22k|                  "Proxy-Connection: Keep-Alive\r\n":"",
 3201|       |#else
 3202|       |                  "",
 3203|       |#endif
 3204|  1.22k|                  te,
 3205|  1.22k|                  altused ? altused : ""
 3206|  1.22k|      );
 3207|       |
 3208|       |  /* clear userpwd and proxyuserpwd to avoid re-using old credentials
 3209|       |   * from re-used connections */
 3210|  1.22k|  Curl_safefree(data->state.aptr.userpwd);
 3211|  1.22k|  Curl_safefree(data->state.aptr.proxyuserpwd);
 3212|  1.22k|  free(altused);
 3213|       |
 3214|  1.22k|  if(result) {
 3215|      0|    Curl_dyn_free(&req);
 3216|      0|    return result;
 3217|      0|  }
 3218|       |
 3219|  1.22k|  if(!(conn->handler->flags&PROTOPT_SSL) &&
 3220|  1.22k|     conn->httpversion != 20 &&
 3221|  1.22k|     (data->state.httpwant == CURL_HTTP_VERSION_2)) {
 3222|       |    /* append HTTP2 upgrade magic stuff to the HTTP request if it isn't done
 3223|       |       over SSL */
 3224|      0|    result = Curl_http2_request_upgrade(&req, data);
 3225|      0|    if(result) {
 3226|      0|      Curl_dyn_free(&req);
 3227|      0|      return result;
 3228|      0|    }
 3229|      0|  }
 3230|       |
 3231|  1.22k|  result = Curl_http_cookies(data, conn, &req);
 3232|  1.22k|  if(!result)
 3233|  1.22k|    result = Curl_add_timecondition(data, &req);
 3234|  1.22k|  if(!result)
 3235|  1.22k|    result = Curl_add_custom_headers(data, FALSE, &req);
 3236|       |
 3237|  1.22k|  if(!result) {
 3238|  1.22k|    http->postdata = NULL;  /* nothing to post at this point */
 3239|  1.22k|    if((httpreq == HTTPREQ_GET) ||
 3240|  1.22k|       (httpreq == HTTPREQ_HEAD))
 3241|  1.03k|      Curl_pgrsSetUploadSize(data, 0); /* nothing */
 3242|       |
 3243|       |    /* bodysend takes ownership of the 'req' memory on success */
 3244|  1.22k|    result = Curl_http_bodysend(data, conn, &req, httpreq);
 3245|  1.22k|  }
 3246|  1.22k|  if(result) {
 3247|      0|    Curl_dyn_free(&req);
 3248|      0|    return result;
 3249|      0|  }
 3250|       |
 3251|  1.22k|  if((http->postsize > -1) &&
 3252|  1.22k|     (http->postsize <= data->req.writebytecount) &&
 3253|  1.22k|     (http->sending != HTTPSEND_REQUEST))
 3254|  1.05k|    data->req.upload_done = TRUE;
 3255|       |
 3256|  1.22k|  if(data->req.writebytecount) {
 3257|       |    /* if a request-body has been sent off, we make sure this progress is noted
 3258|       |       properly */
 3259|     13|    Curl_pgrsSetUploadCounter(data, data->req.writebytecount);
 3260|     13|    if(Curl_pgrsUpdate(data))
 3261|      0|      result = CURLE_ABORTED_BY_CALLBACK;
 3262|       |
 3263|     13|    if(!http->postsize) {
 3264|       |      /* already sent the entire request body, mark the "upload" as
 3265|       |         complete */
 3266|      1|      infof(data, "upload completely sent off: %" CURL_FORMAT_CURL_OFF_T
 3267|      1|            " out of %" CURL_FORMAT_CURL_OFF_T " bytes",
 3268|      1|            data->req.writebytecount, http->postsize);
 3269|      1|      data->req.upload_done = TRUE;
 3270|      1|      data->req.keepon &= ~KEEP_SEND; /* we're done writing */
 3271|      1|      data->req.exp100 = EXP100_SEND_DATA; /* already sent */
 3272|      1|      Curl_expire_done(data, EXPIRE_100_TIMEOUT);
 3273|      1|    }
 3274|     13|  }
 3275|       |
 3276|  1.22k|  if((conn->httpversion == 20) && data->req.upload_chunky)
 3277|       |    /* upload_chunky was set above to set up the request in a chunky fashion,
 3278|       |       but is disabled here again to avoid that the chunked encoded version is
 3279|       |       actually used when sending the request body over h2 */
 3280|      0|    data->req.upload_chunky = FALSE;
 3281|  1.22k|  return result;
 3282|  1.22k|}
Curl_http_header:
 3395|  20.2k|{
 3396|  20.2k|  CURLcode result;
 3397|  20.2k|  struct SingleRequest *k = &data->req;
 3398|       |  /* Check for Content-Length: header lines to get size */
 3399|  20.2k|  if(!k->http_bodyless &&
 3400|  20.2k|     !data->set.ignorecl && checkprefix("Content-Length:", headp)) {
 3401|    395|    curl_off_t contentlength;
 3402|    395|    CURLofft offt = curlx_strtoofft(headp + strlen("Content-Length:"),
 3403|    395|                                    NULL, 10, &contentlength);
 3404|       |
 3405|    395|    if(offt == CURL_OFFT_OK) {
 3406|    387|      k->size = contentlength;
 3407|    387|      k->maxdownload = k->size;
 3408|    387|    }
 3409|      8|    else if(offt == CURL_OFFT_FLOW) {
 3410|       |      /* out of range */
 3411|      1|      if(data->set.max_filesize) {
 3412|      0|        failf(data, "Maximum file size exceeded");
 3413|      0|        return CURLE_FILESIZE_EXCEEDED;
 3414|      0|      }
 3415|      1|      streamclose(conn, "overflow content-length");
 3416|      1|      infof(data, "Overflow Content-Length: value!");
 3417|      1|    }
 3418|      7|    else {
 3419|       |      /* negative or just rubbish - bad HTTP */
 3420|      7|      failf(data, "Invalid Content-Length: value");
 3421|      7|      return CURLE_WEIRD_SERVER_REPLY;
 3422|      7|    }
 3423|    395|  }
 3424|       |  /* check for Content-Type: header lines to get the MIME-type */
 3425|  19.8k|  else if(checkprefix("Content-Type:", headp)) {
 3426|  1.86k|    char *contenttype = Curl_copy_header_value(headp);
 3427|  1.86k|    if(!contenttype)
 3428|      0|      return CURLE_OUT_OF_MEMORY;
 3429|  1.86k|    if(!*contenttype)
 3430|       |      /* ignore empty data */
 3431|     70|      free(contenttype);
 3432|  1.79k|    else {
 3433|  1.79k|      Curl_safefree(data->info.contenttype);
 3434|  1.79k|      data->info.contenttype = contenttype;
 3435|  1.79k|    }
 3436|  1.86k|  }
 3437|  17.9k|#ifndef CURL_DISABLE_PROXY
 3438|  17.9k|  else if((conn->httpversion == 10) &&
 3439|  17.9k|          conn->bits.httpproxy &&
 3440|  17.9k|          Curl_compareheader(headp, "Proxy-Connection:", "keep-alive")) {
 3441|       |    /*
 3442|       |     * When a HTTP/1.0 reply comes when using a proxy, the
 3443|       |     * 'Proxy-Connection: keep-alive' line tells us the
 3444|       |     * connection will be kept alive for our pleasure.
 3445|       |     * Default action for 1.0 is to close.
 3446|       |     */
 3447|      0|    connkeep(conn, "Proxy-Connection keep-alive"); /* don't close */
 3448|      0|    infof(data, "HTTP/1.0 proxy connection set to keep alive!");
 3449|      0|  }
 3450|  17.9k|  else if((conn->httpversion == 11) &&
 3451|  17.9k|          conn->bits.httpproxy &&
 3452|  17.9k|          Curl_compareheader(headp, "Proxy-Connection:", "close")) {
 3453|       |    /*
 3454|       |     * We get a HTTP/1.1 response from a proxy and it says it'll
 3455|       |     * close down after this transfer.
 3456|       |     */
 3457|      0|    connclose(conn, "Proxy-Connection: asked to close after done");
 3458|      0|    infof(data, "HTTP/1.1 proxy connection set close!");
 3459|      0|  }
 3460|  17.9k|#endif
 3461|  17.9k|  else if((conn->httpversion == 10) &&
 3462|  17.9k|          Curl_compareheader(headp, "Connection:", "keep-alive")) {
 3463|       |    /*
 3464|       |     * A HTTP/1.0 reply with the 'Connection: keep-alive' line
 3465|       |     * tells us the connection will be kept alive for our
 3466|       |     * pleasure.  Default action for 1.0 is to close.
 3467|       |     *
 3468|       |     * [RFC2068, section 19.7.1] */
 3469|      0|    connkeep(conn, "Connection keep-alive");
 3470|      0|    infof(data, "HTTP/1.0 connection set to keep alive!");
 3471|      0|  }
 3472|  17.9k|  else if(Curl_compareheader(headp, "Connection:", "close")) {
 3473|       |    /*
 3474|       |     * [RFC 2616, section 8.1.2.1]
 3475|       |     * "Connection: close" is HTTP/1.1 language and means that
 3476|       |     * the connection will close when this request has been
 3477|       |     * served.
 3478|       |     */
 3479|    154|    streamclose(conn, "Connection: close used");
 3480|    154|  }
 3481|  17.8k|  else if(!k->http_bodyless && checkprefix("Transfer-Encoding:", headp)) {
 3482|       |    /* One or more encodings. We check for chunked and/or a compression
 3483|       |       algorithm. */
 3484|       |    /*
 3485|       |     * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding
 3486|       |     * means that the server will send a series of "chunks". Each
 3487|       |     * chunk starts with line with info (including size of the
 3488|       |     * coming block) (terminated with CRLF), then a block of data
 3489|       |     * with the previously mentioned size. There can be any amount
 3490|       |     * of chunks, and a chunk-data set to zero signals the
 3491|       |     * end-of-chunks. */
 3492|       |
 3493|    750|    result = Curl_build_unencoding_stack(data,
 3494|    750|                                         headp + strlen("Transfer-Encoding:"),
 3495|    750|                                         TRUE);
 3496|    750|    if(result)
 3497|      0|      return result;
 3498|    750|    if(!k->chunk) {
 3499|       |      /* if this isn't chunked, only close can signal the end of this transfer
 3500|       |         as Content-Length is said not to be trusted for transfer-encoding! */
 3501|    613|      connclose(conn, "HTTP/1.1 transfer-encoding without chunks");
 3502|    613|      k->ignore_cl = TRUE;
 3503|    613|    }
 3504|    750|  }
 3505|  17.0k|  else if(!k->http_bodyless && checkprefix("Content-Encoding:", headp) &&
 3506|  17.0k|          data->set.str[STRING_ENCODING]) {
 3507|       |    /*
 3508|       |     * Process Content-Encoding. Look for the values: identity,
 3509|       |     * gzip, deflate, compress, x-gzip and x-compress. x-gzip and
 3510|       |     * x-compress are the same as gzip and compress. (Sec 3.5 RFC
 3511|       |     * 2616). zlib cannot handle compress.  However, errors are
 3512|       |     * handled further down when the response body is processed
 3513|       |     */
 3514|    141|    result = Curl_build_unencoding_stack(data,
 3515|    141|                                         headp + strlen("Content-Encoding:"),
 3516|    141|                                         FALSE);
 3517|    141|    if(result)
 3518|      0|      return result;
 3519|    141|  }
 3520|  16.9k|  else if(checkprefix("Retry-After:", headp)) {
 3521|       |    /* Retry-After = HTTP-date / delay-seconds */
 3522|      0|    curl_off_t retry_after = 0; /* zero for unknown or "now" */
 3523|      0|    time_t date = Curl_getdate_capped(headp + strlen("Retry-After:"));
 3524|      0|    if(-1 == date) {
 3525|       |      /* not a date, try it as a decimal number */
 3526|      0|      (void)curlx_strtoofft(headp + strlen("Retry-After:"),
 3527|      0|                            NULL, 10, &retry_after);
 3528|      0|    }
 3529|      0|    else
 3530|       |      /* convert date to number of seconds into the future */
 3531|      0|      retry_after = date - time(NULL);
 3532|      0|    data->info.retry_after = retry_after; /* store it */
 3533|      0|  }
 3534|  16.9k|  else if(!k->http_bodyless && checkprefix("Content-Range:", headp)) {
 3535|       |    /* Content-Range: bytes [num]-
 3536|       |       Content-Range: bytes: [num]-
 3537|       |       Content-Range: [num]-
 3538|       |       Content-Range: [asterisk]/[total]
 3539|       |
 3540|       |       The second format was added since Sun's webserver
 3541|       |       JavaWebServer/1.1.1 obviously sends the header this way!
 3542|       |       The third added since some servers use that!
 3543|       |       The forth means the requested range was unsatisfied.
 3544|       |    */
 3545|       |
 3546|    239|    char *ptr = headp + strlen("Content-Range:");
 3547|       |
 3548|       |    /* Move forward until first digit or asterisk */
 3549|  2.12k|    while(*ptr && !ISDIGIT(*ptr) && *ptr != '*')
 3550|  1.88k|      ptr++;
 3551|       |
 3552|       |    /* if it truly stopped on a digit */
 3553|    239|    if(ISDIGIT(*ptr)) {
 3554|    208|      if(!curlx_strtoofft(ptr, NULL, 10, &k->offset)) {
 3555|    144|        if(data->state.resume_from == k->offset)
 3556|       |          /* we asked for a resume and we got it */
 3557|     86|          k->content_range = TRUE;
 3558|    144|      }
 3559|    208|    }
 3560|     31|    else
 3561|     31|      data->state.resume_from = 0; /* get everything */
 3562|    239|  }
 3563|  16.7k|#if !defined(CURL_DISABLE_COOKIES)
 3564|  16.7k|  else if(data->cookies && data->state.cookie_engine &&
 3565|  16.7k|          checkprefix("Set-Cookie:", headp)) {
 3566|       |    /* If there is a custom-set Host: name, use it here, or else use real peer
 3567|       |       host name. */
 3568|  8.14k|    const char *host = data->state.aptr.cookiehost?
 3569|  8.14k|      data->state.aptr.cookiehost:conn->host.name;
 3570|  8.14k|    const bool secure_context =
 3571|  8.14k|      conn->handler->protocol&CURLPROTO_HTTPS ||
 3572|  8.14k|      strcasecompare("localhost", host) ||
 3573|  8.14k|      !strcmp(host, "127.0.0.1") ||
 3574|  8.14k|      !strcmp(host, "[::1]") ? TRUE : FALSE;
 3575|       |
 3576|  8.14k|    Curl_share_lock(data, CURL_LOCK_DATA_COOKIE,
 3577|  8.14k|                    CURL_LOCK_ACCESS_SINGLE);
 3578|  8.14k|    Curl_cookie_add(data, data->cookies, TRUE, FALSE,
 3579|  8.14k|                    headp + strlen("Set-Cookie:"), host,
 3580|  8.14k|                    data->state.up.path, secure_context);
 3581|  8.14k|    Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
 3582|  8.14k|  }
 3583|  8.56k|#endif
 3584|  8.56k|  else if(!k->http_bodyless && checkprefix("Last-Modified:", headp) &&
 3585|  8.56k|          (data->set.timecondition || data->set.get_filetime) ) {
 3586|      0|    k->timeofdoc = Curl_getdate_capped(headp + strlen("Last-Modified:"));
 3587|      0|    if(data->set.get_filetime)
 3588|      0|      data->info.filetime = k->timeofdoc;
 3589|      0|  }
 3590|  8.56k|  else if((checkprefix("WWW-Authenticate:", headp) &&
 3591|  8.56k|           (401 == k->httpcode)) ||
 3592|  8.56k|          (checkprefix("Proxy-authenticate:", headp) &&
 3593|  8.38k|           (407 == k->httpcode))) {
 3594|       |
 3595|    180|    bool proxy = (k->httpcode == 407) ? TRUE : FALSE;
 3596|    180|    char *auth = Curl_copy_header_value(headp);
 3597|    180|    if(!auth)
 3598|      0|      return CURLE_OUT_OF_MEMORY;
 3599|       |
 3600|    180|    result = Curl_http_input_auth(data, proxy, auth);
 3601|       |
 3602|    180|    free(auth);
 3603|       |
 3604|    180|    if(result)
 3605|      0|      return result;
 3606|    180|  }
 3607|       |#ifdef USE_SPNEGO
 3608|       |  else if(checkprefix("Persistent-Auth:", headp)) {
 3609|       |    struct negotiatedata *negdata = &conn->negotiate;
 3610|       |    struct auth *authp = &data->state.authhost;
 3611|       |    if(authp->picked == CURLAUTH_NEGOTIATE) {
 3612|       |      char *persistentauth = Curl_copy_header_value(headp);
 3613|       |      if(!persistentauth)
 3614|       |        return CURLE_OUT_OF_MEMORY;
 3615|       |      negdata->noauthpersist = checkprefix("false", persistentauth)?
 3616|       |        TRUE:FALSE;
 3617|       |      negdata->havenoauthpersist = TRUE;
 3618|       |      infof(data, "Negotiate: noauthpersist -> %d, header part: %s",
 3619|       |            negdata->noauthpersist, persistentauth);
 3620|       |      free(persistentauth);
 3621|       |    }
 3622|       |  }
 3623|       |#endif
 3624|  8.38k|  else if((k->httpcode >= 300 && k->httpcode < 400) &&
 3625|  8.38k|          checkprefix("Location:", headp) &&
 3626|  8.38k|          !data->req.location) {
 3627|       |    /* this is the URL that the server advises us to use instead */
 3628|    153|    char *location = Curl_copy_header_value(headp);
 3629|    153|    if(!location)
 3630|      0|      return CURLE_OUT_OF_MEMORY;
 3631|    153|    if(!*location)
 3632|       |      /* ignore empty data */
 3633|     10|      free(location);
 3634|    143|    else {
 3635|    143|      data->req.location = location;
 3636|       |
 3637|    143|      if(data->set.http_follow_location) {
 3638|     71|        DEBUGASSERT(!data->req.newurl);
 3639|     71|        data->req.newurl = strdup(data->req.location); /* clone */
 3640|     71|        if(!data->req.newurl)
 3641|      0|          return CURLE_OUT_OF_MEMORY;
 3642|       |
 3643|       |        /* some cases of POST and PUT etc needs to rewind the data
 3644|       |           stream at this point */
 3645|     71|        result = http_perhapsrewind(data, conn);
 3646|     71|        if(result)
 3647|      0|          return result;
 3648|     71|      }
 3649|    143|    }
 3650|    153|  }
 3651|       |
 3652|  8.23k|#ifndef CURL_DISABLE_HSTS
 3653|       |  /* If enabled, the header is incoming and this is over HTTPS */
 3654|  8.23k|  else if(data->hsts && checkprefix("Strict-Transport-Security:", headp) &&
 3655|  8.23k|          (conn->handler->flags & PROTOPT_SSL)) {
 3656|      0|    CURLcode check =
 3657|      0|      Curl_hsts_parse(data->hsts, data->state.up.hostname,
 3658|      0|                      headp + strlen("Strict-Transport-Security:"));
 3659|      0|    if(check)
 3660|      0|      infof(data, "Illegal STS header skipped");
 3661|      0|#ifdef DEBUGBUILD
 3662|      0|    else
 3663|      0|      infof(data, "Parsed STS header fine (%zu entries)",
 3664|      0|            data->hsts->list.size);
 3665|      0|#endif
 3666|      0|  }
 3667|  8.23k|#endif
 3668|  8.23k|#ifndef CURL_DISABLE_ALTSVC
 3669|       |  /* If enabled, the header is incoming and this is over HTTPS */
 3670|  8.23k|  else if(data->asi && checkprefix("Alt-Svc:", headp) &&
 3671|  8.23k|          ((conn->handler->flags & PROTOPT_SSL) ||
 3672|      0|#ifdef CURLDEBUG
 3673|       |           /* allow debug builds to circumvent the HTTPS restriction */
 3674|      0|           getenv("CURL_ALTSVC_HTTP")
 3675|       |#else
 3676|       |           0
 3677|       |#endif
 3678|      0|            )) {
 3679|       |    /* the ALPN of the current request */
 3680|      0|    enum alpnid id = (conn->httpversion == 20) ? ALPN_h2 : ALPN_h1;
 3681|      0|    result = Curl_altsvc_parse(data, data->asi,
 3682|      0|                               headp + strlen("Alt-Svc:"),
 3683|      0|                               id, conn->host.name,
 3684|      0|                               curlx_uitous(conn->remote_port));
 3685|      0|    if(result)
 3686|      0|      return result;
 3687|      0|  }
 3688|  8.23k|#endif
 3689|  8.23k|  else if(conn->handler->protocol & CURLPROTO_RTSP) {
 3690|    371|    result = Curl_rtsp_parseheader(data, headp);
 3691|    371|    if(result)
 3692|      1|      return result;
 3693|    371|  }
 3694|  20.2k|  return CURLE_OK;
 3695|  20.2k|}
Curl_http_statusline:
 3704|    910|{
 3705|    910|  struct SingleRequest *k = &data->req;
 3706|    910|  data->info.httpcode = k->httpcode;
 3707|       |
 3708|    910|  data->info.httpversion = conn->httpversion;
 3709|    910|  if(!data->state.httpversion ||
 3710|    910|     data->state.httpversion > conn->httpversion)
 3711|       |    /* store the lowest server version we encounter */
 3712|    868|    data->state.httpversion = conn->httpversion;
 3713|       |
 3714|       |  /*
 3715|       |   * This code executes as part of processing the header.  As a
 3716|       |   * result, it's not totally clear how to interpret the
 3717|       |   * response code yet as that depends on what other headers may
 3718|       |   * be present.  401 and 407 may be errors, but may be OK
 3719|       |   * depending on how authentication is working.  Other codes
 3720|       |   * are definitely errors, so give up here.
 3721|       |   */
 3722|    910|  if(data->state.resume_from && data->state.httpreq == HTTPREQ_GET &&
 3723|    910|     k->httpcode == 416) {
 3724|       |    /* "Requested Range Not Satisfiable", just proceed and
 3725|       |       pretend this is no error */
 3726|      0|    k->ignorebody = TRUE; /* Avoid appending error msg to good data. */
 3727|      0|  }
 3728|       |
 3729|    910|  if(conn->httpversion == 10) {
 3730|       |    /* Default action for HTTP/1.0 must be to close, unless
 3731|       |       we get one of those fancy headers that tell us the
 3732|       |       server keeps it open for us! */
 3733|     72|    infof(data, "HTTP 1.0, assume close after body");
 3734|     72|    connclose(conn, "HTTP/1.0 close after body");
 3735|     72|  }
 3736|    838|  else if(conn->httpversion == 20 ||
 3737|    838|          (k->upgr101 == UPGR101_REQUESTED && k->httpcode == 101)) {
 3738|     55|    DEBUGF(infof(data, "HTTP/2 found, allow multiplexing"));
 3739|       |    /* HTTP/2 cannot avoid multiplexing since it is a core functionality
 3740|       |       of the protocol */
 3741|     55|    conn->bundle->multiuse = BUNDLE_MULTIPLEX;
 3742|     55|  }
 3743|    783|  else if(conn->httpversion >= 11 &&
 3744|    783|          !conn->bits.close) {
 3745|       |    /* If HTTP version is >= 1.1 and connection is persistent */
 3746|    779|    DEBUGF(infof(data,
 3747|    779|                 "HTTP 1.1 or later with persistent connection"));
 3748|    779|  }
 3749|       |
 3750|    910|  k->http_bodyless = k->httpcode >= 100 && k->httpcode < 200;
 3751|    910|  switch(k->httpcode) {
 3752|     26|  case 304:
 3753|       |    /* (quote from RFC2616, section 10.3.5): The 304 response
 3754|       |     * MUST NOT contain a message-body, and thus is always
 3755|       |     * terminated by the first empty line after the header
 3756|       |     * fields.  */
 3757|     26|    if(data->set.timecondition)
 3758|      0|      data->info.timecond = TRUE;
 3759|       |    /* FALLTHROUGH */
 3760|     35|  case 204:
 3761|       |    /* (quote from RFC2616, section 10.2.5): The server has
 3762|       |     * fulfilled the request but does not need to return an
 3763|       |     * entity-body ... The 204 response MUST NOT include a
 3764|       |     * message-body, and thus is always terminated by the first
 3765|       |     * empty line after the header fields. */
 3766|     35|    k->size = 0;
 3767|     35|    k->maxdownload = 0;
 3768|     35|    k->http_bodyless = TRUE;
 3769|     35|    break;
 3770|    875|  default:
 3771|    875|    break;
 3772|    910|  }
 3773|    910|  return CURLE_OK;
 3774|    910|}
Curl_http_size:
 3782|    480|{
 3783|    480|  struct SingleRequest *k = &data->req;
 3784|    480|  if(data->req.ignore_cl || k->chunk) {
 3785|     36|    k->size = k->maxdownload = -1;
 3786|     36|  }
 3787|    444|  else if(k->size != -1) {
 3788|    238|    if(data->set.max_filesize &&
 3789|    238|       k->size > data->set.max_filesize) {
 3790|      0|      failf(data, "Maximum file size exceeded");
 3791|      0|      return CURLE_FILESIZE_EXCEEDED;
 3792|      0|    }
 3793|    238|    Curl_pgrsSetDownloadSize(data, k->size);
 3794|    238|    k->maxdownload = k->size;
 3795|    238|  }
 3796|    480|  return CURLE_OK;
 3797|    480|}
Curl_http_readwrite_headers:
 3806|  4.13k|{
 3807|  4.13k|  CURLcode result;
 3808|  4.13k|  struct SingleRequest *k = &data->req;
 3809|  4.13k|  ssize_t onread = *nread;
 3810|  4.13k|  char *ostr = k->str;
 3811|  4.13k|  char *headp;
 3812|  4.13k|  char *str_start;
 3813|  4.13k|  char *end_ptr;
 3814|       |
 3815|       |  /* header line within buffer loop */
 3816|  24.2k|  do {
 3817|  24.2k|    size_t rest_length;
 3818|  24.2k|    size_t full_length;
 3819|  24.2k|    int writetype;
 3820|       |
 3821|       |    /* str_start is start of line within buf */
 3822|  24.2k|    str_start = k->str;
 3823|       |
 3824|       |    /* data is in network encoding so use 0x0a instead of '\n' */
 3825|  24.2k|    end_ptr = memchr(str_start, 0x0a, *nread);
 3826|       |
 3827|  24.2k|    if(!end_ptr) {
 3828|       |      /* Not a complete header line within buffer, append the data to
 3829|       |         the end of the headerbuff. */
 3830|  3.39k|      result = Curl_dyn_addn(&data->state.headerb, str_start, *nread);
 3831|  3.39k|      if(result)
 3832|      0|        return result;
 3833|       |
 3834|  3.39k|      if(!k->headerline) {
 3835|       |        /* check if this looks like a protocol header */
 3836|    582|        statusline st =
 3837|    582|          checkprotoprefix(data, conn,
 3838|    582|                           Curl_dyn_ptr(&data->state.headerb),
 3839|    582|                           Curl_dyn_len(&data->state.headerb));
 3840|       |
 3841|    582|        if(st == STATUS_BAD) {
 3842|       |          /* this is not the beginning of a protocol first header line */
 3843|     22|          k->header = FALSE;
 3844|     22|          k->badheader = HEADER_ALLBAD;
 3845|     22|          streamclose(conn, "bad HTTP: No end-of-message indicator");
 3846|     22|          if(!data->set.http09_allowed) {
 3847|     22|            failf(data, "Received HTTP/0.9 when not allowed");
 3848|     22|            return CURLE_UNSUPPORTED_PROTOCOL;
 3849|     22|          }
 3850|      0|          break;
 3851|     22|        }
 3852|    582|      }
 3853|       |
 3854|  3.37k|      break; /* read more and try again */
 3855|  3.39k|    }
 3856|       |
 3857|       |    /* decrease the size of the remaining (supposed) header line */
 3858|  20.8k|    rest_length = (end_ptr - k->str) + 1;
 3859|  20.8k|    *nread -= (ssize_t)rest_length;
 3860|       |
 3861|  20.8k|    k->str = end_ptr + 1; /* move past new line */
 3862|       |
 3863|  20.8k|    full_length = k->str - str_start;
 3864|       |
 3865|  20.8k|    result = Curl_dyn_addn(&data->state.headerb, str_start, full_length);
 3866|  20.8k|    if(result)
 3867|      0|      return result;
 3868|       |
 3869|       |    /****
 3870|       |     * We now have a FULL header line in 'headerb'.
 3871|       |     *****/
 3872|       |
 3873|  20.8k|    if(!k->headerline) {
 3874|       |      /* the first read header */
 3875|    969|      statusline st = checkprotoprefix(data, conn,
 3876|    969|                                       Curl_dyn_ptr(&data->state.headerb),
 3877|    969|                                       Curl_dyn_len(&data->state.headerb));
 3878|    969|      if(st == STATUS_BAD) {
 3879|     22|        streamclose(conn, "bad HTTP: No end-of-message indicator");
 3880|       |        /* this is not the beginning of a protocol first header line */
 3881|     22|        if(!data->set.http09_allowed) {
 3882|     22|          failf(data, "Received HTTP/0.9 when not allowed");
 3883|     22|          return CURLE_UNSUPPORTED_PROTOCOL;
 3884|     22|        }
 3885|      0|        k->header = FALSE;
 3886|      0|        if(*nread)
 3887|       |          /* since there's more, this is a partial bad header */
 3888|      0|          k->badheader = HEADER_PARTHEADER;
 3889|      0|        else {
 3890|       |          /* this was all we read so it's all a bad header */
 3891|      0|          k->badheader = HEADER_ALLBAD;
 3892|      0|          *nread = onread;
 3893|      0|          k->str = ostr;
 3894|      0|          return CURLE_OK;
 3895|      0|        }
 3896|      0|        break;
 3897|      0|      }
 3898|    969|    }
 3899|       |
 3900|       |    /* headers are in network encoding so use 0x0a and 0x0d instead of '\n'
 3901|       |       and '\r' */
 3902|  20.8k|    headp = Curl_dyn_ptr(&data->state.headerb);
 3903|  20.8k|    if((0x0a == *headp) || (0x0d == *headp)) {
 3904|    532|      size_t headerlen;
 3905|       |      /* Zero-length header line means end of headers! */
 3906|       |
 3907|       |#ifdef CURL_DOES_CONVERSIONS
 3908|       |      if(0x0d == *headp) {
 3909|       |        *headp = '\r'; /* replace with CR in host encoding */
 3910|       |        headp++;       /* pass the CR byte */
 3911|       |      }
 3912|       |      if(0x0a == *headp) {
 3913|       |        *headp = '\n'; /* replace with LF in host encoding */
 3914|       |        headp++;       /* pass the LF byte */
 3915|       |      }
 3916|       |#else
 3917|    532|      if('\r' == *headp)
 3918|    448|        headp++; /* pass the \r byte */
 3919|    532|      if('\n' == *headp)
 3920|    432|        headp++; /* pass the \n byte */
 3921|    532|#endif /* CURL_DOES_CONVERSIONS */
 3922|       |
 3923|    532|      if(100 <= k->httpcode && 199 >= k->httpcode) {
 3924|       |        /* "A user agent MAY ignore unexpected 1xx status responses." */
 3925|     53|        switch(k->httpcode) {
 3926|     46|        case 100:
 3927|       |          /*
 3928|       |           * We have made a HTTP PUT or POST and this is 1.1-lingo
 3929|       |           * that tells us that the server is OK with this and ready
 3930|       |           * to receive the data.
 3931|       |           * However, we'll get more headers now so we must get
 3932|       |           * back into the header-parsing state!
 3933|       |           */
 3934|     46|          k->header = TRUE;
 3935|     46|          k->headerline = 0; /* restart the header line counter */
 3936|       |
 3937|       |          /* if we did wait for this do enable write now! */
 3938|     46|          if(k->exp100 > EXP100_SEND_DATA) {
 3939|      4|            k->exp100 = EXP100_SEND_DATA;
 3940|      4|            k->keepon |= KEEP_SEND;
 3941|      4|            Curl_expire_done(data, EXPIRE_100_TIMEOUT);
 3942|      4|          }
 3943|     46|          break;
 3944|      1|        case 101:
 3945|       |          /* Switching Protocols */
 3946|      1|          if(k->upgr101 == UPGR101_REQUESTED) {
 3947|       |            /* Switching to HTTP/2 */
 3948|      0|            infof(data, "Received 101");
 3949|      0|            k->upgr101 = UPGR101_RECEIVED;
 3950|       |
 3951|       |            /* we'll get more headers (HTTP/2 response) */
 3952|      0|            k->header = TRUE;
 3953|      0|            k->headerline = 0; /* restart the header line counter */
 3954|       |
 3955|       |            /* switch to http2 now. The bytes after response headers
 3956|       |               are also processed here, otherwise they are lost. */
 3957|      0|            result = Curl_http2_switched(data, k->str, *nread);
 3958|      0|            if(result)
 3959|      0|              return result;
 3960|      0|            *nread = 0;
 3961|      0|          }
 3962|      1|          else {
 3963|       |            /* Switching to another protocol (e.g. WebSocket) */
 3964|      1|            k->header = FALSE; /* no more header to parse! */
 3965|      1|          }
 3966|      1|          break;
 3967|      6|        default:
 3968|       |          /* the status code 1xx indicates a provisional response, so
 3969|       |             we'll get another set of headers */
 3970|      6|          k->header = TRUE;
 3971|      6|          k->headerline = 0; /* restart the header line counter */
 3972|      6|          break;
 3973|     53|        }
 3974|     53|      }
 3975|    479|      else {
 3976|    479|        k->header = FALSE; /* no more header to parse! */
 3977|       |
 3978|    479|        if((k->size == -1) && !k->chunk && !conn->bits.close &&
 3979|    479|           (conn->httpversion == 11) &&
 3980|    479|           !(conn->handler->protocol & CURLPROTO_RTSP) &&
 3981|    479|           data->state.httpreq != HTTPREQ_HEAD) {
 3982|       |          /* On HTTP 1.1, when connection is not to get closed, but no
 3983|       |             Content-Length nor Transfer-Encoding chunked have been
 3984|       |             received, according to RFC2616 section 4.4 point 5, we
 3985|       |             assume that the server will close the connection to
 3986|       |             signal the end of the document. */
 3987|    177|          infof(data, "no chunk, no close, no size. Assume close to "
 3988|    177|                "signal end");
 3989|    177|          streamclose(conn, "HTTP: No end-of-message indicator");
 3990|    177|        }
 3991|    479|      }
 3992|       |
 3993|    532|      if(!k->header) {
 3994|    480|        result = Curl_http_size(data);
 3995|    480|        if(result)
 3996|      0|          return result;
 3997|    480|      }
 3998|       |
 3999|       |      /* At this point we have some idea about the fate of the connection.
 4000|       |         If we are closing the connection it may result auth failure. */
 4001|    532|#if defined(USE_NTLM)
 4002|    532|      if(conn->bits.close &&
 4003|    532|         (((data->req.httpcode == 401) &&
 4004|    243|           (conn->http_ntlm_state == NTLMSTATE_TYPE2)) ||
 4005|    243|          ((data->req.httpcode == 407) &&
 4006|    243|           (conn->proxy_ntlm_state == NTLMSTATE_TYPE2)))) {
 4007|      0|        infof(data, "Connection closure while negotiating auth (HTTP 1.0?)");
 4008|      0|        data->state.authproblem = TRUE;
 4009|      0|      }
 4010|    532|#endif
 4011|       |#if defined(USE_SPNEGO)
 4012|       |      if(conn->bits.close &&
 4013|       |        (((data->req.httpcode == 401) &&
 4014|       |          (conn->http_negotiate_state == GSS_AUTHRECV)) ||
 4015|       |         ((data->req.httpcode == 407) &&
 4016|       |          (conn->proxy_negotiate_state == GSS_AUTHRECV)))) {
 4017|       |        infof(data, "Connection closure while negotiating auth (HTTP 1.0?)");
 4018|       |        data->state.authproblem = TRUE;
 4019|       |      }
 4020|       |      if((conn->http_negotiate_state == GSS_AUTHDONE) &&
 4021|       |         (data->req.httpcode != 401)) {
 4022|       |        conn->http_negotiate_state = GSS_AUTHSUCC;
 4023|       |      }
 4024|       |      if((conn->proxy_negotiate_state == GSS_AUTHDONE) &&
 4025|       |         (data->req.httpcode != 407)) {
 4026|       |        conn->proxy_negotiate_state = GSS_AUTHSUCC;
 4027|       |      }
 4028|       |#endif
 4029|       |
 4030|       |      /* now, only output this if the header AND body are requested:
 4031|       |       */
 4032|    532|      writetype = CLIENTWRITE_HEADER;
 4033|    532|      if(data->set.include_header)
 4034|      3|        writetype |= CLIENTWRITE_BODY;
 4035|       |
 4036|    532|      headerlen = Curl_dyn_len(&data->state.headerb);
 4037|    532|      result = Curl_client_write(data, writetype,
 4038|    532|                                 Curl_dyn_ptr(&data->state.headerb),
 4039|    532|                                 headerlen);
 4040|    532|      if(result)
 4041|      0|        return result;
 4042|       |
 4043|    532|      data->info.header_size += (long)headerlen;
 4044|    532|      data->req.headerbytecount += (long)headerlen;
 4045|       |
 4046|       |      /*
 4047|       |       * When all the headers have been parsed, see if we should give
 4048|       |       * up and return an error.
 4049|       |       */
 4050|    532|      if(http_should_fail(data)) {
 4051|      0|        failf(data, "The requested URL returned error: %d",
 4052|      0|              k->httpcode);
 4053|      0|        return CURLE_HTTP_RETURNED_ERROR;
 4054|      0|      }
 4055|       |
 4056|    532|      data->req.deductheadercount =
 4057|    532|        (100 <= k->httpcode && 199 >= k->httpcode)?data->req.headerbytecount:0;
 4058|       |
 4059|       |      /* Curl_http_auth_act() checks what authentication methods
 4060|       |       * that are available and decides which one (if any) to
 4061|       |       * use. It will set 'newurl' if an auth method was picked. */
 4062|    532|      result = Curl_http_auth_act(data);
 4063|       |
 4064|    532|      if(result)
 4065|      2|        return result;
 4066|       |
 4067|    530|      if(k->httpcode >= 300) {
 4068|    179|        if((!conn->bits.authneg) && !conn->bits.close &&
 4069|    179|           !conn->bits.rewindaftersend) {
 4070|       |          /*
 4071|       |           * General treatment of errors when about to send data. Including :
 4072|       |           * "417 Expectation Failed", while waiting for 100-continue.
 4073|       |           *
 4074|       |           * The check for close above is done simply because of something
 4075|       |           * else has already deemed the connection to get closed then
 4076|       |           * something else should've considered the big picture and we
 4077|       |           * avoid this check.
 4078|       |           *
 4079|       |           * rewindaftersend indicates that something has told libcurl to
 4080|       |           * continue sending even if it gets discarded
 4081|       |           */
 4082|       |
 4083|     71|          switch(data->state.httpreq) {
 4084|      1|          case HTTPREQ_PUT:
 4085|      2|          case HTTPREQ_POST:
 4086|      2|          case HTTPREQ_POST_FORM:
 4087|      6|          case HTTPREQ_POST_MIME:
 4088|       |            /* We got an error response. If this happened before the whole
 4089|       |             * request body has been sent we stop sending and mark the
 4090|       |             * connection for closure after we've read the entire response.
 4091|       |             */
 4092|      6|            Curl_expire_done(data, EXPIRE_100_TIMEOUT);
 4093|      6|            if(!k->upload_done) {
 4094|      2|              if((k->httpcode == 417) && data->state.expect100header) {
 4095|       |                /* 417 Expectation Failed - try again without the Expect
 4096|       |                   header */
 4097|      0|                infof(data, "Got 417 while waiting for a 100");
 4098|      0|                data->state.disableexpect = TRUE;
 4099|      0|                DEBUGASSERT(!data->req.newurl);
 4100|      0|                data->req.newurl = strdup(data->state.url);
 4101|      0|                Curl_done_sending(data, k);
 4102|      0|              }
 4103|      2|              else if(data->set.http_keep_sending_on_error) {
 4104|      0|                infof(data, "HTTP error before end of send, keep sending");
 4105|      0|                if(k->exp100 > EXP100_SEND_DATA) {
 4106|      0|                  k->exp100 = EXP100_SEND_DATA;
 4107|      0|                  k->keepon |= KEEP_SEND;
 4108|      0|                }
 4109|      0|              }
 4110|      2|              else {
 4111|      2|                infof(data, "HTTP error before end of send, stop sending");
 4112|      2|                streamclose(conn, "Stop sending data before everything sent");
 4113|      2|                result = Curl_done_sending(data, k);
 4114|      2|                if(result)
 4115|      0|                  return result;
 4116|      2|                k->upload_done = TRUE;
 4117|      2|                if(data->state.expect100header)
 4118|      1|                  k->exp100 = EXP100_FAILED;
 4119|      2|              }
 4120|      2|            }
 4121|      6|            break;
 4122|       |
 4123|     65|          default: /* default label present to avoid compiler warnings */
 4124|     65|            break;
 4125|     71|          }
 4126|     71|        }
 4127|       |
 4128|    179|        if(conn->bits.rewindaftersend) {
 4129|       |          /* We rewind after a complete send, so thus we continue
 4130|       |             sending now */
 4131|      0|          infof(data, "Keep sending data to get tossed away!");
 4132|      0|          k->keepon |= KEEP_SEND;
 4133|      0|        }
 4134|    179|      }
 4135|       |
 4136|    530|      if(!k->header) {
 4137|       |        /*
 4138|       |         * really end-of-headers.
 4139|       |         *
 4140|       |         * If we requested a "no body", this is a good time to get
 4141|       |         * out and return home.
 4142|       |         */
 4143|    478|        if(data->set.opt_no_body)
 4144|     11|          *stop_reading = TRUE;
 4145|    467|#ifndef CURL_DISABLE_RTSP
 4146|    467|        else if((conn->handler->protocol & CURLPROTO_RTSP) &&
 4147|    467|                (data->set.rtspreq == RTSPREQ_DESCRIBE) &&
 4148|    467|                (k->size <= -1))
 4149|       |          /* Respect section 4.4 of rfc2326: If the Content-Length header is
 4150|       |             absent, a length 0 must be assumed.  It will prevent libcurl from
 4151|       |             hanging on DESCRIBE request that got refused for whatever
 4152|       |             reason */
 4153|      0|          *stop_reading = TRUE;
 4154|    478|#endif
 4155|       |
 4156|       |        /* If max download size is *zero* (nothing) we already have
 4157|       |           nothing and can safely return ok now!  But for HTTP/2, we'd
 4158|       |           like to call http2_handle_stream_close to properly close a
 4159|       |           stream.  In order to do this, we keep reading until we
 4160|       |           close the stream. */
 4161|    478|        if(0 == k->maxdownload
 4162|    478|#if defined(USE_NGHTTP2)
 4163|    478|           && !((conn->handler->protocol & PROTO_FAMILY_HTTP) &&
 4164|     44|                conn->httpversion == 20)
 4165|    478|#endif
 4166|    478|           )
 4167|     43|          *stop_reading = TRUE;
 4168|       |
 4169|    478|        if(*stop_reading) {
 4170|       |          /* we make sure that this socket isn't read more now */
 4171|     53|          k->keepon &= ~KEEP_RECV;
 4172|     53|        }
 4173|       |
 4174|    478|        Curl_debug(data, CURLINFO_HEADER_IN, str_start, headerlen);
 4175|    478|        break; /* exit header line loop */
 4176|    478|      }
 4177|       |
 4178|       |      /* We continue reading headers, reset the line-based header */
 4179|     52|      Curl_dyn_reset(&data->state.headerb);
 4180|     52|      continue;
 4181|    530|    }
 4182|       |
 4183|       |    /*
 4184|       |     * Checks for special headers coming up.
 4185|       |     */
 4186|       |
 4187|  20.2k|    if(!k->headerline++) {
 4188|       |      /* This is the first header, it MUST be the error code line
 4189|       |         or else we consider this to be the body right away! */
 4190|    947|      int httpversion_major;
 4191|    947|      int rtspversion_major;
 4192|    947|      int nc = 0;
 4193|       |#ifdef CURL_DOES_CONVERSIONS
 4194|       |#define HEADER1 scratch
 4195|       |#define SCRATCHSIZE 21
 4196|       |      CURLcode res;
 4197|       |      char scratch[SCRATCHSIZE + 1]; /* "HTTP/major.minor 123" */
 4198|       |      /* We can't really convert this yet because we don't know if it's the
 4199|       |         1st header line or the body.  So we do a partial conversion into a
 4200|       |         scratch area, leaving the data at 'headp' as-is.
 4201|       |      */
 4202|       |      strncpy(&scratch[0], headp, SCRATCHSIZE);
 4203|       |      scratch[SCRATCHSIZE] = 0; /* null terminate */
 4204|       |      res = Curl_convert_from_network(data,
 4205|       |                                      &scratch[0],
 4206|       |                                      SCRATCHSIZE);
 4207|       |      if(res)
 4208|       |        /* Curl_convert_from_network calls failf if unsuccessful */
 4209|       |        return res;
 4210|       |#else
 4211|    947|#define HEADER1 headp /* no conversion needed, just use headp */
 4212|    947|#endif /* CURL_DOES_CONVERSIONS */
 4213|       |
 4214|    947|      if(conn->handler->protocol & PROTO_FAMILY_HTTP) {
 4215|       |        /*
 4216|       |         * https://tools.ietf.org/html/rfc7230#section-3.1.2
 4217|       |         *
 4218|       |         * The response code is always a three-digit number in HTTP as the spec
 4219|       |         * says. We allow any three-digit number here, but we cannot make
 4220|       |         * guarantees on future behaviors since it isn't within the protocol.
 4221|       |         */
 4222|    884|        char separator;
 4223|    884|        char twoorthree[2];
 4224|    884|        int httpversion = 0;
 4225|    884|        char digit4 = 0;
 4226|    884|        nc = sscanf(HEADER1,
 4227|    884|                    " HTTP/%1d.%1d%c%3d%c",
 4228|    884|                    &httpversion_major,
 4229|    884|                    &httpversion,
 4230|    884|                    &separator,
 4231|    884|                    &k->httpcode,
 4232|    884|                    &digit4);
 4233|       |
 4234|    884|        if(nc == 1 && httpversion_major >= 2 &&
 4235|    884|           2 == sscanf(HEADER1, " HTTP/%1[23] %d", twoorthree, &k->httpcode)) {
 4236|     33|          conn->httpversion = 0;
 4237|     33|          nc = 4;
 4238|     33|          separator = ' ';
 4239|     33|        }
 4240|       |
 4241|       |        /* There can only be a 4th response code digit stored in 'digit4' if
 4242|       |           all the other fields were parsed and stored first, so nc is 5 when
 4243|       |           digit4 a digit.
 4244|       |
 4245|       |           The sscanf() line above will also allow zero-prefixed and negative
 4246|       |           numbers, so we check for that too here.
 4247|       |        */
 4248|    851|        else if(ISDIGIT(digit4) || (k->httpcode < 100)) {
 4249|     23|          failf(data, "Unsupported response code in HTTP response");
 4250|     23|          return CURLE_UNSUPPORTED_PROTOCOL;
 4251|     23|        }
 4252|       |
 4253|    861|        if((nc >= 4) && (' ' == separator)) {
 4254|    858|          httpversion += 10 * httpversion_major;
 4255|    858|          switch(httpversion) {
 4256|     71|          case 10:
 4257|    797|          case 11:
 4258|    797|#if defined(USE_NGHTTP2) || defined(USE_HYPER)
 4259|    852|          case 20:
 4260|    852|#endif
 4261|       |#if defined(ENABLE_QUIC)
 4262|       |          case 30:
 4263|       |#endif
 4264|    852|            conn->httpversion = (unsigned char)httpversion;
 4265|    852|            break;
 4266|      6|          default:
 4267|      6|            failf(data, "Unsupported HTTP version (%u.%d) in response",
 4268|      6|                  httpversion/10, httpversion%10);
 4269|      6|            return CURLE_UNSUPPORTED_PROTOCOL;
 4270|    858|          }
 4271|       |
 4272|    852|          if(k->upgr101 == UPGR101_RECEIVED) {
 4273|       |            /* supposedly upgraded to http2 now */
 4274|      0|            if(conn->httpversion != 20)
 4275|      0|              infof(data, "Lying server, not serving HTTP/2");
 4276|      0|          }
 4277|    852|          if(conn->httpversion < 20) {
 4278|    797|            conn->bundle->multiuse = BUNDLE_NO_MULTIUSE;
 4279|    797|            infof(data, "Mark bundle as not supporting multiuse");
 4280|    797|          }
 4281|    852|        }
 4282|      3|        else if(!nc) {
 4283|       |          /* this is the real world, not a Nirvana
 4284|       |             NCSA 1.5.x returns this crap when asked for HTTP/1.1
 4285|       |          */
 4286|      1|          nc = sscanf(HEADER1, " HTTP %3d", &k->httpcode);
 4287|      1|          conn->httpversion = 10;
 4288|       |
 4289|       |          /* If user has set option HTTP200ALIASES,
 4290|       |             compare header line against list of aliases
 4291|       |          */
 4292|      1|          if(!nc) {
 4293|      1|            statusline check =
 4294|      1|              checkhttpprefix(data,
 4295|      1|                              Curl_dyn_ptr(&data->state.headerb),
 4296|      1|                              Curl_dyn_len(&data->state.headerb));
 4297|      1|            if(check == STATUS_DONE) {
 4298|      1|              nc = 1;
 4299|      1|              k->httpcode = 200;
 4300|      1|              conn->httpversion = 10;
 4301|      1|            }
 4302|      1|          }
 4303|      1|        }
 4304|      2|        else {
 4305|      2|          failf(data, "Unsupported HTTP version in response");
 4306|      2|          return CURLE_UNSUPPORTED_PROTOCOL;
 4307|      2|        }
 4308|    861|      }
 4309|     63|      else if(conn->handler->protocol & CURLPROTO_RTSP) {
 4310|     63|        char separator;
 4311|     63|        int rtspversion;
 4312|     63|        nc = sscanf(HEADER1,
 4313|     63|                    " RTSP/%1d.%1d%c%3d",
 4314|     63|                    &rtspversion_major,
 4315|     63|                    &rtspversion,
 4316|     63|                    &separator,
 4317|     63|                    &k->httpcode);
 4318|     63|        if((nc == 4) && (' ' == separator)) {
 4319|     57|          conn->httpversion = 11; /* For us, RTSP acts like HTTP 1.1 */
 4320|     57|        }
 4321|      6|        else {
 4322|      6|          nc = 0;
 4323|      6|        }
 4324|     63|      }
 4325|       |
 4326|    916|      if(nc) {
 4327|    910|        result = Curl_http_statusline(data, conn);
 4328|    910|        if(result)
 4329|      0|          return result;
 4330|    910|      }
 4331|      6|      else {
 4332|      6|        k->header = FALSE;   /* this is not a header line */
 4333|      6|        break;
 4334|      6|      }
 4335|    916|    }
 4336|       |
 4337|  20.2k|    result = Curl_convert_from_network(data, headp, strlen(headp));
 4338|       |    /* Curl_convert_from_network calls failf if unsuccessful */
 4339|  20.2k|    if(result)
 4340|      0|      return result;
 4341|       |
 4342|  20.2k|    result = Curl_http_header(data, conn, headp);
 4343|  20.2k|    if(result)
 4344|      8|      return result;
 4345|       |
 4346|       |    /*
 4347|       |     * End of header-checks. Write them to the client.
 4348|       |     */
 4349|       |
 4350|  20.2k|    writetype = CLIENTWRITE_HEADER;
 4351|  20.2k|    if(data->set.include_header)
 4352|     36|      writetype |= CLIENTWRITE_BODY;
 4353|       |
 4354|  20.2k|    Curl_debug(data, CURLINFO_HEADER_IN, headp,
 4355|  20.2k|               Curl_dyn_len(&data->state.headerb));
 4356|       |
 4357|  20.2k|    result = Curl_client_write(data, writetype, headp,
 4358|  20.2k|                               Curl_dyn_len(&data->state.headerb));
 4359|  20.2k|    if(result)
 4360|      0|      return result;
 4361|       |
 4362|  20.2k|    data->info.header_size += Curl_dyn_len(&data->state.headerb);
 4363|  20.2k|    data->req.headerbytecount += Curl_dyn_len(&data->state.headerb);
 4364|       |
 4365|  20.2k|    Curl_dyn_reset(&data->state.headerb);
 4366|  20.2k|  }
 4367|  20.2k|  while(*k->str); /* header line within buffer */
 4368|       |
 4369|       |  /* We might have reached the end of the header part here, but
 4370|       |     there might be a non-header part left in the end of the read
 4371|       |     buffer. */
 4372|       |
 4373|  4.05k|  return CURLE_OK;
 4374|  4.13k|}
http.c:http_setup_conn:
  175|  1.23k|{
  176|       |  /* allocate the HTTP-specific struct for the Curl_easy, only to survive
  177|       |     during this request */
  178|  1.23k|  struct HTTP *http;
  179|  1.23k|  DEBUGASSERT(data->req.p.http == NULL);
  180|       |
  181|  1.23k|  http = calloc(1, sizeof(struct HTTP));
  182|  1.23k|  if(!http)
  183|      0|    return CURLE_OUT_OF_MEMORY;
  184|       |
  185|  1.23k|  Curl_mime_initpart(&http->form, data);
  186|  1.23k|  data->req.p.http = http;
  187|       |
  188|  1.23k|  if(data->state.httpwant == CURL_HTTP_VERSION_3) {
  189|      0|    if(conn->handler->flags & PROTOPT_SSL)
  190|       |      /* Only go HTTP/3 directly on HTTPS URLs. It needs a UDP socket and does
  191|       |         the QUIC dance. */
  192|      0|      conn->transport = TRNSPRT_QUIC;
  193|      0|    else {
  194|      0|      failf(data, "HTTP/3 requested for non-HTTPS URL");
  195|      0|      return CURLE_URL_MALFORMAT;
  196|      0|    }
  197|      0|  }
  198|  1.23k|  else {
  199|  1.23k|    if(!CONN_INUSE(conn))
  200|       |      /* if not already multi-using, setup connection details */
  201|  1.23k|      Curl_http2_setup_conn(conn);
  202|  1.23k|    Curl_http2_setup_req(data);
  203|  1.23k|  }
  204|  1.23k|  return CURLE_OK;
  205|  1.23k|}
http.c:pickoneauth:
  387|     59|{
  388|     59|  bool picked;
  389|       |  /* only deal with authentication we want */
  390|     59|  unsigned long avail = pick->avail & pick->want & mask;
  391|     59|  picked = TRUE;
  392|       |
  393|       |  /* The order of these checks is highly relevant, as this will be the order
  394|       |     of preference in case of the existence of multiple accepted types. */
  395|     59|  if(avail & CURLAUTH_NEGOTIATE)
  396|      0|    pick->picked = CURLAUTH_NEGOTIATE;
  397|     59|  else if(avail & CURLAUTH_BEARER)
  398|      0|    pick->picked = CURLAUTH_BEARER;
  399|     59|  else if(avail & CURLAUTH_DIGEST)
  400|     47|    pick->picked = CURLAUTH_DIGEST;
  401|     12|  else if(avail & CURLAUTH_NTLM)
  402|      0|    pick->picked = CURLAUTH_NTLM;
  403|     12|  else if(avail & CURLAUTH_NTLM_WB)
  404|      0|    pick->picked = CURLAUTH_NTLM_WB;
  405|     12|  else if(avail & CURLAUTH_BASIC)
  406|      0|    pick->picked = CURLAUTH_BASIC;
  407|     12|  else if(avail & CURLAUTH_AWS_SIGV4)
  408|      0|    pick->picked = CURLAUTH_AWS_SIGV4;
  409|     12|  else {
  410|     12|    pick->picked = CURLAUTH_PICKNONE; /* we select to use nothing */
  411|     12|    picked = FALSE;
  412|     12|  }
  413|     59|  pick->avail = CURLAUTH_NONE; /* clear it here */
  414|       |
  415|     59|  return picked;
  416|     59|}
http.c:http_perhapsrewind:
  443|     90|{
  444|     90|  struct HTTP *http = data->req.p.http;
  445|     90|  curl_off_t bytessent;
  446|     90|  curl_off_t expectsend = -1; /* default is unknown */
  447|       |
  448|     90|  if(!http)
  449|       |    /* If this is still NULL, we have not reach very far and we can safely
  450|       |       skip this rewinding stuff */
  451|      0|    return CURLE_OK;
  452|       |
  453|     90|  switch(data->state.httpreq) {
  454|     65|  case HTTPREQ_GET:
  455|     69|  case HTTPREQ_HEAD:
  456|     69|    return CURLE_OK;
  457|     21|  default:
  458|     21|    break;
  459|     90|  }
  460|       |
  461|     21|  bytessent = data->req.writebytecount;
  462|       |
  463|     21|  if(conn->bits.authneg) {
  464|       |    /* This is a state where we are known to be negotiating and we don't send
  465|       |       any data then. */
  466|      3|    expectsend = 0;
  467|      3|  }
  468|     18|  else if(!conn->bits.protoconnstart) {
  469|       |    /* HTTP CONNECT in progress: there is no body */
  470|      0|    expectsend = 0;
  471|      0|  }
  472|     18|  else {
  473|       |    /* figure out how much data we are expected to send */
  474|     18|    switch(data->state.httpreq) {
  475|      3|    case HTTPREQ_POST:
  476|      5|    case HTTPREQ_PUT:
  477|      5|      if(data->state.infilesize != -1)
  478|      5|        expectsend = data->state.infilesize;
  479|      5|      break;
  480|      0|    case HTTPREQ_POST_FORM:
  481|     13|    case HTTPREQ_POST_MIME:
  482|     13|      expectsend = http->postsize;
  483|     13|      break;
  484|      0|    default:
  485|      0|      break;
  486|     18|    }
  487|     18|  }
  488|       |
  489|     21|  conn->bits.rewindaftersend = FALSE; /* default */
  490|       |
  491|     21|  if((expectsend == -1) || (expectsend > bytessent)) {
  492|     10|#if defined(USE_NTLM)
  493|       |    /* There is still data left to send */
  494|     10|    if((data->state.authproxy.picked == CURLAUTH_NTLM) ||
  495|     10|       (data->state.authhost.picked == CURLAUTH_NTLM) ||
  496|     10|       (data->state.authproxy.picked == CURLAUTH_NTLM_WB) ||
  497|     10|       (data->state.authhost.picked == CURLAUTH_NTLM_WB)) {
  498|      0|      if(((expectsend - bytessent) < 2000) ||
  499|      0|         (conn->http_ntlm_state != NTLMSTATE_NONE) ||
  500|      0|         (conn->proxy_ntlm_state != NTLMSTATE_NONE)) {
  501|       |        /* The NTLM-negotiation has started *OR* there is just a little (<2K)
  502|       |           data left to send, keep on sending. */
  503|       |
  504|       |        /* rewind data when completely done sending! */
  505|      0|        if(!conn->bits.authneg && (conn->writesockfd != CURL_SOCKET_BAD)) {
  506|      0|          conn->bits.rewindaftersend = TRUE;
  507|      0|          infof(data, "Rewind stream after send");
  508|      0|        }
  509|       |
  510|      0|        return CURLE_OK;
  511|      0|      }
  512|       |
  513|      0|      if(conn->bits.close)
  514|       |        /* this is already marked to get closed */
  515|      0|        return CURLE_OK;
  516|       |
  517|      0|      infof(data, "NTLM send, close instead of sending %"
  518|      0|            CURL_FORMAT_CURL_OFF_T " bytes",
  519|      0|            (curl_off_t)(expectsend - bytessent));
  520|      0|    }
  521|     10|#endif
  522|       |#if defined(USE_SPNEGO)
  523|       |    /* There is still data left to send */
  524|       |    if((data->state.authproxy.picked == CURLAUTH_NEGOTIATE) ||
  525|       |       (data->state.authhost.picked == CURLAUTH_NEGOTIATE)) {
  526|       |      if(((expectsend - bytessent) < 2000) ||
  527|       |         (conn->http_negotiate_state != GSS_AUTHNONE) ||
  528|       |         (conn->proxy_negotiate_state != GSS_AUTHNONE)) {
  529|       |        /* The NEGOTIATE-negotiation has started *OR*
  530|       |        there is just a little (<2K) data left to send, keep on sending. */
  531|       |
  532|       |        /* rewind data when completely done sending! */
  533|       |        if(!conn->bits.authneg && (conn->writesockfd != CURL_SOCKET_BAD)) {
  534|       |          conn->bits.rewindaftersend = TRUE;
  535|       |          infof(data, "Rewind stream after send");
  536|       |        }
  537|       |
  538|       |        return CURLE_OK;
  539|       |      }
  540|       |
  541|       |      if(conn->bits.close)
  542|       |        /* this is already marked to get closed */
  543|       |        return CURLE_OK;
  544|       |
  545|       |      infof(data, "NEGOTIATE send, close instead of sending %"
  546|       |        CURL_FORMAT_CURL_OFF_T " bytes",
  547|       |        (curl_off_t)(expectsend - bytessent));
  548|       |    }
  549|       |#endif
  550|       |
  551|       |    /* This is not NEGOTIATE/NTLM or many bytes left to send: close */
  552|     10|    streamclose(conn, "Mid-auth HTTP and much data left to send");
  553|     10|    data->req.size = 0; /* don't download any more than 0 bytes */
  554|       |
  555|       |    /* There still is data left to send, but this connection is marked for
  556|       |       closure so we can safely do the rewind right now */
  557|     10|  }
  558|       |
  559|     21|  if(bytessent)
  560|       |    /* we rewind now at once since if we already sent something */
  561|      8|    return Curl_readrewind(data);
  562|       |
  563|     13|  return CURLE_OK;
  564|     21|}
http.c:output_auth_headers:
  667|    336|{
  668|    336|  const char *auth = NULL;
  669|    336|  CURLcode result = CURLE_OK;
  670|       |
  671|       |#ifdef CURL_DISABLE_CRYPTO_AUTH
  672|       |  (void)request;
  673|       |  (void)path;
  674|       |#endif
  675|    336|#ifndef CURL_DISABLE_CRYPTO_AUTH
  676|    336|  if(authstatus->picked == CURLAUTH_AWS_SIGV4) {
  677|     11|    auth = "AWS_SIGV4";
  678|     11|    result = Curl_output_aws_sigv4(data, proxy);
  679|     11|    if(result)
  680|      2|      return result;
  681|     11|  }
  682|    325|  else
  683|    325|#endif
  684|       |#ifdef USE_SPNEGO
  685|       |  if(authstatus->picked == CURLAUTH_NEGOTIATE) {
  686|       |    auth = "Negotiate";
  687|       |    result = Curl_output_negotiate(data, conn, proxy);
  688|       |    if(result)
  689|       |      return result;
  690|       |  }
  691|       |  else
  692|       |#endif
  693|    325|#ifdef USE_NTLM
  694|    325|  if(authstatus->picked == CURLAUTH_NTLM) {
  695|      1|    auth = "NTLM";
  696|      1|    result = Curl_output_ntlm(data, proxy);
  697|      1|    if(result)
  698|      0|      return result;
  699|      1|  }
  700|    324|  else
  701|    324|#endif
  702|    324|#if defined(USE_NTLM) && defined(NTLM_WB_ENABLED)
  703|    324|  if(authstatus->picked == CURLAUTH_NTLM_WB) {
  704|      0|    auth = "NTLM_WB";
  705|      0|    result = Curl_output_ntlm_wb(data, conn, proxy);
  706|      0|    if(result)
  707|      0|      return result;
  708|      0|  }
  709|    324|  else
  710|    324|#endif
  711|    324|#ifndef CURL_DISABLE_CRYPTO_AUTH
  712|    324|  if(authstatus->picked == CURLAUTH_DIGEST) {
  713|     77|    auth = "Digest";
  714|     77|    result = Curl_output_digest(data,
  715|     77|                                proxy,
  716|     77|                                (const unsigned char *)request,
  717|     77|                                (const unsigned char *)path);
  718|     77|    if(result)
  719|      0|      return result;
  720|     77|  }
  721|    247|  else
  722|    247|#endif
  723|    247|  if(authstatus->picked == CURLAUTH_BASIC) {
  724|       |    /* Basic */
  725|    199|    if(
  726|    199|#ifndef CURL_DISABLE_PROXY
  727|    199|      (proxy && conn->bits.proxy_user_passwd &&
  728|    199|       !Curl_checkProxyheaders(data, conn, "Proxy-authorization")) ||
  729|    199|#endif
  730|    199|      (!proxy && conn->bits.user_passwd &&
  731|    199|       !Curl_checkheaders(data, "Authorization"))) {
  732|    199|      auth = "Basic";
  733|    199|      result = http_output_basic(data, proxy);
  734|    199|      if(result)
  735|      0|        return result;
  736|    199|    }
  737|       |
  738|       |    /* NOTE: this function should set 'done' TRUE, as the other auth
  739|       |       functions work that way */
  740|    199|    authstatus->done = TRUE;
  741|    199|  }
  742|    334|  if(authstatus->picked == CURLAUTH_BEARER) {
  743|       |    /* Bearer */
  744|      1|    if((!proxy && data->set.str[STRING_BEARER] &&
  745|      1|        !Curl_checkheaders(data, "Authorization"))) {
  746|      0|      auth = "Bearer";
  747|      0|      result = http_output_bearer(data);
  748|      0|      if(result)
  749|      0|        return result;
  750|      0|    }
  751|       |
  752|       |    /* NOTE: this function should set 'done' TRUE, as the other auth
  753|       |       functions work that way */
  754|      1|    authstatus->done = TRUE;
  755|      1|  }
  756|       |
  757|    334|  if(auth) {
  758|    286|#ifndef CURL_DISABLE_PROXY
  759|    286|    infof(data, "%s auth using %s with user '%s'",
  760|    286|          proxy ? "Proxy" : "Server", auth,
  761|    286|          proxy ? (data->state.aptr.proxyuser ?
  762|      0|                   data->state.aptr.proxyuser : "") :
  763|    286|          (data->state.aptr.user ?
  764|    285|           data->state.aptr.user : ""));
  765|       |#else
  766|       |    infof(data, "Server auth using %s with user '%s'",
  767|       |          auth, data->state.aptr.user ?
  768|       |          data->state.aptr.user : "");
  769|       |#endif
  770|    286|    authstatus->multipass = (!authstatus->done) ? TRUE : FALSE;
  771|    286|  }
  772|     48|  else
  773|     48|    authstatus->multipass = FALSE;
  774|       |
  775|    334|  return CURLE_OK;
  776|    334|}
http.c:http_output_basic:
  300|    199|{
  301|    199|  size_t size = 0;
  302|    199|  char *authorization = NULL;
  303|    199|  char **userp;
  304|    199|  const char *user;
  305|    199|  const char *pwd;
  306|    199|  CURLcode result;
  307|    199|  char *out;
  308|       |
  309|       |  /* credentials are unique per transfer for HTTP, do not use the ones for the
  310|       |     connection */
  311|    199|  if(proxy) {
  312|      0|#ifndef CURL_DISABLE_PROXY
  313|      0|    userp = &data->state.aptr.proxyuserpwd;
  314|      0|    user = data->state.aptr.proxyuser;
  315|      0|    pwd = data->state.aptr.proxypasswd;
  316|       |#else
  317|       |    return CURLE_NOT_BUILT_IN;
  318|       |#endif
  319|      0|  }
  320|    199|  else {
  321|    199|    userp = &data->state.aptr.userpwd;
  322|    199|    user = data->state.aptr.user;
  323|    199|    pwd = data->state.aptr.passwd;
  324|    199|  }
  325|       |
  326|    199|  out = aprintf("%s:%s", user ? user : "", pwd ? pwd : "");
  327|    199|  if(!out)
  328|      0|    return CURLE_OUT_OF_MEMORY;
  329|       |
  330|    199|  result = Curl_base64_encode(data, out, strlen(out), &authorization, &size);
  331|    199|  if(result)
  332|      0|    goto fail;
  333|       |
  334|    199|  if(!authorization) {
  335|      0|    result = CURLE_REMOTE_ACCESS_DENIED;
  336|      0|    goto fail;
  337|      0|  }
  338|       |
  339|    199|  free(*userp);
  340|    199|  *userp = aprintf("%sAuthorization: Basic %s\r\n",
  341|    199|                   proxy ? "Proxy-" : "",
  342|    199|                   authorization);
  343|    199|  free(authorization);
  344|    199|  if(!*userp) {
  345|      0|    result = CURLE_OUT_OF_MEMORY;
  346|      0|    goto fail;
  347|      0|  }
  348|       |
  349|    199|  fail:
  350|    199|  free(out);
  351|    199|  return result;
  352|    199|}
http.c:is_valid_auth_separator:
  905|    165|{
  906|    165|  return ch == '\0' || ch == ',' || ISSPACE(ch);
  907|    165|}
http.c:http_should_fail:
 1088|    984|{
 1089|    984|  int httpcode;
 1090|    984|  DEBUGASSERT(data);
 1091|    984|  DEBUGASSERT(data->conn);
 1092|       |
 1093|    984|  httpcode = data->req.httpcode;
 1094|       |
 1095|       |  /*
 1096|       |  ** If we haven't been asked to fail on error,
 1097|       |  ** don't fail.
 1098|       |  */
 1099|    984|  if(!data->set.http_fail_on_error)
 1100|    984|    return FALSE;
 1101|       |
 1102|       |  /*
 1103|       |  ** Any code < 400 is never terminal.
 1104|       |  */
 1105|      0|  if(httpcode < 400)
 1106|      0|    return FALSE;
 1107|       |
 1108|       |  /*
 1109|       |  ** A 416 response to a resume request is presumably because the file is
 1110|       |  ** already completely downloaded and thus not actually a fail.
 1111|       |  */
 1112|      0|  if(data->state.resume_from && data->state.httpreq == HTTPREQ_GET &&
 1113|      0|     httpcode == 416)
 1114|      0|    return FALSE;
 1115|       |
 1116|       |  /*
 1117|       |  ** Any code >= 400 that's not 401 or 407 is always
 1118|       |  ** a terminal error
 1119|       |  */
 1120|      0|  if((httpcode != 401) && (httpcode != 407))
 1121|      0|    return TRUE;
 1122|       |
 1123|       |  /*
 1124|       |  ** All we have left to deal with is 401 and 407
 1125|       |  */
 1126|      0|  DEBUGASSERT((httpcode == 401) || (httpcode == 407));
 1127|       |
 1128|       |  /*
 1129|       |  ** Examine the current authentication state to see if this
 1130|       |  ** is an error.  The idea is for this function to get
 1131|       |  ** called after processing all the headers in a response
 1132|       |  ** message.  So, if we've been to asked to authenticate a
 1133|       |  ** particular stage, and we've done it, we're OK.  But, if
 1134|       |  ** we're already completely authenticated, it's not OK to
 1135|       |  ** get another 401 or 407.
 1136|       |  **
 1137|       |  ** It is possible for authentication to go stale such that
 1138|       |  ** the client needs to reauthenticate.  Once that info is
 1139|       |  ** available, use it here.
 1140|       |  */
 1141|       |
 1142|       |  /*
 1143|       |  ** Either we're not authenticating, or we're supposed to
 1144|       |  ** be authenticating something else.  This is an error.
 1145|       |  */
 1146|      0|  if((httpcode == 401) && !data->conn->bits.user_passwd)
 1147|      0|    return TRUE;
 1148|      0|#ifndef CURL_DISABLE_PROXY
 1149|      0|  if((httpcode == 407) && !data->conn->bits.proxy_user_passwd)
 1150|      0|    return TRUE;
 1151|      0|#endif
 1152|       |
 1153|      0|  return data->state.authproblem;
 1154|      0|}
http.c:expect100:
 1710|     15|{
 1711|     15|  CURLcode result = CURLE_OK;
 1712|     15|  data->state.expect100header = FALSE; /* default to false unless it is set
 1713|       |                                          to TRUE below */
 1714|     15|  if(!data->state.disableexpect && Curl_use_http_1_1plus(data, conn) &&
 1715|     15|     (conn->httpversion < 20)) {
 1716|       |    /* if not doing HTTP 1.0 or version 2, or disabled explicitly, we add an
 1717|       |       Expect: 100-continue to the headers which actually speeds up post
 1718|       |       operations (as there is one packet coming back from the web server) */
 1719|     15|    const char *ptr = Curl_checkheaders(data, "Expect");
 1720|     15|    if(ptr) {
 1721|      0|      data->state.expect100header =
 1722|      0|        Curl_compareheader(ptr, "Expect:", "100-continue");
 1723|      0|    }
 1724|     15|    else {
 1725|     15|      result = Curl_dyn_add(req, "Expect: 100-continue\r\n");
 1726|     15|      if(!result)
 1727|     15|        data->state.expect100header = TRUE;
 1728|     15|    }
 1729|     15|  }
 1730|       |
 1731|     15|  return result;
 1732|     15|}
http.c:get_http_string:
 1687|  1.22k|{
 1688|       |#ifdef ENABLE_QUIC
 1689|       |  if((data->state.httpwant == CURL_HTTP_VERSION_3) ||
 1690|       |     (conn->httpversion == 30))
 1691|       |    return "3";
 1692|       |#endif
 1693|       |
 1694|  1.22k|#ifdef USE_NGHTTP2
 1695|  1.22k|  if(conn->proto.httpc.h2)
 1696|      0|    return "2";
 1697|  1.22k|#endif
 1698|       |
 1699|  1.22k|  if(Curl_use_http_1_1plus(data, conn))
 1700|  1.21k|    return "1.1";
 1701|       |
 1702|      6|  return "1.0";
 1703|  1.22k|}
http.c:checkprotoprefix:
 3379|  1.55k|{
 3380|  1.55k|#ifndef CURL_DISABLE_RTSP
 3381|  1.55k|  if(conn->handler->protocol & CURLPROTO_RTSP)
 3382|     80|    return checkrtspprefix(data, s, len);
 3383|       |#else
 3384|       |  (void)conn;
 3385|       |#endif /* CURL_DISABLE_RTSP */
 3386|       |
 3387|  1.47k|  return checkhttpprefix(data, s, len);
 3388|  1.55k|}
http.c:checkrtspprefix:
 3348|     80|{
 3349|     80|  statusline result = STATUS_BAD;
 3350|     80|  statusline onmatch = len >= 5? STATUS_DONE : STATUS_UNKNOWN;
 3351|       |
 3352|       |#ifdef CURL_DOES_CONVERSIONS
 3353|       |  /* convert from the network encoding using a scratch area */
 3354|       |  char *scratch = strdup(s);
 3355|       |  if(NULL == scratch) {
 3356|       |    failf(data, "Failed to allocate memory for conversion!");
 3357|       |    return FALSE; /* can't return CURLE_OUT_OF_MEMORY so return FALSE */
 3358|       |  }
 3359|       |  if(CURLE_OK != Curl_convert_from_network(data, scratch, strlen(s) + 1)) {
 3360|       |    /* Curl_convert_from_network calls failf if unsuccessful */
 3361|       |    result = FALSE; /* can't return CURLE_foobar so return FALSE */
 3362|       |  }
 3363|       |  else if(checkprefixmax("RTSP/", scratch, len))
 3364|       |    result = onmatch;
 3365|       |  free(scratch);
 3366|       |#else
 3367|     80|  (void)data; /* unused */
 3368|     80|  if(checkprefixmax("RTSP/", s, len))
 3369|     73|    result = onmatch;
 3370|     80|#endif /* CURL_DOES_CONVERSIONS */
 3371|       |
 3372|     80|  return result;
 3373|     80|}
http.c:checkprefixmax:
 3295|  1.55k|{
 3296|  1.55k|  size_t ch = CURLMIN(strlen(prefix), len);
 3297|  1.55k|  return curl_strnequal(prefix, buffer, ch);
 3298|  1.55k|}
http.c:checkhttpprefix:
 3308|  1.47k|{
 3309|  1.47k|  struct curl_slist *head = data->set.http200aliases;
 3310|  1.47k|  statusline rc = STATUS_BAD;
 3311|  1.47k|  statusline onmatch = len >= 5? STATUS_DONE : STATUS_UNKNOWN;
 3312|       |#ifdef CURL_DOES_CONVERSIONS
 3313|       |  /* convert from the network encoding using a scratch area */
 3314|       |  char *scratch = strdup(s);
 3315|       |  if(NULL == scratch) {
 3316|       |    failf(data, "Failed to allocate memory for conversion!");
 3317|       |    return FALSE; /* can't return CURLE_OUT_OF_MEMORY so return FALSE */
 3318|       |  }
 3319|       |  if(CURLE_OK != Curl_convert_from_network(data, scratch, strlen(s) + 1)) {
 3320|       |    /* Curl_convert_from_network calls failf if unsuccessful */
 3321|       |    free(scratch);
 3322|       |    return FALSE; /* can't return CURLE_foobar so return FALSE */
 3323|       |  }
 3324|       |  s = scratch;
 3325|       |#endif /* CURL_DOES_CONVERSIONS */
 3326|       |
 3327|  1.47k|  while(head) {
 3328|      0|    if(checkprefixmax(head->data, s, len)) {
 3329|      0|      rc = onmatch;
 3330|      0|      break;
 3331|      0|    }
 3332|      0|    head = head->next;
 3333|      0|  }
 3334|       |
 3335|  1.47k|  if((rc != STATUS_DONE) && (checkprefixmax("HTTP/", s, len)))
 3336|  1.43k|    rc = onmatch;
 3337|       |
 3338|       |#ifdef CURL_DOES_CONVERSIONS
 3339|       |  free(scratch);
 3340|       |#endif /* CURL_DOES_CONVERSIONS */
 3341|  1.47k|  return rc;
 3342|  1.47k|}

Curl_http2_init_state:
   83|  2.94k|{
   84|  2.94k|  state->stream_weight = NGHTTP2_DEFAULT_WEIGHT;
   85|  2.94k|}
Curl_http2_init_userset:
   92|  6.25k|{
   93|  6.25k|  set->stream_weight = NGHTTP2_DEFAULT_WEIGHT;
   94|  6.25k|}
Curl_http2_setup_req:
  287|  1.23k|{
  288|  1.23k|  struct HTTP *http = data->req.p.http;
  289|  1.23k|  http->bodystarted = FALSE;
  290|  1.23k|  http->status_code = -1;
  291|  1.23k|  http->pausedata = NULL;
  292|  1.23k|  http->pauselen = 0;
  293|  1.23k|  http->closed = FALSE;
  294|  1.23k|  http->close_handled = FALSE;
  295|  1.23k|  http->mem = NULL;
  296|  1.23k|  http->len = 0;
  297|  1.23k|  http->memlen = 0;
  298|  1.23k|  http->error = NGHTTP2_NO_ERROR;
  299|  1.23k|}
Curl_http2_setup_conn:
  303|  1.23k|{
  304|  1.23k|  conn->proto.httpc.settings.max_concurrent_streams =
  305|  1.23k|    DEFAULT_MAX_CONCURRENT_STREAMS;
  306|  1.23k|}
Curl_http2_done:
 1206|  1.38k|{
 1207|  1.38k|  struct HTTP *http = data->req.p.http;
 1208|  1.38k|  struct http_conn *httpc = &data->conn->proto.httpc;
 1209|       |
 1210|       |  /* there might be allocated resources done before this got the 'h2' pointer
 1211|       |     setup */
 1212|  1.38k|  Curl_dyn_free(&http->header_recvbuf);
 1213|  1.38k|  Curl_dyn_free(&http->trailer_recvbuf);
 1214|  1.38k|  if(http->push_headers) {
 1215|       |    /* if they weren't used and then freed before */
 1216|      0|    for(; http->push_headers_used > 0; --http->push_headers_used) {
 1217|      0|      free(http->push_headers[http->push_headers_used - 1]);
 1218|      0|    }
 1219|      0|    free(http->push_headers);
 1220|      0|    http->push_headers = NULL;
 1221|      0|  }
 1222|       |
 1223|  1.38k|  if(!(data->conn->handler->protocol&PROTO_FAMILY_HTTP) ||
 1224|  1.38k|     !httpc->h2) /* not HTTP/2 ? */
 1225|  1.38k|    return;
 1226|       |
 1227|      0|  if(premature) {
 1228|       |    /* RST_STREAM */
 1229|      0|    set_transfer(httpc, data); /* set the transfer */
 1230|      0|    if(!nghttp2_submit_rst_stream(httpc->h2, NGHTTP2_FLAG_NONE,
 1231|      0|                                  http->stream_id, NGHTTP2_STREAM_CLOSED))
 1232|      0|      (void)nghttp2_session_send(httpc->h2);
 1233|       |
 1234|      0|    if(http->stream_id == httpc->pause_stream_id) {
 1235|      0|      infof(data, "stopped the pause stream!");
 1236|      0|      httpc->pause_stream_id = 0;
 1237|      0|    }
 1238|      0|  }
 1239|       |
 1240|      0|  if(data->state.drain)
 1241|      0|    drained_transfer(data, httpc);
 1242|       |
 1243|       |  /* -1 means unassigned and 0 means cleared */
 1244|      0|  if(http->stream_id > 0) {
 1245|      0|    int rv = nghttp2_session_set_stream_user_data(httpc->h2,
 1246|      0|                                                  http->stream_id, 0);
 1247|      0|    if(rv) {
 1248|      0|      infof(data, "http/2: failed to clear user_data for stream %d!",
 1249|      0|            http->stream_id);
 1250|      0|      DEBUGASSERT(0);
 1251|      0|    }
 1252|      0|    set_transfer(httpc, NULL);
 1253|      0|    http->stream_id = 0;
 1254|      0|  }
 1255|      0|}
Curl_http2_done_sending:
 1442|    185|{
 1443|    185|  CURLcode result = CURLE_OK;
 1444|       |
 1445|    185|  if((conn->handler == &Curl_handler_http2_ssl) ||
 1446|    185|     (conn->handler == &Curl_handler_http2)) {
 1447|       |    /* make sure this is only attempted for HTTP/2 transfers */
 1448|      0|    struct HTTP *stream = data->req.p.http;
 1449|      0|    struct http_conn *httpc = &conn->proto.httpc;
 1450|      0|    nghttp2_session *h2 = httpc->h2;
 1451|       |
 1452|      0|    if(stream->upload_left) {
 1453|       |      /* If the stream still thinks there's data left to upload. */
 1454|       |
 1455|      0|      stream->upload_left = 0; /* DONE! */
 1456|       |
 1457|       |      /* resume sending here to trigger the callback to get called again so
 1458|       |         that it can signal EOF to nghttp2 */
 1459|      0|      (void)nghttp2_session_resume_data(h2, stream->stream_id);
 1460|      0|      (void)h2_process_pending_input(data, httpc, &result);
 1461|      0|    }
 1462|       |
 1463|       |    /* If nghttp2 still has pending frames unsent */
 1464|      0|    if(nghttp2_session_want_write(h2)) {
 1465|      0|      struct SingleRequest *k = &data->req;
 1466|      0|      int rv;
 1467|       |
 1468|      0|      H2BUGF(infof(data, "HTTP/2 still wants to send data (easy %p)", data));
 1469|       |
 1470|       |      /* and attempt to send the pending frames */
 1471|      0|      rv = h2_session_send(data, h2);
 1472|      0|      if(rv)
 1473|      0|        result = CURLE_SEND_ERROR;
 1474|       |
 1475|      0|      if(nghttp2_session_want_write(h2)) {
 1476|       |         /* re-set KEEP_SEND to make sure we are called again */
 1477|      0|         k->keepon |= KEEP_SEND;
 1478|      0|      }
 1479|      0|    }
 1480|      0|  }
 1481|    185|  return result;
 1482|    185|}
Curl_http2_cleanup_dependencies:
 2482|  6.25k|{
 2483|  6.25k|  while(data->set.stream_dependents) {
 2484|      0|    struct Curl_easy *tmp = data->set.stream_dependents->data;
 2485|      0|    Curl_http2_remove_child(data, tmp);
 2486|      0|    if(data->set.stream_depends_on)
 2487|      0|      Curl_http2_add_child(data->set.stream_depends_on, tmp, FALSE);
 2488|      0|  }
 2489|       |
 2490|  6.25k|  if(data->set.stream_depends_on)
 2491|      0|    Curl_http2_remove_child(data->set.stream_depends_on, data);
 2492|  6.25k|}

Curl_output_aws_sigv4:
   70|     11|{
   71|     11|  CURLcode ret = CURLE_OUT_OF_MEMORY;
   72|     11|  struct connectdata *conn = data->conn;
   73|     11|  size_t len;
   74|     11|  const char *tmp0;
   75|     11|  const char *tmp1;
   76|     11|  char *provider0_low = NULL;
   77|     11|  char *provider0_up = NULL;
   78|     11|  char *provider1_low = NULL;
   79|     11|  char *provider1_mid = NULL;
   80|     11|  char *region = NULL;
   81|     11|  char *service = NULL;
   82|     11|  const char *hostname = conn->host.name;
   83|     11|#ifdef DEBUGBUILD
   84|     11|  char *force_timestamp;
   85|     11|#endif
   86|     11|  time_t clock;
   87|     11|  struct tm tm;
   88|     11|  char timestamp[17];
   89|     11|  char date[9];
   90|     11|  const char *content_type = Curl_checkheaders(data, "Content-Type");
   91|     11|  char *canonical_headers = NULL;
   92|     11|  char *signed_headers = NULL;
   93|     11|  Curl_HttpReq httpreq;
   94|     11|  const char *method;
   95|     11|  size_t post_data_len;
   96|     11|  const char *post_data = data->set.postfields ? data->set.postfields : "";
   97|     11|  unsigned char sha_hash[32];
   98|     11|  char sha_hex[65];
   99|     11|  char *canonical_request = NULL;
  100|     11|  char *request_type = NULL;
  101|     11|  char *credential_scope = NULL;
  102|     11|  char *str_to_sign = NULL;
  103|     11|  const char *user = data->state.aptr.user ? data->state.aptr.user : "";
  104|     11|  const char *passwd = data->state.aptr.passwd ? data->state.aptr.passwd : "";
  105|     11|  char *secret = NULL;
  106|     11|  unsigned char tmp_sign0[32] = {0};
  107|     11|  unsigned char tmp_sign1[32] = {0};
  108|     11|  char *auth_headers = NULL;
  109|       |
  110|     11|  DEBUGASSERT(!proxy);
  111|     11|  (void)proxy;
  112|       |
  113|     11|  if(Curl_checkheaders(data, "Authorization")) {
  114|       |    /* Authorization already present, Bailing out */
  115|      0|    return CURLE_OK;
  116|      0|  }
  117|       |
  118|       |  /*
  119|       |   * Parameters parsing
  120|       |   * Google and Outscale use the same OSC or GOOG,
  121|       |   * but Amazon uses AWS and AMZ for header arguments.
  122|       |   * AWS is the default because most of non-amazon providers
  123|       |   * are still using aws:amz as a prefix.
  124|       |   */
  125|     11|  tmp0 = data->set.str[STRING_AWS_SIGV4] ?
  126|     11|    data->set.str[STRING_AWS_SIGV4] : "aws:amz";
  127|     11|  tmp1 = strchr(tmp0, ':');
  128|     11|  len = tmp1 ? (size_t)(tmp1 - tmp0) : strlen(tmp0);
  129|     11|  if(len < 1) {
  130|      0|    infof(data, "first provider can't be empty");
  131|      0|    ret = CURLE_BAD_FUNCTION_ARGUMENT;
  132|      0|    goto fail;
  133|      0|  }
  134|     11|  provider0_low = malloc(len + 1);
  135|     11|  provider0_up = malloc(len + 1);
  136|     11|  if(!provider0_low || !provider0_up) {
  137|      0|    goto fail;
  138|      0|  }
  139|     11|  Curl_strntolower(provider0_low, tmp0, len);
  140|     11|  provider0_low[len] = '\0';
  141|     11|  Curl_strntoupper(provider0_up, tmp0, len);
  142|     11|  provider0_up[len] = '\0';
  143|       |
  144|     11|  if(tmp1) {
  145|     11|    tmp0 = tmp1 + 1;
  146|     11|    tmp1 = strchr(tmp0, ':');
  147|     11|    len = tmp1 ? (size_t)(tmp1 - tmp0) : strlen(tmp0);
  148|     11|    if(len < 1) {
  149|      0|      infof(data, "second provider can't be empty");
  150|      0|      ret = CURLE_BAD_FUNCTION_ARGUMENT;
  151|      0|      goto fail;
  152|      0|    }
  153|     11|    provider1_low = malloc(len + 1);
  154|     11|    provider1_mid = malloc(len + 1);
  155|     11|    if(!provider1_low || !provider1_mid) {
  156|      0|      goto fail;
  157|      0|    }
  158|     11|    Curl_strntolower(provider1_low, tmp0, len);
  159|     11|    provider1_low[len] = '\0';
  160|     11|    Curl_strntolower(provider1_mid, tmp0, len);
  161|     11|    provider1_mid[0] = Curl_raw_toupper(provider1_mid[0]);
  162|     11|    provider1_mid[len] = '\0';
  163|       |
  164|     11|    if(tmp1) {
  165|      0|      tmp0 = tmp1 + 1;
  166|      0|      tmp1 = strchr(tmp0, ':');
  167|      0|      len = tmp1 ? (size_t)(tmp1 - tmp0) : strlen(tmp0);
  168|      0|      if(len < 1) {
  169|      0|        infof(data, "region can't be empty");
  170|      0|        ret = CURLE_BAD_FUNCTION_ARGUMENT;
  171|      0|        goto fail;
  172|      0|      }
  173|      0|      region = Curl_memdup(tmp0, len + 1);
  174|      0|      if(!region) {
  175|      0|        goto fail;
  176|      0|      }
  177|      0|      region[len] = '\0';
  178|       |
  179|      0|      if(tmp1) {
  180|      0|        tmp0 = tmp1 + 1;
  181|      0|        service = strdup(tmp0);
  182|      0|        if(!service) {
  183|      0|          goto fail;
  184|      0|        }
  185|      0|        if(strlen(service) < 1) {
  186|      0|          infof(data, "service can't be empty");
  187|      0|          ret = CURLE_BAD_FUNCTION_ARGUMENT;
  188|      0|          goto fail;
  189|      0|        }
  190|      0|      }
  191|      0|    }
  192|     11|  }
  193|      0|  else {
  194|      0|    provider1_low = Curl_memdup(provider0_low, len + 1);
  195|      0|    provider1_mid = Curl_memdup(provider0_low, len + 1);
  196|      0|    if(!provider1_low || !provider1_mid) {
  197|      0|      goto fail;
  198|      0|    }
  199|      0|    provider1_mid[0] = Curl_raw_toupper(provider1_mid[0]);
  200|      0|  }
  201|       |
  202|     11|  if(!service) {
  203|     11|    tmp0 = hostname;
  204|     11|    tmp1 = strchr(tmp0, '.');
  205|     11|    len = tmp1 - tmp0;
  206|     11|    if(!tmp1 || len < 1) {
  207|      1|      infof(data, "service missing in parameters or hostname");
  208|      1|      ret = CURLE_URL_MALFORMAT;
  209|      1|      goto fail;
  210|      1|    }
  211|     10|    service = Curl_memdup(tmp0, len + 1);
  212|     10|    if(!service) {
  213|      0|      goto fail;
  214|      0|    }
  215|     10|    service[len] = '\0';
  216|       |
  217|     10|    if(!region) {
  218|     10|      tmp0 = tmp1 + 1;
  219|     10|      tmp1 = strchr(tmp0, '.');
  220|     10|      len = tmp1 - tmp0;
  221|     10|      if(!tmp1 || len < 1) {
  222|      1|        infof(data, "region missing in parameters or hostname");
  223|      1|        ret = CURLE_URL_MALFORMAT;
  224|      1|        goto fail;
  225|      1|      }
  226|      9|      region = Curl_memdup(tmp0, len + 1);
  227|      9|      if(!region) {
  228|      0|        goto fail;
  229|      0|      }
  230|      9|      region[len] = '\0';
  231|      9|    }
  232|     10|  }
  233|       |
  234|      9|#ifdef DEBUGBUILD
  235|      9|  force_timestamp = getenv("CURL_FORCETIME");
  236|      9|  if(force_timestamp)
  237|      0|    clock = 0;
  238|      9|  else
  239|      9|    time(&clock);
  240|       |#else
  241|       |  time(&clock);
  242|       |#endif
  243|      9|  ret = Curl_gmtime(clock, &tm);
  244|      9|  if(ret != CURLE_OK) {
  245|      0|    goto fail;
  246|      0|  }
  247|      9|  if(!strftime(timestamp, sizeof(timestamp), "%Y%m%dT%H%M%SZ", &tm)) {
  248|      0|    goto fail;
  249|      0|  }
  250|      9|  memcpy(date, timestamp, sizeof(date));
  251|      9|  date[sizeof(date) - 1] = 0;
  252|       |
  253|      9|  if(content_type) {
  254|      0|    content_type = strchr(content_type, ':');
  255|      0|    if(!content_type) {
  256|      0|      ret = CURLE_FAILED_INIT;
  257|      0|      goto fail;
  258|      0|    }
  259|      0|    content_type++;
  260|       |    /* Skip whitespace now */
  261|      0|    while(*content_type == ' ' || *content_type == '\t')
  262|      0|      ++content_type;
  263|       |
  264|      0|    canonical_headers = curl_maprintf("content-type:%s\n"
  265|      0|                                      "host:%s\n"
  266|      0|                                      "x-%s-date:%s\n",
  267|      0|                                      content_type,
  268|      0|                                      hostname,
  269|      0|                                      provider1_low, timestamp);
  270|      0|    signed_headers = curl_maprintf("content-type;host;x-%s-date",
  271|      0|                                   provider1_low);
  272|      0|  }
  273|      9|  else {
  274|      9|    canonical_headers = curl_maprintf("host:%s\n"
  275|      9|                                      "x-%s-date:%s\n",
  276|      9|                                      hostname,
  277|      9|                                      provider1_low, timestamp);
  278|      9|    signed_headers = curl_maprintf("host;x-%s-date", provider1_low);
  279|      9|  }
  280|       |
  281|      9|  if(!canonical_headers || !signed_headers) {
  282|      0|    goto fail;
  283|      0|  }
  284|       |
  285|      9|  if(data->set.postfieldsize < 0)
  286|      9|    post_data_len = strlen(post_data);
  287|      0|  else
  288|      0|    post_data_len = (size_t)data->set.postfieldsize;
  289|      9|  Curl_sha256it(sha_hash,
  290|      9|                (const unsigned char *) post_data, post_data_len);
  291|      9|  sha256_to_hex(sha_hex, sha_hash, sizeof(sha_hex));
  292|       |
  293|      9|  Curl_http_method(data, conn, &method, &httpreq);
  294|       |
  295|      9|  canonical_request =
  296|      9|    curl_maprintf("%s\n" /* HTTPRequestMethod */
  297|      9|                  "%s\n" /* CanonicalURI */
  298|      9|                  "%s\n" /* CanonicalQueryString */
  299|      9|                  "%s\n" /* CanonicalHeaders */
  300|      9|                  "%s\n" /* SignedHeaders */
  301|      9|                  "%s",  /* HashedRequestPayload in hex */
  302|      9|                  method,
  303|      9|                  data->state.up.path,
  304|      9|                  data->state.up.query ? data->state.up.query : "",
  305|      9|                  canonical_headers,
  306|      9|                  signed_headers,
  307|      9|                  sha_hex);
  308|      9|  if(!canonical_request) {
  309|      0|    goto fail;
  310|      0|  }
  311|       |
  312|      9|  request_type = curl_maprintf("%s4_request", provider0_low);
  313|      9|  if(!request_type) {
  314|      0|    goto fail;
  315|      0|  }
  316|       |
  317|      9|  credential_scope = curl_maprintf("%s/%s/%s/%s",
  318|      9|                                   date, region, service, request_type);
  319|      9|  if(!credential_scope) {
  320|      0|    goto fail;
  321|      0|  }
  322|       |
  323|      9|  Curl_sha256it(sha_hash, (unsigned char *) canonical_request,
  324|      9|                strlen(canonical_request));
  325|      9|  sha256_to_hex(sha_hex, sha_hash, sizeof(sha_hex));
  326|       |
  327|       |  /*
  328|       |   * Google allow to use rsa key instead of HMAC, so this code might change
  329|       |   * In the future, but for now we support only HMAC version
  330|       |   */
  331|      9|  str_to_sign = curl_maprintf("%s4-HMAC-SHA256\n" /* Algorithm */
  332|      9|                              "%s\n" /* RequestDateTime */
  333|      9|                              "%s\n" /* CredentialScope */
  334|      9|                              "%s",  /* HashedCanonicalRequest in hex */
  335|      9|                              provider0_up,
  336|      9|                              timestamp,
  337|      9|                              credential_scope,
  338|      9|                              sha_hex);
  339|      9|  if(!str_to_sign) {
  340|      0|    goto fail;
  341|      0|  }
  342|       |
  343|      9|  secret = curl_maprintf("%s4%s", provider0_up, passwd);
  344|      9|  if(!secret) {
  345|      0|    goto fail;
  346|      0|  }
  347|       |
  348|      9|  HMAC_SHA256(secret, strlen(secret),
  349|      9|              date, strlen(date), tmp_sign0);
  350|      9|  HMAC_SHA256(tmp_sign0, sizeof(tmp_sign0),
  351|      9|              region, strlen(region), tmp_sign1);
  352|      9|  HMAC_SHA256(tmp_sign1, sizeof(tmp_sign1),
  353|      9|              service, strlen(service), tmp_sign0);
  354|      9|  HMAC_SHA256(tmp_sign0, sizeof(tmp_sign0),
  355|      9|              request_type, strlen(request_type), tmp_sign1);
  356|      9|  HMAC_SHA256(tmp_sign1, sizeof(tmp_sign1),
  357|      9|              str_to_sign, strlen(str_to_sign), tmp_sign0);
  358|       |
  359|      9|  sha256_to_hex(sha_hex, tmp_sign0, sizeof(sha_hex));
  360|       |
  361|      9|  auth_headers = curl_maprintf("Authorization: %s4-HMAC-SHA256 "
  362|      9|                               "Credential=%s/%s, "
  363|      9|                               "SignedHeaders=%s, "
  364|      9|                               "Signature=%s\r\n"
  365|      9|                               "X-%s-Date: %s\r\n",
  366|      9|                               provider0_up,
  367|      9|                               user,
  368|      9|                               credential_scope,
  369|      9|                               signed_headers,
  370|      9|                               sha_hex,
  371|      9|                               provider1_mid,
  372|      9|                               timestamp);
  373|      9|  if(!auth_headers) {
  374|      0|    goto fail;
  375|      0|  }
  376|       |
  377|      9|  Curl_safefree(data->state.aptr.userpwd);
  378|      9|  data->state.aptr.userpwd = auth_headers;
  379|      9|  data->state.authhost.done = TRUE;
  380|      9|  ret = CURLE_OK;
  381|       |
  382|     11|fail:
  383|     11|  free(provider0_low);
  384|     11|  free(provider0_up);
  385|     11|  free(provider1_low);
  386|     11|  free(provider1_mid);
  387|     11|  free(region);
  388|     11|  free(service);
  389|     11|  free(canonical_headers);
  390|     11|  free(signed_headers);
  391|     11|  free(canonical_request);
  392|     11|  free(request_type);
  393|     11|  free(credential_scope);
  394|     11|  free(str_to_sign);
  395|     11|  free(secret);
  396|     11|  return ret;
  397|      9|}
http_aws_sigv4.c:sha256_to_hex:
   60|     27|{
   61|     27|  int i;
   62|       |
   63|     27|  DEBUGASSERT(dst_l >= 65);
   64|    891|  for(i = 0; i < 32; ++i) {
   65|    864|    curl_msnprintf(dst + (i * 2), dst_l - (i * 2), "%02x", sha[i]);
   66|    864|  }
   67|     27|}

Curl_httpchunk_init:
   91|     27|{
   92|     27|  struct connectdata *conn = data->conn;
   93|     27|  struct Curl_chunker *chunk = &conn->chunk;
   94|     27|  chunk->hexindex = 0;      /* start at 0 */
   95|     27|  chunk->state = CHUNK_HEX; /* we get hex first! */
   96|     27|  Curl_dyn_init(&conn->trailer, DYN_H1_TRAILER);
   97|     27|}
Curl_httpchunk_read:
  115|     16|{
  116|     16|  CURLcode result = CURLE_OK;
  117|     16|  struct connectdata *conn = data->conn;
  118|     16|  struct Curl_chunker *ch = &conn->chunk;
  119|     16|  struct SingleRequest *k = &data->req;
  120|     16|  size_t piece;
  121|     16|  curl_off_t length = (curl_off_t)datalen;
  122|     16|  size_t *wrote = (size_t *)wrotep;
  123|       |
  124|     16|  *wrote = 0; /* nothing's written yet */
  125|       |
  126|       |  /* the original data is written to the client, but we go on with the
  127|       |     chunk read process, to properly calculate the content length*/
  128|     16|  if(data->set.http_te_skip && !k->ignorebody) {
  129|      0|    result = Curl_client_write(data, CLIENTWRITE_BODY, datap, datalen);
  130|      0|    if(result) {
  131|      0|      *extrap = result;
  132|      0|      return CHUNKE_PASSTHRU_ERROR;
  133|      0|    }
  134|      0|  }
  135|       |
  136|    194|  while(length) {
  137|    188|    switch(ch->state) {
  138|     45|    case CHUNK_HEX:
  139|     45|      if(isxdigit_ascii(*datap)) {
  140|     29|        if(ch->hexindex < CHUNK_MAXNUM_LEN) {
  141|     29|          ch->hexbuffer[ch->hexindex] = *datap;
  142|     29|          datap++;
  143|     29|          length--;
  144|     29|          ch->hexindex++;
  145|     29|        }
  146|      0|        else {
  147|      0|          return CHUNKE_TOO_LONG_HEX; /* longer hex than we support */
  148|      0|        }
  149|     29|      }
  150|     16|      else {
  151|     16|        char *endptr;
  152|     16|        if(0 == ch->hexindex)
  153|       |          /* This is illegal data, we received junk where we expected
  154|       |             a hexadecimal digit. */
  155|      6|          return CHUNKE_ILLEGAL_HEX;
  156|       |
  157|       |        /* length and datap are unmodified */
  158|     10|        ch->hexbuffer[ch->hexindex] = 0;
  159|       |
  160|       |        /* convert to host encoding before calling strtoul */
  161|     10|        result = Curl_convert_from_network(data, ch->hexbuffer, ch->hexindex);
  162|     10|        if(result) {
  163|       |          /* Curl_convert_from_network calls failf if unsuccessful */
  164|       |          /* Treat it as a bad hex character */
  165|      0|          return CHUNKE_ILLEGAL_HEX;
  166|      0|        }
  167|       |
  168|     10|        if(curlx_strtoofft(ch->hexbuffer, &endptr, 16, &ch->datasize))
  169|      0|          return CHUNKE_ILLEGAL_HEX;
  170|     10|        ch->state = CHUNK_LF; /* now wait for the CRLF */
  171|     10|      }
  172|     39|      break;
  173|       |
  174|    135|    case CHUNK_LF:
  175|       |      /* waiting for the LF after a chunk size */
  176|    135|      if(*datap == 0x0a) {
  177|       |        /* we're now expecting data to come, unless size was zero! */
  178|      7|        if(0 == ch->datasize) {
  179|      0|          ch->state = CHUNK_TRAILER; /* now check for trailers */
  180|      0|        }
  181|      7|        else
  182|      7|          ch->state = CHUNK_DATA;
  183|      7|      }
  184|       |
  185|    135|      datap++;
  186|    135|      length--;
  187|    135|      break;
  188|       |
  189|      7|    case CHUNK_DATA:
  190|       |      /* We expect 'datasize' of data. We have 'length' right now, it can be
  191|       |         more or less than 'datasize'. Get the smallest piece.
  192|       |      */
  193|      7|      piece = curlx_sotouz((ch->datasize >= length)?length:ch->datasize);
  194|       |
  195|       |      /* Write the data portion available */
  196|      7|      if(!data->set.http_te_skip && !k->ignorebody) {
  197|      7|        if(!data->set.http_ce_skip && k->writer_stack)
  198|      3|          result = Curl_unencode_write(data, k->writer_stack, datap, piece);
  199|      4|        else
  200|      4|          result = Curl_client_write(data, CLIENTWRITE_BODY, datap, piece);
  201|       |
  202|      7|        if(result) {
  203|      3|          *extrap = result;
  204|      3|          return CHUNKE_PASSTHRU_ERROR;
  205|      3|        }
  206|      7|      }
  207|       |
  208|      4|      *wrote += piece;
  209|      4|      ch->datasize -= piece; /* decrease amount left to expect */
  210|      4|      datap += piece;    /* move read pointer forward */
  211|      4|      length -= piece;   /* decrease space left in this round */
  212|       |
  213|      4|      if(0 == ch->datasize)
  214|       |        /* end of data this round, we now expect a trailing CRLF */
  215|      1|        ch->state = CHUNK_POSTLF;
  216|      4|      break;
  217|       |
  218|      1|    case CHUNK_POSTLF:
  219|      1|      if(*datap == 0x0a) {
  220|       |        /* The last one before we go back to hex state and start all over. */
  221|      0|        Curl_httpchunk_init(data); /* sets state back to CHUNK_HEX */
  222|      0|      }
  223|      1|      else if(*datap != 0x0d)
  224|      1|        return CHUNKE_BAD_CHUNK;
  225|      0|      datap++;
  226|      0|      length--;
  227|      0|      break;
  228|       |
  229|      0|    case CHUNK_TRAILER:
  230|      0|      if((*datap == 0x0d) || (*datap == 0x0a)) {
  231|      0|        char *tr = Curl_dyn_ptr(&conn->trailer);
  232|       |        /* this is the end of a trailer, but if the trailer was zero bytes
  233|       |           there was no trailer and we move on */
  234|       |
  235|      0|        if(tr) {
  236|      0|          size_t trlen;
  237|      0|          result = Curl_dyn_add(&conn->trailer, (char *)"\x0d\x0a");
  238|      0|          if(result)
  239|      0|            return CHUNKE_OUT_OF_MEMORY;
  240|       |
  241|      0|          tr = Curl_dyn_ptr(&conn->trailer);
  242|      0|          trlen = Curl_dyn_len(&conn->trailer);
  243|       |          /* Convert to host encoding before calling Curl_client_write */
  244|      0|          result = Curl_convert_from_network(data, tr, trlen);
  245|      0|          if(result)
  246|       |            /* Curl_convert_from_network calls failf if unsuccessful */
  247|       |            /* Treat it as a bad chunk */
  248|      0|            return CHUNKE_BAD_CHUNK;
  249|       |
  250|      0|          if(!data->set.http_te_skip) {
  251|      0|            result = Curl_client_write(data, CLIENTWRITE_HEADER, tr, trlen);
  252|      0|            if(result) {
  253|      0|              *extrap = result;
  254|      0|              return CHUNKE_PASSTHRU_ERROR;
  255|      0|            }
  256|      0|          }
  257|      0|          Curl_dyn_reset(&conn->trailer);
  258|      0|          ch->state = CHUNK_TRAILER_CR;
  259|      0|          if(*datap == 0x0a)
  260|       |            /* already on the LF */
  261|      0|            break;
  262|      0|        }
  263|      0|        else {
  264|       |          /* no trailer, we're on the final CRLF pair */
  265|      0|          ch->state = CHUNK_TRAILER_POSTCR;
  266|      0|          break; /* don't advance the pointer */
  267|      0|        }
  268|      0|      }
  269|      0|      else {
  270|      0|        result = Curl_dyn_addn(&conn->trailer, datap, 1);
  271|      0|        if(result)
  272|      0|          return CHUNKE_OUT_OF_MEMORY;
  273|      0|      }
  274|      0|      datap++;
  275|      0|      length--;
  276|      0|      break;
  277|       |
  278|      0|    case CHUNK_TRAILER_CR:
  279|      0|      if(*datap == 0x0a) {
  280|      0|        ch->state = CHUNK_TRAILER_POSTCR;
  281|      0|        datap++;
  282|      0|        length--;
  283|      0|      }
  284|      0|      else
  285|      0|        return CHUNKE_BAD_CHUNK;
  286|      0|      break;
  287|       |
  288|      0|    case CHUNK_TRAILER_POSTCR:
  289|       |      /* We enter this state when a CR should arrive so we expect to
  290|       |         have to first pass a CR before we wait for LF */
  291|      0|      if((*datap != 0x0d) && (*datap != 0x0a)) {
  292|       |        /* not a CR then it must be another header in the trailer */
  293|      0|        ch->state = CHUNK_TRAILER;
  294|      0|        break;
  295|      0|      }
  296|      0|      if(*datap == 0x0d) {
  297|       |        /* skip if CR */
  298|      0|        datap++;
  299|      0|        length--;
  300|      0|      }
  301|       |      /* now wait for the final LF */
  302|      0|      ch->state = CHUNK_STOP;
  303|      0|      break;
  304|       |
  305|      0|    case CHUNK_STOP:
  306|      0|      if(*datap == 0x0a) {
  307|      0|        length--;
  308|       |
  309|       |        /* Record the length of any data left in the end of the buffer
  310|       |           even if there's no more chunks to read */
  311|      0|        ch->datasize = curlx_sotouz(length);
  312|       |
  313|      0|        return CHUNKE_STOP; /* return stop */
  314|      0|      }
  315|      0|      else
  316|      0|        return CHUNKE_BAD_CHUNK;
  317|    188|    }
  318|    188|  }
  319|      6|  return CHUNKE_OK;
  320|     16|}
Curl_chunked_strerror:
  323|      7|{
  324|      7|  switch(code) {
  325|      0|  default:
  326|      0|    return "OK";
  327|      0|  case CHUNKE_TOO_LONG_HEX:
  328|      0|    return "Too long hexadecimal number";
  329|      6|  case CHUNKE_ILLEGAL_HEX:
  330|      6|    return "Illegal or missing hexadecimal sequence";
  331|      1|  case CHUNKE_BAD_CHUNK:
  332|      1|    return "Malformed encoding found";
  333|      0|  case CHUNKE_PASSTHRU_ERROR:
  334|      0|    DEBUGASSERT(0); /* never used */
  335|      0|    return "";
  336|      0|  case CHUNKE_BAD_ENCODING:
  337|      0|    return "Bad content-encoding found";
  338|      0|  case CHUNKE_OUT_OF_MEMORY:
  339|      0|    return "Out of memory";
  340|      7|  }
  341|      7|}

Curl_input_digest:
   48|    132|{
   49|       |  /* Point to the correct struct with this */
   50|    132|  struct digestdata *digest;
   51|       |
   52|    132|  if(proxy) {
   53|      0|    digest = &data->state.proxydigest;
   54|      0|  }
   55|    132|  else {
   56|    132|    digest = &data->state.digest;
   57|    132|  }
   58|       |
   59|    132|  if(!checkprefix("Digest", header) || !ISSPACE(header[6]))
   60|      6|    return CURLE_BAD_CONTENT_ENCODING;
   61|       |
   62|    126|  header += strlen("Digest");
   63|    353|  while(*header && ISSPACE(*header))
   64|    227|    header++;
   65|       |
   66|    126|  return Curl_auth_decode_digest_http_message(header, digest);
   67|    132|}
Curl_output_digest:
   73|     77|{
   74|     77|  CURLcode result;
   75|     77|  unsigned char *path = NULL;
   76|     77|  char *tmp = NULL;
   77|     77|  char *response;
   78|     77|  size_t len;
   79|     77|  bool have_chlg;
   80|       |
   81|       |  /* Point to the address of the pointer that holds the string to send to the
   82|       |     server, which is for a plain host or for a HTTP proxy */
   83|     77|  char **allocuserpwd;
   84|       |
   85|       |  /* Point to the name and password for this */
   86|     77|  const char *userp;
   87|     77|  const char *passwdp;
   88|       |
   89|       |  /* Point to the correct struct with this */
   90|     77|  struct digestdata *digest;
   91|     77|  struct auth *authp;
   92|       |
   93|     77|  if(proxy) {
   94|       |#ifdef CURL_DISABLE_PROXY
   95|       |    return CURLE_NOT_BUILT_IN;
   96|       |#else
   97|      0|    digest = &data->state.proxydigest;
   98|      0|    allocuserpwd = &data->state.aptr.proxyuserpwd;
   99|      0|    userp = data->state.aptr.proxyuser;
  100|      0|    passwdp = data->state.aptr.proxypasswd;
  101|      0|    authp = &data->state.authproxy;
  102|      0|#endif
  103|      0|  }
  104|     77|  else {
  105|     77|    digest = &data->state.digest;
  106|     77|    allocuserpwd = &data->state.aptr.userpwd;
  107|     77|    userp = data->state.aptr.user;
  108|     77|    passwdp = data->state.aptr.passwd;
  109|     77|    authp = &data->state.authhost;
  110|     77|  }
  111|       |
  112|     77|  Curl_safefree(*allocuserpwd);
  113|       |
  114|       |  /* not set means empty */
  115|     77|  if(!userp)
  116|      0|    userp = "";
  117|       |
  118|     77|  if(!passwdp)
  119|     64|    passwdp = "";
  120|       |
  121|       |#if defined(USE_WINDOWS_SSPI)
  122|       |  have_chlg = digest->input_token ? TRUE : FALSE;
  123|       |#else
  124|     77|  have_chlg = digest->nonce ? TRUE : FALSE;
  125|     77|#endif
  126|       |
  127|     77|  if(!have_chlg) {
  128|     32|    authp->done = FALSE;
  129|     32|    return CURLE_OK;
  130|     32|  }
  131|       |
  132|       |  /* So IE browsers < v7 cut off the URI part at the query part when they
  133|       |     evaluate the MD5 and some (IIS?) servers work with them so we may need to
  134|       |     do the Digest IE-style. Note that the different ways cause different MD5
  135|       |     sums to get sent.
  136|       |
  137|       |     Apache servers can be set to do the Digest IE-style automatically using
  138|       |     the BrowserMatch feature:
  139|       |     https://httpd.apache.org/docs/2.2/mod/mod_auth_digest.html#msie
  140|       |
  141|       |     Further details on Digest implementation differences:
  142|       |     http://www.fngtps.com/2006/09/http-authentication
  143|       |  */
  144|       |
  145|     45|  if(authp->iestyle) {
  146|     16|    tmp = strchr((char *)uripath, '?');
  147|     16|    if(tmp) {
  148|      1|      size_t urilen = tmp - (char *)uripath;
  149|       |      /* typecast is fine here since the value is always less than 32 bits */
  150|      1|      path = (unsigned char *) aprintf("%.*s", (int)urilen, uripath);
  151|      1|    }
  152|     16|  }
  153|     45|  if(!tmp)
  154|     44|    path = (unsigned char *) strdup((char *) uripath);
  155|       |
  156|     45|  if(!path)
  157|      0|    return CURLE_OUT_OF_MEMORY;
  158|       |
  159|     45|  result = Curl_auth_create_digest_http_message(data, userp, passwdp, request,
  160|     45|                                                path, digest, &response, &len);
  161|     45|  free(path);
  162|     45|  if(result)
  163|      0|    return result;
  164|       |
  165|     45|  *allocuserpwd = aprintf("%sAuthorization: Digest %s\r\n",
  166|     45|                          proxy ? "Proxy-" : "",
  167|     45|                          response);
  168|     45|  free(response);
  169|     45|  if(!*allocuserpwd)
  170|      0|    return CURLE_OUT_OF_MEMORY;
  171|       |
  172|     45|  authp->done = TRUE;
  173|       |
  174|     45|  return CURLE_OK;
  175|     45|}
Curl_http_auth_cleanup_digest:
  178|  6.25k|{
  179|  6.25k|  Curl_auth_digest_cleanup(&data->state.digest);
  180|  6.25k|  Curl_auth_digest_cleanup(&data->state.proxydigest);
  181|  6.25k|}

Curl_output_ntlm:
  128|      1|{
  129|      1|  char *base64 = NULL;
  130|      1|  size_t len = 0;
  131|      1|  CURLcode result = CURLE_OK;
  132|      1|  struct bufref ntlmmsg;
  133|       |
  134|       |  /* point to the address of the pointer that holds the string to send to the
  135|       |     server, which is for a plain host or for a HTTP proxy */
  136|      1|  char **allocuserpwd;
  137|       |
  138|       |  /* point to the username, password, service and host */
  139|      1|  const char *userp;
  140|      1|  const char *passwdp;
  141|      1|  const char *service = NULL;
  142|      1|  const char *hostname = NULL;
  143|       |
  144|       |  /* point to the correct struct with this */
  145|      1|  struct ntlmdata *ntlm;
  146|      1|  curlntlm *state;
  147|      1|  struct auth *authp;
  148|      1|  struct connectdata *conn = data->conn;
  149|       |
  150|      1|  DEBUGASSERT(conn);
  151|      1|  DEBUGASSERT(data);
  152|       |
  153|      1|  if(proxy) {
  154|      0|#ifndef CURL_DISABLE_PROXY
  155|      0|    allocuserpwd = &data->state.aptr.proxyuserpwd;
  156|      0|    userp = data->state.aptr.proxyuser;
  157|      0|    passwdp = data->state.aptr.proxypasswd;
  158|      0|    service = data->set.str[STRING_PROXY_SERVICE_NAME] ?
  159|      0|      data->set.str[STRING_PROXY_SERVICE_NAME] : "HTTP";
  160|      0|    hostname = conn->http_proxy.host.name;
  161|      0|    ntlm = &conn->proxyntlm;
  162|      0|    state = &conn->proxy_ntlm_state;
  163|      0|    authp = &data->state.authproxy;
  164|       |#else
  165|       |    return CURLE_NOT_BUILT_IN;
  166|       |#endif
  167|      0|  }
  168|      1|  else {
  169|      1|    allocuserpwd = &data->state.aptr.userpwd;
  170|      1|    userp = data->state.aptr.user;
  171|      1|    passwdp = data->state.aptr.passwd;
  172|      1|    service = data->set.str[STRING_SERVICE_NAME] ?
  173|      1|      data->set.str[STRING_SERVICE_NAME] : "HTTP";
  174|      1|    hostname = conn->host.name;
  175|      1|    ntlm = &conn->ntlm;
  176|      1|    state = &conn->http_ntlm_state;
  177|      1|    authp = &data->state.authhost;
  178|      1|  }
  179|      1|  authp->done = FALSE;
  180|       |
  181|       |  /* not set means empty */
  182|      1|  if(!userp)
  183|      0|    userp = "";
  184|       |
  185|      1|  if(!passwdp)
  186|      1|    passwdp = "";
  187|       |
  188|       |#ifdef USE_WINDOWS_SSPI
  189|       |  if(!s_hSecDll) {
  190|       |    /* not thread safe and leaks - use curl_global_init() to avoid */
  191|       |    CURLcode err = Curl_sspi_global_init();
  192|       |    if(!s_hSecDll)
  193|       |      return err;
  194|       |  }
  195|       |#ifdef SECPKG_ATTR_ENDPOINT_BINDINGS
  196|       |  ntlm->sslContext = conn->sslContext;
  197|       |#endif
  198|       |#endif
  199|       |
  200|      1|  Curl_bufref_init(&ntlmmsg);
  201|       |
  202|       |  /* connection is already authenticated, don't send a header in future
  203|       |   * requests so go directly to NTLMSTATE_LAST */
  204|      1|  if(*state == NTLMSTATE_TYPE3)
  205|      0|    *state = NTLMSTATE_LAST;
  206|       |
  207|      1|  switch(*state) {
  208|      0|  case NTLMSTATE_TYPE1:
  209|      1|  default: /* for the weird cases we (re)start here */
  210|       |    /* Create a type-1 message */
  211|      1|    result = Curl_auth_create_ntlm_type1_message(data, userp, passwdp,
  212|      1|                                                 service, hostname,
  213|      1|                                                 ntlm, &ntlmmsg);
  214|      1|    if(!result) {
  215|      1|      DEBUGASSERT(Curl_bufref_len(&ntlmmsg) != 0);
  216|      1|      result = Curl_base64_encode(data,
  217|      1|                                  (const char *) Curl_bufref_ptr(&ntlmmsg),
  218|      1|                                  Curl_bufref_len(&ntlmmsg), &base64, &len);
  219|      1|      if(!result) {
  220|      1|        free(*allocuserpwd);
  221|      1|        *allocuserpwd = aprintf("%sAuthorization: NTLM %s\r\n",
  222|      1|                                proxy ? "Proxy-" : "",
  223|      1|                                base64);
  224|      1|        free(base64);
  225|      1|        if(!*allocuserpwd)
  226|      0|          result = CURLE_OUT_OF_MEMORY;
  227|      1|      }
  228|      1|    }
  229|      1|    break;
  230|       |
  231|      1|  case NTLMSTATE_TYPE2:
  232|       |    /* We already received the type-2 message, create a type-3 message */
  233|      0|    result = Curl_auth_create_ntlm_type3_message(data, userp, passwdp,
  234|      0|                                                 ntlm, &ntlmmsg);
  235|      0|    if(!result && Curl_bufref_len(&ntlmmsg)) {
  236|      0|      result = Curl_base64_encode(data,
  237|      0|                                  (const char *) Curl_bufref_ptr(&ntlmmsg),
  238|      0|                                  Curl_bufref_len(&ntlmmsg), &base64, &len);
  239|      0|      if(!result) {
  240|      0|        free(*allocuserpwd);
  241|      0|        *allocuserpwd = aprintf("%sAuthorization: NTLM %s\r\n",
  242|      0|                                proxy ? "Proxy-" : "",
  243|      0|                                base64);
  244|      0|        free(base64);
  245|      0|        if(!*allocuserpwd)
  246|      0|          result = CURLE_OUT_OF_MEMORY;
  247|      0|        else {
  248|      0|          *state = NTLMSTATE_TYPE3; /* we send a type-3 */
  249|      0|          authp->done = TRUE;
  250|      0|        }
  251|      0|      }
  252|      0|    }
  253|      0|    break;
  254|       |
  255|      0|  case NTLMSTATE_LAST:
  256|      0|    Curl_safefree(*allocuserpwd);
  257|      0|    authp->done = TRUE;
  258|      0|    break;
  259|      1|  }
  260|      1|  Curl_bufref_free(&ntlmmsg);
  261|       |
  262|      1|  return result;
  263|      1|}
Curl_http_auth_cleanup_ntlm:
  266|  3.05k|{
  267|  3.05k|  Curl_auth_cleanup_ntlm(&conn->ntlm);
  268|  3.05k|  Curl_auth_cleanup_ntlm(&conn->proxyntlm);
  269|       |
  270|  3.05k|#if defined(NTLM_WB_ENABLED)
  271|  3.05k|  Curl_http_auth_cleanup_ntlm_wb(conn);
  272|  3.05k|#endif
  273|  3.05k|}

Curl_proxy_connect:
   80|  4.31k|{
   81|  4.31k|  struct connectdata *conn = data->conn;
   82|  4.31k|  if(conn->http_proxy.proxytype == CURLPROXY_HTTPS) {
   83|      0|    const CURLcode result = https_proxy_connect(data, sockindex);
   84|      0|    if(result)
   85|      0|      return result;
   86|      0|    if(!conn->bits.proxy_ssl_connected[sockindex])
   87|      0|      return result; /* wait for HTTPS proxy SSL initialization to complete */
   88|      0|  }
   89|       |
   90|  4.31k|  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {
   91|      0|#ifndef CURL_DISABLE_PROXY
   92|       |    /* for [protocol] tunneled through HTTP proxy */
   93|      0|    const char *hostname;
   94|      0|    int remote_port;
   95|      0|    CURLcode result;
   96|       |
   97|       |    /* We want "seamless" operations through HTTP proxy tunnel */
   98|       |
   99|       |    /* for the secondary socket (FTP), use the "connect to host"
  100|       |     * but ignore the "connect to port" (use the secondary port)
  101|       |     */
  102|       |
  103|      0|    if(conn->bits.conn_to_host)
  104|      0|      hostname = conn->conn_to_host.name;
  105|      0|    else if(sockindex == SECONDARYSOCKET)
  106|      0|      hostname = conn->secondaryhostname;
  107|      0|    else
  108|      0|      hostname = conn->host.name;
  109|       |
  110|      0|    if(sockindex == SECONDARYSOCKET)
  111|      0|      remote_port = conn->secondary_port;
  112|      0|    else if(conn->bits.conn_to_port)
  113|      0|      remote_port = conn->conn_to_port;
  114|      0|    else
  115|      0|      remote_port = conn->remote_port;
  116|       |
  117|      0|    result = Curl_proxyCONNECT(data, sockindex, hostname, remote_port);
  118|      0|    if(CURLE_OK != result)
  119|      0|      return result;
  120|      0|    Curl_safefree(data->state.aptr.proxyuserpwd);
  121|       |#else
  122|       |    return CURLE_NOT_BUILT_IN;
  123|       |#endif
  124|      0|  }
  125|       |  /* no HTTP tunnel proxy, just return */
  126|  4.31k|  return CURLE_OK;
  127|  4.31k|}
Curl_connect_ongoing:
  136|  7.23k|{
  137|  7.23k|  return conn->connect_state &&
  138|  7.23k|    (conn->connect_state->tunnel_state <= TUNNEL_COMPLETE);
  139|  7.23k|}
Curl_connect_free:
 1021|  2.45k|{
 1022|  2.45k|  struct connectdata *conn = data->conn;
 1023|  2.45k|  struct http_connect_state *s = conn->connect_state;
 1024|  2.45k|  if(s) {
 1025|      0|    free(s);
 1026|      0|    conn->connect_state = NULL;
 1027|      0|  }
 1028|  2.45k|}

Curl_ipv6_scope:
   65|  2.92k|{
   66|       |#ifndef ENABLE_IPV6
   67|       |  (void) sa;
   68|       |#else
   69|  2.92k|  if(sa->sa_family == AF_INET6) {
   70|      0|    const struct sockaddr_in6 * sa6 = (const struct sockaddr_in6 *)(void *) sa;
   71|      0|    const unsigned char *b = sa6->sin6_addr.s6_addr;
   72|      0|    unsigned short w = (unsigned short) ((b[0] << 8) | b[1]);
   73|       |
   74|      0|    if((b[0] & 0xFE) == 0xFC) /* Handle ULAs */
   75|      0|      return IPV6_SCOPE_UNIQUELOCAL;
   76|      0|    switch(w & 0xFFC0) {
   77|      0|    case 0xFE80:
   78|      0|      return IPV6_SCOPE_LINKLOCAL;
   79|      0|    case 0xFEC0:
   80|      0|      return IPV6_SCOPE_SITELOCAL;
   81|      0|    case 0x0000:
   82|      0|      w = b[1] | b[2] | b[3] | b[4] | b[5] | b[6] | b[7] | b[8] | b[9] |
   83|      0|          b[10] | b[11] | b[12] | b[13] | b[14];
   84|      0|      if(w || b[15] != 0x01)
   85|      0|        break;
   86|      0|      return IPV6_SCOPE_NODELOCAL;
   87|      0|    default:
   88|      0|      break;
   89|      0|    }
   90|      0|  }
   91|  2.92k|#endif
   92|       |
   93|  2.92k|  return IPV6_SCOPE_GLOBAL;
   94|  2.92k|}

imap.c:imap_multi_statemach:
 1379|  1.30k|{
 1380|  1.30k|  CURLcode result = CURLE_OK;
 1381|  1.30k|  struct connectdata *conn = data->conn;
 1382|  1.30k|  struct imap_conn *imapc = &conn->proto.imapc;
 1383|       |
 1384|  1.30k|  if((conn->handler->flags & PROTOPT_SSL) && !imapc->ssldone) {
 1385|     30|    result = Curl_ssl_connect_nonblocking(data, conn, FALSE,
 1386|     30|                                          FIRSTSOCKET, &imapc->ssldone);
 1387|     30|    if(result || !imapc->ssldone)
 1388|     30|      return result;
 1389|     30|  }
 1390|       |
 1391|  1.27k|  result = Curl_pp_statemach(data, &imapc->pp, FALSE, FALSE);
 1392|  1.27k|  *done = (imapc->state == IMAP_STOP) ? TRUE : FALSE;
 1393|       |
 1394|  1.27k|  return result;
 1395|  1.30k|}
imap.c:imap_getsock:
 1428|     74|{
 1429|     74|  return Curl_pp_getsock(data, &conn->proto.imapc.pp, socks);
 1430|     74|}
imap.c:imap_connect:
 1443|    741|{
 1444|    741|  CURLcode result = CURLE_OK;
 1445|    741|  struct connectdata *conn = data->conn;
 1446|    741|  struct imap_conn *imapc = &conn->proto.imapc;
 1447|    741|  struct pingpong *pp = &imapc->pp;
 1448|       |
 1449|    741|  *done = FALSE; /* default to not done yet */
 1450|       |
 1451|       |  /* We always support persistent connections in IMAP */
 1452|    741|  connkeep(conn, "IMAP default");
 1453|       |
 1454|    741|  PINGPONG_SETUP(pp, imap_statemachine, imap_endofresp);
 1455|       |
 1456|       |  /* Set the default preferred authentication type and mechanism */
 1457|    741|  imapc->preftype = IMAP_TYPE_ANY;
 1458|    741|  Curl_sasl_init(&imapc->sasl, data, &saslimap);
 1459|       |
 1460|    741|  Curl_dyn_init(&imapc->dyn, DYN_IMAP_CMD);
 1461|       |  /* Initialise the pingpong layer */
 1462|    741|  Curl_pp_setup(pp);
 1463|    741|  Curl_pp_init(data, pp);
 1464|       |
 1465|       |  /* Parse the URL options */
 1466|    741|  result = imap_parse_url_options(conn);
 1467|    741|  if(result)
 1468|     23|    return result;
 1469|       |
 1470|       |  /* Start off waiting for the server greeting response */
 1471|    718|  state(data, IMAP_SERVERGREET);
 1472|       |
 1473|       |  /* Start off with an response id of '*' */
 1474|    718|  strcpy(imapc->resptag, "*");
 1475|       |
 1476|    718|  result = imap_multi_statemach(data, done);
 1477|       |
 1478|    718|  return result;
 1479|    741|}
imap.c:imap_statemachine:
 1288|  1.90k|{
 1289|  1.90k|  CURLcode result = CURLE_OK;
 1290|  1.90k|  curl_socket_t sock = conn->sock[FIRSTSOCKET];
 1291|  1.90k|  int imapcode;
 1292|  1.90k|  struct imap_conn *imapc = &conn->proto.imapc;
 1293|  1.90k|  struct pingpong *pp = &imapc->pp;
 1294|  1.90k|  size_t nread = 0;
 1295|  1.90k|  (void)data;
 1296|       |
 1297|       |  /* Busy upgrading the connection; right now all I/O is SSL/TLS, not IMAP */
 1298|  1.90k|  if(imapc->state == IMAP_UPGRADETLS)
 1299|      0|    return imap_perform_upgrade_tls(data, conn);
 1300|       |
 1301|       |  /* Flush any data that needs to be sent */
 1302|  1.90k|  if(pp->sendleft)
 1303|      0|    return Curl_pp_flushsend(data, pp);
 1304|       |
 1305|  3.78k|  do {
 1306|       |    /* Read the response from the server */
 1307|  3.78k|    result = Curl_pp_readresp(data, sock, pp, &imapcode, &nread);
 1308|  3.78k|    if(result)
 1309|    851|      return result;
 1310|       |
 1311|       |    /* Was there an error parsing the response line? */
 1312|  2.93k|    if(imapcode == -1)
 1313|    279|      return CURLE_WEIRD_SERVER_REPLY;
 1314|       |
 1315|  2.65k|    if(!imapcode)
 1316|     27|      break;
 1317|       |
 1318|       |    /* We have now received a full IMAP server response */
 1319|  2.63k|    switch(imapc->state) {
 1320|    665|    case IMAP_SERVERGREET:
 1321|    665|      result = imap_state_servergreet_resp(data, imapcode, imapc->state);
 1322|    665|      break;
 1323|       |
 1324|    637|    case IMAP_CAPABILITY:
 1325|    637|      result = imap_state_capability_resp(data, imapcode, imapc->state);
 1326|    637|      break;
 1327|       |
 1328|      0|    case IMAP_STARTTLS:
 1329|      0|      result = imap_state_starttls_resp(data, imapcode, imapc->state);
 1330|      0|      break;
 1331|       |
 1332|      0|    case IMAP_AUTHENTICATE:
 1333|      0|      result = imap_state_auth_resp(data, conn, imapcode, imapc->state);
 1334|      0|      break;
 1335|       |
 1336|      5|    case IMAP_LOGIN:
 1337|      5|      result = imap_state_login_resp(data, imapcode, imapc->state);
 1338|      5|      break;
 1339|       |
 1340|    689|    case IMAP_LIST:
 1341|    692|    case IMAP_SEARCH:
 1342|    692|      result = imap_state_listsearch_resp(data, imapcode, imapc->state);
 1343|    692|      break;
 1344|       |
 1345|    571|    case IMAP_SELECT:
 1346|    571|      result = imap_state_select_resp(data, imapcode, imapc->state);
 1347|    571|      break;
 1348|       |
 1349|     12|    case IMAP_FETCH:
 1350|     12|      result = imap_state_fetch_resp(data, conn, imapcode, imapc->state);
 1351|     12|      break;
 1352|       |
 1353|      4|    case IMAP_FETCH_FINAL:
 1354|      4|      result = imap_state_fetch_final_resp(data, imapcode, imapc->state);
 1355|      4|      break;
 1356|       |
 1357|     33|    case IMAP_APPEND:
 1358|     33|      result = imap_state_append_resp(data, imapcode, imapc->state);
 1359|     33|      break;
 1360|       |
 1361|      2|    case IMAP_APPEND_FINAL:
 1362|      2|      result = imap_state_append_final_resp(data, imapcode, imapc->state);
 1363|      2|      break;
 1364|       |
 1365|      9|    case IMAP_LOGOUT:
 1366|       |      /* fallthrough, just stop! */
 1367|      9|    default:
 1368|       |      /* internal error */
 1369|      9|      state(data, IMAP_STOP);
 1370|      9|      break;
 1371|  2.63k|    }
 1372|  2.63k|  } while(!result && imapc->state != IMAP_STOP && Curl_pp_moredata(pp));
 1373|       |
 1374|    778|  return result;
 1375|  1.90k|}
imap.c:imap_perform_capability:
  435|    659|{
  436|    659|  CURLcode result = CURLE_OK;
  437|    659|  struct imap_conn *imapc = &conn->proto.imapc;
  438|    659|  imapc->sasl.authmechs = SASL_AUTH_NONE; /* No known auth. mechanisms yet */
  439|    659|  imapc->sasl.authused = SASL_AUTH_NONE;  /* Clear the auth. mechanism used */
  440|    659|  imapc->tls_supported = FALSE;           /* Clear the TLS capability */
  441|       |
  442|       |  /* Send the CAPABILITY command */
  443|    659|  result = imap_sendf(data, "CAPABILITY");
  444|       |
  445|    659|  if(!result)
  446|    659|    state(data, IMAP_CAPABILITY);
  447|       |
  448|    659|  return result;
  449|    659|}
imap.c:imap_sendf:
 1765|  1.85k|{
 1766|  1.85k|  CURLcode result = CURLE_OK;
 1767|  1.85k|  struct imap_conn *imapc = &data->conn->proto.imapc;
 1768|       |
 1769|  1.85k|  DEBUGASSERT(fmt);
 1770|       |
 1771|       |  /* Calculate the tag based on the connection ID and command ID */
 1772|  1.85k|  msnprintf(imapc->resptag, sizeof(imapc->resptag), "%c%03d",
 1773|  1.85k|            'A' + curlx_sltosi(data->conn->connection_id % 26),
 1774|  1.85k|            (++imapc->cmdid)%1000);
 1775|       |
 1776|       |  /* start with a blank buffer */
 1777|  1.85k|  Curl_dyn_reset(&imapc->dyn);
 1778|       |
 1779|       |  /* append tag + space + fmt */
 1780|  1.85k|  result = Curl_dyn_addf(&imapc->dyn, "%s %s", imapc->resptag, fmt);
 1781|  1.85k|  if(!result) {
 1782|  1.85k|    va_list ap;
 1783|  1.85k|    va_start(ap, fmt);
 1784|  1.85k|    result = Curl_pp_vsendf(data, &imapc->pp, Curl_dyn_ptr(&imapc->dyn), ap);
 1785|  1.85k|    va_end(ap);
 1786|  1.85k|  }
 1787|  1.85k|  return result;
 1788|  1.85k|}
imap.c:imap_state_servergreet_resp:
  869|    665|{
  870|    665|  struct connectdata *conn = data->conn;
  871|    665|  (void)instate; /* no use for this yet */
  872|       |
  873|    665|  if(imapcode == IMAP_RESP_PREAUTH) {
  874|       |    /* PREAUTH */
  875|      5|    struct imap_conn *imapc = &conn->proto.imapc;
  876|      5|    imapc->preauth = TRUE;
  877|      5|    infof(data, "PREAUTH connection, already authenticated!");
  878|      5|  }
  879|    660|  else if(imapcode != IMAP_RESP_OK) {
  880|      6|    failf(data, "Got unexpected imap-server response");
  881|      6|    return CURLE_WEIRD_SERVER_REPLY;
  882|      6|  }
  883|       |
  884|    659|  return imap_perform_capability(data, conn);
  885|    665|}
imap.c:imap_state_capability_resp:
  891|    637|{
  892|    637|  CURLcode result = CURLE_OK;
  893|    637|  struct connectdata *conn = data->conn;
  894|    637|  struct imap_conn *imapc = &conn->proto.imapc;
  895|    637|  const char *line = data->state.buffer;
  896|       |
  897|    637|  (void)instate; /* no use for this yet */
  898|       |
  899|       |  /* Do we have a untagged response? */
  900|    637|  if(imapcode == '*') {
  901|      0|    line += 2;
  902|       |
  903|       |    /* Loop through the data line */
  904|      0|    for(;;) {
  905|      0|      size_t wordlen;
  906|      0|      while(*line &&
  907|      0|            (*line == ' ' || *line == '\t' ||
  908|      0|              *line == '\r' || *line == '\n')) {
  909|       |
  910|      0|        line++;
  911|      0|      }
  912|       |
  913|      0|      if(!*line)
  914|      0|        break;
  915|       |
  916|       |      /* Extract the word */
  917|      0|      for(wordlen = 0; line[wordlen] && line[wordlen] != ' ' &&
  918|      0|            line[wordlen] != '\t' && line[wordlen] != '\r' &&
  919|      0|            line[wordlen] != '\n';)
  920|      0|        wordlen++;
  921|       |
  922|       |      /* Does the server support the STARTTLS capability? */
  923|      0|      if(wordlen == 8 && !memcmp(line, "STARTTLS", 8))
  924|      0|        imapc->tls_supported = TRUE;
  925|       |
  926|       |      /* Has the server explicitly disabled clear text authentication? */
  927|      0|      else if(wordlen == 13 && !memcmp(line, "LOGINDISABLED", 13))
  928|      0|        imapc->login_disabled = TRUE;
  929|       |
  930|       |      /* Does the server support the SASL-IR capability? */
  931|      0|      else if(wordlen == 7 && !memcmp(line, "SASL-IR", 7))
  932|      0|        imapc->ir_supported = TRUE;
  933|       |
  934|       |      /* Do we have a SASL based authentication mechanism? */
  935|      0|      else if(wordlen > 5 && !memcmp(line, "AUTH=", 5)) {
  936|      0|        size_t llen;
  937|      0|        unsigned short mechbit;
  938|       |
  939|      0|        line += 5;
  940|      0|        wordlen -= 5;
  941|       |
  942|       |        /* Test the word for a matching authentication mechanism */
  943|      0|        mechbit = Curl_sasl_decode_mech(line, wordlen, &llen);
  944|      0|        if(mechbit && llen == wordlen)
  945|      0|          imapc->sasl.authmechs |= mechbit;
  946|      0|      }
  947|       |
  948|      0|      line += wordlen;
  949|      0|    }
  950|      0|  }
  951|    637|  else if(data->set.use_ssl && !conn->ssl[FIRSTSOCKET].use) {
  952|       |    /* PREAUTH is not compatible with STARTTLS. */
  953|      0|    if(imapcode == IMAP_RESP_OK && imapc->tls_supported && !imapc->preauth) {
  954|       |      /* Switch to TLS connection now */
  955|      0|      result = imap_perform_starttls(data);
  956|      0|    }
  957|      0|    else if(data->set.use_ssl <= CURLUSESSL_TRY)
  958|      0|      result = imap_perform_authentication(data, conn);
  959|      0|    else {
  960|      0|      failf(data, "STARTTLS not available.");
  961|      0|      result = CURLE_USE_SSL_FAILED;
  962|      0|    }
  963|      0|  }
  964|    637|  else
  965|    637|    result = imap_perform_authentication(data, conn);
  966|       |
  967|    637|  return result;
  968|    637|}
imap.c:imap_perform_authentication:
  603|    637|{
  604|    637|  CURLcode result = CURLE_OK;
  605|    637|  struct imap_conn *imapc = &conn->proto.imapc;
  606|    637|  saslprogress progress;
  607|       |
  608|       |  /* Check if already authenticated OR if there is enough data to authenticate
  609|       |     with and end the connect phase if we don't */
  610|    637|  if(imapc->preauth ||
  611|    637|     !Curl_sasl_can_authenticate(&imapc->sasl, conn)) {
  612|    617|    state(data, IMAP_STOP);
  613|    617|    return result;
  614|    617|  }
  615|       |
  616|       |  /* Calculate the SASL login details */
  617|     20|  result = Curl_sasl_start(&imapc->sasl, data, imapc->ir_supported, &progress);
  618|       |
  619|     20|  if(!result) {
  620|     20|    if(progress == SASL_INPROGRESS)
  621|      0|      state(data, IMAP_AUTHENTICATE);
  622|     20|    else if(!imapc->login_disabled && (imapc->preftype & IMAP_TYPE_CLEARTEXT))
  623|       |      /* Perform clear text authentication */
  624|     20|      result = imap_perform_login(data, conn);
  625|      0|    else {
  626|       |      /* Other mechanisms not supported */
  627|      0|      infof(data, "No known authentication mechanisms supported!");
  628|      0|      result = CURLE_LOGIN_DENIED;
  629|      0|    }
  630|     20|  }
  631|       |
  632|     20|  return result;
  633|    637|}
imap.c:imap_perform_login:
  503|     20|{
  504|     20|  CURLcode result = CURLE_OK;
  505|     20|  char *user;
  506|     20|  char *passwd;
  507|       |
  508|       |  /* Check we have a username and password to authenticate with and end the
  509|       |     connect phase if we don't */
  510|     20|  if(!conn->bits.user_passwd) {
  511|      0|    state(data, IMAP_STOP);
  512|       |
  513|      0|    return result;
  514|      0|  }
  515|       |
  516|       |  /* Make sure the username and password are in the correct atom format */
  517|     20|  user = imap_atom(conn->user, false);
  518|     20|  passwd = imap_atom(conn->passwd, false);
  519|       |
  520|       |  /* Send the LOGIN command */
  521|     20|  result = imap_sendf(data, "LOGIN %s %s", user ? user : "",
  522|     20|                      passwd ? passwd : "");
  523|       |
  524|     20|  free(user);
  525|     20|  free(passwd);
  526|       |
  527|     20|  if(!result)
  528|     20|    state(data, IMAP_LOGIN);
  529|       |
  530|     20|  return result;
  531|     20|}
imap.c:imap_atom:
 1801|    466|{
 1802|       |  /* !checksrc! disable PARENBRACE 1 */
 1803|    466|  const char atom_specials[] = "(){ %*]";
 1804|    466|  const char *p1;
 1805|    466|  char *p2;
 1806|    466|  size_t backsp_count = 0;
 1807|    466|  size_t quote_count = 0;
 1808|    466|  bool others_exists = FALSE;
 1809|    466|  size_t newlen = 0;
 1810|    466|  char *newstr = NULL;
 1811|       |
 1812|    466|  if(!str)
 1813|      0|    return NULL;
 1814|       |
 1815|       |  /* Look for "atom-specials", counting the backslash and quote characters as
 1816|       |     these will need escaping */
 1817|    466|  p1 = str;
 1818|  27.6k|  while(*p1) {
 1819|  27.1k|    if(*p1 == '\\')
 1820|    101|      backsp_count++;
 1821|  27.0k|    else if(*p1 == '"')
 1822|    119|      quote_count++;
 1823|  26.9k|    else if(!escape_only) {
 1824|  6.78k|      const char *p3 = atom_specials;
 1825|       |
 1826|  27.0k|      while(*p3 && !others_exists) {
 1827|  20.2k|        if(*p1 == *p3)
 1828|     74|          others_exists = TRUE;
 1829|       |
 1830|  20.2k|        p3++;
 1831|  20.2k|      }
 1832|  6.78k|    }
 1833|       |
 1834|  27.1k|    p1++;
 1835|  27.1k|  }
 1836|       |
 1837|       |  /* Does the input contain any "atom-special" characters? */
 1838|    466|  if(!backsp_count && !quote_count && !others_exists)
 1839|    381|    return strdup(str);
 1840|       |
 1841|       |  /* Calculate the new string length */
 1842|     85|  newlen = strlen(str) + backsp_count + quote_count + (escape_only ? 0 : 2);
 1843|       |
 1844|       |  /* Allocate the new string */
 1845|     85|  newstr = (char *) malloc((newlen + 1) * sizeof(char));
 1846|     85|  if(!newstr)
 1847|      0|    return NULL;
 1848|       |
 1849|       |  /* Surround the string in quotes if necessary */
 1850|     85|  p2 = newstr;
 1851|     85|  if(!escape_only) {
 1852|     84|    newstr[0] = '"';
 1853|     84|    newstr[newlen - 1] = '"';
 1854|     84|    p2++;
 1855|     84|  }
 1856|       |
 1857|       |  /* Copy the string, escaping backslash and quote characters along the way */
 1858|     85|  p1 = str;
 1859|  4.78k|  while(*p1) {
 1860|  4.70k|    if(*p1 == '\\' || *p1 == '"') {
 1861|    220|      *p2 = '\\';
 1862|    220|      p2++;
 1863|    220|    }
 1864|       |
 1865|  4.70k|   *p2 = *p1;
 1866|       |
 1867|  4.70k|    p1++;
 1868|  4.70k|    p2++;
 1869|  4.70k|  }
 1870|       |
 1871|       |  /* Terminate the string */
 1872|     85|  newstr[newlen] = '\0';
 1873|       |
 1874|     85|  return newstr;
 1875|     85|}
imap.c:imap_state_login_resp:
 1036|      5|{
 1037|      5|  CURLcode result = CURLE_OK;
 1038|      5|  (void)instate; /* no use for this yet */
 1039|       |
 1040|      5|  if(imapcode != IMAP_RESP_OK) {
 1041|      1|    failf(data, "Access denied. %c", imapcode);
 1042|      1|    result = CURLE_LOGIN_DENIED;
 1043|      1|  }
 1044|      4|  else
 1045|       |    /* End of connect phase */
 1046|      4|    state(data, IMAP_STOP);
 1047|       |
 1048|      5|  return result;
 1049|      5|}
imap.c:imap_state_listsearch_resp:
 1055|    692|{
 1056|    692|  CURLcode result = CURLE_OK;
 1057|    692|  char *line = data->state.buffer;
 1058|    692|  size_t len = strlen(line);
 1059|       |
 1060|    692|  (void)instate; /* No use for this yet */
 1061|       |
 1062|    692|  if(imapcode == '*') {
 1063|       |    /* Temporarily add the LF character back and send as body to the client */
 1064|    666|    line[len] = '\n';
 1065|    666|    result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
 1066|    666|    line[len] = '\0';
 1067|    666|  }
 1068|     26|  else if(imapcode != IMAP_RESP_OK)
 1069|      9|    result = CURLE_QUOTE_ERROR;
 1070|     17|  else
 1071|       |    /* End of DO phase */
 1072|     17|    state(data, IMAP_STOP);
 1073|       |
 1074|    692|  return result;
 1075|    692|}
imap.c:imap_state_select_resp:
 1080|    571|{
 1081|    571|  CURLcode result = CURLE_OK;
 1082|    571|  struct connectdata *conn = data->conn;
 1083|    571|  struct IMAP *imap = data->req.p.imap;
 1084|    571|  struct imap_conn *imapc = &conn->proto.imapc;
 1085|    571|  const char *line = data->state.buffer;
 1086|       |
 1087|    571|  (void)instate; /* no use for this yet */
 1088|       |
 1089|    571|  if(imapcode == '*') {
 1090|       |    /* See if this is an UIDVALIDITY response */
 1091|    535|    char tmp[20];
 1092|    535|    if(sscanf(line + 2, "OK [UIDVALIDITY %19[0123456789]]", tmp) == 1) {
 1093|      0|      Curl_safefree(imapc->mailbox_uidvalidity);
 1094|      0|      imapc->mailbox_uidvalidity = strdup(tmp);
 1095|      0|    }
 1096|    535|  }
 1097|     36|  else if(imapcode == IMAP_RESP_OK) {
 1098|       |    /* Check if the UIDVALIDITY has been specified and matches */
 1099|     34|    if(imap->uidvalidity && imapc->mailbox_uidvalidity &&
 1100|     34|       !strcasecompare(imap->uidvalidity, imapc->mailbox_uidvalidity)) {
 1101|      0|      failf(data, "Mailbox UIDVALIDITY has changed");
 1102|      0|      result = CURLE_REMOTE_FILE_NOT_FOUND;
 1103|      0|    }
 1104|     34|    else {
 1105|       |      /* Note the currently opened mailbox on this connection */
 1106|     34|      imapc->mailbox = strdup(imap->mailbox);
 1107|       |
 1108|     34|      if(imap->custom)
 1109|      1|        result = imap_perform_list(data);
 1110|     33|      else if(imap->query)
 1111|     12|        result = imap_perform_search(data);
 1112|     21|      else
 1113|     21|        result = imap_perform_fetch(data);
 1114|     34|    }
 1115|     34|  }
 1116|      2|  else {
 1117|      2|    failf(data, "Select failed");
 1118|      2|    result = CURLE_LOGIN_DENIED;
 1119|      2|  }
 1120|       |
 1121|    571|  return result;
 1122|    571|}
imap.c:imap_perform_list:
  642|    342|{
  643|    342|  CURLcode result = CURLE_OK;
  644|    342|  struct IMAP *imap = data->req.p.imap;
  645|       |
  646|    342|  if(imap->custom)
  647|       |    /* Send the custom request */
  648|     82|    result = imap_sendf(data, "%s%s", imap->custom,
  649|     82|                        imap->custom_params ? imap->custom_params : "");
  650|    260|  else {
  651|       |    /* Make sure the mailbox is in the correct atom format if necessary */
  652|    260|    char *mailbox = imap->mailbox ? imap_atom(imap->mailbox, true)
  653|    260|                                  : strdup("");
  654|    260|    if(!mailbox)
  655|      0|      return CURLE_OUT_OF_MEMORY;
  656|       |
  657|       |    /* Send the LIST command */
  658|    260|    result = imap_sendf(data, "LIST \"%s\" *", mailbox);
  659|       |
  660|    260|    free(mailbox);
  661|    260|  }
  662|       |
  663|    342|  if(!result)
  664|    342|    state(data, IMAP_LIST);
  665|       |
  666|    342|  return result;
  667|    342|}
imap.c:imap_perform_search:
  829|     12|{
  830|     12|  CURLcode result = CURLE_OK;
  831|     12|  struct IMAP *imap = data->req.p.imap;
  832|       |
  833|       |  /* Check we have a query string */
  834|     12|  if(!imap->query) {
  835|      0|    failf(data, "Cannot SEARCH without a query string.");
  836|      0|    return CURLE_URL_MALFORMAT;
  837|      0|  }
  838|       |
  839|       |  /* Send the SEARCH command */
  840|     12|  result = imap_sendf(data, "SEARCH %s", imap->query);
  841|       |
  842|     12|  if(!result)
  843|     12|    state(data, IMAP_SEARCH);
  844|       |
  845|     12|  return result;
  846|     12|}
imap.c:imap_perform_fetch:
  716|     21|{
  717|     21|  CURLcode result = CURLE_OK;
  718|     21|  struct IMAP *imap = data->req.p.imap;
  719|       |  /* Check we have a UID */
  720|     21|  if(imap->uid) {
  721|       |
  722|       |    /* Send the FETCH command */
  723|     21|    if(imap->partial)
  724|      0|      result = imap_sendf(data, "UID FETCH %s BODY[%s]<%s>",
  725|      0|                          imap->uid, imap->section ? imap->section : "",
  726|      0|                          imap->partial);
  727|     21|    else
  728|     21|      result = imap_sendf(data, "UID FETCH %s BODY[%s]",
  729|     21|                          imap->uid, imap->section ? imap->section : "");
  730|     21|  }
  731|      0|  else if(imap->mindex) {
  732|       |    /* Send the FETCH command */
  733|      0|    if(imap->partial)
  734|      0|      result = imap_sendf(data, "FETCH %s BODY[%s]<%s>",
  735|      0|                          imap->mindex, imap->section ? imap->section : "",
  736|      0|                          imap->partial);
  737|      0|    else
  738|      0|      result = imap_sendf(data, "FETCH %s BODY[%s]",
  739|      0|                          imap->mindex, imap->section ? imap->section : "");
  740|      0|  }
  741|      0|  else {
  742|      0|    failf(data, "Cannot FETCH without a UID.");
  743|      0|    return CURLE_URL_MALFORMAT;
  744|      0|  }
  745|     21|  if(!result)
  746|     21|    state(data, IMAP_FETCH);
  747|       |
  748|     21|  return result;
  749|     21|}
imap.c:imap_state_fetch_resp:
 1128|     12|{
 1129|     12|  CURLcode result = CURLE_OK;
 1130|     12|  struct imap_conn *imapc = &conn->proto.imapc;
 1131|     12|  struct pingpong *pp = &imapc->pp;
 1132|     12|  const char *ptr = data->state.buffer;
 1133|     12|  bool parsed = FALSE;
 1134|     12|  curl_off_t size = 0;
 1135|       |
 1136|     12|  (void)instate; /* no use for this yet */
 1137|       |
 1138|     12|  if(imapcode != '*') {
 1139|      2|    Curl_pgrsSetDownloadSize(data, -1);
 1140|      2|    state(data, IMAP_STOP);
 1141|      2|    return CURLE_REMOTE_FILE_NOT_FOUND;
 1142|      2|  }
 1143|       |
 1144|       |  /* Something like this is received "* 1 FETCH (BODY[TEXT] {2021}\r" so parse
 1145|       |     the continuation data contained within the curly brackets */
 1146|    235|  while(*ptr && (*ptr != '{'))
 1147|    225|    ptr++;
 1148|       |
 1149|     10|  if(*ptr == '{') {
 1150|      8|    char *endptr;
 1151|      8|    if(!curlx_strtoofft(ptr + 1, &endptr, 10, &size)) {
 1152|      7|      if(endptr - ptr > 1 && endptr[0] == '}' &&
 1153|      7|         endptr[1] == '\r' && endptr[2] == '\0')
 1154|      4|        parsed = TRUE;
 1155|      7|    }
 1156|      8|  }
 1157|       |
 1158|     10|  if(parsed) {
 1159|      4|    infof(data, "Found %" CURL_FORMAT_CURL_OFF_T " bytes to download",
 1160|      4|          size);
 1161|      4|    Curl_pgrsSetDownloadSize(data, size);
 1162|       |
 1163|      4|    if(pp->cache) {
 1164|       |      /* At this point there is a bunch of data in the header "cache" that is
 1165|       |         actually body content, send it as body and then skip it. Do note
 1166|       |         that there may even be additional "headers" after the body. */
 1167|      4|      size_t chunk = pp->cache_size;
 1168|       |
 1169|      4|      if(chunk > (size_t)size)
 1170|       |        /* The conversion from curl_off_t to size_t is always fine here */
 1171|      2|        chunk = (size_t)size;
 1172|       |
 1173|      4|      if(!chunk) {
 1174|       |        /* no size, we're done with the data */
 1175|      1|        state(data, IMAP_STOP);
 1176|      1|        return CURLE_OK;
 1177|      1|      }
 1178|      3|      result = Curl_client_write(data, CLIENTWRITE_BODY, pp->cache, chunk);
 1179|      3|      if(result)
 1180|      0|        return result;
 1181|       |
 1182|      3|      data->req.bytecount += chunk;
 1183|       |
 1184|      3|      infof(data, "Written %zu bytes, %" CURL_FORMAT_CURL_OFF_TU
 1185|      3|            " bytes are left for transfer", chunk, size - chunk);
 1186|       |
 1187|       |      /* Have we used the entire cache or just part of it?*/
 1188|      3|      if(pp->cache_size > chunk) {
 1189|       |        /* Only part of it so shrink the cache to fit the trailing data */
 1190|      1|        memmove(pp->cache, pp->cache + chunk, pp->cache_size - chunk);
 1191|      1|        pp->cache_size -= chunk;
 1192|      1|      }
 1193|      2|      else {
 1194|       |        /* Free the cache */
 1195|      2|        Curl_safefree(pp->cache);
 1196|       |
 1197|       |        /* Reset the cache size */
 1198|      2|        pp->cache_size = 0;
 1199|      2|      }
 1200|      3|    }
 1201|       |
 1202|      3|    if(data->req.bytecount == size)
 1203|       |      /* The entire data is already transferred! */
 1204|      2|      Curl_setup_transfer(data, -1, -1, FALSE, -1);
 1205|      1|    else {
 1206|       |      /* IMAP download */
 1207|      1|      data->req.maxdownload = size;
 1208|       |      /* force a recv/send check of this connection, as the data might've been
 1209|       |       read off the socket already */
 1210|      1|      data->conn->cselect_bits = CURL_CSELECT_IN;
 1211|      1|      Curl_setup_transfer(data, FIRSTSOCKET, size, FALSE, -1);
 1212|      1|    }
 1213|      3|  }
 1214|      6|  else {
 1215|       |    /* We don't know how to parse this line */
 1216|      6|    failf(data, "Failed to parse FETCH response.");
 1217|      6|    result = CURLE_WEIRD_SERVER_REPLY;
 1218|      6|  }
 1219|       |
 1220|       |  /* End of DO phase */
 1221|      9|  state(data, IMAP_STOP);
 1222|       |
 1223|      9|  return result;
 1224|     10|}
imap.c:imap_state_fetch_final_resp:
 1230|      4|{
 1231|      4|  CURLcode result = CURLE_OK;
 1232|       |
 1233|      4|  (void)instate; /* No use for this yet */
 1234|       |
 1235|      4|  if(imapcode != IMAP_RESP_OK)
 1236|      2|    result = CURLE_WEIRD_SERVER_REPLY;
 1237|      2|  else
 1238|       |    /* End of DONE phase */
 1239|      2|    state(data, IMAP_STOP);
 1240|       |
 1241|      4|  return result;
 1242|      4|}
imap.c:imap_state_append_resp:
 1247|     33|{
 1248|     33|  CURLcode result = CURLE_OK;
 1249|     33|  (void)instate; /* No use for this yet */
 1250|       |
 1251|     33|  if(imapcode != '+') {
 1252|      1|    result = CURLE_UPLOAD_FAILED;
 1253|      1|  }
 1254|     32|  else {
 1255|       |    /* Set the progress upload size */
 1256|     32|    Curl_pgrsSetUploadSize(data, data->state.infilesize);
 1257|       |
 1258|       |    /* IMAP upload */
 1259|     32|    Curl_setup_transfer(data, -1, -1, FALSE, FIRSTSOCKET);
 1260|       |
 1261|       |    /* End of DO phase */
 1262|     32|    state(data, IMAP_STOP);
 1263|     32|  }
 1264|       |
 1265|     33|  return result;
 1266|     33|}
imap.c:imap_state_append_final_resp:
 1272|      2|{
 1273|      2|  CURLcode result = CURLE_OK;
 1274|       |
 1275|      2|  (void)instate; /* No use for this yet */
 1276|       |
 1277|      2|  if(imapcode != IMAP_RESP_OK)
 1278|      1|    result = CURLE_UPLOAD_FAILED;
 1279|      1|  else
 1280|       |    /* End of DONE phase */
 1281|      1|    state(data, IMAP_STOP);
 1282|       |
 1283|      2|  return result;
 1284|      2|}
imap.c:imap_endofresp:
  259|  18.5k|{
  260|  18.5k|  struct IMAP *imap = data->req.p.imap;
  261|  18.5k|  struct imap_conn *imapc = &conn->proto.imapc;
  262|  18.5k|  const char *id = imapc->resptag;
  263|  18.5k|  size_t id_len = strlen(id);
  264|       |
  265|       |  /* Do we have a tagged command response? */
  266|  18.5k|  if(len >= id_len + 1 && !memcmp(id, line, id_len) && line[id_len] == ' ') {
  267|  1.38k|    line += id_len + 1;
  268|  1.38k|    len -= id_len + 1;
  269|       |
  270|  1.38k|    if(len >= 2 && !memcmp(line, "OK", 2))
  271|    727|      *resp = IMAP_RESP_OK;
  272|    660|    else if(len >= 7 && !memcmp(line, "PREAUTH", 7))
  273|      9|      *resp = IMAP_RESP_PREAUTH;
  274|    651|    else
  275|    651|      *resp = IMAP_RESP_NOT_OK;
  276|       |
  277|  1.38k|    return TRUE;
  278|  1.38k|  }
  279|       |
  280|       |  /* Do we have an untagged command response? */
  281|  17.2k|  if(len >= 2 && !memcmp("* ", line, 2)) {
  282|  5.58k|    switch(imapc->state) {
  283|       |      /* States which are interested in untagged responses */
  284|  1.55k|      case IMAP_CAPABILITY:
  285|  1.55k|        if(!imap_matchresp(line, len, "CAPABILITY"))
  286|  1.55k|          return FALSE;
  287|      0|        break;
  288|       |
  289|  2.64k|      case IMAP_LIST:
  290|  2.64k|        if((!imap->custom && !imap_matchresp(line, len, "LIST")) ||
  291|  2.64k|          (imap->custom && !imap_matchresp(line, len, imap->custom) &&
  292|  2.03k|           (!strcasecompare(imap->custom, "STORE") ||
  293|  1.89k|            !imap_matchresp(line, len, "FETCH")) &&
  294|  2.03k|           !strcasecompare(imap->custom, "SELECT") &&
  295|  2.03k|           !strcasecompare(imap->custom, "EXAMINE") &&
  296|  2.03k|           !strcasecompare(imap->custom, "SEARCH") &&
  297|  2.03k|           !strcasecompare(imap->custom, "EXPUNGE") &&
  298|  2.03k|           !strcasecompare(imap->custom, "LSUB") &&
  299|  2.03k|           !strcasecompare(imap->custom, "UID") &&
  300|  2.03k|           !strcasecompare(imap->custom, "GETQUOTAROOT") &&
  301|  2.03k|           !strcasecompare(imap->custom, "NOOP")))
  302|  1.97k|          return FALSE;
  303|    666|        break;
  304|       |
  305|    666|      case IMAP_SELECT:
  306|       |        /* SELECT is special in that its untagged responses do not have a
  307|       |           common prefix so accept anything! */
  308|    535|        break;
  309|       |
  310|     77|      case IMAP_FETCH:
  311|     77|        if(!imap_matchresp(line, len, "FETCH"))
  312|     67|          return FALSE;
  313|     10|        break;
  314|       |
  315|    266|      case IMAP_SEARCH:
  316|    266|        if(!imap_matchresp(line, len, "SEARCH"))
  317|    266|          return FALSE;
  318|      0|        break;
  319|       |
  320|       |      /* Ignore other untagged responses */
  321|    509|      default:
  322|    509|        return FALSE;
  323|  5.58k|    }
  324|       |
  325|  1.21k|    *resp = '*';
  326|  1.21k|    return TRUE;
  327|  5.58k|  }
  328|       |
  329|       |  /* Do we have a continuation response? This should be a + symbol followed by
  330|       |     a space and optionally some text as per RFC-3501 for the AUTHENTICATE and
  331|       |     APPEND commands and as outlined in Section 4. Examples of RFC-4959 but
  332|       |     some e-mail servers ignore this and only send a single + instead. */
  333|  11.6k|  if(imap && !imap->custom && ((len == 3 && line[0] == '+') ||
  334|  8.30k|     (len >= 2 && !memcmp("+ ", line, 2)))) {
  335|    311|    switch(imapc->state) {
  336|       |      /* States which are interested in continuation responses */
  337|      0|      case IMAP_AUTHENTICATE:
  338|     32|      case IMAP_APPEND:
  339|     32|        *resp = '+';
  340|     32|        break;
  341|       |
  342|    279|      default:
  343|    279|        failf(data, "Unexpected continuation response");
  344|    279|        *resp = -1;
  345|    279|        break;
  346|    311|    }
  347|       |
  348|    311|    return TRUE;
  349|    311|  }
  350|       |
  351|  11.3k|  return FALSE; /* Nothing for us */
  352|  11.6k|}
imap.c:imap_matchresp:
  220|  4.62k|{
  221|  4.62k|  const char *end = line + len;
  222|  4.62k|  size_t cmd_len = strlen(cmd);
  223|       |
  224|       |  /* Skip the untagged response marker */
  225|  4.62k|  line += 2;
  226|       |
  227|       |  /* Do we have a number after the marker? */
  228|  4.62k|  if(line < end && ISDIGIT(*line)) {
  229|       |    /* Skip the number */
  230|  1.83k|    do
  231|  4.25k|      line++;
  232|  4.25k|    while(line < end && ISDIGIT(*line));
  233|       |
  234|       |    /* Do we have the space character? */
  235|  1.83k|    if(line == end || *line != ' ')
  236|  1.71k|      return FALSE;
  237|       |
  238|    117|    line++;
  239|    117|  }
  240|       |
  241|       |  /* Does the command name match and is it followed by a space character or at
  242|       |     the end of line? */
  243|  2.90k|  if(line + cmd_len <= end && strncasecompare(line, cmd, cmd_len) &&
  244|  2.90k|     (line[cmd_len] == ' ' || line + cmd_len + 2 == end))
  245|    155|    return TRUE;
  246|       |
  247|  2.75k|  return FALSE;
  248|  2.90k|}
imap.c:imap_parse_url_options:
 1922|    741|{
 1923|    741|  CURLcode result = CURLE_OK;
 1924|    741|  struct imap_conn *imapc = &conn->proto.imapc;
 1925|    741|  const char *ptr = conn->options;
 1926|       |
 1927|    771|  while(!result && ptr && *ptr) {
 1928|     30|    const char *key = ptr;
 1929|     30|    const char *value;
 1930|       |
 1931|    557|    while(*ptr && *ptr != '=')
 1932|    527|        ptr++;
 1933|       |
 1934|     30|    value = ptr + 1;
 1935|       |
 1936|    302|    while(*ptr && *ptr != ';')
 1937|    272|      ptr++;
 1938|       |
 1939|     30|    if(strncasecompare(key, "AUTH=", 5))
 1940|     12|      result = Curl_sasl_parse_url_auth_option(&imapc->sasl,
 1941|     12|                                               value, ptr - value);
 1942|     18|    else
 1943|     18|      result = CURLE_URL_MALFORMAT;
 1944|       |
 1945|     30|    if(*ptr == ';')
 1946|     14|      ptr++;
 1947|     30|  }
 1948|       |
 1949|    741|  switch(imapc->sasl.prefmech) {
 1950|      2|  case SASL_AUTH_NONE:
 1951|      2|    imapc->preftype = IMAP_TYPE_NONE;
 1952|      2|    break;
 1953|    737|  case SASL_AUTH_DEFAULT:
 1954|    737|    imapc->preftype = IMAP_TYPE_ANY;
 1955|    737|    break;
 1956|      2|  default:
 1957|      2|    imapc->preftype = IMAP_TYPE_SASL;
 1958|      2|    break;
 1959|    741|  }
 1960|       |
 1961|    741|  return result;
 1962|    741|}
imap.c:state:
  395|  3.30k|{
  396|  3.30k|  struct imap_conn *imapc = &data->conn->proto.imapc;
  397|  3.30k|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
  398|       |  /* for debug purposes */
  399|  3.30k|  static const char * const names[]={
  400|  3.30k|    "STOP",
  401|  3.30k|    "SERVERGREET",
  402|  3.30k|    "CAPABILITY",
  403|  3.30k|    "STARTTLS",
  404|  3.30k|    "UPGRADETLS",
  405|  3.30k|    "AUTHENTICATE",
  406|  3.30k|    "LOGIN",
  407|  3.30k|    "LIST",
  408|  3.30k|    "SELECT",
  409|  3.30k|    "FETCH",
  410|  3.30k|    "FETCH_FINAL",
  411|  3.30k|    "APPEND",
  412|  3.30k|    "APPEND_FINAL",
  413|  3.30k|    "SEARCH",
  414|  3.30k|    "LOGOUT",
  415|       |    /* LAST */
  416|  3.30k|  };
  417|       |
  418|  3.30k|  if(imapc->state != newstate)
  419|  3.30k|    infof(data, "IMAP %p state change from %s to %s",
  420|  3.30k|          (void *)imapc, names[imapc->state], names[newstate]);
  421|  3.30k|#endif
  422|       |
  423|  3.30k|  imapc->state = newstate;
  424|  3.30k|}
imap.c:imap_done:
 1492|    741|{
 1493|    741|  CURLcode result = CURLE_OK;
 1494|    741|  struct connectdata *conn = data->conn;
 1495|    741|  struct IMAP *imap = data->req.p.imap;
 1496|       |
 1497|    741|  (void)premature;
 1498|       |
 1499|    741|  if(!imap)
 1500|      0|    return CURLE_OK;
 1501|       |
 1502|    741|  if(status) {
 1503|    684|    connclose(conn, "IMAP done with bad status"); /* marked for closure */
 1504|    684|    result = status;         /* use the already set error code */
 1505|    684|  }
 1506|     57|  else if(!data->set.connect_only && !imap->custom &&
 1507|     57|          (imap->uid || imap->mindex || data->set.upload ||
 1508|     55|          data->set.mimepost.kind != MIMEKIND_NONE)) {
 1509|       |    /* Handle responses after FETCH or APPEND transfer has finished */
 1510|       |
 1511|     39|    if(!data->set.upload && data->set.mimepost.kind == MIMEKIND_NONE)
 1512|      7|      state(data, IMAP_FETCH_FINAL);
 1513|     32|    else {
 1514|       |      /* End the APPEND command first by sending an empty line */
 1515|     32|      result = Curl_pp_sendf(data, &conn->proto.imapc.pp, "%s", "");
 1516|     32|      if(!result)
 1517|     32|        state(data, IMAP_APPEND_FINAL);
 1518|     32|    }
 1519|       |
 1520|       |    /* Run the state-machine */
 1521|     39|    if(!result)
 1522|     39|      result = imap_block_statemach(data, conn, FALSE);
 1523|     39|  }
 1524|       |
 1525|       |  /* Cleanup our per-request based variables */
 1526|    741|  Curl_safefree(imap->mailbox);
 1527|    741|  Curl_safefree(imap->uidvalidity);
 1528|    741|  Curl_safefree(imap->uid);
 1529|    741|  Curl_safefree(imap->mindex);
 1530|    741|  Curl_safefree(imap->section);
 1531|    741|  Curl_safefree(imap->partial);
 1532|    741|  Curl_safefree(imap->query);
 1533|    741|  Curl_safefree(imap->custom);
 1534|    741|  Curl_safefree(imap->custom_params);
 1535|       |
 1536|       |  /* Clear the transfer mode for the next request */
 1537|    741|  imap->transfer = PPTRANSFER_BODY;
 1538|       |
 1539|    741|  return result;
 1540|    741|}
imap.c:imap_block_statemach:
 1400|    656|{
 1401|    656|  CURLcode result = CURLE_OK;
 1402|    656|  struct imap_conn *imapc = &conn->proto.imapc;
 1403|       |
 1404|  1.33k|  while(imapc->state != IMAP_STOP && !result)
 1405|    677|    result = Curl_pp_statemach(data, &imapc->pp, TRUE, disconnecting);
 1406|       |
 1407|    656|  return result;
 1408|    656|}
imap.c:imap_do:
 1621|    621|{
 1622|    621|  CURLcode result = CURLE_OK;
 1623|    621|  *done = FALSE; /* default to false */
 1624|       |
 1625|       |  /* Parse the URL path */
 1626|    621|  result = imap_parse_url_path(data);
 1627|    621|  if(result)
 1628|     97|    return result;
 1629|       |
 1630|       |  /* Parse the custom request */
 1631|    524|  result = imap_parse_custom_request(data);
 1632|    524|  if(result)
 1633|      1|    return result;
 1634|       |
 1635|    523|  result = imap_regular_transfer(data, done);
 1636|       |
 1637|    523|  return result;
 1638|    524|}
imap.c:imap_parse_url_path:
 1972|    621|{
 1973|       |  /* The imap struct is already initialised in imap_connect() */
 1974|    621|  CURLcode result = CURLE_OK;
 1975|    621|  struct IMAP *imap = data->req.p.imap;
 1976|    621|  const char *begin = &data->state.up.path[1]; /* skip leading slash */
 1977|    621|  const char *ptr = begin;
 1978|       |
 1979|       |  /* See how much of the URL is a valid path and decode it */
 1980|  31.6k|  while(imap_is_bchar(*ptr))
 1981|  31.0k|    ptr++;
 1982|       |
 1983|    621|  if(ptr != begin) {
 1984|       |    /* Remove the trailing slash if present */
 1985|    516|    const char *end = ptr;
 1986|    516|    if(end > begin && end[-1] == '/')
 1987|     38|      end--;
 1988|       |
 1989|    516|    result = Curl_urldecode(data, begin, end - begin, &imap->mailbox, NULL,
 1990|    516|                            REJECT_CTRL);
 1991|    516|    if(result)
 1992|      2|      return result;
 1993|    516|  }
 1994|    105|  else
 1995|    105|    imap->mailbox = NULL;
 1996|       |
 1997|       |  /* There can be any number of parameters in the form ";NAME=VALUE" */
 1998|    657|  while(*ptr == ';') {
 1999|     68|    char *name;
 2000|     68|    char *value;
 2001|     68|    size_t valuelen;
 2002|       |
 2003|       |    /* Find the length of the name parameter */
 2004|     68|    begin = ++ptr;
 2005|    490|    while(*ptr && *ptr != '=')
 2006|    422|      ptr++;
 2007|       |
 2008|     68|    if(!*ptr)
 2009|      8|      return CURLE_URL_MALFORMAT;
 2010|       |
 2011|       |    /* Decode the name parameter */
 2012|     60|    result = Curl_urldecode(data, begin, ptr - begin, &name, NULL,
 2013|     60|                            REJECT_CTRL);
 2014|     60|    if(result)
 2015|      0|      return result;
 2016|       |
 2017|       |    /* Find the length of the value parameter */
 2018|     60|    begin = ++ptr;
 2019|    807|    while(imap_is_bchar(*ptr))
 2020|    747|      ptr++;
 2021|       |
 2022|       |    /* Decode the value parameter */
 2023|     60|    result = Curl_urldecode(data, begin, ptr - begin, &value, &valuelen,
 2024|     60|                            REJECT_CTRL);
 2025|     60|    if(result) {
 2026|      1|      free(name);
 2027|      1|      return result;
 2028|      1|    }
 2029|       |
 2030|     59|    DEBUGF(infof(data, "IMAP URL parameter '%s' = '%s'", name, value));
 2031|       |
 2032|       |    /* Process the known hierarchical parameters (UIDVALIDITY, UID, SECTION and
 2033|       |       PARTIAL) stripping of the trailing slash character if it is present.
 2034|       |
 2035|       |       Note: Unknown parameters trigger a URL_MALFORMAT error. */
 2036|     59|    if(strcasecompare(name, "UIDVALIDITY") && !imap->uidvalidity) {
 2037|      0|      if(valuelen > 0 && value[valuelen - 1] == '/')
 2038|      0|        value[valuelen - 1] = '\0';
 2039|       |
 2040|      0|      imap->uidvalidity = value;
 2041|      0|      value = NULL;
 2042|      0|    }
 2043|     59|    else if(strcasecompare(name, "UID") && !imap->uid) {
 2044|     38|      if(valuelen > 0 && value[valuelen - 1] == '/')
 2045|      3|        value[valuelen - 1] = '\0';
 2046|       |
 2047|     38|      imap->uid = value;
 2048|     38|      value = NULL;
 2049|     38|    }
 2050|     21|    else if(strcasecompare(name, "MAILINDEX") && !imap->mindex) {
 2051|      0|      if(valuelen > 0 && value[valuelen - 1] == '/')
 2052|      0|        value[valuelen - 1] = '\0';
 2053|       |
 2054|      0|      imap->mindex = value;
 2055|      0|      value = NULL;
 2056|      0|    }
 2057|     21|    else if(strcasecompare(name, "SECTION") && !imap->section) {
 2058|      0|      if(valuelen > 0 && value[valuelen - 1] == '/')
 2059|      0|        value[valuelen - 1] = '\0';
 2060|       |
 2061|      0|      imap->section = value;
 2062|      0|      value = NULL;
 2063|      0|    }
 2064|     21|    else if(strcasecompare(name, "PARTIAL") && !imap->partial) {
 2065|      0|      if(valuelen > 0 && value[valuelen - 1] == '/')
 2066|      0|        value[valuelen - 1] = '\0';
 2067|       |
 2068|      0|      imap->partial = value;
 2069|      0|      value = NULL;
 2070|      0|    }
 2071|     21|    else {
 2072|     21|      free(name);
 2073|     21|      free(value);
 2074|       |
 2075|     21|      return CURLE_URL_MALFORMAT;
 2076|     21|    }
 2077|       |
 2078|     38|    free(name);
 2079|     38|    free(value);
 2080|     38|  }
 2081|       |
 2082|       |  /* Does the URL contain a query parameter? Only valid when we have a mailbox
 2083|       |     and no UID as per RFC-5092 */
 2084|    589|  if(imap->mailbox && !imap->uid && !imap->mindex) {
 2085|       |    /* Get the query parameter, URL decoded */
 2086|    457|    (void)curl_url_get(data->state.uh, CURLUPART_QUERY, &imap->query,
 2087|    457|                       CURLU_URLDECODE);
 2088|    457|  }
 2089|       |
 2090|       |  /* Any extra stuff at the end of the URL is an error */
 2091|    589|  if(*ptr)
 2092|     65|    return CURLE_URL_MALFORMAT;
 2093|       |
 2094|    524|  return CURLE_OK;
 2095|    589|}
imap.c:imap_is_bchar:
 1885|  32.4k|{
 1886|  32.4k|  switch(ch) {
 1887|       |    /* bchar */
 1888|  1.53k|    case ':': case '@': case '/':
 1889|       |    /* bchar -> achar */
 1890|  2.18k|    case '&': case '=':
 1891|       |    /* bchar -> achar -> uchar -> unreserved */
 1892|  5.48k|    case '0': case '1': case '2': case '3': case '4': case '5': case '6':
 1893|  6.45k|    case '7': case '8': case '9':
 1894|  8.26k|    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':
 1895|  9.72k|    case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':
 1896|  11.6k|    case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U':
 1897|  12.6k|    case 'V': case 'W': case 'X': case 'Y': case 'Z':
 1898|  17.2k|    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':
 1899|  20.0k|    case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':
 1900|  26.1k|    case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u':
 1901|  27.5k|    case 'v': case 'w': case 'x': case 'y': case 'z':
 1902|  29.6k|    case '-': case '.': case '_': case '~':
 1903|       |    /* bchar -> achar -> uchar -> sub-delims-sh */
 1904|  31.3k|    case '!': case '$': case '\'': case '(': case ')': case '*':
 1905|  31.4k|    case '+': case ',':
 1906|       |    /* bchar -> achar -> uchar -> pct-encoded */
 1907|  31.7k|    case '%': /* HEXDIG chars are already included above */
 1908|  31.7k|      return true;
 1909|       |
 1910|    681|    default:
 1911|    681|      return false;
 1912|  32.4k|  }
 1913|  32.4k|}
imap.c:imap_parse_custom_request:
 2104|    524|{
 2105|    524|  CURLcode result = CURLE_OK;
 2106|    524|  struct IMAP *imap = data->req.p.imap;
 2107|    524|  const char *custom = data->set.str[STRING_CUSTOMREQUEST];
 2108|       |
 2109|    524|  if(custom) {
 2110|       |    /* URL decode the custom request */
 2111|    150|    result = Curl_urldecode(data, custom, 0, &imap->custom, NULL, REJECT_CTRL);
 2112|       |
 2113|       |    /* Extract the parameters if specified */
 2114|    150|    if(!result) {
 2115|    149|      const char *params = imap->custom;
 2116|       |
 2117|    703|      while(*params && *params != ' ')
 2118|    554|        params++;
 2119|       |
 2120|    149|      if(*params) {
 2121|      6|        imap->custom_params = strdup(params);
 2122|      6|        imap->custom[params - imap->custom] = '\0';
 2123|       |
 2124|      6|        if(!imap->custom_params)
 2125|      0|          result = CURLE_OUT_OF_MEMORY;
 2126|      6|      }
 2127|    149|    }
 2128|    150|  }
 2129|       |
 2130|    524|  return result;
 2131|    524|}
imap.c:imap_regular_transfer:
 1719|    523|{
 1720|    523|  CURLcode result = CURLE_OK;
 1721|    523|  bool connected = FALSE;
 1722|       |
 1723|       |  /* Make sure size is unknown at this point */
 1724|    523|  data->req.size = -1;
 1725|       |
 1726|       |  /* Set the progress data */
 1727|    523|  Curl_pgrsSetUploadCounter(data, 0);
 1728|    523|  Curl_pgrsSetDownloadCounter(data, 0);
 1729|    523|  Curl_pgrsSetUploadSize(data, -1);
 1730|    523|  Curl_pgrsSetDownloadSize(data, -1);
 1731|       |
 1732|       |  /* Carry out the perform */
 1733|    523|  result = imap_perform(data, &connected, dophase_done);
 1734|       |
 1735|       |  /* Perform post DO phase operations if necessary */
 1736|    523|  if(!result && *dophase_done)
 1737|     48|    result = imap_dophase_done(data, connected);
 1738|       |
 1739|    523|  return result;
 1740|    523|}
imap.c:imap_perform:
 1551|    523|{
 1552|       |  /* This is IMAP and no proxy */
 1553|    523|  CURLcode result = CURLE_OK;
 1554|    523|  struct connectdata *conn = data->conn;
 1555|    523|  struct IMAP *imap = data->req.p.imap;
 1556|    523|  struct imap_conn *imapc = &conn->proto.imapc;
 1557|    523|  bool selected = FALSE;
 1558|       |
 1559|    523|  DEBUGF(infof(data, "DO phase starts"));
 1560|       |
 1561|    523|  if(data->set.opt_no_body) {
 1562|       |    /* Requested no body means no transfer */
 1563|      1|    imap->transfer = PPTRANSFER_INFO;
 1564|      1|  }
 1565|       |
 1566|    523|  *dophase_done = FALSE; /* not done yet */
 1567|       |
 1568|       |  /* Determine if the requested mailbox (with the same UIDVALIDITY if set)
 1569|       |     has already been selected on this connection */
 1570|    523|  if(imap->mailbox && imapc->mailbox &&
 1571|    523|     strcasecompare(imap->mailbox, imapc->mailbox) &&
 1572|    523|     (!imap->uidvalidity || !imapc->mailbox_uidvalidity ||
 1573|      0|      strcasecompare(imap->uidvalidity, imapc->mailbox_uidvalidity)))
 1574|      0|    selected = TRUE;
 1575|       |
 1576|       |  /* Start the first command in the DO phase */
 1577|    523|  if(data->set.upload || data->set.mimepost.kind != MIMEKIND_NONE)
 1578|       |    /* APPEND can be executed directly */
 1579|     41|    result = imap_perform_append(data);
 1580|    482|  else if(imap->custom && (selected || !imap->mailbox))
 1581|       |    /* Custom command using the same mailbox or no mailbox */
 1582|     81|    result = imap_perform_list(data);
 1583|    401|  else if(!imap->custom && selected && (imap->uid || imap->mindex))
 1584|       |    /* FETCH from the same mailbox */
 1585|      0|    result = imap_perform_fetch(data);
 1586|    401|  else if(!imap->custom && selected && imap->query)
 1587|       |    /* SEARCH the current mailbox */
 1588|      0|    result = imap_perform_search(data);
 1589|    401|  else if(imap->mailbox && !selected &&
 1590|    401|         (imap->custom || imap->uid || imap->mindex || imap->query))
 1591|       |    /* SELECT the mailbox */
 1592|    141|    result = imap_perform_select(data);
 1593|    260|  else
 1594|       |    /* LIST */
 1595|    260|    result = imap_perform_list(data);
 1596|       |
 1597|    523|  if(result)
 1598|      1|    return result;
 1599|       |
 1600|       |  /* Run the state-machine */
 1601|    522|  result = imap_multi_statemach(data, dophase_done);
 1602|       |
 1603|    522|  *connected = conn->bits.tcpconnect[FIRSTSOCKET];
 1604|       |
 1605|    522|  if(*dophase_done)
 1606|     49|    DEBUGF(infof(data, "DO phase is complete"));
 1607|       |
 1608|    522|  return result;
 1609|    523|}
imap.c:imap_perform_append:
  758|     41|{
  759|     41|  CURLcode result = CURLE_OK;
  760|     41|  struct IMAP *imap = data->req.p.imap;
  761|     41|  char *mailbox;
  762|       |
  763|       |  /* Check we have a mailbox */
  764|     41|  if(!imap->mailbox) {
  765|      1|    failf(data, "Cannot APPEND without a mailbox.");
  766|      1|    return CURLE_URL_MALFORMAT;
  767|      1|  }
  768|       |
  769|       |  /* Prepare the mime data if some. */
  770|     40|  if(data->set.mimepost.kind != MIMEKIND_NONE) {
  771|       |    /* Use the whole structure as data. */
  772|     32|    data->set.mimepost.flags &= ~MIME_BODY_ONLY;
  773|       |
  774|       |    /* Add external headers and mime version. */
  775|     32|    curl_mime_headers(&data->set.mimepost, data->set.headers, 0);
  776|     32|    result = Curl_mime_prepare_headers(&data->set.mimepost, NULL,
  777|     32|                                       NULL, MIMESTRATEGY_MAIL);
  778|       |
  779|     32|    if(!result)
  780|     32|      if(!Curl_checkheaders(data, "Mime-Version"))
  781|     32|        result = Curl_mime_add_header(&data->set.mimepost.curlheaders,
  782|     32|                                      "Mime-Version: 1.0");
  783|       |
  784|       |    /* Make sure we will read the entire mime structure. */
  785|     32|    if(!result)
  786|     32|      result = Curl_mime_rewind(&data->set.mimepost);
  787|       |
  788|     32|    if(result)
  789|      0|      return result;
  790|       |
  791|     32|    data->state.infilesize = Curl_mime_size(&data->set.mimepost);
  792|       |
  793|       |    /* Read from mime structure. */
  794|     32|    data->state.fread_func = (curl_read_callback) Curl_mime_read;
  795|     32|    data->state.in = (void *) &data->set.mimepost;
  796|     32|  }
  797|       |
  798|       |  /* Check we know the size of the upload */
  799|     40|  if(data->state.infilesize < 0) {
  800|      0|    failf(data, "Cannot APPEND with unknown input file size");
  801|      0|    return CURLE_UPLOAD_FAILED;
  802|      0|  }
  803|       |
  804|       |  /* Make sure the mailbox is in the correct atom format */
  805|     40|  mailbox = imap_atom(imap->mailbox, false);
  806|     40|  if(!mailbox)
  807|      0|    return CURLE_OUT_OF_MEMORY;
  808|       |
  809|       |  /* Send the APPEND command */
  810|     40|  result = imap_sendf(data,
  811|     40|                      "APPEND %s (\\Seen) {%" CURL_FORMAT_CURL_OFF_T "}",
  812|     40|                      mailbox, data->state.infilesize);
  813|       |
  814|     40|  free(mailbox);
  815|       |
  816|     40|  if(!result)
  817|     40|    state(data, IMAP_APPEND);
  818|       |
  819|     40|  return result;
  820|     40|}
imap.c:imap_perform_select:
  676|    141|{
  677|    141|  CURLcode result = CURLE_OK;
  678|    141|  struct connectdata *conn = data->conn;
  679|    141|  struct IMAP *imap = data->req.p.imap;
  680|    141|  struct imap_conn *imapc = &conn->proto.imapc;
  681|    141|  char *mailbox;
  682|       |
  683|       |  /* Invalidate old information as we are switching mailboxes */
  684|    141|  Curl_safefree(imapc->mailbox);
  685|    141|  Curl_safefree(imapc->mailbox_uidvalidity);
  686|       |
  687|       |  /* Check we have a mailbox */
  688|    141|  if(!imap->mailbox) {
  689|      0|    failf(data, "Cannot SELECT without a mailbox.");
  690|      0|    return CURLE_URL_MALFORMAT;
  691|      0|  }
  692|       |
  693|       |  /* Make sure the mailbox is in the correct atom format */
  694|    141|  mailbox = imap_atom(imap->mailbox, false);
  695|    141|  if(!mailbox)
  696|      0|    return CURLE_OUT_OF_MEMORY;
  697|       |
  698|       |  /* Send the SELECT command */
  699|    141|  result = imap_sendf(data, "SELECT %s", mailbox);
  700|       |
  701|    141|  free(mailbox);
  702|       |
  703|    141|  if(!result)
  704|    141|    state(data, IMAP_SELECT);
  705|       |
  706|    141|  return result;
  707|    141|}
imap.c:imap_dophase_done:
 1680|     53|{
 1681|     53|  struct IMAP *imap = data->req.p.imap;
 1682|       |
 1683|     53|  (void)connected;
 1684|       |
 1685|     53|  if(imap->transfer != PPTRANSFER_BODY)
 1686|       |    /* no data to transfer */
 1687|      1|    Curl_setup_transfer(data, -1, -1, FALSE, -1);
 1688|       |
 1689|     53|  return CURLE_OK;
 1690|     53|}
imap.c:imap_disconnect:
 1649|    741|{
 1650|    741|  struct imap_conn *imapc = &conn->proto.imapc;
 1651|    741|  (void)data;
 1652|       |
 1653|       |  /* We cannot send quit unconditionally. If this connection is stale or
 1654|       |     bad in any way, sending quit and waiting around here will make the
 1655|       |     disconnect wait in vain and cause more problems than we need to. */
 1656|       |
 1657|       |  /* The IMAP session may or may not have been allocated/setup at this
 1658|       |     point! */
 1659|    741|  if(!dead_connection && conn->bits.protoconnstart) {
 1660|    617|    if(!imap_perform_logout(data))
 1661|    617|      (void)imap_block_statemach(data, conn, TRUE); /* ignore errors */
 1662|    617|  }
 1663|       |
 1664|       |  /* Disconnect from the server */
 1665|    741|  Curl_pp_disconnect(&imapc->pp);
 1666|    741|  Curl_dyn_free(&imapc->dyn);
 1667|       |
 1668|       |  /* Cleanup the SASL module */
 1669|    741|  Curl_sasl_cleanup(conn, imapc->sasl.authused);
 1670|       |
 1671|       |  /* Cleanup our connection based variables */
 1672|    741|  Curl_safefree(imapc->mailbox);
 1673|    741|  Curl_safefree(imapc->mailbox_uidvalidity);
 1674|       |
 1675|    741|  return CURLE_OK;
 1676|    741|}
imap.c:imap_perform_logout:
  855|    617|{
  856|       |  /* Send the LOGOUT command */
  857|    617|  CURLcode result = imap_sendf(data, "LOGOUT");
  858|       |
  859|    617|  if(!result)
  860|    617|    state(data, IMAP_LOGOUT);
  861|       |
  862|    617|  return result;
  863|    617|}
imap.c:imap_doing:
 1694|     38|{
 1695|     38|  CURLcode result = imap_multi_statemach(data, dophase_done);
 1696|       |
 1697|     38|  if(result)
 1698|     15|    DEBUGF(infof(data, "DO phase failed"));
 1699|     23|  else if(*dophase_done) {
 1700|      5|    result = imap_dophase_done(data, FALSE /* not connected */);
 1701|       |
 1702|      5|    DEBUGF(infof(data, "DO phase is complete"));
 1703|      5|  }
 1704|       |
 1705|     38|  return result;
 1706|     38|}
imap.c:imap_setup_connection:
 1744|    741|{
 1745|       |  /* Initialise the IMAP layer */
 1746|    741|  CURLcode result = imap_init(data);
 1747|    741|  if(result)
 1748|      0|    return result;
 1749|       |
 1750|       |  /* Clear the TLS upgraded flag */
 1751|    741|  conn->bits.tls_upgraded = FALSE;
 1752|       |
 1753|    741|  return CURLE_OK;
 1754|    741|}
imap.c:imap_init:
 1413|    741|{
 1414|    741|  CURLcode result = CURLE_OK;
 1415|    741|  struct IMAP *imap;
 1416|       |
 1417|    741|  imap = data->req.p.imap = calloc(sizeof(struct IMAP), 1);
 1418|    741|  if(!imap)
 1419|      0|    result = CURLE_OUT_OF_MEMORY;
 1420|       |
 1421|    741|  return result;
 1422|    741|}

Curl_llist_init:
   38|  3.15M|{
   39|  3.15M|  l->size = 0;
   40|  3.15M|  l->dtor = dtor;
   41|  3.15M|  l->head = NULL;
   42|  3.15M|  l->tail = NULL;
   43|  3.15M|}
Curl_llist_insert_next:
   60|  26.9k|{
   61|  26.9k|  ne->ptr = (void *) p;
   62|  26.9k|  if(list->size == 0) {
   63|  20.9k|    list->head = ne;
   64|  20.9k|    list->head->prev = NULL;
   65|  20.9k|    list->head->next = NULL;
   66|  20.9k|    list->tail = ne;
   67|  20.9k|  }
   68|  6.00k|  else {
   69|       |    /* if 'e' is NULL here, we insert the new element first in the list */
   70|  6.00k|    ne->next = e?e->next:list->head;
   71|  6.00k|    ne->prev = e;
   72|  6.00k|    if(!e) {
   73|      7|      list->head->prev = ne;
   74|      7|      list->head = ne;
   75|      7|    }
   76|  6.00k|    else if(e->next) {
   77|      4|      e->next->prev = ne;
   78|      4|    }
   79|  5.99k|    else {
   80|  5.99k|      list->tail = ne;
   81|  5.99k|    }
   82|  6.00k|    if(e)
   83|  6.00k|      e->next = ne;
   84|  6.00k|  }
   85|       |
   86|  26.9k|  ++list->size;
   87|  26.9k|}
Curl_llist_remove:
   95|  26.9k|{
   96|  26.9k|  void *ptr;
   97|  26.9k|  if(!e || list->size == 0)
   98|      0|    return;
   99|       |
  100|  26.9k|  if(e == list->head) {
  101|  22.0k|    list->head = e->next;
  102|       |
  103|  22.0k|    if(!list->head)
  104|  20.9k|      list->tail = NULL;
  105|  1.15k|    else
  106|  1.15k|      e->next->prev = NULL;
  107|  22.0k|  }
  108|  4.85k|  else {
  109|  4.85k|    if(e->prev)
  110|  4.85k|      e->prev->next = e->next;
  111|       |
  112|  4.85k|    if(!e->next)
  113|  4.74k|      list->tail = e->prev;
  114|    107|    else
  115|    107|      e->next->prev = e->prev;
  116|  4.85k|  }
  117|       |
  118|  26.9k|  ptr = e->ptr;
  119|       |
  120|  26.9k|  e->ptr  = NULL;
  121|  26.9k|  e->prev = NULL;
  122|  26.9k|  e->next = NULL;
  123|       |
  124|  26.9k|  --list->size;
  125|       |
  126|       |  /* call the dtor() last for when it actually frees the 'e' memory itself */
  127|  26.9k|  if(list->dtor)
  128|  8.74k|    list->dtor(user, ptr);
  129|  26.9k|}
Curl_llist_destroy:
  133|  3.17M|{
  134|  3.17M|  if(list) {
  135|  3.17M|    while(list->size > 0)
  136|  2.82k|      Curl_llist_remove(list, list->tail, user);
  137|  3.17M|  }
  138|  3.17M|}
Curl_llist_count:
  142|  9.09k|{
  143|  9.09k|  return list->size;
  144|  9.09k|}

Curl_md5it:
  561|    135|{
  562|    135|  MD5_CTX ctx;
  563|       |
  564|    135|  MD5_Init(&ctx);
  565|    135|  MD5_Update(&ctx, input, curlx_uztoui(len));
  566|    135|  MD5_Final(outbuffer, &ctx);
  567|    135|}
Curl_MD5_init:
  570|      5|{
  571|      5|  struct MD5_context *ctxt;
  572|       |
  573|       |  /* Create MD5 context */
  574|      5|  ctxt = malloc(sizeof(*ctxt));
  575|       |
  576|      5|  if(!ctxt)
  577|      0|    return ctxt;
  578|       |
  579|      5|  ctxt->md5_hashctx = malloc(md5params->md5_ctxtsize);
  580|       |
  581|      5|  if(!ctxt->md5_hashctx) {
  582|      0|    free(ctxt);
  583|      0|    return NULL;
  584|      0|  }
  585|       |
  586|      5|  ctxt->md5_hash = md5params;
  587|       |
  588|      5|  (*md5params->md5_init_func)(ctxt->md5_hashctx);
  589|       |
  590|      5|  return ctxt;
  591|      5|}
Curl_MD5_update:
  596|     10|{
  597|     10|  (*context->md5_hash->md5_update_func)(context->md5_hashctx, data, len);
  598|       |
  599|     10|  return CURLE_OK;
  600|     10|}
Curl_MD5_final:
  603|      5|{
  604|      5|  (*context->md5_hash->md5_final_func)(result, context->md5_hashctx);
  605|       |
  606|      5|  free(context->md5_hashctx);
  607|      5|  free(context);
  608|       |
  609|      5|  return CURLE_OK;
  610|      5|}

curl_dbg_malloc:
  131|  5.99M|{
  132|  5.99M|  struct memdebug *mem;
  133|  5.99M|  size_t size;
  134|       |
  135|  5.99M|  DEBUGASSERT(wantedsize != 0);
  136|       |
  137|  5.99M|  if(countcheck("malloc", line, source))
  138|      0|    return NULL;
  139|       |
  140|       |  /* alloc at least 64 bytes */
  141|  5.99M|  size = sizeof(struct memdebug) + wantedsize;
  142|       |
  143|  5.99M|  mem = (Curl_cmalloc)(size);
  144|  5.99M|  if(mem) {
  145|  5.99M|    mem->size = wantedsize;
  146|  5.99M|  }
  147|       |
  148|  5.99M|  if(source)
  149|  5.87M|    curl_dbg_log("MEM %s:%d malloc(%zu) = %p\n",
  150|  5.87M|                 source, line, wantedsize,
  151|  5.87M|                 mem ? (void *)mem->mem : (void *)0);
  152|       |
  153|  5.99M|  return (mem ? mem->mem : NULL);
  154|  5.99M|}
curl_dbg_calloc:
  158|  52.4k|{
  159|  52.4k|  struct memdebug *mem;
  160|  52.4k|  size_t size, user_size;
  161|       |
  162|  52.4k|  DEBUGASSERT(wanted_elements != 0);
  163|  52.4k|  DEBUGASSERT(wanted_size != 0);
  164|       |
  165|  52.4k|  if(countcheck("calloc", line, source))
  166|      0|    return NULL;
  167|       |
  168|       |  /* alloc at least 64 bytes */
  169|  52.4k|  user_size = wanted_size * wanted_elements;
  170|  52.4k|  size = sizeof(struct memdebug) + user_size;
  171|       |
  172|  52.4k|  mem = (Curl_ccalloc)(1, size);
  173|  52.4k|  if(mem)
  174|  52.4k|    mem->size = user_size;
  175|       |
  176|  52.4k|  if(source)
  177|  52.4k|    curl_dbg_log("MEM %s:%d calloc(%zu,%zu) = %p\n",
  178|  52.4k|                 source, line, wanted_elements, wanted_size,
  179|  52.4k|                 mem ? (void *)mem->mem : (void *)0);
  180|       |
  181|  52.4k|  return (mem ? mem->mem : NULL);
  182|  52.4k|}
curl_dbg_strdup:
  185|   123k|{
  186|   123k|  char *mem;
  187|   123k|  size_t len;
  188|       |
  189|   123k|  DEBUGASSERT(str != NULL);
  190|       |
  191|   123k|  if(countcheck("strdup", line, source))
  192|      0|    return NULL;
  193|       |
  194|   123k|  len = strlen(str) + 1;
  195|       |
  196|   123k|  mem = curl_dbg_malloc(len, 0, NULL); /* NULL prevents logging */
  197|   123k|  if(mem)
  198|   123k|    memcpy(mem, str, len);
  199|       |
  200|   123k|  if(source)
  201|   123k|    curl_dbg_log("MEM %s:%d strdup(%p) (%zu) = %p\n",
  202|   123k|                 source, line, (const void *)str, len, (const void *)mem);
  203|       |
  204|   123k|  return mem;
  205|   123k|}
curl_dbg_realloc:
  237|  5.80M|{
  238|  5.80M|  struct memdebug *mem = NULL;
  239|       |
  240|  5.80M|  size_t size = sizeof(struct memdebug) + wantedsize;
  241|       |
  242|  5.80M|  DEBUGASSERT(wantedsize != 0);
  243|       |
  244|  5.80M|  if(countcheck("realloc", line, source))
  245|      0|    return NULL;
  246|       |
  247|       |#ifdef __INTEL_COMPILER
  248|       |#  pragma warning(push)
  249|       |#  pragma warning(disable:1684)
  250|       |   /* 1684: conversion from pointer to same-sized integral type */
  251|       |#endif
  252|       |
  253|  5.80M|  if(ptr)
  254|  5.79M|    mem = (void *)((char *)ptr - offsetof(struct memdebug, mem));
  255|       |
  256|       |#ifdef __INTEL_COMPILER
  257|       |#  pragma warning(pop)
  258|       |#endif
  259|       |
  260|  5.80M|  mem = (Curl_crealloc)(mem, size);
  261|  5.80M|  if(source)
  262|  5.80M|    curl_dbg_log("MEM %s:%d realloc(%p, %zu) = %p\n",
  263|  5.80M|                source, line, (void *)ptr, wantedsize,
  264|  5.80M|                mem ? (void *)mem->mem : (void *)0);
  265|       |
  266|  5.80M|  if(mem) {
  267|  5.80M|    mem->size = wantedsize;
  268|  5.80M|    return mem->mem;
  269|  5.80M|  }
  270|       |
  271|      0|  return NULL;
  272|  5.80M|}
curl_dbg_free:
  275|  7.36M|{
  276|  7.36M|  if(ptr) {
  277|  6.06M|    struct memdebug *mem;
  278|       |
  279|       |#ifdef __INTEL_COMPILER
  280|       |#  pragma warning(push)
  281|       |#  pragma warning(disable:1684)
  282|       |   /* 1684: conversion from pointer to same-sized integral type */
  283|       |#endif
  284|       |
  285|  6.06M|    mem = (void *)((char *)ptr - offsetof(struct memdebug, mem));
  286|       |
  287|       |#ifdef __INTEL_COMPILER
  288|       |#  pragma warning(pop)
  289|       |#endif
  290|       |
  291|       |    /* free for real */
  292|  6.06M|    (Curl_cfree)(mem);
  293|  6.06M|  }
  294|       |
  295|  7.36M|  if(source && ptr)
  296|  6.06M|    curl_dbg_log("MEM %s:%d free(%p)\n", source, line, (void *)ptr);
  297|  7.36M|}
curl_dbg_socket:
  301|  3.09k|{
  302|  3.09k|  const char *fmt = (sizeof(curl_socket_t) == sizeof(int)) ?
  303|  3.09k|    "FD %s:%d socket() = %d\n" :
  304|  3.09k|    (sizeof(curl_socket_t) == sizeof(long)) ?
  305|      0|    "FD %s:%d socket() = %ld\n" :
  306|      0|    "FD %s:%d socket() = %zd\n";
  307|       |
  308|  3.09k|  curl_socket_t sockfd;
  309|       |
  310|  3.09k|  if(countcheck("socket", line, source))
  311|      0|    return CURL_SOCKET_BAD;
  312|       |
  313|  3.09k|  sockfd = socket(domain, type, protocol);
  314|       |
  315|  3.09k|  if(source && (sockfd != CURL_SOCKET_BAD))
  316|  3.09k|    curl_dbg_log(fmt, source, line, sockfd);
  317|       |
  318|  3.09k|  return sockfd;
  319|  3.09k|}
curl_dbg_send:
  325|  5.65k|{
  326|  5.65k|  SEND_TYPE_RETV rc;
  327|  5.65k|  if(countcheck("send", line, source))
  328|      0|    return -1;
  329|  5.65k|  rc = send(sockfd, buf, len, flags);
  330|  5.65k|  if(source)
  331|  5.65k|    curl_dbg_log("SEND %s:%d send(%lu) = %ld\n",
  332|  5.65k|                source, line, (unsigned long)len, (long)rc);
  333|  5.65k|  return rc;
  334|  5.65k|}
curl_dbg_recv:
  339|  5.78M|{
  340|  5.78M|  RECV_TYPE_RETV rc;
  341|  5.78M|  if(countcheck("recv", line, source))
  342|      0|    return -1;
  343|  5.78M|  rc = recv(sockfd, buf, len, flags);
  344|  5.78M|  if(source)
  345|  5.78M|    curl_dbg_log("RECV %s:%d recv(%lu) = %ld\n",
  346|  5.78M|                source, line, (unsigned long)len, (long)rc);
  347|  5.78M|  return rc;
  348|  5.78M|}
curl_dbg_socketpair:
  354|  3.10k|{
  355|  3.10k|  const char *fmt = (sizeof(curl_socket_t) == sizeof(int)) ?
  356|  3.10k|    "FD %s:%d socketpair() = %d %d\n" :
  357|  3.10k|    (sizeof(curl_socket_t) == sizeof(long)) ?
  358|      0|    "FD %s:%d socketpair() = %ld %ld\n" :
  359|      0|    "FD %s:%d socketpair() = %zd %zd\n";
  360|       |
  361|  3.10k|  int res = socketpair(domain, type, protocol, socket_vector);
  362|       |
  363|  3.10k|  if(source && (0 == res))
  364|  3.10k|    curl_dbg_log(fmt, source, line, socket_vector[0], socket_vector[1]);
  365|       |
  366|  3.10k|  return res;
  367|  3.10k|}
curl_dbg_mark_sclose:
  392|  12.2k|{
  393|  12.2k|  const char *fmt = (sizeof(curl_socket_t) == sizeof(int)) ?
  394|  12.2k|    "FD %s:%d sclose(%d)\n":
  395|  12.2k|    (sizeof(curl_socket_t) == sizeof(long)) ?
  396|      0|    "FD %s:%d sclose(%ld)\n":
  397|      0|    "FD %s:%d sclose(%zd)\n";
  398|       |
  399|  12.2k|  if(source)
  400|  12.2k|    curl_dbg_log(fmt, source, line, sockfd);
  401|  12.2k|}
curl_dbg_sclose:
  405|  12.2k|{
  406|  12.2k|  int res = sclose(sockfd);
  407|  12.2k|  curl_dbg_mark_sclose(sockfd, line, source);
  408|  12.2k|  return res;
  409|  12.2k|}
curl_dbg_fopen:
  413|  3.09k|{
  414|  3.09k|  FILE *res = fopen(file, mode);
  415|       |
  416|  3.09k|  if(source)
  417|  3.09k|    curl_dbg_log("FILE %s:%d fopen(\"%s\",\"%s\") = %p\n",
  418|  3.09k|                source, line, file, mode, (void *)res);
  419|       |
  420|  3.09k|  return res;
  421|  3.09k|}
curl_dbg_fclose:
  434|  3.09k|{
  435|  3.09k|  int res;
  436|       |
  437|  3.09k|  DEBUGASSERT(file != NULL);
  438|       |
  439|  3.09k|  if(source)
  440|  3.09k|    curl_dbg_log("FILE %s:%d fclose(%p)\n",
  441|  3.09k|                 source, line, (void *)file);
  442|       |
  443|  3.09k|  res = fclose(file);
  444|       |
  445|  3.09k|  return res;
  446|  3.09k|}
curl_dbg_log:
  452|  23.7M|{
  453|  23.7M|  char *buf;
  454|  23.7M|  int nchars;
  455|  23.7M|  va_list ap;
  456|       |
  457|  23.7M|  if(!curl_dbg_logfile)
  458|  23.7M|    return;
  459|       |
  460|      0|  buf = (Curl_cmalloc)(LOGLINE_BUFSIZE);
  461|      0|  if(!buf)
  462|      0|    return;
  463|       |
  464|      0|  va_start(ap, format);
  465|      0|  nchars = mvsnprintf(buf, LOGLINE_BUFSIZE, format, ap);
  466|      0|  va_end(ap);
  467|       |
  468|      0|  if(nchars > LOGLINE_BUFSIZE - 1)
  469|      0|    nchars = LOGLINE_BUFSIZE - 1;
  470|       |
  471|      0|  if(nchars > 0)
  472|      0|    fwrite(buf, 1, (size_t)nchars, curl_dbg_logfile);
  473|       |
  474|      0|  (Curl_cfree)(buf);
  475|      0|}
memdebug.c:countcheck:
  106|  17.7M|{
  107|       |  /* if source is NULL, then the call is made internally and this check
  108|       |     should not be made */
  109|  17.7M|  if(memlimit && source) {
  110|      0|    if(!memsize) {
  111|       |      /* log to file */
  112|      0|      curl_dbg_log("LIMIT %s:%d %s reached memlimit\n",
  113|      0|                   source, line, func);
  114|       |      /* log to stderr also */
  115|      0|      fprintf(stderr, "LIMIT %s:%d %s reached memlimit\n",
  116|      0|              source, line, func);
  117|      0|      fflush(curl_dbg_logfile); /* because it might crash now */
  118|      0|      errno = ENOMEM;
  119|      0|      return TRUE; /* RETURN ERROR! */
  120|      0|    }
  121|      0|    else
  122|      0|      memsize--; /* countdown */
  123|       |
  124|       |
  125|      0|  }
  126|       |
  127|  17.7M|  return FALSE; /* allow this */
  128|  17.7M|}

Curl_mime_cleanpart:
 1200|  30.3k|{
 1201|  30.3k|  cleanup_part_content(part);
 1202|  30.3k|  curl_slist_free_all(part->curlheaders);
 1203|  30.3k|  if(part->flags & MIME_USERHEADERS_OWNER)
 1204|      0|    curl_slist_free_all(part->userheaders);
 1205|  30.3k|  Curl_safefree(part->mimetype);
 1206|  30.3k|  Curl_safefree(part->name);
 1207|  30.3k|  Curl_safefree(part->filename);
 1208|  30.3k|  Curl_mime_initpart(part, part->easy);
 1209|  30.3k|}
curl_mime_free:
 1213|    285|{
 1214|    285|  curl_mimepart *part;
 1215|       |
 1216|    285|  if(mime) {
 1217|    285|    mime_subparts_unbind(mime);  /* Be sure it's not referenced anymore. */
 1218|  22.9k|    while(mime->firstpart) {
 1219|  22.6k|      part = mime->firstpart;
 1220|  22.6k|      mime->firstpart = part->nextpart;
 1221|  22.6k|      Curl_mime_cleanpart(part);
 1222|  22.6k|      free(part);
 1223|  22.6k|    }
 1224|    285|    free(mime);
 1225|    285|  }
 1226|    285|}
curl_mime_init:
 1309|    285|{
 1310|    285|  curl_mime *mime;
 1311|       |
 1312|    285|  mime = (curl_mime *) malloc(sizeof(*mime));
 1313|       |
 1314|    285|  if(mime) {
 1315|    285|    mime->easy = easy;
 1316|    285|    mime->parent = NULL;
 1317|    285|    mime->firstpart = NULL;
 1318|    285|    mime->lastpart = NULL;
 1319|       |
 1320|    285|    memset(mime->boundary, '-', 24);
 1321|    285|    if(Curl_rand_hex(easy, (unsigned char *) &mime->boundary[24],
 1322|    285|                     MIME_RAND_BOUNDARY_CHARS + 1)) {
 1323|       |      /* failed to get random separator, bail out */
 1324|      0|      free(mime);
 1325|      0|      return NULL;
 1326|      0|    }
 1327|    285|    mimesetstate(&mime->state, MIMESTATE_BEGIN, NULL);
 1328|    285|  }
 1329|       |
 1330|    285|  return mime;
 1331|    285|}
Curl_mime_initpart:
 1335|  60.5k|{
 1336|  60.5k|  memset((char *) part, 0, sizeof(*part));
 1337|  60.5k|  part->easy = easy;
 1338|  60.5k|  part->lastreadstatus = 1; /* Successful read status. */
 1339|  60.5k|  mimesetstate(&part->state, MIMESTATE_BEGIN, NULL);
 1340|  60.5k|}
curl_mime_addpart:
 1344|  22.6k|{
 1345|  22.6k|  curl_mimepart *part;
 1346|       |
 1347|  22.6k|  if(!mime)
 1348|      0|    return NULL;
 1349|       |
 1350|  22.6k|  part = (curl_mimepart *) malloc(sizeof(*part));
 1351|       |
 1352|  22.6k|  if(part) {
 1353|  22.6k|    Curl_mime_initpart(part, mime->easy);
 1354|  22.6k|    part->parent = mime;
 1355|       |
 1356|  22.6k|    if(mime->lastpart)
 1357|  22.4k|      mime->lastpart->nextpart = part;
 1358|    285|    else
 1359|    285|      mime->firstpart = part;
 1360|       |
 1361|  22.6k|    mime->lastpart = part;
 1362|  22.6k|  }
 1363|       |
 1364|  22.6k|  return part;
 1365|  22.6k|}
curl_mime_name:
 1369|    353|{
 1370|    353|  if(!part)
 1371|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1372|       |
 1373|    353|  Curl_safefree(part->name);
 1374|    353|  part->name = NULL;
 1375|       |
 1376|    353|  if(name) {
 1377|    353|    part->name = strdup(name);
 1378|    353|    if(!part->name)
 1379|      0|      return CURLE_OUT_OF_MEMORY;
 1380|    353|  }
 1381|       |
 1382|    353|  return CURLE_OK;
 1383|    353|}
curl_mime_data:
 1406|    467|{
 1407|    467|  if(!part)
 1408|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1409|       |
 1410|    467|  cleanup_part_content(part);
 1411|       |
 1412|    467|  if(data) {
 1413|    467|    if(datasize == CURL_ZERO_TERMINATED)
 1414|      0|      datasize = strlen(data);
 1415|       |
 1416|    467|    part->data = malloc(datasize + 1);
 1417|    467|    if(!part->data)
 1418|      0|      return CURLE_OUT_OF_MEMORY;
 1419|       |
 1420|    467|    part->datasize = datasize;
 1421|       |
 1422|    467|    if(datasize)
 1423|    264|      memcpy(part->data, data, datasize);
 1424|    467|    part->data[datasize] = '\0';    /* Set a null terminator as sentinel. */
 1425|       |
 1426|    467|    part->readfunc = mime_mem_read;
 1427|    467|    part->seekfunc = mime_mem_seek;
 1428|    467|    part->freefunc = mime_mem_free;
 1429|    467|    part->flags |= MIME_FAST_READ;
 1430|    467|    part->kind = MIMEKIND_DATA;
 1431|    467|  }
 1432|       |
 1433|    467|  return CURLE_OK;
 1434|    467|}
curl_mime_headers:
 1529|    386|{
 1530|    386|  if(!part)
 1531|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1532|       |
 1533|    386|  if(part->flags & MIME_USERHEADERS_OWNER) {
 1534|      0|    if(part->userheaders != headers)  /* Allow setting twice the same list. */
 1535|      0|      curl_slist_free_all(part->userheaders);
 1536|      0|    part->flags &= ~MIME_USERHEADERS_OWNER;
 1537|      0|  }
 1538|    386|  part->userheaders = headers;
 1539|    386|  if(headers && take_ownership)
 1540|      0|    part->flags |= MIME_USERHEADERS_OWNER;
 1541|    386|  return CURLE_OK;
 1542|    386|}
Curl_mime_set_subparts:
 1570|    270|{
 1571|    270|  curl_mime *root;
 1572|       |
 1573|    270|  if(!part)
 1574|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1575|       |
 1576|       |  /* Accept setting twice the same subparts. */
 1577|    270|  if(part->kind == MIMEKIND_MULTIPART && part->arg == subparts)
 1578|      0|    return CURLE_OK;
 1579|       |
 1580|    270|  cleanup_part_content(part);
 1581|       |
 1582|    270|  if(subparts) {
 1583|       |    /* Must belong to the same data handle. */
 1584|    270|    if(part->easy && subparts->easy && part->easy != subparts->easy)
 1585|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1586|       |
 1587|       |    /* Should not have been attached already. */
 1588|    270|    if(subparts->parent)
 1589|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1590|       |
 1591|       |    /* Should not be the part's root. */
 1592|    270|    root = part->parent;
 1593|    270|    if(root) {
 1594|      0|      while(root->parent && root->parent->parent)
 1595|      0|        root = root->parent->parent;
 1596|      0|      if(subparts == root) {
 1597|      0|        if(part->easy)
 1598|      0|          failf(part->easy, "Can't add itself as a subpart!");
 1599|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
 1600|      0|      }
 1601|      0|    }
 1602|       |
 1603|    270|    subparts->parent = part;
 1604|       |    /* Subparts are processed internally: no read callback. */
 1605|    270|    part->seekfunc = mime_subparts_seek;
 1606|    270|    part->freefunc = take_ownership? mime_subparts_free: mime_subparts_unbind;
 1607|    270|    part->arg = subparts;
 1608|    270|    part->datasize = -1;
 1609|    270|    part->kind = MIMEKIND_MULTIPART;
 1610|    270|  }
 1611|       |
 1612|    270|  return CURLE_OK;
 1613|    270|}
Curl_mime_read:
 1624|    193|{
 1625|    193|  curl_mimepart *part = (curl_mimepart *) instream;
 1626|    193|  size_t ret;
 1627|    193|  bool hasread;
 1628|       |
 1629|    193|  (void) size;   /* Always 1. */
 1630|       |
 1631|    193|  do {
 1632|    193|    hasread = FALSE;
 1633|    193|    ret = readback_part(part, buffer, nitems, &hasread);
 1634|       |    /*
 1635|       |     * If this is not possible to get some data without calling more than
 1636|       |     * one read callback (probably because a content encoder is not able to
 1637|       |     * deliver a new bunch for the few data accumulated so far), force another
 1638|       |     * read until we get enough data or a special exit code.
 1639|       |     */
 1640|    193|  } while(ret == STOP_FILLING);
 1641|       |
 1642|    193|  return ret;
 1643|    193|}
Curl_mime_rewind:
 1647|    238|{
 1648|    238|  return mime_part_rewind(part) == CURL_SEEKFUNC_OK?
 1649|    232|         CURLE_OK: CURLE_SEND_FAIL_REWIND;
 1650|    238|}
Curl_mime_size:
 1693|  21.2k|{
 1694|  21.2k|  curl_off_t size;
 1695|       |
 1696|  21.2k|  if(part->kind == MIMEKIND_MULTIPART)
 1697|    229|    part->datasize = multipart_size(part->arg);
 1698|       |
 1699|  21.2k|  size = part->datasize;
 1700|       |
 1701|  21.2k|  if(part->encoder)
 1702|      0|    size = part->encoder->sizefunc(part);
 1703|       |
 1704|  21.2k|  if(size >= 0 && !(part->flags & MIME_BODY_ONLY)) {
 1705|       |    /* Compute total part size. */
 1706|  21.0k|    size += slist_size(part->curlheaders, 2, NULL);
 1707|  21.0k|    size += slist_size(part->userheaders, 2, "Content-Type");
 1708|  21.0k|    size += 2;    /* CRLF after headers. */
 1709|  21.0k|  }
 1710|  21.2k|  return size;
 1711|  21.2k|}
Curl_mime_add_header:
 1716|  3.49k|{
 1717|  3.49k|  struct curl_slist *hdr = NULL;
 1718|  3.49k|  char *s = NULL;
 1719|  3.49k|  va_list ap;
 1720|       |
 1721|  3.49k|  va_start(ap, fmt);
 1722|  3.49k|  s = curl_mvaprintf(fmt, ap);
 1723|  3.49k|  va_end(ap);
 1724|       |
 1725|  3.49k|  if(s) {
 1726|  3.49k|    hdr = Curl_slist_append_nodup(*slp, s);
 1727|  3.49k|    if(hdr)
 1728|  3.49k|      *slp = hdr;
 1729|      0|    else
 1730|      0|      free(s);
 1731|  3.49k|  }
 1732|       |
 1733|  3.49k|  return hdr? CURLE_OK: CURLE_OUT_OF_MEMORY;
 1734|  3.49k|}
Curl_mime_contenttype:
 1746|  21.0k|{
 1747|       |  /*
 1748|       |   * If no content type was specified, we scan through a few well-known
 1749|       |   * extensions and pick the first we match!
 1750|       |   */
 1751|  21.0k|  struct ContentType {
 1752|  21.0k|    const char *extension;
 1753|  21.0k|    const char *type;
 1754|  21.0k|  };
 1755|  21.0k|  static const struct ContentType ctts[] = {
 1756|  21.0k|    {".gif",  "image/gif"},
 1757|  21.0k|    {".jpg",  "image/jpeg"},
 1758|  21.0k|    {".jpeg", "image/jpeg"},
 1759|  21.0k|    {".png",  "image/png"},
 1760|  21.0k|    {".svg",  "image/svg+xml"},
 1761|  21.0k|    {".txt",  "text/plain"},
 1762|  21.0k|    {".htm",  "text/html"},
 1763|  21.0k|    {".html", "text/html"},
 1764|  21.0k|    {".pdf",  "application/pdf"},
 1765|  21.0k|    {".xml",  "application/xml"}
 1766|  21.0k|  };
 1767|       |
 1768|  21.0k|  if(filename) {
 1769|      0|    size_t len1 = strlen(filename);
 1770|      0|    const char *nameend = filename + len1;
 1771|      0|    unsigned int i;
 1772|       |
 1773|      0|    for(i = 0; i < sizeof(ctts) / sizeof(ctts[0]); i++) {
 1774|      0|      size_t len2 = strlen(ctts[i].extension);
 1775|       |
 1776|      0|      if(len1 >= len2 && strcasecompare(nameend - len2, ctts[i].extension))
 1777|      0|          return ctts[i].type;
 1778|      0|    }
 1779|      0|  }
 1780|  21.0k|  return NULL;
 1781|  21.0k|}
Curl_mime_prepare_headers:
 1804|  21.2k|{
 1805|  21.2k|  curl_mime *mime = NULL;
 1806|  21.2k|  const char *boundary = NULL;
 1807|  21.2k|  char *customct;
 1808|  21.2k|  const char *cte = NULL;
 1809|  21.2k|  CURLcode ret = CURLE_OK;
 1810|       |
 1811|       |  /* Get rid of previously prepared headers. */
 1812|  21.2k|  curl_slist_free_all(part->curlheaders);
 1813|  21.2k|  part->curlheaders = NULL;
 1814|       |
 1815|       |  /* Be sure we won't access old headers later. */
 1816|  21.2k|  if(part->state.state == MIMESTATE_CURLHEADERS)
 1817|      0|    mimesetstate(&part->state, MIMESTATE_CURLHEADERS, NULL);
 1818|       |
 1819|       |  /* Check if content type is specified. */
 1820|  21.2k|  customct = part->mimetype;
 1821|  21.2k|  if(!customct)
 1822|  21.2k|    customct = search_header(part->userheaders, "Content-Type");
 1823|  21.2k|  if(customct)
 1824|     27|    contenttype = customct;
 1825|       |
 1826|       |  /* If content type is not specified, try to determine it. */
 1827|  21.2k|  if(!contenttype) {
 1828|  21.0k|    switch(part->kind) {
 1829|     71|    case MIMEKIND_MULTIPART:
 1830|     71|      contenttype = MULTIPART_CONTENTTYPE_DEFAULT;
 1831|     71|      break;
 1832|      0|    case MIMEKIND_FILE:
 1833|      0|      contenttype = Curl_mime_contenttype(part->filename);
 1834|      0|      if(!contenttype)
 1835|      0|        contenttype = Curl_mime_contenttype(part->data);
 1836|      0|      if(!contenttype && part->filename)
 1837|      0|        contenttype = FILE_CONTENTTYPE_DEFAULT;
 1838|      0|      break;
 1839|  21.0k|    default:
 1840|  21.0k|      contenttype = Curl_mime_contenttype(part->filename);
 1841|  21.0k|      break;
 1842|  21.0k|    }
 1843|  21.0k|  }
 1844|       |
 1845|  21.2k|  if(part->kind == MIMEKIND_MULTIPART) {
 1846|    233|    mime = (curl_mime *) part->arg;
 1847|    233|    if(mime)
 1848|    233|      boundary = mime->boundary;
 1849|    233|  }
 1850|  21.0k|  else if(contenttype && !customct &&
 1851|  21.0k|          content_type_match(contenttype, "text/plain"))
 1852|      0|    if(strategy == MIMESTRATEGY_MAIL || !part->filename)
 1853|      0|      contenttype = NULL;
 1854|       |
 1855|       |  /* Issue content-disposition header only if not already set by caller. */
 1856|  21.2k|  if(!search_header(part->userheaders, "Content-Disposition")) {
 1857|  21.2k|    if(!disposition)
 1858|  18.0k|      if(part->filename || part->name ||
 1859|  18.0k|        (contenttype && !strncasecompare(contenttype, "multipart/", 10)))
 1860|     48|          disposition = DISPOSITION_DEFAULT;
 1861|  21.2k|    if(disposition && curl_strequal(disposition, "attachment") &&
 1862|  21.2k|     !part->name && !part->filename)
 1863|     27|      disposition = NULL;
 1864|  21.2k|    if(disposition) {
 1865|  3.18k|      char *name = NULL;
 1866|  3.18k|      char *filename = NULL;
 1867|       |
 1868|  3.18k|      if(part->name) {
 1869|    348|        name = escape_string(part->name);
 1870|    348|        if(!name)
 1871|      0|          ret = CURLE_OUT_OF_MEMORY;
 1872|    348|      }
 1873|  3.18k|      if(!ret && part->filename) {
 1874|      0|        filename = escape_string(part->filename);
 1875|      0|        if(!filename)
 1876|      0|          ret = CURLE_OUT_OF_MEMORY;
 1877|      0|      }
 1878|  3.18k|      if(!ret)
 1879|  3.18k|        ret = Curl_mime_add_header(&part->curlheaders,
 1880|  3.18k|                                   "Content-Disposition: %s%s%s%s%s%s%s",
 1881|  3.18k|                                   disposition,
 1882|  3.18k|                                   name? "; name=\"": "",
 1883|  3.18k|                                   name? name: "",
 1884|  3.18k|                                   name? "\"": "",
 1885|  3.18k|                                   filename? "; filename=\"": "",
 1886|  3.18k|                                   filename? filename: "",
 1887|  3.18k|                                   filename? "\"": "");
 1888|  3.18k|      Curl_safefree(name);
 1889|  3.18k|      Curl_safefree(filename);
 1890|  3.18k|      if(ret)
 1891|      0|        return ret;
 1892|  3.18k|      }
 1893|  21.2k|    }
 1894|       |
 1895|       |  /* Issue Content-Type header. */
 1896|  21.2k|  if(contenttype) {
 1897|    233|    ret = add_content_type(&part->curlheaders, contenttype, boundary);
 1898|    233|    if(ret)
 1899|      0|      return ret;
 1900|    233|  }
 1901|       |
 1902|       |  /* Content-Transfer-Encoding header. */
 1903|  21.2k|  if(!search_header(part->userheaders, "Content-Transfer-Encoding")) {
 1904|  21.2k|    if(part->encoder)
 1905|      0|      cte = part->encoder->name;
 1906|  21.2k|    else if(contenttype && strategy == MIMESTRATEGY_MAIL &&
 1907|  21.2k|     part->kind != MIMEKIND_MULTIPART)
 1908|      0|      cte = "8bit";
 1909|  21.2k|    if(cte) {
 1910|      0|      ret = Curl_mime_add_header(&part->curlheaders,
 1911|      0|                                 "Content-Transfer-Encoding: %s", cte);
 1912|      0|      if(ret)
 1913|      0|        return ret;
 1914|      0|    }
 1915|  21.2k|  }
 1916|       |
 1917|       |  /* If we were reading curl-generated headers, restart with new ones (this
 1918|       |     should not occur). */
 1919|  21.2k|  if(part->state.state == MIMESTATE_CURLHEADERS)
 1920|      0|    mimesetstate(&part->state, MIMESTATE_CURLHEADERS, part->curlheaders);
 1921|       |
 1922|       |  /* Process subparts. */
 1923|  21.2k|  if(part->kind == MIMEKIND_MULTIPART && mime) {
 1924|    233|    curl_mimepart *subpart;
 1925|       |
 1926|    233|    disposition = NULL;
 1927|    233|    if(content_type_match(contenttype, "multipart/form-data"))
 1928|    135|      disposition = "form-data";
 1929|  21.2k|    for(subpart = mime->firstpart; subpart; subpart = subpart->nextpart) {
 1930|  21.0k|      ret = Curl_mime_prepare_headers(subpart, NULL, disposition, strategy);
 1931|  21.0k|      if(ret)
 1932|      0|        return ret;
 1933|  21.0k|    }
 1934|    233|  }
 1935|  21.2k|  return ret;
 1936|  21.2k|}
mime.c:cleanup_part_content:
 1157|  31.3k|{
 1158|  31.3k|  if(part->freefunc)
 1159|    467|    part->freefunc(part->arg);
 1160|       |
 1161|  31.3k|  part->readfunc = NULL;
 1162|  31.3k|  part->seekfunc = NULL;
 1163|  31.3k|  part->freefunc = NULL;
 1164|  31.3k|  part->arg = (void *) part;          /* Defaults to part itself. */
 1165|  31.3k|  part->data = NULL;
 1166|  31.3k|  part->fp = NULL;
 1167|  31.3k|  part->datasize = (curl_off_t) 0;    /* No size yet. */
 1168|  31.3k|  cleanup_encoder_state(&part->encstate);
 1169|  31.3k|  part->kind = MIMEKIND_NONE;
 1170|  31.3k|  part->flags &= ~MIME_FAST_READ;
 1171|  31.3k|  part->lastreadstatus = 1; /* Successful read status. */
 1172|  31.3k|  part->state.state = MIMESTATE_BEGIN;
 1173|  31.3k|}
mime.c:cleanup_encoder_state:
  347|  50.2k|{
  348|  50.2k|  p->pos = 0;
  349|  50.2k|  p->bufbeg = 0;
  350|  50.2k|  p->bufend = 0;
  351|  50.2k|}
mime.c:mime_subparts_unbind:
 1188|    285|{
 1189|    285|  curl_mime *mime = (curl_mime *) ptr;
 1190|       |
 1191|    285|  if(mime && mime->parent) {
 1192|    270|    mime->parent->freefunc = NULL;  /* Be sure we won't be called again. */
 1193|    270|    cleanup_part_content(mime->parent);  /* Avoid dangling pointer in part. */
 1194|    270|    mime->parent = NULL;
 1195|    270|  }
 1196|    285|}
mime.c:mimesetstate:
  274|   231k|{
  275|   231k|  state->state = tok;
  276|   231k|  state->ptr = ptr;
  277|   231k|  state->offset = 0;
  278|   231k|}
mime.c:mime_mem_read:
  644|    259|{
  645|    259|  curl_mimepart *part = (curl_mimepart *) instream;
  646|    259|  size_t sz = curlx_sotouz(part->datasize - part->state.offset);
  647|    259|  (void) size;   /* Always 1.*/
  648|       |
  649|    259|  if(!nitems)
  650|      0|    return STOP_FILLING;
  651|       |
  652|    259|  if(sz > nitems)
  653|      0|    sz = nitems;
  654|       |
  655|    259|  if(sz)
  656|    259|    memcpy(buffer, part->data + curlx_sotouz(part->state.offset), sz);
  657|       |
  658|    259|  return sz;
  659|    259|}
mime.c:mime_mem_seek:
  662|     10|{
  663|     10|  curl_mimepart *part = (curl_mimepart *) instream;
  664|       |
  665|     10|  switch(whence) {
  666|      0|  case SEEK_CUR:
  667|      0|    offset += part->state.offset;
  668|      0|    break;
  669|      0|  case SEEK_END:
  670|      0|    offset += part->datasize;
  671|      0|    break;
  672|     10|  }
  673|       |
  674|     10|  if(offset < 0 || offset > part->datasize)
  675|      0|    return CURL_SEEKFUNC_FAIL;
  676|       |
  677|     10|  part->state.offset = offset;
  678|     10|  return CURL_SEEKFUNC_OK;
  679|     10|}
mime.c:mime_mem_free:
  682|    467|{
  683|    467|  Curl_safefree(((curl_mimepart *) ptr)->data);
  684|    467|}
mime.c:mime_subparts_seek:
 1132|      9|{
 1133|      9|  curl_mime *mime = (curl_mime *) instream;
 1134|      9|  curl_mimepart *part;
 1135|      9|  int result = CURL_SEEKFUNC_OK;
 1136|       |
 1137|      9|  if(whence != SEEK_SET || offset)
 1138|      0|    return CURL_SEEKFUNC_CANTSEEK;    /* Only support full rewind. */
 1139|       |
 1140|      9|  if(mime->state.state == MIMESTATE_BEGIN)
 1141|      0|   return CURL_SEEKFUNC_OK;           /* Already rewound. */
 1142|       |
 1143|     30|  for(part = mime->firstpart; part; part = part->nextpart) {
 1144|     21|    int res = mime_part_rewind(part);
 1145|     21|    if(res != CURL_SEEKFUNC_OK)
 1146|     11|      result = res;
 1147|     21|  }
 1148|       |
 1149|      9|  if(result == CURL_SEEKFUNC_OK)
 1150|      3|    mimesetstate(&mime->state, MIMESTATE_BEGIN, NULL);
 1151|       |
 1152|      9|  return result;
 1153|      9|}
mime.c:readback_part:
  902|  37.1k|{
  903|  37.1k|  size_t cursize = 0;
  904|       |#ifdef CURL_DOES_CONVERSIONS
  905|       |  char *convbuf = buffer;
  906|       |#endif
  907|       |
  908|       |  /* Readback from part. */
  909|       |
  910|   156k|  while(bufsize) {
  911|   156k|    size_t sz = 0;
  912|   156k|    struct curl_slist *hdr = (struct curl_slist *) part->state.ptr;
  913|   156k|    switch(part->state.state) {
  914|  18.5k|    case MIMESTATE_BEGIN:
  915|  18.5k|      mimesetstate(&part->state,
  916|  18.5k|                   (part->flags & MIME_BODY_ONLY)?
  917|  18.5k|                     MIMESTATE_BODY: MIMESTATE_CURLHEADERS,
  918|  18.5k|                   part->curlheaders);
  919|  18.5k|      break;
  920|  23.2k|    case MIMESTATE_USERHEADERS:
  921|  23.2k|      if(!hdr) {
  922|  18.5k|        mimesetstate(&part->state, MIMESTATE_EOH, NULL);
  923|  18.5k|        break;
  924|  18.5k|      }
  925|  4.69k|      if(match_header(hdr, "Content-Type", 12)) {
  926|     28|        mimesetstate(&part->state, MIMESTATE_USERHEADERS, hdr->next);
  927|     28|        break;
  928|     28|      }
  929|       |      /* FALLTHROUGH */
  930|  26.0k|    case MIMESTATE_CURLHEADERS:
  931|  26.0k|      if(!hdr)
  932|  18.5k|        mimesetstate(&part->state, MIMESTATE_USERHEADERS, part->userheaders);
  933|  7.43k|      else {
  934|  7.43k|        sz = readback_bytes(&part->state, buffer, bufsize,
  935|  7.43k|                            hdr->data, strlen(hdr->data), "\r\n");
  936|  7.43k|        if(!sz)
  937|  3.05k|          mimesetstate(&part->state, part->state.state, hdr->next);
  938|  7.43k|      }
  939|  26.0k|      break;
  940|  37.1k|    case MIMESTATE_EOH:
  941|  37.1k|      sz = readback_bytes(&part->state, buffer, bufsize, "\r\n", 2, "");
  942|  37.1k|      if(!sz)
  943|  18.5k|        mimesetstate(&part->state, MIMESTATE_BODY, NULL);
  944|  37.1k|      break;
  945|  18.6k|    case MIMESTATE_BODY:
  946|       |#ifdef CURL_DOES_CONVERSIONS
  947|       |      if(part->easy && convbuf < buffer) {
  948|       |        CURLcode result = Curl_convert_to_network(part->easy, convbuf,
  949|       |                                                  buffer - convbuf);
  950|       |        if(result)
  951|       |          return READ_ERROR;
  952|       |        convbuf = buffer;
  953|       |      }
  954|       |#endif
  955|  18.6k|      cleanup_encoder_state(&part->encstate);
  956|  18.6k|      mimesetstate(&part->state, MIMESTATE_CONTENT, NULL);
  957|  18.6k|      break;
  958|  19.1k|    case MIMESTATE_CONTENT:
  959|  19.1k|      if(part->encoder)
  960|      0|        sz = read_encoded_part_content(part, buffer, bufsize, hasread);
  961|  19.1k|      else
  962|  19.1k|        sz = read_part_content(part, buffer, bufsize, hasread);
  963|  19.1k|      switch(sz) {
  964|  18.6k|      case 0:
  965|  18.6k|        mimesetstate(&part->state, MIMESTATE_END, NULL);
  966|       |        /* Try sparing open file descriptors. */
  967|  18.6k|        if(part->kind == MIMEKIND_FILE && part->fp) {
  968|      0|          fclose(part->fp);
  969|      0|          part->fp = NULL;
  970|      0|        }
  971|       |        /* FALLTHROUGH */
  972|  18.6k|      case CURL_READFUNC_ABORT:
  973|  18.6k|      case CURL_READFUNC_PAUSE:
  974|  18.6k|      case READ_ERROR:
  975|  18.6k|      case STOP_FILLING:
  976|  18.6k|        return cursize? cursize: sz;
  977|  19.1k|      }
  978|    433|      break;
  979|  18.5k|    case MIMESTATE_END:
  980|  18.5k|      return cursize;
  981|      0|    default:
  982|      0|      break;    /* Other values not in part state. */
  983|   156k|    }
  984|       |
  985|       |    /* Bump buffer and counters according to read size. */
  986|   119k|    cursize += sz;
  987|   119k|    buffer += sz;
  988|   119k|    bufsize -= sz;
  989|   119k|  }
  990|       |
  991|       |#ifdef CURL_DOES_CONVERSIONS
  992|       |      if(part->easy && convbuf < buffer &&
  993|       |         part->state.state < MIMESTATE_BODY) {
  994|       |        CURLcode result = Curl_convert_to_network(part->easy, convbuf,
  995|       |                                                  buffer - convbuf);
  996|       |        if(result)
  997|       |          return READ_ERROR;
  998|       |      }
  999|       |#endif
 1000|       |
 1001|      4|  return cursize;
 1002|  37.1k|}
mime.c:match_header:
  309|  15.4k|{
  310|  15.4k|  char *value = NULL;
  311|       |
  312|  15.4k|  if(strncasecompare(hdr->data, lbl, len) && hdr->data[len] == ':')
  313|    101|    for(value = hdr->data + len + 1; *value == ' '; value++)
  314|     18|      ;
  315|  15.4k|  return value;
  316|  15.4k|}
mime.c:readback_bytes:
  748|   137k|{
  749|   137k|  size_t sz;
  750|   137k|  size_t offset = curlx_sotouz(state->offset);
  751|       |
  752|   137k|  if(numbytes > offset) {
  753|  57.2k|    sz = numbytes - offset;
  754|  57.2k|    bytes += offset;
  755|  57.2k|  }
  756|  80.6k|  else {
  757|  80.6k|    size_t tsz = strlen(trail);
  758|       |
  759|  80.6k|    sz = offset - numbytes;
  760|  80.6k|    if(sz >= tsz)
  761|  58.9k|      return 0;
  762|  21.7k|    bytes = trail + sz;
  763|  21.7k|    sz = tsz - sz;
  764|  21.7k|  }
  765|       |
  766|  78.9k|  if(sz > bufsize)
  767|      2|    sz = bufsize;
  768|       |
  769|  78.9k|  memcpy(buffer, bytes, sz);
  770|  78.9k|  state->offset += sz;
  771|  78.9k|  return sz;
  772|   137k|}
mime.c:read_part_content:
  777|  19.1k|{
  778|  19.1k|  size_t sz = 0;
  779|       |
  780|  19.1k|  switch(part->lastreadstatus) {
  781|      0|  case 0:
  782|      0|  case CURL_READFUNC_ABORT:
  783|      0|  case CURL_READFUNC_PAUSE:
  784|      0|  case READ_ERROR:
  785|      0|    return part->lastreadstatus;
  786|  19.1k|  default:
  787|  19.1k|    break;
  788|  19.1k|  }
  789|       |
  790|       |  /* If we can determine we are at end of part data, spare a read. */
  791|  19.1k|  if(part->datasize != (curl_off_t) -1 &&
  792|  19.1k|     part->state.offset >= part->datasize) {
  793|       |    /* sz is already zero. */
  794|  18.6k|  }
  795|    433|  else {
  796|    433|    switch(part->kind) {
  797|    174|    case MIMEKIND_MULTIPART:
  798|       |      /*
  799|       |       * Cannot be processed as other kinds since read function requires
  800|       |       * an additional parameter and is highly recursive.
  801|       |       */
  802|    174|       sz = mime_subparts_read(buffer, 1, bufsize, part->arg, hasread);
  803|    174|       break;
  804|      0|    case MIMEKIND_FILE:
  805|      0|      if(part->fp && feof(part->fp))
  806|      0|        break;  /* At EOF. */
  807|       |      /* FALLTHROUGH */
  808|    259|    default:
  809|    259|      if(part->readfunc) {
  810|    259|        if(!(part->flags & MIME_FAST_READ)) {
  811|      0|          if(*hasread)
  812|      0|            return STOP_FILLING;
  813|      0|          *hasread = TRUE;
  814|      0|        }
  815|    259|        sz = part->readfunc(buffer, 1, bufsize, part->arg);
  816|    259|      }
  817|    259|      break;
  818|    433|    }
  819|    433|  }
  820|       |
  821|  19.1k|  switch(sz) {
  822|      0|  case STOP_FILLING:
  823|      0|    break;
  824|  18.6k|  case 0:
  825|  18.6k|  case CURL_READFUNC_ABORT:
  826|  18.6k|  case CURL_READFUNC_PAUSE:
  827|  18.6k|  case READ_ERROR:
  828|  18.6k|    part->lastreadstatus = sz;
  829|  18.6k|    break;
  830|    433|  default:
  831|    433|    part->state.offset += sz;
  832|    433|    part->lastreadstatus = sz;
  833|    433|    break;
  834|  19.1k|  }
  835|       |
  836|  19.1k|  return sz;
  837|  19.1k|}
mime.c:mime_subparts_read:
 1007|    174|{
 1008|    174|  curl_mime *mime = (curl_mime *) instream;
 1009|    174|  size_t cursize = 0;
 1010|       |#ifdef CURL_DOES_CONVERSIONS
 1011|       |  char *convbuf = buffer;
 1012|       |#endif
 1013|       |
 1014|    174|  (void) size;   /* Always 1. */
 1015|       |
 1016|   130k|  while(nitems) {
 1017|   130k|    size_t sz = 0;
 1018|   130k|    curl_mimepart *part = mime->state.ptr;
 1019|   130k|    switch(mime->state.state) {
 1020|    172|    case MIMESTATE_BEGIN:
 1021|    172|    case MIMESTATE_BODY:
 1022|       |#ifdef CURL_DOES_CONVERSIONS
 1023|       |      convbuf = buffer;
 1024|       |#endif
 1025|    172|      mimesetstate(&mime->state, MIMESTATE_BOUNDARY1, mime->firstpart);
 1026|       |      /* The first boundary always follows the header termination empty line,
 1027|       |         so is always preceded by a CRLF. We can then spare 2 characters
 1028|       |         by skipping the leading CRLF in boundary. */
 1029|    172|      mime->state.offset += 2;
 1030|    172|      break;
 1031|  37.3k|    case MIMESTATE_BOUNDARY1:
 1032|  37.3k|      sz = readback_bytes(&mime->state, buffer, nitems, "\r\n--", 4, "");
 1033|  37.3k|      if(!sz)
 1034|  18.6k|        mimesetstate(&mime->state, MIMESTATE_BOUNDARY2, part);
 1035|  37.3k|      break;
 1036|  56.0k|    case MIMESTATE_BOUNDARY2:
 1037|  56.0k|      sz = readback_bytes(&mime->state, buffer, nitems, mime->boundary,
 1038|  56.0k|                          strlen(mime->boundary), part? "\r\n": "--\r\n");
 1039|  56.0k|      if(!sz) {
 1040|       |#ifdef CURL_DOES_CONVERSIONS
 1041|       |        if(mime->easy && convbuf < buffer) {
 1042|       |          CURLcode result = Curl_convert_to_network(mime->easy, convbuf,
 1043|       |                                                    buffer - convbuf);
 1044|       |          if(result)
 1045|       |            return READ_ERROR;
 1046|       |          convbuf = buffer;
 1047|       |        }
 1048|       |#endif
 1049|  18.6k|        mimesetstate(&mime->state, MIMESTATE_CONTENT, part);
 1050|  18.6k|      }
 1051|  56.0k|      break;
 1052|  37.1k|    case MIMESTATE_CONTENT:
 1053|  37.1k|      if(!part) {
 1054|    171|        mimesetstate(&mime->state, MIMESTATE_END, NULL);
 1055|    171|        break;
 1056|    171|      }
 1057|  36.9k|      sz = readback_part(part, buffer, nitems, hasread);
 1058|  36.9k|      switch(sz) {
 1059|      0|      case CURL_READFUNC_ABORT:
 1060|      0|      case CURL_READFUNC_PAUSE:
 1061|      0|      case READ_ERROR:
 1062|      0|      case STOP_FILLING:
 1063|      0|        return cursize? cursize: sz;
 1064|  18.4k|      case 0:
 1065|       |#ifdef CURL_DOES_CONVERSIONS
 1066|       |        convbuf = buffer;
 1067|       |#endif
 1068|  18.4k|        mimesetstate(&mime->state, MIMESTATE_BOUNDARY1, part->nextpart);
 1069|  18.4k|        break;
 1070|  36.9k|      }
 1071|  36.9k|      break;
 1072|  36.9k|    case MIMESTATE_END:
 1073|    171|      return cursize;
 1074|      0|    default:
 1075|      0|      break;    /* other values not used in mime state. */
 1076|   130k|    }
 1077|       |
 1078|       |    /* Bump buffer and counters according to read size. */
 1079|   130k|    cursize += sz;
 1080|   130k|    buffer += sz;
 1081|   130k|    nitems -= sz;
 1082|   130k|  }
 1083|       |
 1084|       |#ifdef CURL_DOES_CONVERSIONS
 1085|       |      if(mime->easy && convbuf < buffer &&
 1086|       |         mime->state.state <= MIMESTATE_CONTENT) {
 1087|       |        CURLcode result = Curl_convert_to_network(mime->easy, convbuf,
 1088|       |                                                  buffer - convbuf);
 1089|       |        if(result)
 1090|       |          return READ_ERROR;
 1091|       |      }
 1092|       |#endif
 1093|       |
 1094|      3|  return cursize;
 1095|    174|}
mime.c:mime_part_rewind:
 1098|    259|{
 1099|    259|  int res = CURL_SEEKFUNC_OK;
 1100|    259|  enum mimestate targetstate = MIMESTATE_BEGIN;
 1101|       |
 1102|    259|  if(part->flags & MIME_BODY_ONLY)
 1103|    158|    targetstate = MIMESTATE_BODY;
 1104|    259|  cleanup_encoder_state(&part->encstate);
 1105|    259|  if(part->state.state > targetstate) {
 1106|     30|    res = CURL_SEEKFUNC_CANTSEEK;
 1107|     30|    if(part->seekfunc) {
 1108|     19|      res = part->seekfunc(part->arg, (curl_off_t) 0, SEEK_SET);
 1109|     19|      switch(res) {
 1110|     13|      case CURL_SEEKFUNC_OK:
 1111|     13|      case CURL_SEEKFUNC_FAIL:
 1112|     19|      case CURL_SEEKFUNC_CANTSEEK:
 1113|     19|        break;
 1114|      0|      case -1:    /* For fseek() error. */
 1115|      0|        res = CURL_SEEKFUNC_CANTSEEK;
 1116|      0|        break;
 1117|      0|      default:
 1118|      0|        res = CURL_SEEKFUNC_FAIL;
 1119|      0|        break;
 1120|     19|      }
 1121|     19|    }
 1122|     30|  }
 1123|       |
 1124|    259|  if(res == CURL_SEEKFUNC_OK)
 1125|    242|    mimesetstate(&part->state, targetstate, NULL);
 1126|       |
 1127|    259|  part->lastreadstatus = 1; /* Successful read status. */
 1128|    259|  return res;
 1129|    259|}
mime.c:multipart_size:
 1667|    229|{
 1668|    229|  curl_off_t size;
 1669|    229|  size_t boundarysize;
 1670|    229|  curl_mimepart *part;
 1671|       |
 1672|    229|  if(!mime)
 1673|      0|    return 0;           /* Not present -> empty. */
 1674|       |
 1675|    229|  boundarysize = 4 + strlen(mime->boundary) + 2;
 1676|    229|  size = boundarysize;  /* Final boundary - CRLF after headers. */
 1677|       |
 1678|  21.2k|  for(part = mime->firstpart; part; part = part->nextpart) {
 1679|  21.0k|    curl_off_t sz = Curl_mime_size(part);
 1680|       |
 1681|  21.0k|    if(sz < 0)
 1682|      0|      size = sz;
 1683|       |
 1684|  21.0k|    if(size >= 0)
 1685|  21.0k|      size += boundarysize + sz;
 1686|  21.0k|  }
 1687|       |
 1688|    229|  return size;
 1689|    229|}
mime.c:slist_size:
 1655|  42.1k|{
 1656|  42.1k|  size_t size = 0;
 1657|  42.1k|  size_t skiplen = skip? strlen(skip): 0;
 1658|       |
 1659|  47.6k|  for(; s; s = s->next)
 1660|  5.50k|    if(!skip || !match_header(s, skip, skiplen))
 1661|  5.48k|      size += strlen(s->data) + overhead;
 1662|  42.1k|  return size;
 1663|  42.1k|}
mime.c:search_header:
  320|  63.7k|{
  321|  63.7k|  size_t len = strlen(hdr);
  322|  63.7k|  char *value = NULL;
  323|       |
  324|  72.3k|  for(; !value && hdrlist; hdrlist = hdrlist->next)
  325|  8.56k|    value = match_header(hdrlist, hdr, len);
  326|       |
  327|  63.7k|  return value;
  328|  63.7k|}
mime.c:content_type_match:
 1784|    233|{
 1785|    233|  size_t len = strlen(target);
 1786|       |
 1787|    233|  if(contenttype && strncasecompare(contenttype, target, len))
 1788|    135|    switch(contenttype[len]) {
 1789|    135|    case '\0':
 1790|    135|    case '\t':
 1791|    135|    case '\r':
 1792|    135|    case '\n':
 1793|    135|    case ' ':
 1794|    135|    case ';':
 1795|    135|      return TRUE;
 1796|    135|    }
 1797|     98|  return FALSE;
 1798|    233|}
mime.c:escape_string:
  283|    348|{
  284|    348|  size_t bytecount = 0;
  285|    348|  size_t i;
  286|    348|  char *dst;
  287|       |
  288|  1.58k|  for(i = 0; src[i]; i++)
  289|  1.23k|    if(src[i] == '"' || src[i] == '\\')
  290|    162|      bytecount++;
  291|       |
  292|    348|  bytecount += i;
  293|    348|  dst = malloc(bytecount + 1);
  294|    348|  if(!dst)
  295|      0|    return NULL;
  296|       |
  297|  1.58k|  for(i = 0; *src; src++) {
  298|  1.23k|    if(*src == '"' || *src == '\\')
  299|    162|      dst[i++] = '\\';
  300|  1.23k|    dst[i++] = *src;
  301|  1.23k|  }
  302|       |
  303|    348|  dst[i] = '\0';
  304|    348|  return dst;
  305|    348|}
mime.c:add_content_type:
 1739|    233|{
 1740|    233|  return Curl_mime_add_header(slp, "Content-Type: %s%s%s", type,
 1741|    233|                              boundary? "; boundary=": "",
 1742|    233|                              boundary? boundary: "");
 1743|    233|}

curl_mvsnprintf:
 1009|  52.1k|{
 1010|  52.1k|  int retcode;
 1011|  52.1k|  struct nsprintf info;
 1012|       |
 1013|  52.1k|  info.buffer = buffer;
 1014|  52.1k|  info.length = 0;
 1015|  52.1k|  info.max = maxlength;
 1016|       |
 1017|  52.1k|  retcode = dprintf_formatf(&info, addbyter, format, ap_save);
 1018|  52.1k|  if((retcode != -1) && info.max) {
 1019|       |    /* we terminate this with a zero byte */
 1020|  52.1k|    if(info.max == info.length) {
 1021|       |      /* we're at maximum, scrap the last letter */
 1022|      0|      info.buffer[-1] = 0;
 1023|      0|      retcode--; /* don't count the nul byte */
 1024|      0|    }
 1025|  52.1k|    else
 1026|  52.1k|      info.buffer[0] = 0;
 1027|  52.1k|  }
 1028|  52.1k|  return retcode;
 1029|  52.1k|}
curl_msnprintf:
 1032|  52.1k|{
 1033|  52.1k|  int retcode;
 1034|  52.1k|  va_list ap_save; /* argument pointer */
 1035|  52.1k|  va_start(ap_save, format);
 1036|  52.1k|  retcode = curl_mvsnprintf(buffer, maxlength, format, ap_save);
 1037|  52.1k|  va_end(ap_save);
 1038|  52.1k|  return retcode;
 1039|  52.1k|}
Curl_dyn_vprintf:
 1059|  10.2k|{
 1060|  10.2k|  int retcode;
 1061|  10.2k|  struct asprintf info;
 1062|  10.2k|  info.b = dyn;
 1063|  10.2k|  info.fail = 0;
 1064|       |
 1065|  10.2k|  retcode = dprintf_formatf(&info, alloc_addbyter, format, ap_save);
 1066|  10.2k|  if((-1 == retcode) || info.fail) {
 1067|      0|    Curl_dyn_free(info.b);
 1068|      0|    return 1;
 1069|      0|  }
 1070|  10.2k|  return 0;
 1071|  10.2k|}
curl_mvaprintf:
 1074|  13.9k|{
 1075|  13.9k|  int retcode;
 1076|  13.9k|  struct asprintf info;
 1077|  13.9k|  struct dynbuf dyn;
 1078|  13.9k|  info.b = &dyn;
 1079|  13.9k|  Curl_dyn_init(info.b, DYN_APRINTF);
 1080|  13.9k|  info.fail = 0;
 1081|       |
 1082|  13.9k|  retcode = dprintf_formatf(&info, alloc_addbyter, format, ap_save);
 1083|  13.9k|  if((-1 == retcode) || info.fail) {
 1084|      0|    Curl_dyn_free(info.b);
 1085|      0|    return NULL;
 1086|      0|  }
 1087|  13.9k|  if(Curl_dyn_len(info.b))
 1088|  13.9k|    return Curl_dyn_ptr(info.b);
 1089|      0|  return strdup("");
 1090|  13.9k|}
curl_maprintf:
 1093|  10.4k|{
 1094|  10.4k|  va_list ap_save;
 1095|  10.4k|  char *s;
 1096|  10.4k|  va_start(ap_save, format);
 1097|  10.4k|  s = curl_mvaprintf(format, ap_save);
 1098|  10.4k|  va_end(ap_save);
 1099|  10.4k|  return s;
 1100|  10.4k|}
curl_mfprintf:
 1134|  1.84k|{
 1135|  1.84k|  int retcode;
 1136|  1.84k|  va_list ap_save; /* argument pointer */
 1137|  1.84k|  va_start(ap_save, format);
 1138|  1.84k|  retcode = dprintf_formatf(whereto, fputc, format, ap_save);
 1139|  1.84k|  va_end(ap_save);
 1140|  1.84k|  return retcode;
 1141|  1.84k|}
mprintf.c:dprintf_formatf:
  570|  78.2k|{
  571|       |  /* Base-36 digits for numbers.  */
  572|  78.2k|  const char *digits = lower_digits;
  573|       |
  574|       |  /* Pointer into the format string.  */
  575|  78.2k|  char *f;
  576|       |
  577|       |  /* Number of characters written.  */
  578|  78.2k|  int done = 0;
  579|       |
  580|  78.2k|  long param; /* current parameter to read */
  581|  78.2k|  long param_num = 0; /* parameter counter */
  582|       |
  583|  78.2k|  struct va_stack vto[MAX_PARAMETERS];
  584|  78.2k|  char *endpos[MAX_PARAMETERS];
  585|  78.2k|  char **end;
  586|  78.2k|  char work[BUFFSIZE];
  587|  78.2k|  struct va_stack *p;
  588|       |
  589|       |  /* 'workend' points to the final buffer byte position, but with an extra
  590|       |     byte as margin to avoid the (false?) warning Coverity gives us
  591|       |     otherwise */
  592|  78.2k|  char *workend = &work[sizeof(work) - 2];
  593|       |
  594|       |  /* Do the actual %-code parsing */
  595|  78.2k|  if(dprintf_Pass1(format, vto, endpos, ap_save))
  596|      0|    return -1;
  597|       |
  598|  78.2k|  end = &endpos[0]; /* the initial end-position from the list dprintf_Pass1()
  599|       |                       created for us */
  600|       |
  601|  78.2k|  f = (char *)format;
  602|   383k|  while(*f != '\0') {
  603|       |    /* Format spec modifiers.  */
  604|   304k|    int is_alt;
  605|       |
  606|       |    /* Width of a field.  */
  607|   304k|    long width;
  608|       |
  609|       |    /* Precision of a field.  */
  610|   304k|    long prec;
  611|       |
  612|       |    /* Decimal integer is negative.  */
  613|   304k|    int is_neg;
  614|       |
  615|       |    /* Base of a number to be written.  */
  616|   304k|    unsigned long base;
  617|       |
  618|       |    /* Integral values to be written.  */
  619|   304k|    mp_uintmax_t num;
  620|       |
  621|       |    /* Used to convert negative in positive.  */
  622|   304k|    mp_intmax_t signed_num;
  623|       |
  624|   304k|    char *w;
  625|       |
  626|   304k|    if(*f != '%') {
  627|       |      /* This isn't a format spec, so write everything out until the next one
  628|       |         OR end of string is reached.  */
  629|   218k|      do {
  630|   218k|        OUTCHAR(*f);
  631|   218k|      } while(*++f && ('%' != *f));
  632|  56.8k|      continue;
  633|  56.8k|    }
  634|       |
  635|   248k|    ++f;
  636|       |
  637|       |    /* Check for "%%".  Note that although the ANSI standard lists
  638|       |       '%' as a conversion specifier, it says "The complete format
  639|       |       specification shall be `%%'," so we can avoid all the width
  640|       |       and precision processing.  */
  641|   248k|    if(*f == '%') {
  642|  15.5k|      ++f;
  643|  15.5k|      OUTCHAR('%');
  644|  15.5k|      continue;
  645|  15.5k|    }
  646|       |
  647|       |    /* If this is a positional parameter, the position must follow immediately
  648|       |       after the %, thus create a %<num>$ sequence */
  649|   232k|    param = dprintf_DollarString(f, &f);
  650|       |
  651|   232k|    if(!param)
  652|   232k|      param = param_num;
  653|      0|    else
  654|      0|      --param;
  655|       |
  656|   232k|    param_num++; /* increase this always to allow "%2$s %1$s %s" and then the
  657|       |                    third %s will pick the 3rd argument */
  658|       |
  659|   232k|    p = &vto[param];
  660|       |
  661|       |    /* pick up the specified width */
  662|   232k|    if(p->flags & FLAGS_WIDTHPARAM) {
  663|      0|      width = (long)vto[p->width].data.num.as_signed;
  664|      0|      param_num++; /* since the width is extracted from a parameter, we
  665|       |                      must skip that to get to the next one properly */
  666|      0|      if(width < 0) {
  667|       |        /* "A negative field width is taken as a '-' flag followed by a
  668|       |           positive field width." */
  669|      0|        width = -width;
  670|      0|        p->flags |= FLAGS_LEFT;
  671|      0|        p->flags &= ~FLAGS_PAD_NIL;
  672|      0|      }
  673|      0|    }
  674|   232k|    else
  675|   232k|      width = p->width;
  676|       |
  677|       |    /* pick up the specified precision */
  678|   232k|    if(p->flags & FLAGS_PRECPARAM) {
  679|      1|      prec = (long)vto[p->precision].data.num.as_signed;
  680|      1|      param_num++; /* since the precision is extracted from a parameter, we
  681|       |                      must skip that to get to the next one properly */
  682|      1|      if(prec < 0)
  683|       |        /* "A negative precision is taken as if the precision were
  684|       |           omitted." */
  685|      0|        prec = -1;
  686|      1|    }
  687|   232k|    else if(p->flags & FLAGS_PREC)
  688|      0|      prec = p->precision;
  689|   232k|    else
  690|   232k|      prec = -1;
  691|       |
  692|   232k|    is_alt = (p->flags & FLAGS_ALT) ? 1 : 0;
  693|       |
  694|   232k|    switch(p->type) {
  695|  88.6k|    case FORMAT_INT:
  696|  88.6k|      num = p->data.num.as_unsigned;
  697|  88.6k|      if(p->flags & FLAGS_CHAR) {
  698|       |        /* Character.  */
  699|  35.0k|        if(!(p->flags & FLAGS_LEFT))
  700|  35.0k|          while(--width > 0)
  701|      0|            OUTCHAR(' ');
  702|  35.0k|        OUTCHAR((char) num);
  703|  35.0k|        if(p->flags & FLAGS_LEFT)
  704|      0|          while(--width > 0)
  705|      0|            OUTCHAR(' ');
  706|  35.0k|        break;
  707|  35.0k|      }
  708|  53.6k|      if(p->flags & FLAGS_OCTAL) {
  709|       |        /* Octal unsigned integer.  */
  710|      0|        base = 8;
  711|      0|        goto unsigned_number;
  712|      0|      }
  713|  53.6k|      else if(p->flags & FLAGS_HEX) {
  714|       |        /* Hexadecimal unsigned integer.  */
  715|       |
  716|  19.0k|        digits = (p->flags & FLAGS_UPPER)? upper_digits : lower_digits;
  717|  19.0k|        base = 16;
  718|  19.0k|        goto unsigned_number;
  719|  19.0k|      }
  720|  34.5k|      else if(p->flags & FLAGS_UNSIGNED) {
  721|       |        /* Decimal unsigned integer.  */
  722|  16.0k|        base = 10;
  723|  16.0k|        goto unsigned_number;
  724|  16.0k|      }
  725|       |
  726|       |      /* Decimal integer.  */
  727|  18.4k|      base = 10;
  728|       |
  729|  18.4k|      is_neg = (p->data.num.as_signed < (mp_intmax_t)0) ? 1 : 0;
  730|  18.4k|      if(is_neg) {
  731|       |        /* signed_num might fail to hold absolute negative minimum by 1 */
  732|      1|        signed_num = p->data.num.as_signed + (mp_intmax_t)1;
  733|      1|        signed_num = -signed_num;
  734|      1|        num = (mp_uintmax_t)signed_num;
  735|      1|        num += (mp_uintmax_t)1;
  736|      1|      }
  737|       |
  738|  18.4k|      goto number;
  739|       |
  740|  35.1k|      unsigned_number:
  741|       |      /* Unsigned number of base BASE.  */
  742|  35.1k|      is_neg = 0;
  743|       |
  744|  53.6k|      number:
  745|       |      /* Number of base BASE.  */
  746|       |
  747|       |      /* Supply a default precision if none was given.  */
  748|  53.6k|      if(prec == -1)
  749|  53.6k|        prec = 1;
  750|       |
  751|       |      /* Put the number in WORK.  */
  752|  53.6k|      w = workend;
  753|   166k|      while(num > 0) {
  754|   113k|        *w-- = digits[num % base];
  755|   113k|        num /= base;
  756|   113k|      }
  757|  53.6k|      width -= (long)(workend - w);
  758|  53.6k|      prec -= (long)(workend - w);
  759|       |
  760|  53.6k|      if(is_alt && base == 8 && prec <= 0) {
  761|      0|        *w-- = '0';
  762|      0|        --width;
  763|      0|      }
  764|       |
  765|  53.6k|      if(prec > 0) {
  766|  7.38k|        width -= prec;
  767|  14.7k|        while(prec-- > 0 && w >= work)
  768|  7.38k|          *w-- = '0';
  769|  7.38k|      }
  770|       |
  771|  53.6k|      if(is_alt && base == 16)
  772|      0|        width -= 2;
  773|       |
  774|  53.6k|      if(is_neg || (p->flags & FLAGS_SHOWSIGN) || (p->flags & FLAGS_SPACE))
  775|      1|        --width;
  776|       |
  777|  53.6k|      if(!(p->flags & FLAGS_LEFT) && !(p->flags & FLAGS_PAD_NIL))
  778|  32.6k|        while(width-- > 0)
  779|      0|          OUTCHAR(' ');
  780|       |
  781|  53.6k|      if(is_neg)
  782|      1|        OUTCHAR('-');
  783|  53.6k|      else if(p->flags & FLAGS_SHOWSIGN)
  784|      0|        OUTCHAR('+');
  785|  53.6k|      else if(p->flags & FLAGS_SPACE)
  786|      0|        OUTCHAR(' ');
  787|       |
  788|  53.6k|      if(is_alt && base == 16) {
  789|      0|        OUTCHAR('0');
  790|      0|        if(p->flags & FLAGS_UPPER)
  791|      0|          OUTCHAR('X');
  792|      0|        else
  793|      0|          OUTCHAR('x');
  794|      0|      }
  795|       |
  796|  53.6k|      if(!(p->flags & FLAGS_LEFT) && (p->flags & FLAGS_PAD_NIL))
  797|  27.1k|        while(width-- > 0)
  798|  6.07k|          OUTCHAR('0');
  799|       |
  800|       |      /* Write the number.  */
  801|   174k|      while(++w <= workend) {
  802|   120k|        OUTCHAR(*w);
  803|   120k|      }
  804|       |
  805|  53.6k|      if(p->flags & FLAGS_LEFT)
  806|      0|        while(width-- > 0)
  807|      0|          OUTCHAR(' ');
  808|  53.6k|      break;
  809|       |
  810|   144k|    case FORMAT_STRING:
  811|       |            /* String.  */
  812|   144k|      {
  813|   144k|        static const char null[] = "(nil)";
  814|   144k|        const char *str;
  815|   144k|        size_t len;
  816|       |
  817|   144k|        str = (char *) p->data.str;
  818|   144k|        if(!str) {
  819|       |          /* Write null[] if there's space.  */
  820|     28|          if(prec == -1 || prec >= (long) sizeof(null) - 1) {
  821|     28|            str = null;
  822|     28|            len = sizeof(null) - 1;
  823|       |            /* Disable quotes around (nil) */
  824|     28|            p->flags &= (~FLAGS_ALT);
  825|     28|          }
  826|      0|          else {
  827|      0|            str = "";
  828|      0|            len = 0;
  829|      0|          }
  830|     28|        }
  831|   143k|        else if(prec != -1)
  832|      1|          len = (size_t)prec;
  833|   143k|        else
  834|   143k|          len = strlen(str);
  835|       |
  836|   144k|        width -= (len > LONG_MAX) ? LONG_MAX : (long)len;
  837|       |
  838|   144k|        if(p->flags & FLAGS_ALT)
  839|      0|          OUTCHAR('"');
  840|       |
  841|   144k|        if(!(p->flags&FLAGS_LEFT))
  842|   144k|          while(width-- > 0)
  843|      0|            OUTCHAR(' ');
  844|       |
  845|  1.10M|        for(; len && *str; len--)
  846|   960k|          OUTCHAR(*str++);
  847|   144k|        if(p->flags&FLAGS_LEFT)
  848|      0|          while(width-- > 0)
  849|      0|            OUTCHAR(' ');
  850|       |
  851|   144k|        if(p->flags & FLAGS_ALT)
  852|      0|          OUTCHAR('"');
  853|   144k|      }
  854|   144k|      break;
  855|       |
  856|   144k|    case FORMAT_PTR:
  857|       |      /* Generic pointer.  */
  858|      0|      {
  859|      0|        void *ptr;
  860|      0|        ptr = (void *) p->data.ptr;
  861|      0|        if(ptr != NULL) {
  862|       |          /* If the pointer is not NULL, write it as a %#x spec.  */
  863|      0|          base = 16;
  864|      0|          digits = (p->flags & FLAGS_UPPER)? upper_digits : lower_digits;
  865|      0|          is_alt = 1;
  866|      0|          num = (size_t) ptr;
  867|      0|          is_neg = 0;
  868|      0|          goto number;
  869|      0|        }
  870|      0|        else {
  871|       |          /* Write "(nil)" for a nil pointer.  */
  872|      0|          static const char strnil[] = "(nil)";
  873|      0|          const char *point;
  874|       |
  875|      0|          width -= (long)(sizeof(strnil) - 1);
  876|      0|          if(p->flags & FLAGS_LEFT)
  877|      0|            while(width-- > 0)
  878|      0|              OUTCHAR(' ');
  879|      0|          for(point = strnil; *point != '\0'; ++point)
  880|      0|            OUTCHAR(*point);
  881|      0|          if(!(p->flags & FLAGS_LEFT))
  882|      0|            while(width-- > 0)
  883|      0|              OUTCHAR(' ');
  884|      0|        }
  885|      0|      }
  886|      0|      break;
  887|       |
  888|      0|    case FORMAT_DOUBLE:
  889|      0|      {
  890|      0|        char formatbuf[32]="%";
  891|      0|        char *fptr = &formatbuf[1];
  892|      0|        size_t left = sizeof(formatbuf)-strlen(formatbuf);
  893|      0|        int len;
  894|       |
  895|      0|        width = -1;
  896|      0|        if(p->flags & FLAGS_WIDTH)
  897|      0|          width = p->width;
  898|      0|        else if(p->flags & FLAGS_WIDTHPARAM)
  899|      0|          width = (long)vto[p->width].data.num.as_signed;
  900|       |
  901|      0|        prec = -1;
  902|      0|        if(p->flags & FLAGS_PREC)
  903|      0|          prec = p->precision;
  904|      0|        else if(p->flags & FLAGS_PRECPARAM)
  905|      0|          prec = (long)vto[p->precision].data.num.as_signed;
  906|       |
  907|      0|        if(p->flags & FLAGS_LEFT)
  908|      0|          *fptr++ = '-';
  909|      0|        if(p->flags & FLAGS_SHOWSIGN)
  910|      0|          *fptr++ = '+';
  911|      0|        if(p->flags & FLAGS_SPACE)
  912|      0|          *fptr++ = ' ';
  913|      0|        if(p->flags & FLAGS_ALT)
  914|      0|          *fptr++ = '#';
  915|       |
  916|      0|        *fptr = 0;
  917|       |
  918|      0|        if(width >= 0) {
  919|      0|          if(width >= (long)sizeof(work))
  920|      0|            width = sizeof(work)-1;
  921|       |          /* RECURSIVE USAGE */
  922|      0|          len = curl_msnprintf(fptr, left, "%ld", width);
  923|      0|          fptr += len;
  924|      0|          left -= len;
  925|      0|        }
  926|      0|        if(prec >= 0) {
  927|       |          /* for each digit in the integer part, we can have one less
  928|       |             precision */
  929|      0|          size_t maxprec = sizeof(work) - 2;
  930|      0|          double val = p->data.dnum;
  931|      0|          if(width > 0 && prec <= width)
  932|      0|            maxprec -= width;
  933|      0|          while(val >= 10.0) {
  934|      0|            val /= 10;
  935|      0|            maxprec--;
  936|      0|          }
  937|       |
  938|      0|          if(prec > (long)maxprec)
  939|      0|            prec = (long)maxprec-1;
  940|      0|          if(prec < 0)
  941|      0|            prec = 0;
  942|       |          /* RECURSIVE USAGE */
  943|      0|          len = curl_msnprintf(fptr, left, ".%ld", prec);
  944|      0|          fptr += len;
  945|      0|        }
  946|      0|        if(p->flags & FLAGS_LONG)
  947|      0|          *fptr++ = 'l';
  948|       |
  949|      0|        if(p->flags & FLAGS_FLOATE)
  950|      0|          *fptr++ = (char)((p->flags & FLAGS_UPPER) ? 'E':'e');
  951|      0|        else if(p->flags & FLAGS_FLOATG)
  952|      0|          *fptr++ = (char)((p->flags & FLAGS_UPPER) ? 'G' : 'g');
  953|      0|        else
  954|      0|          *fptr++ = 'f';
  955|       |
  956|      0|        *fptr = 0; /* and a final zero termination */
  957|       |
  958|       |        /* NOTE NOTE NOTE!! Not all sprintf implementations return number of
  959|       |           output characters */
  960|      0|        (sprintf)(work, formatbuf, p->data.dnum);
  961|      0|        DEBUGASSERT(strlen(work) <= sizeof(work));
  962|      0|        for(fptr = work; *fptr; fptr++)
  963|      0|          OUTCHAR(*fptr);
  964|      0|      }
  965|      0|      break;
  966|       |
  967|      0|    case FORMAT_INTPTR:
  968|       |      /* Answer the count of characters written.  */
  969|      0|#ifdef HAVE_LONG_LONG_TYPE
  970|      0|      if(p->flags & FLAGS_LONGLONG)
  971|      0|        *(LONG_LONG_TYPE *) p->data.ptr = (LONG_LONG_TYPE)done;
  972|      0|      else
  973|      0|#endif
  974|      0|        if(p->flags & FLAGS_LONG)
  975|      0|          *(long *) p->data.ptr = (long)done;
  976|      0|      else if(!(p->flags & FLAGS_SHORT))
  977|      0|        *(int *) p->data.ptr = (int)done;
  978|      0|      else
  979|      0|        *(short *) p->data.ptr = (short)done;
  980|      0|      break;
  981|       |
  982|      0|    default:
  983|      0|      break;
  984|   232k|    }
  985|   232k|    f = *end++; /* goto end of %-code */
  986|       |
  987|   232k|  }
  988|  78.2k|  return done;
  989|  78.2k|}
mprintf.c:dprintf_Pass1:
  230|  78.2k|{
  231|  78.2k|  char *fmt = (char *)format;
  232|  78.2k|  int param_num = 0;
  233|  78.2k|  long this_param;
  234|  78.2k|  long width;
  235|  78.2k|  long precision;
  236|  78.2k|  int flags;
  237|  78.2k|  long max_param = 0;
  238|  78.2k|  long i;
  239|       |
  240|   777k|  while(*fmt) {
  241|   699k|    if(*fmt++ == '%') {
  242|   248k|      if(*fmt == '%') {
  243|  15.5k|        fmt++;
  244|  15.5k|        continue; /* while */
  245|  15.5k|      }
  246|       |
  247|   232k|      flags = FLAGS_NEW;
  248|       |
  249|       |      /* Handle the positional case (N$) */
  250|       |
  251|   232k|      param_num++;
  252|       |
  253|   232k|      this_param = dprintf_DollarString(fmt, &fmt);
  254|   232k|      if(0 == this_param)
  255|       |        /* we got no positional, get the next counter */
  256|   232k|        this_param = param_num;
  257|       |
  258|   232k|      if(this_param > max_param)
  259|   232k|        max_param = this_param;
  260|       |
  261|       |      /*
  262|       |       * The parameter with number 'i' should be used. Next, we need
  263|       |       * to get SIZE and TYPE of the parameter. Add the information
  264|       |       * to our array.
  265|       |       */
  266|       |
  267|   232k|      width = 0;
  268|   232k|      precision = 0;
  269|       |
  270|       |      /* Handle the flags */
  271|       |
  272|   269k|      while(dprintf_IsQualifierNoDollar(fmt)) {
  273|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  274|       |        if(!strncmp(fmt, "I32", 3)) {
  275|       |          flags |= FLAGS_LONG;
  276|       |          fmt += 3;
  277|       |        }
  278|       |        else if(!strncmp(fmt, "I64", 3)) {
  279|       |          flags |= FLAGS_LONGLONG;
  280|       |          fmt += 3;
  281|       |        }
  282|       |        else
  283|       |#endif
  284|       |
  285|  36.9k|        switch(*fmt++) {
  286|      0|        case ' ':
  287|      0|          flags |= FLAGS_SPACE;
  288|      0|          break;
  289|      0|        case '+':
  290|      0|          flags |= FLAGS_SHOWSIGN;
  291|      0|          break;
  292|      0|        case '-':
  293|      0|          flags |= FLAGS_LEFT;
  294|      0|          flags &= ~FLAGS_PAD_NIL;
  295|      0|          break;
  296|      0|        case '#':
  297|      0|          flags |= FLAGS_ALT;
  298|      0|          break;
  299|      1|        case '.':
  300|      1|          if('*' == *fmt) {
  301|       |            /* The precision is picked from a specified parameter */
  302|       |
  303|      1|            flags |= FLAGS_PRECPARAM;
  304|      1|            fmt++;
  305|      1|            param_num++;
  306|       |
  307|      1|            i = dprintf_DollarString(fmt, &fmt);
  308|      1|            if(i)
  309|      0|              precision = i;
  310|      1|            else
  311|      1|              precision = param_num;
  312|       |
  313|      1|            if(precision > max_param)
  314|      1|              max_param = precision;
  315|      1|          }
  316|      0|          else {
  317|      0|            flags |= FLAGS_PREC;
  318|      0|            precision = strtol(fmt, &fmt, 10);
  319|      0|          }
  320|      1|          break;
  321|      0|        case 'h':
  322|      0|          flags |= FLAGS_SHORT;
  323|      0|          break;
  324|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  325|       |        case 'I':
  326|       |#if (SIZEOF_CURL_OFF_T > SIZEOF_LONG)
  327|       |          flags |= FLAGS_LONGLONG;
  328|       |#else
  329|       |          flags |= FLAGS_LONG;
  330|       |#endif
  331|       |          break;
  332|       |#endif
  333|  15.8k|        case 'l':
  334|  15.8k|          if(flags & FLAGS_LONG)
  335|      0|            flags |= FLAGS_LONGLONG;
  336|  15.8k|          else
  337|  15.8k|            flags |= FLAGS_LONG;
  338|  15.8k|          break;
  339|      0|        case 'L':
  340|      0|          flags |= FLAGS_LONGDOUBLE;
  341|      0|          break;
  342|      0|        case 'q':
  343|      0|          flags |= FLAGS_LONGLONG;
  344|      0|          break;
  345|      6|        case 'z':
  346|       |          /* the code below generates a warning if -Wunreachable-code is
  347|       |             used */
  348|       |#if (SIZEOF_SIZE_T > SIZEOF_LONG)
  349|       |          flags |= FLAGS_LONGLONG;
  350|       |#else
  351|      6|          flags |= FLAGS_LONG;
  352|      6|#endif
  353|      6|          break;
  354|      0|        case 'O':
  355|       |#if (SIZEOF_CURL_OFF_T > SIZEOF_LONG)
  356|       |          flags |= FLAGS_LONGLONG;
  357|       |#else
  358|      0|          flags |= FLAGS_LONG;
  359|      0|#endif
  360|      0|          break;
  361|  21.0k|        case '0':
  362|  21.0k|          if(!(flags & FLAGS_LEFT))
  363|  21.0k|            flags |= FLAGS_PAD_NIL;
  364|       |          /* FALLTHROUGH */
  365|  21.0k|        case '1': case '2': case '3': case '4':
  366|  21.0k|        case '5': case '6': case '7': case '8': case '9':
  367|  21.0k|          flags |= FLAGS_WIDTH;
  368|  21.0k|          width = strtol(fmt-1, &fmt, 10);
  369|  21.0k|          break;
  370|      0|        case '*':  /* Special case */
  371|      0|          flags |= FLAGS_WIDTHPARAM;
  372|      0|          param_num++;
  373|       |
  374|      0|          i = dprintf_DollarString(fmt, &fmt);
  375|      0|          if(i)
  376|      0|            width = i;
  377|      0|          else
  378|      0|            width = param_num;
  379|      0|          if(width > max_param)
  380|      0|            max_param = width;
  381|      0|          break;
  382|      0|        case '\0':
  383|      0|          fmt--;
  384|      0|        default:
  385|      0|          break;
  386|  36.9k|        }
  387|  36.9k|      } /* switch */
  388|       |
  389|       |      /* Handle the specifier */
  390|       |
  391|   232k|      i = this_param - 1;
  392|       |
  393|   232k|      if((i < 0) || (i >= MAX_PARAMETERS))
  394|       |        /* out of allowed range */
  395|      0|        return 1;
  396|       |
  397|   232k|      switch (*fmt) {
  398|      0|      case 'S':
  399|      0|        flags |= FLAGS_ALT;
  400|       |        /* FALLTHROUGH */
  401|   144k|      case 's':
  402|   144k|        vto[i].type = FORMAT_STRING;
  403|   144k|        break;
  404|      0|      case 'n':
  405|      0|        vto[i].type = FORMAT_INTPTR;
  406|      0|        break;
  407|      0|      case 'p':
  408|      0|        vto[i].type = FORMAT_PTR;
  409|      0|        break;
  410|  18.4k|      case 'd': case 'i':
  411|  18.4k|        vto[i].type = FORMAT_INT;
  412|  18.4k|        break;
  413|  16.0k|      case 'u':
  414|  16.0k|        vto[i].type = FORMAT_INT;
  415|  16.0k|        flags |= FLAGS_UNSIGNED;
  416|  16.0k|        break;
  417|      0|      case 'o':
  418|      0|        vto[i].type = FORMAT_INT;
  419|      0|        flags |= FLAGS_OCTAL;
  420|      0|        break;
  421|  18.9k|      case 'x':
  422|  18.9k|        vto[i].type = FORMAT_INT;
  423|  18.9k|        flags |= FLAGS_HEX|FLAGS_UNSIGNED;
  424|  18.9k|        break;
  425|    170|      case 'X':
  426|    170|        vto[i].type = FORMAT_INT;
  427|    170|        flags |= FLAGS_HEX|FLAGS_UPPER|FLAGS_UNSIGNED;
  428|    170|        break;
  429|  35.0k|      case 'c':
  430|  35.0k|        vto[i].type = FORMAT_INT;
  431|  35.0k|        flags |= FLAGS_CHAR;
  432|  35.0k|        break;
  433|      0|      case 'f':
  434|      0|        vto[i].type = FORMAT_DOUBLE;
  435|      0|        break;
  436|      0|      case 'e':
  437|      0|        vto[i].type = FORMAT_DOUBLE;
  438|      0|        flags |= FLAGS_FLOATE;
  439|      0|        break;
  440|      0|      case 'E':
  441|      0|        vto[i].type = FORMAT_DOUBLE;
  442|      0|        flags |= FLAGS_FLOATE|FLAGS_UPPER;
  443|      0|        break;
  444|      0|      case 'g':
  445|      0|        vto[i].type = FORMAT_DOUBLE;
  446|      0|        flags |= FLAGS_FLOATG;
  447|      0|        break;
  448|      0|      case 'G':
  449|      0|        vto[i].type = FORMAT_DOUBLE;
  450|      0|        flags |= FLAGS_FLOATG|FLAGS_UPPER;
  451|      0|        break;
  452|      0|      default:
  453|      0|        vto[i].type = FORMAT_UNKNOWN;
  454|      0|        break;
  455|   232k|      } /* switch */
  456|       |
  457|   232k|      vto[i].flags = flags;
  458|   232k|      vto[i].width = width;
  459|   232k|      vto[i].precision = precision;
  460|       |
  461|   232k|      if(flags & FLAGS_WIDTHPARAM) {
  462|       |        /* we have the width specified from a parameter, so we make that
  463|       |           parameter's info setup properly */
  464|      0|        long k = width - 1;
  465|      0|        if((k < 0) || (k >= MAX_PARAMETERS))
  466|       |          /* out of allowed range */
  467|      0|          return 1;
  468|      0|        vto[i].width = k;
  469|      0|        vto[k].type = FORMAT_WIDTH;
  470|      0|        vto[k].flags = FLAGS_NEW;
  471|       |        /* can't use width or precision of width! */
  472|      0|        vto[k].width = 0;
  473|      0|        vto[k].precision = 0;
  474|      0|      }
  475|   232k|      if(flags & FLAGS_PRECPARAM) {
  476|       |        /* we have the precision specified from a parameter, so we make that
  477|       |           parameter's info setup properly */
  478|      1|        long k = precision - 1;
  479|      1|        if((k < 0) || (k >= MAX_PARAMETERS))
  480|       |          /* out of allowed range */
  481|      0|          return 1;
  482|      1|        vto[i].precision = k;
  483|      1|        vto[k].type = FORMAT_WIDTH;
  484|      1|        vto[k].flags = FLAGS_NEW;
  485|       |        /* can't use width or precision of width! */
  486|      1|        vto[k].width = 0;
  487|      1|        vto[k].precision = 0;
  488|      1|      }
  489|   232k|      *endpos++ = fmt + ((*fmt == '\0') ? 0 : 1); /* end of this sequence */
  490|   232k|    }
  491|   699k|  }
  492|       |
  493|       |  /* Read the arg list parameters into our data list */
  494|   310k|  for(i = 0; i<max_param; i++) {
  495|       |    /* Width/precision arguments must be read before the main argument
  496|       |       they are attached to */
  497|   232k|    if(vto[i].flags & FLAGS_WIDTHPARAM) {
  498|      0|      vto[vto[i].width].data.num.as_signed =
  499|      0|        (mp_intmax_t)va_arg(arglist, int);
  500|      0|    }
  501|   232k|    if(vto[i].flags & FLAGS_PRECPARAM) {
  502|      1|      vto[vto[i].precision].data.num.as_signed =
  503|      1|        (mp_intmax_t)va_arg(arglist, int);
  504|      1|    }
  505|       |
  506|   232k|    switch(vto[i].type) {
  507|   144k|    case FORMAT_STRING:
  508|   144k|      vto[i].data.str = va_arg(arglist, char *);
  509|   144k|      break;
  510|       |
  511|      0|    case FORMAT_INTPTR:
  512|      0|    case FORMAT_UNKNOWN:
  513|      0|    case FORMAT_PTR:
  514|      0|      vto[i].data.ptr = va_arg(arglist, void *);
  515|      0|      break;
  516|       |
  517|  88.6k|    case FORMAT_INT:
  518|  88.6k|#ifdef HAVE_LONG_LONG_TYPE
  519|  88.6k|      if((vto[i].flags & FLAGS_LONGLONG) && (vto[i].flags & FLAGS_UNSIGNED))
  520|      0|        vto[i].data.num.as_unsigned =
  521|      0|          (mp_uintmax_t)va_arg(arglist, mp_uintmax_t);
  522|  88.6k|      else if(vto[i].flags & FLAGS_LONGLONG)
  523|      0|        vto[i].data.num.as_signed =
  524|      0|          (mp_intmax_t)va_arg(arglist, mp_intmax_t);
  525|  88.6k|      else
  526|  88.6k|#endif
  527|  88.6k|      {
  528|  88.6k|        if((vto[i].flags & FLAGS_LONG) && (vto[i].flags & FLAGS_UNSIGNED))
  529|      6|          vto[i].data.num.as_unsigned =
  530|      6|            (mp_uintmax_t)va_arg(arglist, unsigned long);
  531|  88.6k|        else if(vto[i].flags & FLAGS_LONG)
  532|  15.8k|          vto[i].data.num.as_signed =
  533|  15.8k|            (mp_intmax_t)va_arg(arglist, long);
  534|  72.8k|        else if(vto[i].flags & FLAGS_UNSIGNED)
  535|  35.1k|          vto[i].data.num.as_unsigned =
  536|  35.1k|            (mp_uintmax_t)va_arg(arglist, unsigned int);
  537|  37.6k|        else
  538|  37.6k|          vto[i].data.num.as_signed =
  539|  37.6k|            (mp_intmax_t)va_arg(arglist, int);
  540|  88.6k|      }
  541|  88.6k|      break;
  542|       |
  543|      0|    case FORMAT_DOUBLE:
  544|      0|      vto[i].data.dnum = va_arg(arglist, double);
  545|      0|      break;
  546|       |
  547|      1|    case FORMAT_WIDTH:
  548|       |      /* Argument has been read. Silently convert it into an integer
  549|       |       * for later use
  550|       |       */
  551|      1|      vto[i].type = FORMAT_INT;
  552|      1|      break;
  553|       |
  554|      0|    default:
  555|      0|      break;
  556|   232k|    }
  557|   232k|  }
  558|       |
  559|  78.2k|  return 0;
  560|       |
  561|  78.2k|}
mprintf.c:dprintf_IsQualifierNoDollar:
  195|   269k|{
  196|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  197|       |  if(!strncmp(fmt, "I32", 3) || !strncmp(fmt, "I64", 3)) {
  198|       |    return TRUE;
  199|       |  }
  200|       |#endif
  201|       |
  202|   269k|  switch(*fmt) {
  203|      1|  case '-': case '+': case ' ': case '#': case '.':
  204|  21.0k|  case '0': case '1': case '2': case '3': case '4':
  205|  21.0k|  case '5': case '6': case '7': case '8': case '9':
  206|  36.9k|  case 'h': case 'l': case 'L': case 'z': case 'q':
  207|  36.9k|  case '*': case 'O':
  208|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  209|       |  case 'I':
  210|       |#endif
  211|  36.9k|    return TRUE;
  212|       |
  213|   232k|  default:
  214|   232k|    return FALSE;
  215|   269k|  }
  216|   269k|}
mprintf.c:dprintf_DollarString:
  178|   465k|{
  179|   465k|  int number = 0;
  180|   549k|  while(ISDIGIT(*input)) {
  181|  84.2k|    if(number < MAX_PARAMETERS) {
  182|  84.2k|      number *= 10;
  183|  84.2k|      number += *input - '0';
  184|  84.2k|    }
  185|  84.2k|    input++;
  186|  84.2k|  }
  187|   465k|  if(number <= MAX_PARAMETERS && ('$' == *input)) {
  188|      0|    *end = ++input;
  189|      0|    return number;
  190|      0|  }
  191|   465k|  return 0;
  192|   465k|}
mprintf.c:addbyter:
  993|   337k|{
  994|   337k|  struct nsprintf *infop = (struct nsprintf *)data;
  995|   337k|  unsigned char outc = (unsigned char)output;
  996|       |
  997|   337k|  if(infop->length < infop->max) {
  998|       |    /* only do this if we haven't reached max length yet */
  999|   337k|    infop->buffer[0] = outc; /* store */
 1000|   337k|    infop->buffer++; /* increase pointer */
 1001|   337k|    infop->length++; /* we are now one byte larger */
 1002|   337k|    return outc;     /* fputc() returns like this on success */
 1003|   337k|  }
 1004|      0|  return -1;
 1005|   337k|}
mprintf.c:alloc_addbyter:
 1043|   851k|{
 1044|   851k|  struct asprintf *infop = (struct asprintf *)data;
 1045|   851k|  unsigned char outc = (unsigned char)output;
 1046|       |
 1047|   851k|  if(Curl_dyn_addn(infop->b, &outc, 1)) {
 1048|      0|    infop->fail = 1;
 1049|      0|    return -1; /* fail */
 1050|      0|  }
 1051|   851k|  return outc; /* fputc() returns like this on success */
 1052|   851k|}

Curl_multi_handle:
  357|  3.09k|{
  358|  3.09k|  struct Curl_multi *multi = calloc(1, sizeof(struct Curl_multi));
  359|       |
  360|  3.09k|  if(!multi)
  361|      0|    return NULL;
  362|       |
  363|  3.09k|  multi->magic = CURL_MULTI_HANDLE;
  364|       |
  365|  3.09k|  if(Curl_mk_dnscache(&multi->hostcache))
  366|      0|    goto error;
  367|       |
  368|  3.09k|  if(sh_init(&multi->sockhash, hashsize))
  369|      0|    goto error;
  370|       |
  371|  3.09k|  if(Curl_conncache_init(&multi->conn_cache, chashsize))
  372|      0|    goto error;
  373|       |
  374|  3.09k|  Curl_llist_init(&multi->msglist, NULL);
  375|  3.09k|  Curl_llist_init(&multi->pending, NULL);
  376|       |
  377|  3.09k|  multi->multiplexing = TRUE;
  378|       |
  379|       |  /* -1 means it not set by user, use the default value */
  380|  3.09k|  multi->maxconnects = -1;
  381|  3.09k|  multi->max_concurrent_streams = 100;
  382|  3.09k|  multi->ipv6_works = Curl_ipv6works(NULL);
  383|       |
  384|       |#ifdef USE_WINSOCK
  385|       |  multi->wsa_event = WSACreateEvent();
  386|       |  if(multi->wsa_event == WSA_INVALID_EVENT)
  387|       |    goto error;
  388|       |#else
  389|  3.09k|#ifdef ENABLE_WAKEUP
  390|  3.09k|  if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, multi->wakeup_pair) < 0) {
  391|      0|    multi->wakeup_pair[0] = CURL_SOCKET_BAD;
  392|      0|    multi->wakeup_pair[1] = CURL_SOCKET_BAD;
  393|      0|  }
  394|  3.09k|  else if(curlx_nonblock(multi->wakeup_pair[0], TRUE) < 0 ||
  395|  3.09k|          curlx_nonblock(multi->wakeup_pair[1], TRUE) < 0) {
  396|      0|    sclose(multi->wakeup_pair[0]);
  397|      0|    sclose(multi->wakeup_pair[1]);
  398|      0|    multi->wakeup_pair[0] = CURL_SOCKET_BAD;
  399|      0|    multi->wakeup_pair[1] = CURL_SOCKET_BAD;
  400|      0|  }
  401|  3.09k|#endif
  402|  3.09k|#endif
  403|       |
  404|  3.09k|  return multi;
  405|       |
  406|      0|  error:
  407|       |
  408|      0|  Curl_hash_destroy(&multi->sockhash);
  409|      0|  Curl_hash_destroy(&multi->hostcache);
  410|      0|  Curl_conncache_destroy(&multi->conn_cache);
  411|      0|  Curl_llist_destroy(&multi->msglist, NULL);
  412|      0|  Curl_llist_destroy(&multi->pending, NULL);
  413|       |
  414|      0|  free(multi);
  415|      0|  return NULL;
  416|  3.09k|}
curl_multi_init:
  419|  3.09k|{
  420|  3.09k|  return Curl_multi_handle(CURL_SOCKET_HASH_TABLE_SIZE,
  421|  3.09k|                           CURL_CONNECTION_HASH_SIZE);
  422|  3.09k|}
curl_multi_add_handle:
  426|  3.09k|{
  427|       |  /* First, make some basic checks that the CURLM handle is a good handle */
  428|  3.09k|  if(!GOOD_MULTI_HANDLE(multi))
  429|      0|    return CURLM_BAD_HANDLE;
  430|       |
  431|       |  /* Verify that we got a somewhat good easy handle too */
  432|  3.09k|  if(!GOOD_EASY_HANDLE(data))
  433|      0|    return CURLM_BAD_EASY_HANDLE;
  434|       |
  435|       |  /* Prevent users from adding same easy handle more than once and prevent
  436|       |     adding to more than one multi stack */
  437|  3.09k|  if(data->multi)
  438|      0|    return CURLM_ADDED_ALREADY;
  439|       |
  440|  3.09k|  if(multi->in_callback)
  441|      0|    return CURLM_RECURSIVE_API_CALL;
  442|       |
  443|       |  /* Initialize timeout list for this handle */
  444|  3.09k|  Curl_llist_init(&data->state.timeoutlist, NULL);
  445|       |
  446|       |  /*
  447|       |   * No failure allowed in this function beyond this point. And no
  448|       |   * modification of easy nor multi handle allowed before this except for
  449|       |   * potential multi's connection cache growing which won't be undone in this
  450|       |   * function no matter what.
  451|       |   */
  452|  3.09k|  if(data->set.errorbuffer)
  453|      0|    data->set.errorbuffer[0] = 0;
  454|       |
  455|       |  /* set the easy handle */
  456|  3.09k|  multistate(data, MSTATE_INIT);
  457|       |
  458|       |  /* for multi interface connections, we share DNS cache automatically if the
  459|       |     easy handle's one is currently not set. */
  460|  3.09k|  if(!data->dns.hostcache ||
  461|  3.09k|     (data->dns.hostcachetype == HCACHE_NONE)) {
  462|  3.09k|    data->dns.hostcache = &multi->hostcache;
  463|  3.09k|    data->dns.hostcachetype = HCACHE_MULTI;
  464|  3.09k|  }
  465|       |
  466|       |  /* Point to the shared or multi handle connection cache */
  467|  3.09k|  if(data->share && (data->share->specifier & (1<< CURL_LOCK_DATA_CONNECT)))
  468|      0|    data->state.conn_cache = &data->share->conn_cache;
  469|  3.09k|  else
  470|  3.09k|    data->state.conn_cache = &multi->conn_cache;
  471|  3.09k|  data->state.lastconnect_id = -1;
  472|       |
  473|       |#ifdef USE_LIBPSL
  474|       |  /* Do the same for PSL. */
  475|       |  if(data->share && (data->share->specifier & (1 << CURL_LOCK_DATA_PSL)))
  476|       |    data->psl = &data->share->psl;
  477|       |  else
  478|       |    data->psl = &multi->psl;
  479|       |#endif
  480|       |
  481|       |  /* We add the new entry last in the list. */
  482|  3.09k|  data->next = NULL; /* end of the line */
  483|  3.09k|  if(multi->easyp) {
  484|      0|    struct Curl_easy *last = multi->easylp;
  485|      0|    last->next = data;
  486|      0|    data->prev = last;
  487|      0|    multi->easylp = data; /* the new last node */
  488|      0|  }
  489|  3.09k|  else {
  490|       |    /* first node, make prev NULL! */
  491|  3.09k|    data->prev = NULL;
  492|  3.09k|    multi->easylp = multi->easyp = data; /* both first and last */
  493|  3.09k|  }
  494|       |
  495|       |  /* make the Curl_easy refer back to this multi handle */
  496|  3.09k|  data->multi = multi;
  497|       |
  498|       |  /* Set the timeout for this handle to expire really soon so that it will
  499|       |     be taken care of even when this handle is added in the midst of operation
  500|       |     when only the curl_multi_socket() API is used. During that flow, only
  501|       |     sockets that time-out or have actions will be dealt with. Since this
  502|       |     handle has no action yet, we make sure it times out to get things to
  503|       |     happen. */
  504|  3.09k|  Curl_expire(data, 0, EXPIRE_RUN_NOW);
  505|       |
  506|       |  /* increase the node-counter */
  507|  3.09k|  multi->num_easy++;
  508|       |
  509|       |  /* increase the alive-counter */
  510|  3.09k|  multi->num_alive++;
  511|       |
  512|       |  /* A somewhat crude work-around for a little glitch in Curl_update_timer()
  513|       |     that happens if the lastcall time is set to the same time when the handle
  514|       |     is removed as when the next handle is added, as then the check in
  515|       |     Curl_update_timer() that prevents calling the application multiple times
  516|       |     with the same timer info will not trigger and then the new handle's
  517|       |     timeout will not be notified to the app.
  518|       |
  519|       |     The work-around is thus simply to clear the 'lastcall' variable to force
  520|       |     Curl_update_timer() to always trigger a callback to the app when a new
  521|       |     easy handle is added */
  522|  3.09k|  memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));
  523|       |
  524|  3.09k|  CONNCACHE_LOCK(data);
  525|       |  /* The closure handle only ever has default timeouts set. To improve the
  526|       |     state somewhat we clone the timeouts from each added handle so that the
  527|       |     closure handle always has the same timeouts as the most recently added
  528|       |     easy handle. */
  529|  3.09k|  data->state.conn_cache->closure_handle->set.timeout = data->set.timeout;
  530|  3.09k|  data->state.conn_cache->closure_handle->set.server_response_timeout =
  531|  3.09k|    data->set.server_response_timeout;
  532|  3.09k|  data->state.conn_cache->closure_handle->set.no_signal =
  533|  3.09k|    data->set.no_signal;
  534|  3.09k|  CONNCACHE_UNLOCK(data);
  535|       |
  536|  3.09k|  Curl_update_timer(multi);
  537|  3.09k|  return CURLM_OK;
  538|  3.09k|}
curl_multi_remove_handle:
  718|  3.09k|{
  719|  3.09k|  struct Curl_easy *easy = data;
  720|  3.09k|  bool premature;
  721|  3.09k|  struct Curl_llist_element *e;
  722|       |
  723|       |  /* First, make some basic checks that the CURLM handle is a good handle */
  724|  3.09k|  if(!GOOD_MULTI_HANDLE(multi))
  725|      0|    return CURLM_BAD_HANDLE;
  726|       |
  727|       |  /* Verify that we got a somewhat good easy handle too */
  728|  3.09k|  if(!GOOD_EASY_HANDLE(data))
  729|      0|    return CURLM_BAD_EASY_HANDLE;
  730|       |
  731|       |  /* Prevent users from trying to remove same easy handle more than once */
  732|  3.09k|  if(!data->multi)
  733|      0|    return CURLM_OK; /* it is already removed so let's say it is fine! */
  734|       |
  735|       |  /* Prevent users from trying to remove an easy handle from the wrong multi */
  736|  3.09k|  if(data->multi != multi)
  737|      0|    return CURLM_BAD_EASY_HANDLE;
  738|       |
  739|  3.09k|  if(multi->in_callback)
  740|      0|    return CURLM_RECURSIVE_API_CALL;
  741|       |
  742|  3.09k|  premature = (data->mstate < MSTATE_COMPLETED) ? TRUE : FALSE;
  743|       |
  744|       |  /* If the 'state' is not INIT or COMPLETED, we might need to do something
  745|       |     nice to put the easy_handle in a good known state when this returns. */
  746|  3.09k|  if(premature) {
  747|       |    /* this handle is "alive" so we need to count down the total number of
  748|       |       alive connections when this is removed */
  749|     30|    multi->num_alive--;
  750|     30|  }
  751|       |
  752|  3.09k|  if(data->conn &&
  753|  3.09k|     data->mstate > MSTATE_DO &&
  754|  3.09k|     data->mstate < MSTATE_COMPLETED) {
  755|       |    /* Set connection owner so that the DONE function closes it.  We can
  756|       |       safely do this here since connection is killed. */
  757|     17|    streamclose(data->conn, "Removed with partial response");
  758|     17|  }
  759|       |
  760|  3.09k|  if(data->conn) {
  761|       |    /* multi_done() clears the association between the easy handle and the
  762|       |       connection.
  763|       |
  764|       |       Note that this ignores the return code simply because there's
  765|       |       nothing really useful to do with it anyway! */
  766|     30|    (void)multi_done(data, data->result, premature);
  767|     30|  }
  768|       |
  769|       |  /* The timer must be shut down before data->multi is set to NULL, else the
  770|       |     timenode will remain in the splay tree after curl_easy_cleanup is
  771|       |     called. Do it after multi_done() in case that sets another time! */
  772|  3.09k|  Curl_expire_clear(data);
  773|       |
  774|  3.09k|  if(data->connect_queue.ptr)
  775|       |    /* the handle was in the pending list waiting for an available connection,
  776|       |       so go ahead and remove it */
  777|      0|    Curl_llist_remove(&multi->pending, &data->connect_queue, NULL);
  778|       |
  779|  3.09k|  if(data->dns.hostcachetype == HCACHE_MULTI) {
  780|       |    /* stop using the multi handle's DNS cache, *after* the possible
  781|       |       multi_done() call above */
  782|  3.09k|    data->dns.hostcache = NULL;
  783|  3.09k|    data->dns.hostcachetype = HCACHE_NONE;
  784|  3.09k|  }
  785|       |
  786|  3.09k|  Curl_wildcard_dtor(&data->wildcard);
  787|       |
  788|       |  /* destroy the timeout list that is held in the easy handle, do this *after*
  789|       |     multi_done() as that may actually call Curl_expire that uses this */
  790|  3.09k|  Curl_llist_destroy(&data->state.timeoutlist, NULL);
  791|       |
  792|       |  /* change state without using multistate(), only to make singlesocket() do
  793|       |     what we want */
  794|  3.09k|  data->mstate = MSTATE_COMPLETED;
  795|  3.09k|  singlesocket(multi, easy); /* to let the application know what sockets that
  796|       |                                vanish with this handle */
  797|       |
  798|       |  /* Remove the association between the connection and the handle */
  799|  3.09k|  Curl_detach_connnection(data);
  800|       |
  801|  3.09k|  if(data->state.lastconnect_id != -1) {
  802|       |    /* Mark any connect-only connection for closure */
  803|    559|    Curl_conncache_foreach(data, data->state.conn_cache,
  804|    559|                           NULL, close_connect_only);
  805|    559|  }
  806|       |
  807|       |#ifdef USE_LIBPSL
  808|       |  /* Remove the PSL association. */
  809|       |  if(data->psl == &multi->psl)
  810|       |    data->psl = NULL;
  811|       |#endif
  812|       |
  813|       |  /* as this was using a shared connection cache we clear the pointer to that
  814|       |     since we're not part of that multi handle anymore */
  815|  3.09k|  data->state.conn_cache = NULL;
  816|       |
  817|  3.09k|  data->multi = NULL; /* clear the association to this multi handle */
  818|       |
  819|       |  /* make sure there's no pending message in the queue sent from this easy
  820|       |     handle */
  821|       |
  822|  3.09k|  for(e = multi->msglist.head; e; e = e->next) {
  823|  3.06k|    struct Curl_message *msg = e->ptr;
  824|       |
  825|  3.06k|    if(msg->extmsg.easy_handle == easy) {
  826|  3.06k|      Curl_llist_remove(&multi->msglist, e, NULL);
  827|       |      /* there can only be one from this specific handle */
  828|  3.06k|      break;
  829|  3.06k|    }
  830|  3.06k|  }
  831|       |
  832|       |  /* Remove from the pending list if it is there. Otherwise this will
  833|       |     remain on the pending list forever due to the state change. */
  834|  3.09k|  for(e = multi->pending.head; e; e = e->next) {
  835|      0|    struct Curl_easy *curr_data = e->ptr;
  836|       |
  837|      0|    if(curr_data == data) {
  838|      0|      Curl_llist_remove(&multi->pending, e, NULL);
  839|      0|      break;
  840|      0|    }
  841|      0|  }
  842|       |
  843|       |  /* make the previous node point to our next */
  844|  3.09k|  if(data->prev)
  845|      0|    data->prev->next = data->next;
  846|  3.09k|  else
  847|  3.09k|    multi->easyp = data->next; /* point to first node */
  848|       |
  849|       |  /* make our next point to our previous node */
  850|  3.09k|  if(data->next)
  851|      0|    data->next->prev = data->prev;
  852|  3.09k|  else
  853|  3.09k|    multi->easylp = data->prev; /* point to last node */
  854|       |
  855|       |  /* NOTE NOTE NOTE
  856|       |     We do not touch the easy handle here! */
  857|  3.09k|  multi->num_easy--; /* one less to care about now */
  858|       |
  859|  3.09k|  process_pending_handles(multi);
  860|       |
  861|  3.09k|  Curl_update_timer(multi);
  862|  3.09k|  return CURLM_OK;
  863|  3.09k|}
Curl_multiplex_wanted:
  867|  1.24k|{
  868|  1.24k|  return (multi && (multi->multiplexing));
  869|  1.24k|}
Curl_detach_connnection:
  878|  18.5k|{
  879|  18.5k|  struct connectdata *conn = data->conn;
  880|  18.5k|  if(conn) {
  881|  6.02k|    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);
  882|  6.02k|    Curl_ssl_detach_conn(data, conn);
  883|  6.02k|  }
  884|  18.5k|  data->conn = NULL;
  885|  18.5k|}
Curl_attach_connnection:
  894|  6.02k|{
  895|  6.02k|  DEBUGASSERT(!data->conn);
  896|  6.02k|  DEBUGASSERT(conn);
  897|  6.02k|  data->conn = conn;
  898|  6.02k|  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,
  899|  6.02k|                         &data->conn_queue);
  900|  6.02k|  if(conn->handler->attach)
  901|      0|    conn->handler->attach(data, conn);
  902|  6.02k|  Curl_ssl_associate_conn(data, conn);
  903|  6.02k|}
curl_multi_fdset:
 1027|  5.78M|{
 1028|       |  /* Scan through all the easy handles to get the file descriptors set.
 1029|       |     Some easy handles may not have connected to the remote host yet,
 1030|       |     and then we must make sure that is done. */
 1031|  5.78M|  struct Curl_easy *data;
 1032|  5.78M|  int this_max_fd = -1;
 1033|  5.78M|  curl_socket_t sockbunch[MAX_SOCKSPEREASYHANDLE];
 1034|  5.78M|  int i;
 1035|  5.78M|  (void)exc_fd_set; /* not used */
 1036|       |
 1037|  5.78M|  if(!GOOD_MULTI_HANDLE(multi))
 1038|      0|    return CURLM_BAD_HANDLE;
 1039|       |
 1040|  5.78M|  if(multi->in_callback)
 1041|      0|    return CURLM_RECURSIVE_API_CALL;
 1042|       |
 1043|  5.78M|  data = multi->easyp;
 1044|  11.5M|  while(data) {
 1045|  5.78M|    int bitmap;
 1046|       |#ifdef __clang_analyzer_
 1047|       |    /* to prevent "The left operand of '>=' is a garbage value" warnings */
 1048|       |    memset(sockbunch, 0, sizeof(sockbunch));
 1049|       |#endif
 1050|  5.78M|    bitmap = multi_getsock(data, sockbunch);
 1051|       |
 1052|  11.5M|    for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++) {
 1053|  11.5M|      curl_socket_t s = CURL_SOCKET_BAD;
 1054|       |
 1055|  11.5M|      if((bitmap & GETSOCK_READSOCK(i)) && VALID_SOCK(sockbunch[i])) {
 1056|  5.78M|        if(!FDSET_SOCK(sockbunch[i]))
 1057|       |          /* pretend it doesn't exist */
 1058|      0|          continue;
 1059|  5.78M|        FD_SET(sockbunch[i], read_fd_set);
 1060|  5.78M|        s = sockbunch[i];
 1061|  5.78M|      }
 1062|  11.5M|      if((bitmap & GETSOCK_WRITESOCK(i)) && VALID_SOCK(sockbunch[i])) {
 1063|     30|        if(!FDSET_SOCK(sockbunch[i]))
 1064|       |          /* pretend it doesn't exist */
 1065|      0|          continue;
 1066|     30|        FD_SET(sockbunch[i], write_fd_set);
 1067|     30|        s = sockbunch[i];
 1068|     30|      }
 1069|  11.5M|      if(s == CURL_SOCKET_BAD)
 1070|       |        /* this socket is unused, break out of loop */
 1071|  5.78M|        break;
 1072|  5.78M|      if((int)s > this_max_fd)
 1073|  5.78M|        this_max_fd = (int)s;
 1074|  5.78M|    }
 1075|       |
 1076|  5.78M|    data = data->next; /* check next handle */
 1077|  5.78M|  }
 1078|       |
 1079|  5.78M|  *max_fd = this_max_fd;
 1080|       |
 1081|  5.78M|  return CURLM_OK;
 1082|  5.78M|}
Curl_preconnect:
 1716|  6.02k|{
 1717|  6.02k|  if(!data->state.buffer) {
 1718|  3.05k|    data->state.buffer = malloc(data->set.buffer_size + 1);
 1719|  3.05k|    if(!data->state.buffer)
 1720|      0|      return CURLE_OUT_OF_MEMORY;
 1721|  3.05k|  }
 1722|  6.02k|  return CURLE_OK;
 1723|  6.02k|}
curl_multi_perform:
 2572|  5.78M|{
 2573|  5.78M|  struct Curl_easy *data;
 2574|  5.78M|  CURLMcode returncode = CURLM_OK;
 2575|  5.78M|  struct Curl_tree *t;
 2576|  5.78M|  struct curltime now = Curl_now();
 2577|       |
 2578|  5.78M|  if(!GOOD_MULTI_HANDLE(multi))
 2579|      0|    return CURLM_BAD_HANDLE;
 2580|       |
 2581|  5.78M|  if(multi->in_callback)
 2582|      0|    return CURLM_RECURSIVE_API_CALL;
 2583|       |
 2584|  5.78M|  data = multi->easyp;
 2585|  11.5M|  while(data) {
 2586|  5.78M|    CURLMcode result;
 2587|  5.78M|    SIGPIPE_VARIABLE(pipe_st);
 2588|       |
 2589|  5.78M|    sigpipe_ignore(data, &pipe_st);
 2590|  5.78M|    result = multi_runsingle(multi, &now, data);
 2591|  5.78M|    sigpipe_restore(&pipe_st);
 2592|       |
 2593|  5.78M|    if(result)
 2594|      0|      returncode = result;
 2595|       |
 2596|  5.78M|    data = data->next; /* operate on next handle */
 2597|  5.78M|  }
 2598|       |
 2599|       |  /*
 2600|       |   * Simply remove all expired timers from the splay since handles are dealt
 2601|       |   * with unconditionally by this function and curl_multi_timeout() requires
 2602|       |   * that already passed/handled expire times are removed from the splay.
 2603|       |   *
 2604|       |   * It is important that the 'now' value is set at the entry of this function
 2605|       |   * and not for the current time as it may have ticked a little while since
 2606|       |   * then and then we risk this loop to remove timers that actually have not
 2607|       |   * been handled!
 2608|       |   */
 2609|  5.78M|  do {
 2610|  5.78M|    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);
 2611|  5.78M|    if(t)
 2612|       |      /* the removed may have another timeout in queue */
 2613|  1.03k|      (void)add_next_timeout(now, multi, t->payload);
 2614|       |
 2615|  5.78M|  } while(t);
 2616|       |
 2617|  5.78M|  *running_handles = multi->num_alive;
 2618|       |
 2619|  5.78M|  if(CURLM_OK >= returncode)
 2620|  5.78M|    Curl_update_timer(multi);
 2621|       |
 2622|  5.78M|  return returncode;
 2623|  5.78M|}
curl_multi_cleanup:
 2626|  3.09k|{
 2627|  3.09k|  struct Curl_easy *data;
 2628|  3.09k|  struct Curl_easy *nextdata;
 2629|       |
 2630|  3.09k|  if(GOOD_MULTI_HANDLE(multi)) {
 2631|  3.09k|    if(multi->in_callback)
 2632|      0|      return CURLM_RECURSIVE_API_CALL;
 2633|       |
 2634|  3.09k|    multi->magic = 0; /* not good anymore */
 2635|       |
 2636|       |    /* First remove all remaining easy handles */
 2637|  3.09k|    data = multi->easyp;
 2638|  3.09k|    while(data) {
 2639|      0|      nextdata = data->next;
 2640|      0|      if(!data->state.done && data->conn)
 2641|       |        /* if DONE was never called for this handle */
 2642|      0|        (void)multi_done(data, CURLE_OK, TRUE);
 2643|      0|      if(data->dns.hostcachetype == HCACHE_MULTI) {
 2644|       |        /* clear out the usage of the shared DNS cache */
 2645|      0|        Curl_hostcache_clean(data, data->dns.hostcache);
 2646|      0|        data->dns.hostcache = NULL;
 2647|      0|        data->dns.hostcachetype = HCACHE_NONE;
 2648|      0|      }
 2649|       |
 2650|       |      /* Clear the pointer to the connection cache */
 2651|      0|      data->state.conn_cache = NULL;
 2652|      0|      data->multi = NULL; /* clear the association */
 2653|       |
 2654|       |#ifdef USE_LIBPSL
 2655|       |      if(data->psl == &multi->psl)
 2656|       |        data->psl = NULL;
 2657|       |#endif
 2658|       |
 2659|      0|      data = nextdata;
 2660|      0|    }
 2661|       |
 2662|       |    /* Close all the connections in the connection cache */
 2663|  3.09k|    Curl_conncache_close_all_connections(&multi->conn_cache);
 2664|       |
 2665|  3.09k|    Curl_hash_destroy(&multi->sockhash);
 2666|  3.09k|    Curl_conncache_destroy(&multi->conn_cache);
 2667|  3.09k|    Curl_llist_destroy(&multi->msglist, NULL);
 2668|  3.09k|    Curl_llist_destroy(&multi->pending, NULL);
 2669|       |
 2670|  3.09k|    Curl_hash_destroy(&multi->hostcache);
 2671|  3.09k|    Curl_psl_destroy(&multi->psl);
 2672|       |
 2673|       |#ifdef USE_WINSOCK
 2674|       |    WSACloseEvent(multi->wsa_event);
 2675|       |#else
 2676|  3.09k|#ifdef ENABLE_WAKEUP
 2677|  3.09k|    sclose(multi->wakeup_pair[0]);
 2678|  3.09k|    sclose(multi->wakeup_pair[1]);
 2679|  3.09k|#endif
 2680|  3.09k|#endif
 2681|  3.09k|    free(multi);
 2682|       |
 2683|  3.09k|    return CURLM_OK;
 2684|  3.09k|  }
 2685|      0|  return CURLM_BAD_HANDLE;
 2686|  3.09k|}
Curl_multi_closed:
 2899|  2.93k|{
 2900|  2.93k|  if(data) {
 2901|       |    /* if there's still an easy handle associated with this connection */
 2902|  2.92k|    struct Curl_multi *multi = data->multi;
 2903|  2.92k|    if(multi) {
 2904|       |      /* this is set if this connection is part of a handle that is added to
 2905|       |         a multi handle, and only then this is necessary */
 2906|  2.40k|      struct Curl_sh_entry *entry = sh_getentry(&multi->sockhash, s);
 2907|       |
 2908|  2.40k|      if(entry) {
 2909|      0|        if(multi->socket_cb)
 2910|      0|          multi->socket_cb(data, s, CURL_POLL_REMOVE,
 2911|      0|                           multi->socket_userp,
 2912|      0|                           entry->socketp);
 2913|       |
 2914|       |        /* now remove it from the socket hash */
 2915|      0|        sh_delentry(entry, &multi->sockhash, s);
 2916|      0|      }
 2917|  2.40k|    }
 2918|  2.92k|  }
 2919|  2.93k|}
Curl_update_timer:
 3259|  5.79M|{
 3260|  5.79M|  long timeout_ms;
 3261|       |
 3262|  5.79M|  if(!multi->timer_cb)
 3263|  5.79M|    return;
 3264|      0|  if(multi_timeout(multi, &timeout_ms)) {
 3265|      0|    return;
 3266|      0|  }
 3267|      0|  if(timeout_ms < 0) {
 3268|      0|    static const struct curltime none = {0, 0};
 3269|      0|    if(Curl_splaycomparekeys(none, multi->timer_lastcall)) {
 3270|      0|      multi->timer_lastcall = none;
 3271|       |      /* there's no timeout now but there was one previously, tell the app to
 3272|       |         disable it */
 3273|      0|      multi->timer_cb(multi, -1, multi->timer_userp);
 3274|      0|      return;
 3275|      0|    }
 3276|      0|    return;
 3277|      0|  }
 3278|       |
 3279|       |  /* When multi_timeout() is done, multi->timetree points to the node with the
 3280|       |   * timeout we got the (relative) time-out time for. We can thus easily check
 3281|       |   * if this is the same (fixed) time as we got in a previous call and then
 3282|       |   * avoid calling the callback again. */
 3283|      0|  if(Curl_splaycomparekeys(multi->timetree->key, multi->timer_lastcall) == 0)
 3284|      0|    return;
 3285|       |
 3286|      0|  multi->timer_lastcall = multi->timetree->key;
 3287|       |
 3288|      0|  multi->timer_cb(multi, timeout_ms, multi->timer_userp);
 3289|      0|}
Curl_expire:
 3366|  9.09k|{
 3367|  9.09k|  struct Curl_multi *multi = data->multi;
 3368|  9.09k|  struct curltime *nowp = &data->state.expiretime;
 3369|  9.09k|  struct curltime set;
 3370|       |
 3371|       |  /* this is only interesting while there is still an associated multi struct
 3372|       |     remaining! */
 3373|  9.09k|  if(!multi)
 3374|      0|    return;
 3375|       |
 3376|  9.09k|  DEBUGASSERT(id < EXPIRE_LAST);
 3377|       |
 3378|  9.09k|  set = Curl_now();
 3379|  9.09k|  set.tv_sec += (time_t)(milli/1000); /* might be a 64 to 32 bit conversion */
 3380|  9.09k|  set.tv_usec += (unsigned int)(milli%1000)*1000;
 3381|       |
 3382|  9.09k|  if(set.tv_usec >= 1000000) {
 3383|  1.18k|    set.tv_sec++;
 3384|  1.18k|    set.tv_usec -= 1000000;
 3385|  1.18k|  }
 3386|       |
 3387|       |  /* Remove any timer with the same id just in case. */
 3388|  9.09k|  multi_deltimeout(data, id);
 3389|       |
 3390|       |  /* Add it to the timer list.  It must stay in the list until it has expired
 3391|       |     in case we need to recompute the minimum timer later. */
 3392|  9.09k|  multi_addtimeout(data, &set, id);
 3393|       |
 3394|  9.09k|  if(nowp->tv_sec || nowp->tv_usec) {
 3395|       |    /* This means that the struct is added as a node in the splay tree.
 3396|       |       Compare if the new time is earlier, and only remove-old/add-new if it
 3397|       |       is. */
 3398|  5.99k|    timediff_t diff = Curl_timediff(set, *nowp);
 3399|  5.99k|    int rc;
 3400|       |
 3401|  5.99k|    if(diff > 0) {
 3402|       |      /* The current splay tree entry is sooner than this new expiry time.
 3403|       |         We don't need to update our splay tree entry. */
 3404|  5.87k|      return;
 3405|  5.87k|    }
 3406|       |
 3407|       |    /* Since this is an updated time, we must remove the previous entry from
 3408|       |       the splay tree first and then re-add the new value */
 3409|    121|    rc = Curl_splayremove(multi->timetree, &data->state.timenode,
 3410|    121|                          &multi->timetree);
 3411|    121|    if(rc)
 3412|      0|      infof(data, "Internal error removing splay node = %d", rc);
 3413|    121|  }
 3414|       |
 3415|       |  /* Indicate that we are in the splay tree and insert the new timer expiry
 3416|       |     value since it is our local minimum. */
 3417|  3.21k|  *nowp = set;
 3418|  3.21k|  data->state.timenode.payload = data;
 3419|  3.21k|  multi->timetree = Curl_splayinsert(*nowp, multi->timetree,
 3420|  3.21k|                                     &data->state.timenode);
 3421|  3.21k|}
Curl_expire_done:
 3430|     11|{
 3431|       |  /* remove the timer, if there */
 3432|     11|  multi_deltimeout(data, id);
 3433|     11|}
Curl_expire_clear:
 3441|  12.4k|{
 3442|  12.4k|  struct Curl_multi *multi = data->multi;
 3443|  12.4k|  struct curltime *nowp = &data->state.expiretime;
 3444|       |
 3445|       |  /* this is only interesting while there is still an associated multi struct
 3446|       |     remaining! */
 3447|  12.4k|  if(!multi)
 3448|  6.25k|    return;
 3449|       |
 3450|  6.15k|  if(nowp->tv_sec || nowp->tv_usec) {
 3451|       |    /* Since this is an cleared time, we must remove the previous entry from
 3452|       |       the splay tree */
 3453|  3.09k|    struct Curl_llist *list = &data->state.timeoutlist;
 3454|  3.09k|    int rc;
 3455|       |
 3456|  3.09k|    rc = Curl_splayremove(multi->timetree, &data->state.timenode,
 3457|  3.09k|                          &multi->timetree);
 3458|  3.09k|    if(rc)
 3459|      0|      infof(data, "Internal error clearing splay node = %d", rc);
 3460|       |
 3461|       |    /* flush the timeout list too */
 3462|  10.9k|    while(list->size > 0) {
 3463|  7.82k|      Curl_llist_remove(list, list->tail, NULL);
 3464|  7.82k|    }
 3465|       |
 3466|  3.09k|#ifdef DEBUGBUILD
 3467|  3.09k|    infof(data, "Expire cleared (transfer %p)", data);
 3468|  3.09k|#endif
 3469|  3.09k|    nowp->tv_sec = 0;
 3470|  3.09k|    nowp->tv_usec = 0;
 3471|  3.09k|  }
 3472|  6.15k|}
Curl_multi_max_host_connections:
 3496|  3.05k|{
 3497|  3.05k|  return multi ? multi->max_host_connections : 0;
 3498|  3.05k|}
Curl_multi_max_total_connections:
 3501|  3.05k|{
 3502|  3.05k|  return multi ? multi->max_total_connections : 0;
 3503|  3.05k|}
Curl_set_in_callback:
 3545|  26.2k|{
 3546|       |  /* might get called when there is no data pointer! */
 3547|  26.2k|  if(data) {
 3548|  26.2k|    if(data->multi_easy)
 3549|      0|      data->multi_easy->in_callback = value;
 3550|  26.2k|    else if(data->multi)
 3551|  26.2k|      data->multi->in_callback = value;
 3552|  26.2k|  }
 3553|  26.2k|}
multi.c:sh_init:
  336|  3.09k|{
  337|  3.09k|  return Curl_hash_init(hash, hashsize, hash_fd, fd_key_compare,
  338|  3.09k|                        sh_freeentry);
  339|  3.09k|}
multi.c:hash_fd:
  310|  2.40k|{
  311|  2.40k|  curl_socket_t fd = *((curl_socket_t *) key);
  312|  2.40k|  (void) key_length;
  313|       |
  314|  2.40k|  return (fd % slots_num);
  315|  2.40k|}
multi.c:mstate:
  131|  25.4k|{
  132|  25.4k|  CURLMstate oldstate = data->mstate;
  133|  25.4k|  static const init_multistate_func finit[MSTATE_LAST] = {
  134|  25.4k|    NULL,              /* INIT */
  135|  25.4k|    NULL,              /* PENDING */
  136|  25.4k|    Curl_init_CONNECT, /* CONNECT */
  137|  25.4k|    NULL,              /* RESOLVING */
  138|  25.4k|    NULL,              /* CONNECTING */
  139|  25.4k|    NULL,              /* TUNNELING */
  140|  25.4k|    NULL,              /* PROTOCONNECT */
  141|  25.4k|    NULL,              /* PROTOCONNECTING */
  142|  25.4k|    Curl_connect_free, /* DO */
  143|  25.4k|    NULL,              /* DOING */
  144|  25.4k|    NULL,              /* DOING_MORE */
  145|  25.4k|    before_perform,    /* DID */
  146|  25.4k|    NULL,              /* PERFORMING */
  147|  25.4k|    NULL,              /* RATELIMITING */
  148|  25.4k|    NULL,              /* DONE */
  149|  25.4k|    init_completed,    /* COMPLETED */
  150|       |    NULL               /* MSGSENT */
  151|  25.4k|  };
  152|       |
  153|       |#if defined(DEBUGBUILD) && defined(CURL_DISABLE_VERBOSE_STRINGS)
  154|       |  (void) lineno;
  155|       |#endif
  156|       |
  157|  25.4k|  if(oldstate == state)
  158|       |    /* don't bother when the new state is the same as the old state */
  159|  3.09k|    return;
  160|       |
  161|  22.3k|  data->mstate = state;
  162|       |
  163|  22.3k|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
  164|  22.3k|  if(data->mstate >= MSTATE_PENDING &&
  165|  22.3k|     data->mstate < MSTATE_COMPLETED) {
  166|  16.2k|    long connection_id = -5000;
  167|       |
  168|  16.2k|    if(data->conn)
  169|  13.2k|      connection_id = data->conn->connection_id;
  170|       |
  171|  16.2k|    infof(data,
  172|  16.2k|          "STATE: %s => %s handle %p; line %d (connection #%ld)",
  173|  16.2k|          statename[oldstate], statename[data->mstate],
  174|  16.2k|          (void *)data, lineno, connection_id);
  175|  16.2k|  }
  176|  22.3k|#endif
  177|       |
  178|  22.3k|  if(state == MSTATE_COMPLETED) {
  179|       |    /* changing to COMPLETED means there's one less easy handle 'alive' */
  180|  3.06k|    DEBUGASSERT(data->multi->num_alive > 0);
  181|  3.06k|    data->multi->num_alive--;
  182|  3.06k|  }
  183|       |
  184|       |  /* if this state has an init-function, run it */
  185|  22.3k|  if(finit[state])
  186|  10.2k|    finit[state](data);
  187|  22.3k|}
multi.c:before_perform:
  110|  1.63k|{
  111|  1.63k|  data->req.chunk = FALSE;
  112|  1.63k|  Curl_pgrsTime(data, TIMER_PRETRANSFER);
  113|  1.63k|}
multi.c:init_completed:
  116|  3.06k|{
  117|       |  /* this is a completed transfer */
  118|       |
  119|       |  /* Important: reset the conn pointer so that we don't point to memory
  120|       |     that could be freed anytime */
  121|  3.06k|  Curl_detach_connnection(data);
  122|  3.06k|  Curl_expire_clear(data); /* stop all timers */
  123|  3.06k|}
multi.c:multi_done:
  560|  2.95k|{
  561|  2.95k|  CURLcode result;
  562|  2.95k|  struct connectdata *conn = data->conn;
  563|  2.95k|  unsigned int i;
  564|       |
  565|  2.95k|  DEBUGF(infof(data, "multi_done"));
  566|       |
  567|  2.95k|  if(data->state.done)
  568|       |    /* Stop if multi_done() has already been called */
  569|      0|    return CURLE_OK;
  570|       |
  571|       |  /* Stop the resolver and free its own resources (but not dns_entry yet). */
  572|  2.95k|  Curl_resolver_kill(data);
  573|       |
  574|       |  /* Cleanup possible redirect junk */
  575|  2.95k|  Curl_safefree(data->req.newurl);
  576|  2.95k|  Curl_safefree(data->req.location);
  577|       |
  578|  2.95k|  switch(status) {
  579|      3|  case CURLE_ABORTED_BY_CALLBACK:
  580|      3|  case CURLE_READ_ERROR:
  581|      4|  case CURLE_WRITE_ERROR:
  582|       |    /* When we're aborted due to a callback return code it basically have to
  583|       |       be counted as premature as there is trouble ahead if we don't. We have
  584|       |       many callbacks and protocols work differently, we could potentially do
  585|       |       this more fine-grained in the future. */
  586|      4|    premature = TRUE;
  587|  2.95k|  default:
  588|  2.95k|    break;
  589|  2.95k|  }
  590|       |
  591|       |  /* this calls the protocol-specific function pointer previously set */
  592|  2.95k|  if(conn->handler->done)
  593|  2.91k|    result = conn->handler->done(data, status, premature);
  594|     45|  else
  595|     45|    result = status;
  596|       |
  597|  2.95k|  if(CURLE_ABORTED_BY_CALLBACK != result) {
  598|       |    /* avoid this if we already aborted by callback to avoid this calling
  599|       |       another callback */
  600|  2.95k|    CURLcode rc = Curl_pgrsDone(data);
  601|  2.95k|    if(!result && rc)
  602|      0|      result = CURLE_ABORTED_BY_CALLBACK;
  603|  2.95k|  }
  604|       |
  605|  2.95k|  process_pending_handles(data->multi); /* connection / multiplex */
  606|       |
  607|  2.95k|  CONNCACHE_LOCK(data);
  608|  2.95k|  Curl_detach_connnection(data);
  609|  2.95k|  if(CONN_INUSE(conn)) {
  610|       |    /* Stop if still used. */
  611|      0|    CONNCACHE_UNLOCK(data);
  612|      0|    DEBUGF(infof(data, "Connection still in use %zu, "
  613|      0|                 "no more multi_done now!",
  614|      0|                 conn->easyq.size));
  615|      0|    return CURLE_OK;
  616|      0|  }
  617|       |
  618|  2.95k|  data->state.done = TRUE; /* called just now! */
  619|       |
  620|  2.95k|  if(conn->dns_entry) {
  621|  2.92k|    Curl_resolv_unlock(data, conn->dns_entry); /* done with this */
  622|  2.92k|    conn->dns_entry = NULL;
  623|  2.92k|  }
  624|  2.95k|  Curl_hostcache_prune(data);
  625|  2.95k|  Curl_safefree(data->state.ulbuf);
  626|       |
  627|       |  /* if the transfer was completed in a paused state there can be buffered
  628|       |     data left to free */
  629|  2.95k|  for(i = 0; i < data->state.tempcount; i++) {
  630|      0|    Curl_dyn_free(&data->state.tempwrite[i].b);
  631|      0|  }
  632|  2.95k|  data->state.tempcount = 0;
  633|       |
  634|       |  /* if data->set.reuse_forbid is TRUE, it means the libcurl client has
  635|       |     forced us to close this connection. This is ignored for requests taking
  636|       |     place in a NTLM/NEGOTIATE authentication handshake
  637|       |
  638|       |     if conn->bits.close is TRUE, it means that the connection should be
  639|       |     closed in spite of all our efforts to be nice, due to protocol
  640|       |     restrictions in our or the server's end
  641|       |
  642|       |     if premature is TRUE, it means this connection was said to be DONE before
  643|       |     the entire request operation is complete and thus we can't know in what
  644|       |     state it is for re-using, so we're forced to close it. In a perfect world
  645|       |     we can add code that keep track of if we really must close it here or not,
  646|       |     but currently we have no such detail knowledge.
  647|       |  */
  648|       |
  649|  2.95k|  if((data->set.reuse_forbid
  650|  2.95k|#if defined(USE_NTLM)
  651|  2.95k|      && !(conn->http_ntlm_state == NTLMSTATE_TYPE2 ||
  652|      0|           conn->proxy_ntlm_state == NTLMSTATE_TYPE2)
  653|  2.95k|#endif
  654|       |#if defined(USE_SPNEGO)
  655|       |      && !(conn->http_negotiate_state == GSS_AUTHRECV ||
  656|       |           conn->proxy_negotiate_state == GSS_AUTHRECV)
  657|       |#endif
  658|  2.95k|     ) || conn->bits.close
  659|  2.95k|       || (premature && !(conn->handler->flags & PROTOPT_STREAM))) {
  660|  2.38k|    CURLcode res2;
  661|  2.38k|    connclose(conn, "disconnecting");
  662|  2.38k|    Curl_conncache_remove_conn(data, conn, FALSE);
  663|  2.38k|    CONNCACHE_UNLOCK(data);
  664|  2.38k|    res2 = Curl_disconnect(data, conn, premature);
  665|       |
  666|       |    /* If we had an error already, make sure we return that one. But
  667|       |       if we got a new error, return that. */
  668|  2.38k|    if(!result && res2)
  669|      0|      result = res2;
  670|  2.38k|  }
  671|    571|  else {
  672|    571|    char buffer[256];
  673|    571|    const char *host =
  674|    571|#ifndef CURL_DISABLE_PROXY
  675|    571|      conn->bits.socksproxy ?
  676|      0|      conn->socks_proxy.host.dispname :
  677|    571|      conn->bits.httpproxy ? conn->http_proxy.host.dispname :
  678|    571|#endif
  679|    571|      conn->bits.conn_to_host ? conn->conn_to_host.dispname :
  680|    571|      conn->host.dispname;
  681|       |    /* create string before returning the connection */
  682|    571|    msnprintf(buffer, sizeof(buffer),
  683|    571|              "Connection #%ld to host %s left intact",
  684|    571|              conn->connection_id, host);
  685|       |    /* the connection is no longer in use by this transfer */
  686|    571|    CONNCACHE_UNLOCK(data);
  687|    571|    if(Curl_conncache_return_conn(data, conn)) {
  688|       |      /* remember the most recently used connection */
  689|    571|      data->state.lastconnect_id = conn->connection_id;
  690|    571|      infof(data, "%s", buffer);
  691|    571|    }
  692|      0|    else
  693|      0|      data->state.lastconnect_id = -1;
  694|    571|  }
  695|       |
  696|  2.95k|  Curl_safefree(data->state.buffer);
  697|  2.95k|  Curl_free_request_state(data);
  698|  2.95k|  return result;
  699|  2.95k|}
multi.c:close_connect_only:
  703|    516|{
  704|    516|  (void)param;
  705|    516|  if(data->state.lastconnect_id != conn->connection_id)
  706|      1|    return 0;
  707|       |
  708|    515|  if(!conn->bits.connect_only)
  709|    515|    return 1;
  710|       |
  711|      0|  connclose(conn, "Removing connect-only easy handle");
  712|       |
  713|      0|  return 1;
  714|    515|}
multi.c:multi_getsock:
  984|  5.78M|{
  985|  5.78M|  struct connectdata *conn = data->conn;
  986|       |  /* The no connection case can happen when this is called from
  987|       |     curl_multi_remove_handle() => singlesocket() => multi_getsock().
  988|       |  */
  989|  5.78M|  if(!conn)
  990|  3.09k|    return 0;
  991|       |
  992|  5.78M|  switch(data->mstate) {
  993|      0|  default:
  994|      0|    return 0;
  995|       |
  996|      0|  case MSTATE_RESOLVING:
  997|      0|    return Curl_resolv_getsock(data, socks);
  998|       |
  999|  1.56k|  case MSTATE_PROTOCONNECTING:
 1000|  1.56k|  case MSTATE_PROTOCONNECT:
 1001|  1.56k|    return protocol_getsock(data, conn, socks);
 1002|       |
 1003|      0|  case MSTATE_DO:
 1004|  1.07k|  case MSTATE_DOING:
 1005|  1.07k|    return doing_getsock(data, conn, socks);
 1006|       |
 1007|      0|  case MSTATE_TUNNELING:
 1008|      0|    return waitproxyconnect_getsock(conn, socks);
 1009|       |
 1010|      0|  case MSTATE_CONNECTING:
 1011|      0|    return waitconnect_getsock(conn, socks);
 1012|       |
 1013|      0|  case MSTATE_DOING_MORE:
 1014|      0|    return domore_getsock(data, conn, socks);
 1015|       |
 1016|      0|  case MSTATE_DID: /* since is set after DO is completed, we switch to
 1017|       |                        waiting for the same as the PERFORMING state */
 1018|  5.78M|  case MSTATE_PERFORMING:
 1019|  5.78M|    return Curl_single_getsock(data, conn, socks);
 1020|  5.78M|  }
 1021|       |
 1022|  5.78M|}
multi.c:protocol_getsock:
  970|  1.56k|{
  971|  1.56k|  if(conn->handler->proto_getsock)
  972|  1.56k|    return conn->handler->proto_getsock(data, conn, socks);
  973|       |  /* Backup getsock logic. Since there is a live socket in use, we must wait
  974|       |     for it or it will be removed from watching when the multi_socket API is
  975|       |     used. */
  976|      0|  socks[0] = conn->sock[FIRSTSOCKET];
  977|      0|  return GETSOCK_READSOCK(0) | GETSOCK_WRITESOCK(0);
  978|  1.56k|}
multi.c:doing_getsock:
  961|  1.07k|{
  962|  1.07k|  if(conn && conn->handler->doing_getsock)
  963|  1.07k|    return conn->handler->doing_getsock(data, conn, socks);
  964|      0|  return GETSOCK_BLANK;
  965|  1.07k|}
multi.c:multi_runsingle:
 1729|  5.78M|{
 1730|  5.78M|  struct Curl_message *msg = NULL;
 1731|  5.78M|  bool connected;
 1732|  5.78M|  bool async;
 1733|  5.78M|  bool protocol_connected = FALSE;
 1734|  5.78M|  bool dophase_done = FALSE;
 1735|  5.78M|  bool done = FALSE;
 1736|  5.78M|  CURLMcode rc;
 1737|  5.78M|  CURLcode result = CURLE_OK;
 1738|  5.78M|  timediff_t recv_timeout_ms;
 1739|  5.78M|  timediff_t send_timeout_ms;
 1740|  5.78M|  int control;
 1741|       |
 1742|  5.78M|  if(!GOOD_EASY_HANDLE(data))
 1743|      0|    return CURLM_BAD_EASY_HANDLE;
 1744|       |
 1745|  5.80M|  do {
 1746|       |    /* A "stream" here is a logical stream if the protocol can handle that
 1747|       |       (HTTP/2), or the full connection for older protocols */
 1748|  5.80M|    bool stream_error = FALSE;
 1749|  5.80M|    rc = CURLM_OK;
 1750|       |
 1751|  5.80M|    if(multi_ischanged(multi, TRUE)) {
 1752|      0|      DEBUGF(infof(data, "multi changed, check CONNECT_PEND queue!"));
 1753|      0|      process_pending_handles(multi); /* multiplexed */
 1754|      0|    }
 1755|       |
 1756|  5.80M|    if(data->mstate > MSTATE_CONNECT &&
 1757|  5.80M|       data->mstate < MSTATE_COMPLETED) {
 1758|       |      /* Make sure we set the connection's current owner */
 1759|  5.79M|      DEBUGASSERT(data->conn);
 1760|  5.79M|      if(!data->conn)
 1761|      0|        return CURLM_INTERNAL_ERROR;
 1762|  5.79M|    }
 1763|       |
 1764|  5.80M|    if(data->conn &&
 1765|  5.80M|       (data->mstate >= MSTATE_CONNECT) &&
 1766|  5.80M|       (data->mstate < MSTATE_COMPLETED)) {
 1767|       |      /* Check for overall operation timeout here but defer handling the
 1768|       |       * connection timeout to later, to allow for a connection to be set up
 1769|       |       * in the window since we last checked timeout. This prevents us
 1770|       |       * tearing down a completed connection in the case where we were slow
 1771|       |       * to check the timeout (e.g. process descheduled during this loop).
 1772|       |       * We set connect_timeout=FALSE to do this. */
 1773|       |
 1774|       |      /* we need to wait for the connect state as only then is the start time
 1775|       |         stored, but we must not check already completed handles */
 1776|  5.79M|      if(multi_handle_timeout(data, nowp, &stream_error, &result, FALSE)) {
 1777|       |        /* Skip the statemachine and go directly to error handling section. */
 1778|     52|        goto statemachine_end;
 1779|     52|      }
 1780|  5.79M|    }
 1781|       |
 1782|  5.80M|    switch(data->mstate) {
 1783|  3.09k|    case MSTATE_INIT:
 1784|       |      /* init this transfer. */
 1785|  3.09k|      result = Curl_pretransfer(data);
 1786|       |
 1787|  3.09k|      if(!result) {
 1788|       |        /* after init, go CONNECT */
 1789|  2.94k|        multistate(data, MSTATE_CONNECT);
 1790|  2.94k|        *nowp = Curl_pgrsTime(data, TIMER_STARTOP);
 1791|  2.94k|        rc = CURLM_CALL_MULTI_PERFORM;
 1792|  2.94k|      }
 1793|  3.09k|      break;
 1794|       |
 1795|      0|    case MSTATE_PENDING:
 1796|       |      /* We will stay here until there is a connection available. Then
 1797|       |         we try again in the MSTATE_CONNECT state. */
 1798|      0|      break;
 1799|       |
 1800|  3.05k|    case MSTATE_CONNECT:
 1801|       |      /* Connect. We want to get a connection identifier filled in. */
 1802|       |      /* init this transfer. */
 1803|  3.05k|      result = Curl_preconnect(data);
 1804|  3.05k|      if(result)
 1805|      0|        break;
 1806|       |
 1807|  3.05k|      *nowp = Curl_pgrsTime(data, TIMER_STARTSINGLE);
 1808|  3.05k|      if(data->set.timeout)
 1809|  3.05k|        Curl_expire(data, data->set.timeout, EXPIRE_TIMEOUT);
 1810|       |
 1811|  3.05k|      if(data->set.connecttimeout)
 1812|      0|        Curl_expire(data, data->set.connecttimeout, EXPIRE_CONNECTTIMEOUT);
 1813|       |
 1814|  3.05k|      result = Curl_connect(data, &async, &protocol_connected);
 1815|  3.05k|      if(CURLE_NO_CONNECTION_AVAILABLE == result) {
 1816|       |        /* There was no connection available. We will go to the pending
 1817|       |           state and wait for an available connection. */
 1818|      0|        multistate(data, MSTATE_PENDING);
 1819|       |
 1820|       |        /* add this handle to the list of connect-pending handles */
 1821|      0|        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,
 1822|      0|                               &data->connect_queue);
 1823|      0|        result = CURLE_OK;
 1824|      0|        break;
 1825|      0|      }
 1826|  3.05k|      else if(data->state.previouslypending) {
 1827|       |        /* this transfer comes from the pending queue so try move another */
 1828|      0|        infof(data, "Transfer was pending, now try another");
 1829|      0|        process_pending_handles(data->multi);
 1830|      0|      }
 1831|       |
 1832|  3.05k|      if(!result) {
 1833|  2.95k|        if(async)
 1834|       |          /* We're now waiting for an asynchronous name lookup */
 1835|      0|          multistate(data, MSTATE_RESOLVING);
 1836|  2.95k|        else {
 1837|       |          /* after the connect has been sent off, go WAITCONNECT unless the
 1838|       |             protocol connect is already done and we can go directly to
 1839|       |             WAITDO or DO! */
 1840|  2.95k|          rc = CURLM_CALL_MULTI_PERFORM;
 1841|       |
 1842|  2.95k|          if(protocol_connected)
 1843|     36|            multistate(data, MSTATE_DO);
 1844|  2.92k|          else {
 1845|  2.92k|#ifndef CURL_DISABLE_HTTP
 1846|  2.92k|            if(Curl_connect_ongoing(data->conn))
 1847|      0|              multistate(data, MSTATE_TUNNELING);
 1848|  2.92k|            else
 1849|  2.92k|#endif
 1850|  2.92k|              multistate(data, MSTATE_CONNECTING);
 1851|  2.92k|          }
 1852|  2.95k|        }
 1853|  2.95k|      }
 1854|  3.05k|      break;
 1855|       |
 1856|      0|    case MSTATE_RESOLVING:
 1857|       |      /* awaiting an asynch name resolve to complete */
 1858|      0|    {
 1859|      0|      struct Curl_dns_entry *dns = NULL;
 1860|      0|      struct connectdata *conn = data->conn;
 1861|      0|      const char *hostname;
 1862|       |
 1863|      0|      DEBUGASSERT(conn);
 1864|      0|#ifndef CURL_DISABLE_PROXY
 1865|      0|      if(conn->bits.httpproxy)
 1866|      0|        hostname = conn->http_proxy.host.name;
 1867|      0|      else
 1868|      0|#endif
 1869|      0|        if(conn->bits.conn_to_host)
 1870|      0|        hostname = conn->conn_to_host.name;
 1871|      0|      else
 1872|      0|        hostname = conn->host.name;
 1873|       |
 1874|       |      /* check if we have the name resolved by now */
 1875|      0|      dns = Curl_fetch_addr(data, hostname, (int)conn->port);
 1876|       |
 1877|      0|      if(dns) {
 1878|      0|#ifdef CURLRES_ASYNCH
 1879|      0|        data->state.async.dns = dns;
 1880|      0|        data->state.async.done = TRUE;
 1881|      0|#endif
 1882|      0|        result = CURLE_OK;
 1883|      0|        infof(data, "Hostname '%s' was found in DNS cache", hostname);
 1884|      0|      }
 1885|       |
 1886|      0|      if(!dns)
 1887|      0|        result = Curl_resolv_check(data, &dns);
 1888|       |
 1889|       |      /* Update sockets here, because the socket(s) may have been
 1890|       |         closed and the application thus needs to be told, even if it
 1891|       |         is likely that the same socket(s) will again be used further
 1892|       |         down.  If the name has not yet been resolved, it is likely
 1893|       |         that new sockets have been opened in an attempt to contact
 1894|       |         another resolver. */
 1895|      0|      singlesocket(multi, data);
 1896|       |
 1897|      0|      if(dns) {
 1898|       |        /* Perform the next step in the connection phase, and then move on
 1899|       |           to the WAITCONNECT state */
 1900|      0|        result = Curl_once_resolved(data, &protocol_connected);
 1901|       |
 1902|      0|        if(result)
 1903|       |          /* if Curl_once_resolved() returns failure, the connection struct
 1904|       |             is already freed and gone */
 1905|      0|          data->conn = NULL; /* no more connection */
 1906|      0|        else {
 1907|       |          /* call again please so that we get the next socket setup */
 1908|      0|          rc = CURLM_CALL_MULTI_PERFORM;
 1909|      0|          if(protocol_connected)
 1910|      0|            multistate(data, MSTATE_DO);
 1911|      0|          else {
 1912|      0|#ifndef CURL_DISABLE_HTTP
 1913|      0|            if(Curl_connect_ongoing(data->conn))
 1914|      0|              multistate(data, MSTATE_TUNNELING);
 1915|      0|            else
 1916|      0|#endif
 1917|      0|              multistate(data, MSTATE_CONNECTING);
 1918|      0|          }
 1919|      0|        }
 1920|      0|      }
 1921|       |
 1922|      0|      if(result) {
 1923|       |        /* failure detected */
 1924|      0|        stream_error = TRUE;
 1925|      0|        break;
 1926|      0|      }
 1927|      0|    }
 1928|      0|    break;
 1929|       |
 1930|      0|#ifndef CURL_DISABLE_HTTP
 1931|      0|    case MSTATE_TUNNELING:
 1932|       |      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */
 1933|      0|      DEBUGASSERT(data->conn);
 1934|      0|      result = Curl_http_connect(data, &protocol_connected);
 1935|      0|#ifndef CURL_DISABLE_PROXY
 1936|      0|      if(data->conn->bits.proxy_connect_closed) {
 1937|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 1938|       |        /* connect back to proxy again */
 1939|      0|        result = CURLE_OK;
 1940|      0|        multi_done(data, CURLE_OK, FALSE);
 1941|      0|        multistate(data, MSTATE_CONNECT);
 1942|      0|      }
 1943|      0|      else
 1944|      0|#endif
 1945|      0|        if(!result) {
 1946|      0|          if(
 1947|      0|#ifndef CURL_DISABLE_PROXY
 1948|      0|            (data->conn->http_proxy.proxytype != CURLPROXY_HTTPS ||
 1949|      0|             data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&
 1950|      0|#endif
 1951|      0|            Curl_connect_complete(data->conn)) {
 1952|      0|            rc = CURLM_CALL_MULTI_PERFORM;
 1953|       |            /* initiate protocol connect phase */
 1954|      0|            multistate(data, MSTATE_PROTOCONNECT);
 1955|      0|          }
 1956|      0|        }
 1957|      0|      else
 1958|      0|        stream_error = TRUE;
 1959|      0|      break;
 1960|      0|#endif
 1961|       |
 1962|  2.92k|    case MSTATE_CONNECTING:
 1963|       |      /* awaiting a completion of an asynch TCP connect */
 1964|  2.92k|      DEBUGASSERT(data->conn);
 1965|  2.92k|      result = Curl_is_connected(data, data->conn, FIRSTSOCKET, &connected);
 1966|  2.92k|      if(connected && !result) {
 1967|  2.92k|#ifndef CURL_DISABLE_HTTP
 1968|  2.92k|        if(
 1969|  2.92k|#ifndef CURL_DISABLE_PROXY
 1970|  2.92k|          (data->conn->http_proxy.proxytype == CURLPROXY_HTTPS &&
 1971|  2.92k|           !data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||
 1972|  2.92k|#endif
 1973|  2.92k|          Curl_connect_ongoing(data->conn)) {
 1974|      0|          multistate(data, MSTATE_TUNNELING);
 1975|      0|          break;
 1976|      0|        }
 1977|  2.92k|#endif
 1978|  2.92k|        rc = CURLM_CALL_MULTI_PERFORM;
 1979|  2.92k|#ifndef CURL_DISABLE_PROXY
 1980|  2.92k|        multistate(data,
 1981|  2.92k|                   data->conn->bits.tunnel_proxy?
 1982|  2.92k|                   MSTATE_TUNNELING : MSTATE_PROTOCONNECT);
 1983|       |#else
 1984|       |        multistate(data, MSTATE_PROTOCONNECT);
 1985|       |#endif
 1986|  2.92k|      }
 1987|      0|      else if(result) {
 1988|       |        /* failure detected */
 1989|      0|        Curl_posttransfer(data);
 1990|      0|        multi_done(data, result, TRUE);
 1991|      0|        stream_error = TRUE;
 1992|      0|        break;
 1993|      0|      }
 1994|  2.92k|      break;
 1995|       |
 1996|  2.92k|    case MSTATE_PROTOCONNECT:
 1997|  2.92k|      result = protocol_connect(data, &protocol_connected);
 1998|  2.92k|      if(!result && !protocol_connected)
 1999|       |        /* switch to waiting state */
 2000|    317|        multistate(data, MSTATE_PROTOCONNECTING);
 2001|  2.60k|      else if(!result) {
 2002|       |        /* protocol connect has completed, go WAITDO or DO */
 2003|  2.19k|        multistate(data, MSTATE_DO);
 2004|  2.19k|        rc = CURLM_CALL_MULTI_PERFORM;
 2005|  2.19k|      }
 2006|    407|      else {
 2007|       |        /* failure detected */
 2008|    407|        Curl_posttransfer(data);
 2009|    407|        multi_done(data, result, TRUE);
 2010|    407|        stream_error = TRUE;
 2011|    407|      }
 2012|  2.92k|      break;
 2013|       |
 2014|  1.55k|    case MSTATE_PROTOCONNECTING:
 2015|       |      /* protocol-specific connect phase */
 2016|  1.55k|      result = protocol_connecting(data, &protocol_connected);
 2017|  1.55k|      if(!result && protocol_connected) {
 2018|       |        /* after the connect has completed, go WAITDO or DO */
 2019|    223|        multistate(data, MSTATE_DO);
 2020|    223|        rc = CURLM_CALL_MULTI_PERFORM;
 2021|    223|      }
 2022|  1.32k|      else if(result) {
 2023|       |        /* failure detected */
 2024|     81|        Curl_posttransfer(data);
 2025|     81|        multi_done(data, result, TRUE);
 2026|     81|        stream_error = TRUE;
 2027|     81|      }
 2028|  1.55k|      break;
 2029|       |
 2030|  2.45k|    case MSTATE_DO:
 2031|  2.45k|      if(data->set.fprereq) {
 2032|      0|        int prereq_rc;
 2033|       |
 2034|       |        /* call the prerequest callback function */
 2035|      0|        Curl_set_in_callback(data, true);
 2036|      0|        prereq_rc = data->set.fprereq(data->set.prereq_userp,
 2037|      0|                                      data->info.conn_primary_ip,
 2038|      0|                                      data->info.conn_local_ip,
 2039|      0|                                      data->info.conn_primary_port,
 2040|      0|                                      data->info.conn_local_port);
 2041|      0|        Curl_set_in_callback(data, false);
 2042|      0|        if(prereq_rc != CURL_PREREQFUNC_OK) {
 2043|      0|          failf(data, "operation aborted by pre-request callback");
 2044|       |          /* failure in pre-request callback - don't do any other processing */
 2045|      0|          result = CURLE_ABORTED_BY_CALLBACK;
 2046|      0|          Curl_posttransfer(data);
 2047|      0|          multi_done(data, result, FALSE);
 2048|      0|          stream_error = TRUE;
 2049|      0|          break;
 2050|      0|        }
 2051|      0|      }
 2052|       |
 2053|  2.45k|      if(data->set.connect_only) {
 2054|       |        /* keep connection open for application to use the socket */
 2055|      0|        connkeep(data->conn, "CONNECT_ONLY");
 2056|      0|        multistate(data, MSTATE_DONE);
 2057|      0|        result = CURLE_OK;
 2058|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 2059|      0|      }
 2060|  2.45k|      else {
 2061|       |        /* Perform the protocol's DO action */
 2062|  2.45k|        result = multi_do(data, &dophase_done);
 2063|       |
 2064|       |        /* When multi_do() returns failure, data->conn might be NULL! */
 2065|       |
 2066|  2.45k|        if(!result) {
 2067|  1.78k|          if(!dophase_done) {
 2068|    208|#ifndef CURL_DISABLE_FTP
 2069|       |            /* some steps needed for wildcard matching */
 2070|    208|            if(data->state.wildcardmatch) {
 2071|      6|              struct WildcardData *wc = &data->wildcard;
 2072|      6|              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {
 2073|       |                /* skip some states if it is important */
 2074|      1|                multi_done(data, CURLE_OK, FALSE);
 2075|       |
 2076|       |                /* if there's no connection left, skip the DONE state */
 2077|      1|                multistate(data, data->conn ?
 2078|      1|                           MSTATE_DONE : MSTATE_COMPLETED);
 2079|      1|                rc = CURLM_CALL_MULTI_PERFORM;
 2080|      1|                break;
 2081|      1|              }
 2082|      6|            }
 2083|    207|#endif
 2084|       |            /* DO was not completed in one function call, we must continue
 2085|       |               DOING... */
 2086|    207|            multistate(data, MSTATE_DOING);
 2087|    207|            rc = CURLM_OK;
 2088|    207|          }
 2089|       |
 2090|       |          /* after DO, go DO_DONE... or DO_MORE */
 2091|  1.57k|          else if(data->conn->bits.do_more) {
 2092|       |            /* we're supposed to do more, but we need to sit down, relax
 2093|       |               and wait a little while first */
 2094|      0|            multistate(data, MSTATE_DOING_MORE);
 2095|      0|            rc = CURLM_OK;
 2096|      0|          }
 2097|  1.57k|          else {
 2098|       |            /* we're done with the DO, now DID */
 2099|  1.57k|            multistate(data, MSTATE_DID);
 2100|  1.57k|            rc = CURLM_CALL_MULTI_PERFORM;
 2101|  1.57k|          }
 2102|  1.78k|        }
 2103|    676|        else if((CURLE_SEND_ERROR == result) &&
 2104|    676|                data->conn->bits.reuse) {
 2105|       |          /*
 2106|       |           * In this situation, a connection that we were trying to use
 2107|       |           * may have unexpectedly died.  If possible, send the connection
 2108|       |           * back to the CONNECT phase so we can try again.
 2109|       |           */
 2110|      0|          char *newurl = NULL;
 2111|      0|          followtype follow = FOLLOW_NONE;
 2112|      0|          CURLcode drc;
 2113|       |
 2114|      0|          drc = Curl_retry_request(data, &newurl);
 2115|      0|          if(drc) {
 2116|       |            /* a failure here pretty much implies an out of memory */
 2117|      0|            result = drc;
 2118|      0|            stream_error = TRUE;
 2119|      0|          }
 2120|       |
 2121|      0|          Curl_posttransfer(data);
 2122|      0|          drc = multi_done(data, result, FALSE);
 2123|       |
 2124|       |          /* When set to retry the connection, we must to go back to
 2125|       |           * the CONNECT state */
 2126|      0|          if(newurl) {
 2127|      0|            if(!drc || (drc == CURLE_SEND_ERROR)) {
 2128|      0|              follow = FOLLOW_RETRY;
 2129|      0|              drc = Curl_follow(data, newurl, follow);
 2130|      0|              if(!drc) {
 2131|      0|                multistate(data, MSTATE_CONNECT);
 2132|      0|                rc = CURLM_CALL_MULTI_PERFORM;
 2133|      0|                result = CURLE_OK;
 2134|      0|              }
 2135|      0|              else {
 2136|       |                /* Follow failed */
 2137|      0|                result = drc;
 2138|      0|              }
 2139|      0|            }
 2140|      0|            else {
 2141|       |              /* done didn't return OK or SEND_ERROR */
 2142|      0|              result = drc;
 2143|      0|            }
 2144|      0|          }
 2145|      0|          else {
 2146|       |            /* Have error handler disconnect conn if we can't retry */
 2147|      0|            stream_error = TRUE;
 2148|      0|          }
 2149|      0|          free(newurl);
 2150|      0|        }
 2151|    676|        else {
 2152|       |          /* failure detected */
 2153|    676|          Curl_posttransfer(data);
 2154|    676|          if(data->conn)
 2155|    676|            multi_done(data, result, FALSE);
 2156|    676|          stream_error = TRUE;
 2157|    676|        }
 2158|  2.45k|      }
 2159|  2.45k|      break;
 2160|       |
 2161|  2.45k|    case MSTATE_DOING:
 2162|       |      /* we continue DOING until the DO phase is complete */
 2163|  1.06k|      DEBUGASSERT(data->conn);
 2164|  1.06k|      result = protocol_doing(data, &dophase_done);
 2165|  1.06k|      if(!result) {
 2166|    935|        if(dophase_done) {
 2167|       |          /* after DO, go DO_DONE or DO_MORE */
 2168|     64|          multistate(data, data->conn->bits.do_more?
 2169|     64|                     MSTATE_DOING_MORE : MSTATE_DID);
 2170|     64|          rc = CURLM_CALL_MULTI_PERFORM;
 2171|     64|        } /* dophase_done */
 2172|    935|      }
 2173|    127|      else {
 2174|       |        /* failure detected */
 2175|    127|        Curl_posttransfer(data);
 2176|    127|        multi_done(data, result, FALSE);
 2177|    127|        stream_error = TRUE;
 2178|    127|      }
 2179|  1.06k|      break;
 2180|       |
 2181|      0|    case MSTATE_DOING_MORE:
 2182|       |      /*
 2183|       |       * When we are connected, DOING MORE and then go DID
 2184|       |       */
 2185|      0|      DEBUGASSERT(data->conn);
 2186|      0|      result = multi_do_more(data, &control);
 2187|       |
 2188|      0|      if(!result) {
 2189|      0|        if(control) {
 2190|       |          /* if positive, advance to DO_DONE
 2191|       |             if negative, go back to DOING */
 2192|      0|          multistate(data, control == 1?
 2193|      0|                     MSTATE_DID : MSTATE_DOING);
 2194|      0|          rc = CURLM_CALL_MULTI_PERFORM;
 2195|      0|        }
 2196|      0|        else
 2197|       |          /* stay in DO_MORE */
 2198|      0|          rc = CURLM_OK;
 2199|      0|      }
 2200|      0|      else {
 2201|       |        /* failure detected */
 2202|      0|        Curl_posttransfer(data);
 2203|      0|        multi_done(data, result, FALSE);
 2204|      0|        stream_error = TRUE;
 2205|      0|      }
 2206|      0|      break;
 2207|       |
 2208|  1.63k|    case MSTATE_DID:
 2209|  1.63k|      DEBUGASSERT(data->conn);
 2210|  1.63k|      if(data->conn->bits.multiplex)
 2211|       |        /* Check if we can move pending requests to send pipe */
 2212|      0|        process_pending_handles(multi); /*  multiplexed */
 2213|       |
 2214|       |      /* Only perform the transfer if there's a good socket to work with.
 2215|       |         Having both BAD is a signal to skip immediately to DONE */
 2216|  1.63k|      if((data->conn->sockfd != CURL_SOCKET_BAD) ||
 2217|  1.63k|         (data->conn->writesockfd != CURL_SOCKET_BAD))
 2218|  1.60k|        multistate(data, MSTATE_PERFORMING);
 2219|     31|      else {
 2220|     31|#ifndef CURL_DISABLE_FTP
 2221|     31|        if(data->state.wildcardmatch &&
 2222|     31|           ((data->conn->handler->flags & PROTOPT_WILDCARD) == 0)) {
 2223|      0|          data->wildcard.state = CURLWC_DONE;
 2224|      0|        }
 2225|     31|#endif
 2226|     31|        multistate(data, MSTATE_DONE);
 2227|     31|      }
 2228|  1.63k|      rc = CURLM_CALL_MULTI_PERFORM;
 2229|  1.63k|      break;
 2230|       |
 2231|      0|    case MSTATE_RATELIMITING: /* limit-rate exceeded in either direction */
 2232|      0|      DEBUGASSERT(data->conn);
 2233|       |      /* if both rates are within spec, resume transfer */
 2234|      0|      if(Curl_pgrsUpdate(data))
 2235|      0|        result = CURLE_ABORTED_BY_CALLBACK;
 2236|      0|      else
 2237|      0|        result = Curl_speedcheck(data, *nowp);
 2238|       |
 2239|      0|      if(result) {
 2240|      0|        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&
 2241|      0|           result != CURLE_HTTP2_STREAM)
 2242|      0|          streamclose(data->conn, "Transfer returned error");
 2243|       |
 2244|      0|        Curl_posttransfer(data);
 2245|      0|        multi_done(data, result, TRUE);
 2246|      0|      }
 2247|      0|      else {
 2248|      0|        send_timeout_ms = 0;
 2249|      0|        if(data->set.max_send_speed)
 2250|      0|          send_timeout_ms =
 2251|      0|            Curl_pgrsLimitWaitTime(data->progress.uploaded,
 2252|      0|                                   data->progress.ul_limit_size,
 2253|      0|                                   data->set.max_send_speed,
 2254|      0|                                   data->progress.ul_limit_start,
 2255|      0|                                   *nowp);
 2256|       |
 2257|      0|        recv_timeout_ms = 0;
 2258|      0|        if(data->set.max_recv_speed)
 2259|      0|          recv_timeout_ms =
 2260|      0|            Curl_pgrsLimitWaitTime(data->progress.downloaded,
 2261|      0|                                   data->progress.dl_limit_size,
 2262|      0|                                   data->set.max_recv_speed,
 2263|      0|                                   data->progress.dl_limit_start,
 2264|      0|                                   *nowp);
 2265|       |
 2266|      0|        if(!send_timeout_ms && !recv_timeout_ms) {
 2267|      0|          multistate(data, MSTATE_PERFORMING);
 2268|      0|          Curl_ratelimit(data, *nowp);
 2269|      0|        }
 2270|      0|        else if(send_timeout_ms >= recv_timeout_ms)
 2271|      0|          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);
 2272|      0|        else
 2273|      0|          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);
 2274|      0|      }
 2275|      0|      break;
 2276|       |
 2277|  5.78M|    case MSTATE_PERFORMING:
 2278|  5.78M|    {
 2279|  5.78M|      char *newurl = NULL;
 2280|  5.78M|      bool retry = FALSE;
 2281|  5.78M|      bool comeback = FALSE;
 2282|  5.78M|      DEBUGASSERT(data->state.buffer);
 2283|       |      /* check if over send speed */
 2284|  5.78M|      send_timeout_ms = 0;
 2285|  5.78M|      if(data->set.max_send_speed)
 2286|      0|        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,
 2287|      0|                                                 data->progress.ul_limit_size,
 2288|      0|                                                 data->set.max_send_speed,
 2289|      0|                                                 data->progress.ul_limit_start,
 2290|      0|                                                 *nowp);
 2291|       |
 2292|       |      /* check if over recv speed */
 2293|  5.78M|      recv_timeout_ms = 0;
 2294|  5.78M|      if(data->set.max_recv_speed)
 2295|      0|        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,
 2296|      0|                                                 data->progress.dl_limit_size,
 2297|      0|                                                 data->set.max_recv_speed,
 2298|      0|                                                 data->progress.dl_limit_start,
 2299|      0|                                                 *nowp);
 2300|       |
 2301|  5.78M|      if(send_timeout_ms || recv_timeout_ms) {
 2302|      0|        Curl_ratelimit(data, *nowp);
 2303|      0|        multistate(data, MSTATE_RATELIMITING);
 2304|      0|        if(send_timeout_ms >= recv_timeout_ms)
 2305|      0|          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);
 2306|      0|        else
 2307|      0|          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);
 2308|      0|        break;
 2309|      0|      }
 2310|       |
 2311|       |      /* read/write data if it is ready to do so */
 2312|  5.78M|      result = Curl_readwrite(data->conn, data, &done, &comeback);
 2313|       |
 2314|  5.78M|      if(done || (result == CURLE_RECV_ERROR)) {
 2315|       |        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race
 2316|       |         * condition and the server closed the re-used connection exactly when
 2317|       |         * we wanted to use it, so figure out if that is indeed the case.
 2318|       |         */
 2319|  1.22k|        CURLcode ret = Curl_retry_request(data, &newurl);
 2320|  1.22k|        if(!ret)
 2321|  1.22k|          retry = (newurl)?TRUE:FALSE;
 2322|      0|        else if(!result)
 2323|      0|          result = ret;
 2324|       |
 2325|  1.22k|        if(retry) {
 2326|       |          /* if we are to retry, set the result to OK and consider the
 2327|       |             request as done */
 2328|      0|          result = CURLE_OK;
 2329|      0|          done = TRUE;
 2330|      0|        }
 2331|  1.22k|      }
 2332|  5.78M|      else if((CURLE_HTTP2_STREAM == result) &&
 2333|  5.78M|              Curl_h2_http_1_1_error(data)) {
 2334|      0|        CURLcode ret = Curl_retry_request(data, &newurl);
 2335|       |
 2336|      0|        if(!ret) {
 2337|      0|          infof(data, "Downgrades to HTTP/1.1!");
 2338|      0|          streamclose(data->conn, "Disconnect HTTP/2 for HTTP/1");
 2339|      0|          data->state.httpwant = CURL_HTTP_VERSION_1_1;
 2340|       |          /* clear the error message bit too as we ignore the one we got */
 2341|      0|          data->state.errorbuf = FALSE;
 2342|      0|          if(!newurl)
 2343|       |            /* typically for HTTP_1_1_REQUIRED error on first flight */
 2344|      0|            newurl = strdup(data->state.url);
 2345|       |          /* if we are to retry, set the result to OK and consider the request
 2346|       |             as done */
 2347|      0|          retry = TRUE;
 2348|      0|          result = CURLE_OK;
 2349|      0|          done = TRUE;
 2350|      0|        }
 2351|      0|        else
 2352|      0|          result = ret;
 2353|      0|      }
 2354|       |
 2355|  5.78M|      if(result) {
 2356|       |        /*
 2357|       |         * The transfer phase returned error, we mark the connection to get
 2358|       |         * closed to prevent being re-used. This is because we can't possibly
 2359|       |         * know if the connection is in a good shape or not now.  Unless it is
 2360|       |         * a protocol which uses two "channels" like FTP, as then the error
 2361|       |         * happened in the data connection.
 2362|       |         */
 2363|       |
 2364|    337|        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&
 2365|    337|           result != CURLE_HTTP2_STREAM)
 2366|    337|          streamclose(data->conn, "Transfer returned error");
 2367|       |
 2368|    337|        Curl_posttransfer(data);
 2369|    337|        multi_done(data, result, TRUE);
 2370|    337|      }
 2371|  5.78M|      else if(done) {
 2372|       |
 2373|       |        /* call this even if the readwrite function returned error */
 2374|  1.21k|        Curl_posttransfer(data);
 2375|       |
 2376|       |        /* When we follow redirects or is set to retry the connection, we must
 2377|       |           to go back to the CONNECT state */
 2378|  1.21k|        if(data->req.newurl || retry) {
 2379|    120|          followtype follow = FOLLOW_NONE;
 2380|    120|          if(!retry) {
 2381|       |            /* if the URL is a follow-location and not just a retried request
 2382|       |               then figure out the URL here */
 2383|    120|            free(newurl);
 2384|    120|            newurl = data->req.newurl;
 2385|    120|            data->req.newurl = NULL;
 2386|    120|            follow = FOLLOW_REDIR;
 2387|    120|          }
 2388|      0|          else
 2389|      0|            follow = FOLLOW_RETRY;
 2390|    120|          (void)multi_done(data, CURLE_OK, FALSE);
 2391|       |          /* multi_done() might return CURLE_GOT_NOTHING */
 2392|    120|          result = Curl_follow(data, newurl, follow);
 2393|    120|          if(!result) {
 2394|    113|            multistate(data, MSTATE_CONNECT);
 2395|    113|            rc = CURLM_CALL_MULTI_PERFORM;
 2396|    113|          }
 2397|    120|          free(newurl);
 2398|    120|        }
 2399|  1.09k|        else {
 2400|       |          /* after the transfer is done, go DONE */
 2401|       |
 2402|       |          /* but first check to see if we got a location info even though we're
 2403|       |             not following redirects */
 2404|  1.09k|          if(data->req.location) {
 2405|     70|            free(newurl);
 2406|     70|            newurl = data->req.location;
 2407|     70|            data->req.location = NULL;
 2408|     70|            result = Curl_follow(data, newurl, FOLLOW_FAKE);
 2409|     70|            free(newurl);
 2410|     70|            if(result) {
 2411|      0|              stream_error = TRUE;
 2412|      0|              result = multi_done(data, result, TRUE);
 2413|      0|            }
 2414|     70|          }
 2415|       |
 2416|  1.09k|          if(!result) {
 2417|  1.09k|            multistate(data, MSTATE_DONE);
 2418|  1.09k|            rc = CURLM_CALL_MULTI_PERFORM;
 2419|  1.09k|          }
 2420|  1.09k|        }
 2421|  1.21k|      }
 2422|  5.78M|      else if(comeback) {
 2423|       |        /* This avoids CURLM_CALL_MULTI_PERFORM so that a very fast transfer
 2424|       |           won't get stuck on this transfer at the expense of other concurrent
 2425|       |           transfers */
 2426|      0|        Curl_expire(data, 0, EXPIRE_RUN_NOW);
 2427|      0|        rc = CURLM_OK;
 2428|      0|      }
 2429|  5.78M|      break;
 2430|  5.78M|    }
 2431|       |
 2432|  1.12k|    case MSTATE_DONE:
 2433|       |      /* this state is highly transient, so run another loop after this */
 2434|  1.12k|      rc = CURLM_CALL_MULTI_PERFORM;
 2435|       |
 2436|  1.12k|      if(data->conn) {
 2437|  1.12k|        CURLcode res;
 2438|       |
 2439|  1.12k|        if(data->conn->bits.multiplex)
 2440|       |          /* Check if we can move pending requests to connection */
 2441|      0|          process_pending_handles(multi); /* multiplexing */
 2442|       |
 2443|       |        /* post-transfer command */
 2444|  1.12k|        res = multi_done(data, result, FALSE);
 2445|       |
 2446|       |        /* allow a previously set error code take precedence */
 2447|  1.12k|        if(!result)
 2448|  1.12k|          result = res;
 2449|  1.12k|      }
 2450|       |
 2451|  1.12k|#ifndef CURL_DISABLE_FTP
 2452|  1.12k|      if(data->state.wildcardmatch) {
 2453|      4|        if(data->wildcard.state != CURLWC_DONE) {
 2454|       |          /* if a wildcard is set and we are not ending -> lets start again
 2455|       |             with MSTATE_INIT */
 2456|      4|          multistate(data, MSTATE_INIT);
 2457|      4|          break;
 2458|      4|        }
 2459|      4|      }
 2460|  1.12k|#endif
 2461|       |      /* after we have DONE what we're supposed to do, go COMPLETED, and
 2462|       |         it doesn't matter what the multi_done() returned! */
 2463|  1.12k|      multistate(data, MSTATE_COMPLETED);
 2464|  1.12k|      break;
 2465|       |
 2466|      0|    case MSTATE_COMPLETED:
 2467|      0|      break;
 2468|       |
 2469|      0|    case MSTATE_MSGSENT:
 2470|      0|      data->result = result;
 2471|      0|      return CURLM_OK; /* do nothing */
 2472|       |
 2473|      0|    default:
 2474|      0|      return CURLM_INTERNAL_ERROR;
 2475|  5.80M|    }
 2476|       |
 2477|  5.80M|    if(data->conn &&
 2478|  5.80M|       data->mstate >= MSTATE_CONNECT &&
 2479|  5.80M|       data->mstate < MSTATE_DO &&
 2480|  5.80M|       rc != CURLM_CALL_MULTI_PERFORM &&
 2481|  5.80M|       !multi_ischanged(multi, false)) {
 2482|       |      /* We now handle stream timeouts if and only if this will be the last
 2483|       |       * loop iteration. We only check this on the last iteration to ensure
 2484|       |       * that if we know we have additional work to do immediately
 2485|       |       * (i.e. CURLM_CALL_MULTI_PERFORM == TRUE) then we should do that before
 2486|       |       * declaring the connection timed out as we may almost have a completed
 2487|       |       * connection. */
 2488|  1.56k|      multi_handle_timeout(data, nowp, &stream_error, &result, TRUE);
 2489|  1.56k|    }
 2490|       |
 2491|  5.80M|    statemachine_end:
 2492|       |
 2493|  5.80M|    if(data->mstate < MSTATE_COMPLETED) {
 2494|  5.80M|      if(result) {
 2495|       |        /*
 2496|       |         * If an error was returned, and we aren't in completed state now,
 2497|       |         * then we go to completed and consider this transfer aborted.
 2498|       |         */
 2499|       |
 2500|       |        /* NOTE: no attempt to disconnect connections must be made
 2501|       |           in the case blocks above - cleanup happens only here */
 2502|       |
 2503|       |        /* Check if we can move pending requests to send pipe */
 2504|  1.93k|        process_pending_handles(multi); /* connection */
 2505|       |
 2506|  1.93k|        if(data->conn) {
 2507|      0|          if(stream_error) {
 2508|       |            /* Don't attempt to send data over a connection that timed out */
 2509|      0|            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;
 2510|      0|            struct connectdata *conn = data->conn;
 2511|       |
 2512|       |            /* This is where we make sure that the conn pointer is reset.
 2513|       |               We don't have to do this in every case block above where a
 2514|       |               failure is detected */
 2515|      0|            Curl_detach_connnection(data);
 2516|       |
 2517|       |            /* remove connection from cache */
 2518|      0|            Curl_conncache_remove_conn(data, conn, TRUE);
 2519|       |
 2520|       |            /* disconnect properly */
 2521|      0|            Curl_disconnect(data, conn, dead_connection);
 2522|      0|          }
 2523|      0|        }
 2524|  1.93k|        else if(data->mstate == MSTATE_CONNECT) {
 2525|       |          /* Curl_connect() failed */
 2526|     94|          (void)Curl_posttransfer(data);
 2527|     94|        }
 2528|       |
 2529|  1.93k|        multistate(data, MSTATE_COMPLETED);
 2530|  1.93k|        rc = CURLM_CALL_MULTI_PERFORM;
 2531|  1.93k|      }
 2532|       |      /* if there's still a connection to use, call the progress function */
 2533|  5.79M|      else if(data->conn && Curl_pgrsUpdate(data)) {
 2534|       |        /* aborted due to progress callback return code must close the
 2535|       |           connection */
 2536|      0|        result = CURLE_ABORTED_BY_CALLBACK;
 2537|      0|        streamclose(data->conn, "Aborted by callback");
 2538|       |
 2539|       |        /* if not yet in DONE state, go there, otherwise COMPLETED */
 2540|      0|        multistate(data, (data->mstate < MSTATE_DONE)?
 2541|      0|                   MSTATE_DONE: MSTATE_COMPLETED);
 2542|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 2543|      0|      }
 2544|  5.80M|    }
 2545|       |
 2546|  5.80M|    if(MSTATE_COMPLETED == data->mstate) {
 2547|  3.06k|      if(data->set.fmultidone) {
 2548|       |        /* signal via callback instead */
 2549|      0|        data->set.fmultidone(data, result);
 2550|      0|      }
 2551|  3.06k|      else {
 2552|       |        /* now fill in the Curl_message with this info */
 2553|  3.06k|        msg = &data->msg;
 2554|       |
 2555|  3.06k|        msg->extmsg.msg = CURLMSG_DONE;
 2556|  3.06k|        msg->extmsg.easy_handle = data;
 2557|  3.06k|        msg->extmsg.data.result = result;
 2558|       |
 2559|  3.06k|        rc = multi_addmsg(multi, msg);
 2560|  3.06k|        DEBUGASSERT(!data->conn);
 2561|  3.06k|      }
 2562|  3.06k|      multistate(data, MSTATE_MSGSENT);
 2563|  3.06k|    }
 2564|  5.80M|  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));
 2565|       |
 2566|  5.78M|  data->result = result;
 2567|  5.78M|  return rc;
 2568|  5.78M|}
multi.c:multi_ischanged:
 1486|  11.5M|{
 1487|  11.5M|  bool retval = multi->recheckstate;
 1488|  11.5M|  if(clear)
 1489|  5.80M|    multi->recheckstate = FALSE;
 1490|  11.5M|  return retval;
 1491|  11.5M|}
multi.c:multi_handle_timeout:
 1563|  5.79M|{
 1564|  5.79M|  timediff_t timeout_ms;
 1565|  5.79M|  timeout_ms = Curl_timeleft(data, now, connect_timeout);
 1566|       |
 1567|  5.79M|  if(timeout_ms < 0) {
 1568|       |    /* Handle timed out */
 1569|     52|    if(data->mstate == MSTATE_RESOLVING)
 1570|      0|      failf(data, "Resolving timed out after %" CURL_FORMAT_TIMEDIFF_T
 1571|      0|            " milliseconds",
 1572|      0|            Curl_timediff(*now, data->progress.t_startsingle));
 1573|     52|    else if(data->mstate == MSTATE_CONNECTING)
 1574|      0|      failf(data, "Connection timed out after %" CURL_FORMAT_TIMEDIFF_T
 1575|      0|            " milliseconds",
 1576|      0|            Curl_timediff(*now, data->progress.t_startsingle));
 1577|     52|    else {
 1578|     52|      struct SingleRequest *k = &data->req;
 1579|     52|      if(k->size != -1) {
 1580|     10|        failf(data, "Operation timed out after %" CURL_FORMAT_TIMEDIFF_T
 1581|     10|              " milliseconds with %" CURL_FORMAT_CURL_OFF_T " out of %"
 1582|     10|              CURL_FORMAT_CURL_OFF_T " bytes received",
 1583|     10|              Curl_timediff(*now, data->progress.t_startsingle),
 1584|     10|              k->bytecount, k->size);
 1585|     10|      }
 1586|     42|      else {
 1587|     42|        failf(data, "Operation timed out after %" CURL_FORMAT_TIMEDIFF_T
 1588|     42|              " milliseconds with %" CURL_FORMAT_CURL_OFF_T
 1589|     42|              " bytes received",
 1590|     42|              Curl_timediff(*now, data->progress.t_startsingle),
 1591|     42|              k->bytecount);
 1592|     42|      }
 1593|     52|    }
 1594|       |
 1595|       |    /* Force connection closed if the connection has indeed been used */
 1596|     52|    if(data->mstate > MSTATE_DO) {
 1597|     52|      streamclose(data->conn, "Disconnected with pending data");
 1598|     52|      *stream_error = TRUE;
 1599|     52|    }
 1600|     52|    *result = CURLE_OPERATION_TIMEDOUT;
 1601|     52|    (void)multi_done(data, *result, TRUE);
 1602|     52|  }
 1603|       |
 1604|  5.79M|  return (timeout_ms < 0);
 1605|  5.79M|}
multi.c:protocol_connect:
 1655|  2.92k|{
 1656|  2.92k|  CURLcode result = CURLE_OK;
 1657|  2.92k|  struct connectdata *conn = data->conn;
 1658|  2.92k|  DEBUGASSERT(conn);
 1659|  2.92k|  DEBUGASSERT(protocol_done);
 1660|       |
 1661|  2.92k|  *protocol_done = FALSE;
 1662|       |
 1663|  2.92k|  if(conn->bits.tcpconnect[FIRSTSOCKET] && conn->bits.protoconnstart) {
 1664|       |    /* We already are connected, get back. This may happen when the connect
 1665|       |       worked fine in the first call, like when we connect to a local server
 1666|       |       or proxy. Note that we don't know if the protocol is actually done.
 1667|       |
 1668|       |       Unless this protocol doesn't have any protocol-connect callback, as
 1669|       |       then we know we're done. */
 1670|      0|    if(!conn->handler->connecting)
 1671|      0|      *protocol_done = TRUE;
 1672|       |
 1673|      0|    return CURLE_OK;
 1674|      0|  }
 1675|       |
 1676|  2.92k|  if(!conn->bits.protoconnstart) {
 1677|  2.92k|#ifndef CURL_DISABLE_PROXY
 1678|  2.92k|    result = Curl_proxy_connect(data, FIRSTSOCKET);
 1679|  2.92k|    if(result)
 1680|      0|      return result;
 1681|       |
 1682|  2.92k|    if(CONNECT_FIRSTSOCKET_PROXY_SSL())
 1683|       |      /* wait for HTTPS proxy SSL initialization to complete */
 1684|      0|      return CURLE_OK;
 1685|       |
 1686|  2.92k|    if(conn->bits.tunnel_proxy && conn->bits.httpproxy &&
 1687|  2.92k|       Curl_connect_ongoing(conn))
 1688|       |      /* when using an HTTP tunnel proxy, await complete tunnel establishment
 1689|       |         before proceeding further. Return CURLE_OK so we'll be called again */
 1690|      0|      return CURLE_OK;
 1691|  2.92k|#endif
 1692|  2.92k|    if(conn->handler->connect_it) {
 1693|       |      /* is there a protocol-specific connect() procedure? */
 1694|       |
 1695|       |      /* Call the protocol-specific connect function */
 1696|  2.87k|      result = conn->handler->connect_it(data, protocol_done);
 1697|  2.87k|    }
 1698|     45|    else
 1699|     45|      *protocol_done = TRUE;
 1700|       |
 1701|       |    /* it has started, possibly even completed but that knowledge isn't stored
 1702|       |       in this bit! */
 1703|  2.92k|    if(!result)
 1704|  2.51k|      conn->bits.protoconnstart = TRUE;
 1705|  2.92k|  }
 1706|       |
 1707|  2.92k|  return result; /* pass back status */
 1708|  2.92k|}
multi.c:protocol_connecting:
 1614|  1.55k|{
 1615|  1.55k|  CURLcode result = CURLE_OK;
 1616|  1.55k|  struct connectdata *conn = data->conn;
 1617|       |
 1618|  1.55k|  if(conn && conn->handler->connecting) {
 1619|  1.55k|    *done = FALSE;
 1620|  1.55k|    result = conn->handler->connecting(data, done);
 1621|  1.55k|  }
 1622|      0|  else
 1623|      0|    *done = TRUE;
 1624|       |
 1625|  1.55k|  return result;
 1626|  1.55k|}
multi.c:multi_do:
 1519|  2.45k|{
 1520|  2.45k|  CURLcode result = CURLE_OK;
 1521|  2.45k|  struct connectdata *conn = data->conn;
 1522|       |
 1523|  2.45k|  DEBUGASSERT(conn);
 1524|  2.45k|  DEBUGASSERT(conn->handler);
 1525|       |
 1526|  2.45k|  if(conn->handler->do_it)
 1527|       |    /* generic protocol-specific function pointer set in curl_connect() */
 1528|  2.45k|    result = conn->handler->do_it(data, done);
 1529|       |
 1530|  2.45k|  return result;
 1531|  2.45k|}
multi.c:protocol_doing:
 1634|  1.06k|{
 1635|  1.06k|  CURLcode result = CURLE_OK;
 1636|  1.06k|  struct connectdata *conn = data->conn;
 1637|       |
 1638|  1.06k|  if(conn && conn->handler->doing) {
 1639|  1.06k|    *done = FALSE;
 1640|  1.06k|    result = conn->handler->doing(data, done);
 1641|  1.06k|  }
 1642|      0|  else
 1643|      0|    *done = TRUE;
 1644|       |
 1645|  1.06k|  return result;
 1646|  1.06k|}
multi.c:multi_addmsg:
  349|  3.06k|{
  350|  3.06k|  Curl_llist_insert_next(&multi->msglist, multi->msglist.tail, msg,
  351|  3.06k|                         &msg->list);
  352|  3.06k|  return CURLM_OK;
  353|  3.06k|}
multi.c:singlesocket:
 2732|  3.09k|{
 2733|  3.09k|  curl_socket_t socks[MAX_SOCKSPEREASYHANDLE];
 2734|  3.09k|  int i;
 2735|  3.09k|  struct Curl_sh_entry *entry;
 2736|  3.09k|  curl_socket_t s;
 2737|  3.09k|  int num;
 2738|  3.09k|  unsigned int curraction;
 2739|  3.09k|  unsigned char actions[MAX_SOCKSPEREASYHANDLE];
 2740|       |
 2741|  18.5k|  for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++)
 2742|  15.4k|    socks[i] = CURL_SOCKET_BAD;
 2743|       |
 2744|       |  /* Fill in the 'current' struct with the state as it is now: what sockets to
 2745|       |     supervise and for what actions */
 2746|  3.09k|  curraction = multi_getsock(data, socks);
 2747|       |
 2748|       |  /* We have 0 .. N sockets already and we get to know about the 0 .. M
 2749|       |     sockets we should have from now on. Detect the differences, remove no
 2750|       |     longer supervised ones and add new ones */
 2751|       |
 2752|       |  /* walk over the sockets we got right now */
 2753|  3.09k|  for(i = 0; (i< MAX_SOCKSPEREASYHANDLE) &&
 2754|  3.09k|        (curraction & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i)));
 2755|  3.09k|      i++) {
 2756|      0|    unsigned char action = CURL_POLL_NONE;
 2757|      0|    unsigned char prevaction = 0;
 2758|      0|    int comboaction;
 2759|      0|    bool sincebefore = FALSE;
 2760|       |
 2761|      0|    s = socks[i];
 2762|       |
 2763|       |    /* get it from the hash */
 2764|      0|    entry = sh_getentry(&multi->sockhash, s);
 2765|       |
 2766|      0|    if(curraction & GETSOCK_READSOCK(i))
 2767|      0|      action |= CURL_POLL_IN;
 2768|      0|    if(curraction & GETSOCK_WRITESOCK(i))
 2769|      0|      action |= CURL_POLL_OUT;
 2770|       |
 2771|      0|    actions[i] = action;
 2772|      0|    if(entry) {
 2773|       |      /* check if new for this transfer */
 2774|      0|      int j;
 2775|      0|      for(j = 0; j< data->numsocks; j++) {
 2776|      0|        if(s == data->sockets[j]) {
 2777|      0|          prevaction = data->actions[j];
 2778|      0|          sincebefore = TRUE;
 2779|      0|          break;
 2780|      0|        }
 2781|      0|      }
 2782|      0|    }
 2783|      0|    else {
 2784|       |      /* this is a socket we didn't have before, add it to the hash! */
 2785|      0|      entry = sh_addentry(&multi->sockhash, s);
 2786|      0|      if(!entry)
 2787|       |        /* fatal */
 2788|      0|        return CURLM_OUT_OF_MEMORY;
 2789|      0|    }
 2790|      0|    if(sincebefore && (prevaction != action)) {
 2791|       |      /* Socket was used already, but different action now */
 2792|      0|      if(prevaction & CURL_POLL_IN)
 2793|      0|        entry->readers--;
 2794|      0|      if(prevaction & CURL_POLL_OUT)
 2795|      0|        entry->writers--;
 2796|      0|      if(action & CURL_POLL_IN)
 2797|      0|        entry->readers++;
 2798|      0|      if(action & CURL_POLL_OUT)
 2799|      0|        entry->writers++;
 2800|      0|    }
 2801|      0|    else if(!sincebefore) {
 2802|       |      /* a new user */
 2803|      0|      entry->users++;
 2804|      0|      if(action & CURL_POLL_IN)
 2805|      0|        entry->readers++;
 2806|      0|      if(action & CURL_POLL_OUT)
 2807|      0|        entry->writers++;
 2808|       |
 2809|       |      /* add 'data' to the transfer hash on this socket! */
 2810|      0|      if(!Curl_hash_add(&entry->transfers, (char *)&data, /* hash key */
 2811|      0|                        sizeof(struct Curl_easy *), data))
 2812|      0|        return CURLM_OUT_OF_MEMORY;
 2813|      0|    }
 2814|       |
 2815|      0|    comboaction = (entry->writers? CURL_POLL_OUT : 0) |
 2816|      0|                   (entry->readers ? CURL_POLL_IN : 0);
 2817|       |
 2818|       |    /* socket existed before and has the same action set as before */
 2819|      0|    if(sincebefore && ((int)entry->action == comboaction))
 2820|       |      /* same, continue */
 2821|      0|      continue;
 2822|       |
 2823|      0|    if(multi->socket_cb)
 2824|      0|      multi->socket_cb(data, s, comboaction, multi->socket_userp,
 2825|      0|                       entry->socketp);
 2826|       |
 2827|      0|    entry->action = comboaction; /* store the current action state */
 2828|      0|  }
 2829|       |
 2830|  3.09k|  num = i; /* number of sockets */
 2831|       |
 2832|       |  /* when we've walked over all the sockets we should have right now, we must
 2833|       |     make sure to detect sockets that are removed */
 2834|  3.09k|  for(i = 0; i< data->numsocks; i++) {
 2835|      0|    int j;
 2836|      0|    bool stillused = FALSE;
 2837|      0|    s = data->sockets[i];
 2838|      0|    for(j = 0; j < num; j++) {
 2839|      0|      if(s == socks[j]) {
 2840|       |        /* this is still supervised */
 2841|      0|        stillused = TRUE;
 2842|      0|        break;
 2843|      0|      }
 2844|      0|    }
 2845|      0|    if(stillused)
 2846|      0|      continue;
 2847|       |
 2848|      0|    entry = sh_getentry(&multi->sockhash, s);
 2849|       |    /* if this is NULL here, the socket has been closed and notified so
 2850|       |       already by Curl_multi_closed() */
 2851|      0|    if(entry) {
 2852|      0|      unsigned char oldactions = data->actions[i];
 2853|       |      /* this socket has been removed. Decrease user count */
 2854|      0|      entry->users--;
 2855|      0|      if(oldactions & CURL_POLL_OUT)
 2856|      0|        entry->writers--;
 2857|      0|      if(oldactions & CURL_POLL_IN)
 2858|      0|        entry->readers--;
 2859|      0|      if(!entry->users) {
 2860|      0|        if(multi->socket_cb)
 2861|      0|          multi->socket_cb(data, s, CURL_POLL_REMOVE,
 2862|      0|                           multi->socket_userp,
 2863|      0|                           entry->socketp);
 2864|      0|        sh_delentry(entry, &multi->sockhash, s);
 2865|      0|      }
 2866|      0|      else {
 2867|       |        /* still users, but remove this handle as a user of this socket */
 2868|      0|        if(Curl_hash_delete(&entry->transfers, (char *)&data,
 2869|      0|                            sizeof(struct Curl_easy *))) {
 2870|      0|          DEBUGASSERT(NULL);
 2871|      0|        }
 2872|      0|      }
 2873|      0|    }
 2874|      0|  } /* for loop over numsocks */
 2875|       |
 2876|  3.09k|  memcpy(data->sockets, socks, num*sizeof(curl_socket_t));
 2877|  3.09k|  memcpy(data->actions, actions, num*sizeof(char));
 2878|  3.09k|  data->numsocks = num;
 2879|  3.09k|  return CURLM_OK;
 2880|  3.09k|}
multi.c:sh_getentry:
  216|  2.40k|{
  217|  2.40k|  if(s != CURL_SOCKET_BAD) {
  218|       |    /* only look for proper sockets */
  219|  2.40k|    return Curl_hash_pick(sh, (char *)&s, sizeof(curl_socket_t));
  220|  2.40k|  }
  221|      0|  return NULL;
  222|  2.40k|}
multi.c:add_next_timeout:
 2936|  1.03k|{
 2937|  1.03k|  struct curltime *tv = &d->state.expiretime;
 2938|  1.03k|  struct Curl_llist *list = &d->state.timeoutlist;
 2939|  1.03k|  struct Curl_llist_element *e;
 2940|  1.03k|  struct time_node *node = NULL;
 2941|       |
 2942|       |  /* move over the timeout list for this specific handle and remove all
 2943|       |     timeouts that are now passed tense and store the next pending
 2944|       |     timeout in *tv */
 2945|  2.07k|  for(e = list->head; e;) {
 2946|  2.07k|    struct Curl_llist_element *n = e->next;
 2947|  2.07k|    timediff_t diff;
 2948|  2.07k|    node = (struct time_node *)e->ptr;
 2949|  2.07k|    diff = Curl_timediff(node->time, now);
 2950|  2.07k|    if(diff <= 0)
 2951|       |      /* remove outdated entry */
 2952|  1.03k|      Curl_llist_remove(list, e, NULL);
 2953|  1.03k|    else
 2954|       |      /* the list is sorted so get out on the first mismatch */
 2955|  1.03k|      break;
 2956|  1.03k|    e = n;
 2957|  1.03k|  }
 2958|  1.03k|  e = list->head;
 2959|  1.03k|  if(!e) {
 2960|       |    /* clear the expire times within the handles that we remove from the
 2961|       |       splay tree */
 2962|      0|    tv->tv_sec = 0;
 2963|      0|    tv->tv_usec = 0;
 2964|      0|  }
 2965|  1.03k|  else {
 2966|       |    /* copy the first entry to 'tv' */
 2967|  1.03k|    memcpy(tv, &node->time, sizeof(*tv));
 2968|       |
 2969|       |    /* Insert this node again into the splay.  Keep the timer in the list in
 2970|       |       case we need to recompute future timers. */
 2971|  1.03k|    multi->timetree = Curl_splayinsert(*tv, multi->timetree,
 2972|  1.03k|                                       &d->state.timenode);
 2973|  1.03k|  }
 2974|  1.03k|  return CURLM_OK;
 2975|  1.03k|}
multi.c:multi_deltimeout:
 3298|  9.10k|{
 3299|  9.10k|  struct Curl_llist_element *e;
 3300|  9.10k|  struct Curl_llist *timeoutlist = &data->state.timeoutlist;
 3301|       |  /* find and remove the specific node from the list */
 3302|  17.8k|  for(e = timeoutlist->head; e; e = e->next) {
 3303|  8.99k|    struct time_node *n = (struct time_node *)e->ptr;
 3304|  8.99k|    if(n->eid == eid) {
 3305|    228|      Curl_llist_remove(timeoutlist, e, NULL);
 3306|    228|      return;
 3307|    228|    }
 3308|  8.99k|  }
 3309|  9.10k|}
multi.c:multi_addtimeout:
 3322|  9.09k|{
 3323|  9.09k|  struct Curl_llist_element *e;
 3324|  9.09k|  struct time_node *node;
 3325|  9.09k|  struct Curl_llist_element *prev = NULL;
 3326|  9.09k|  size_t n;
 3327|  9.09k|  struct Curl_llist *timeoutlist = &data->state.timeoutlist;
 3328|       |
 3329|  9.09k|  node = &data->state.expires[eid];
 3330|       |
 3331|       |  /* copy the timestamp and id */
 3332|  9.09k|  memcpy(&node->time, stamp, sizeof(*stamp));
 3333|  9.09k|  node->eid = eid; /* also marks it as in use */
 3334|       |
 3335|  9.09k|  n = Curl_llist_count(timeoutlist);
 3336|  9.09k|  if(n) {
 3337|       |    /* find the correct spot in the list */
 3338|  14.9k|    for(e = timeoutlist->head; e; e = e->next) {
 3339|  8.95k|      struct time_node *check = (struct time_node *)e->ptr;
 3340|  8.95k|      timediff_t diff = Curl_timediff(check->time, node->time);
 3341|  8.95k|      if(diff > 0)
 3342|     11|        break;
 3343|  8.94k|      prev = e;
 3344|  8.94k|    }
 3345|       |
 3346|  5.99k|  }
 3347|       |  /* else
 3348|       |     this is the first timeout on the list */
 3349|       |
 3350|  9.09k|  Curl_llist_insert_next(timeoutlist, prev, node, &node->list);
 3351|  9.09k|  return CURLM_OK;
 3352|  9.09k|}
multi.c:process_pending_handles:
 3524|  7.99k|{
 3525|  7.99k|  struct Curl_llist_element *e = multi->pending.head;
 3526|  7.99k|  if(e) {
 3527|      0|    struct Curl_easy *data = e->ptr;
 3528|       |
 3529|      0|    DEBUGASSERT(data->mstate == MSTATE_PENDING);
 3530|       |
 3531|      0|    multistate(data, MSTATE_CONNECT);
 3532|       |
 3533|       |    /* Remove this node from the list */
 3534|      0|    Curl_llist_remove(&multi->pending, e, NULL);
 3535|       |
 3536|       |    /* Make sure that the handle will be processed soonish. */
 3537|      0|    Curl_expire(data, 0, EXPIRE_RUN_NOW);
 3538|       |
 3539|       |    /* mark this as having been in the pending queue */
 3540|      0|    data->state.previouslypending = TRUE;
 3541|      0|  }
 3542|  7.99k|}

curlx_nonblock:
   49|  9.10k|{
   50|  9.10k|#if defined(HAVE_FCNTL_O_NONBLOCK)
   51|       |  /* most recent unix versions */
   52|  9.10k|  int flags;
   53|  9.10k|  flags = sfcntl(sockfd, F_GETFL, 0);
   54|  9.10k|  if(nonblock)
   55|  9.10k|    return sfcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
   56|      0|  return sfcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));
   57|       |
   58|       |#elif defined(HAVE_IOCTL_FIONBIO)
   59|       |
   60|       |  /* older unix versions */
   61|       |  int flags = nonblock ? 1 : 0;
   62|       |  return ioctl(sockfd, FIONBIO, &flags);
   63|       |
   64|       |#elif defined(HAVE_IOCTLSOCKET_FIONBIO)
   65|       |
   66|       |  /* Windows */
   67|       |  unsigned long flags = nonblock ? 1UL : 0UL;
   68|       |  return ioctlsocket(sockfd, FIONBIO, &flags);
   69|       |
   70|       |#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)
   71|       |
   72|       |  /* Amiga */
   73|       |  long flags = nonblock ? 1L : 0L;
   74|       |  return IoctlSocket(sockfd, FIONBIO, (char *)&flags);
   75|       |
   76|       |#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)
   77|       |
   78|       |  /* BeOS */
   79|       |  long b = nonblock ? 1L : 0L;
   80|       |  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));
   81|       |
   82|       |#else
   83|       |#  error "no non-blocking method was found/used/set"
   84|       |#endif
   85|  9.10k|}

Curl_getdate_capped:
  560|  2.99k|{
  561|  2.99k|  time_t parsed = -1;
  562|  2.99k|  int rc = parsedate(p, &parsed);
  563|       |
  564|  2.99k|  switch(rc) {
  565|    914|  case PARSEDATE_OK:
  566|    914|    if(parsed == -1)
  567|       |      /* avoid returning -1 for a working scenario */
  568|      0|      parsed++;
  569|    914|    return parsed;
  570|      0|  case PARSEDATE_LATER:
  571|       |    /* this returns the maximum time value */
  572|      0|    return parsed;
  573|  2.08k|  default:
  574|  2.08k|    return -1; /* everything else is fail */
  575|  2.99k|  }
  576|       |  /* UNREACHABLE */
  577|  2.99k|}
Curl_gmtime:
  586|     40|{
  587|     40|  const struct tm *tm;
  588|     40|#ifdef HAVE_GMTIME_R
  589|       |  /* thread-safe version */
  590|     40|  tm = (struct tm *)gmtime_r(&intime, store);
  591|       |#else
  592|       |  /* !checksrc! disable BANNEDFUNC 1 */
  593|       |  tm = gmtime(&intime);
  594|       |  if(tm)
  595|       |    *store = *tm; /* copy the pointed struct to the local copy */
  596|       |#endif
  597|       |
  598|     40|  if(!tm)
  599|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
  600|     40|  return CURLE_OK;
  601|     40|}
parsedate.c:parsedate:
  307|  2.99k|{
  308|  2.99k|  time_t t = 0;
  309|  2.99k|  int wdaynum = -1;  /* day of the week number, 0-6 (mon-sun) */
  310|  2.99k|  int monnum = -1;   /* month of the year number, 0-11 */
  311|  2.99k|  int mdaynum = -1; /* day of month, 1 - 31 */
  312|  2.99k|  int hournum = -1;
  313|  2.99k|  int minnum = -1;
  314|  2.99k|  int secnum = -1;
  315|  2.99k|  int yearnum = -1;
  316|  2.99k|  int tzoff = -1;
  317|  2.99k|  enum assume dignext = DATE_MDAY;
  318|  2.99k|  const char *indate = date; /* save the original pointer */
  319|  2.99k|  int part = 0; /* max 6 parts */
  320|       |
  321|  15.8k|  while(*date && (part < 6)) {
  322|  14.5k|    bool found = FALSE;
  323|       |
  324|  14.5k|    skip(&date);
  325|       |
  326|  14.5k|    if(ISALPHA(*date)) {
  327|       |      /* a name coming up */
  328|  7.22k|      char buf[32]="";
  329|  7.22k|      size_t len;
  330|  7.22k|      if(sscanf(date, "%31[ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  331|  7.22k|                          "abcdefghijklmnopqrstuvwxyz]", buf))
  332|  7.22k|        len = strlen(buf);
  333|      0|      else
  334|      0|        len = 0;
  335|       |
  336|  7.22k|      if(wdaynum == -1) {
  337|  3.22k|        wdaynum = checkday(buf, len);
  338|  3.22k|        if(wdaynum != -1)
  339|  2.44k|          found = TRUE;
  340|  3.22k|      }
  341|  7.22k|      if(!found && (monnum == -1)) {
  342|  3.07k|        monnum = checkmonth(buf);
  343|  3.07k|        if(monnum != -1)
  344|  2.19k|          found = TRUE;
  345|  3.07k|      }
  346|       |
  347|  7.22k|      if(!found && (tzoff == -1)) {
  348|       |        /* this just must be a time zone string */
  349|  2.06k|        tzoff = checktz(buf);
  350|  2.06k|        if(tzoff != -1)
  351|  1.41k|          found = TRUE;
  352|  2.06k|      }
  353|       |
  354|  7.22k|      if(!found)
  355|  1.17k|        return PARSEDATE_FAIL; /* bad string */
  356|       |
  357|  6.05k|      date += len;
  358|  6.05k|    }
  359|  7.31k|    else if(ISDIGIT(*date)) {
  360|       |      /* a digit */
  361|  7.01k|      int val;
  362|  7.01k|      char *end;
  363|  7.01k|      int len = 0;
  364|  7.01k|      if((secnum == -1) &&
  365|  7.01k|         (3 == sscanf(date, "%02d:%02d:%02d%n",
  366|  6.89k|                      &hournum, &minnum, &secnum, &len))) {
  367|       |        /* time stamp! */
  368|  1.18k|        date += len;
  369|  1.18k|      }
  370|  5.83k|      else if((secnum == -1) &&
  371|  5.83k|              (2 == sscanf(date, "%02d:%02d%n", &hournum, &minnum, &len))) {
  372|       |        /* time stamp without seconds */
  373|    403|        date += len;
  374|    403|        secnum = 0;
  375|    403|      }
  376|  5.42k|      else {
  377|  5.42k|        long lval;
  378|  5.42k|        int error;
  379|  5.42k|        int old_errno;
  380|       |
  381|  5.42k|        old_errno = errno;
  382|  5.42k|        errno = 0;
  383|  5.42k|        lval = strtol(date, &end, 10);
  384|  5.42k|        error = errno;
  385|  5.42k|        if(errno != old_errno)
  386|  4.83k|          errno = old_errno;
  387|       |
  388|  5.42k|        if(error)
  389|     28|          return PARSEDATE_FAIL;
  390|       |
  391|  5.40k|#if LONG_MAX != INT_MAX
  392|  5.40k|        if((lval > (long)INT_MAX) || (lval < (long)INT_MIN))
  393|     18|          return PARSEDATE_FAIL;
  394|  5.38k|#endif
  395|       |
  396|  5.38k|        val = curlx_sltosi(lval);
  397|       |
  398|  5.38k|        if((tzoff == -1) &&
  399|  5.38k|           ((end - date) == 4) &&
  400|  5.38k|           (val <= 1400) &&
  401|  5.38k|           (indate< date) &&
  402|  5.38k|           ((date[-1] == '+' || date[-1] == '-'))) {
  403|       |          /* four digits and a value less than or equal to 1400 (to take into
  404|       |             account all sorts of funny time zone diffs) and it is preceded
  405|       |             with a plus or minus. This is a time zone indication.  1400 is
  406|       |             picked since +1300 is frequently used and +1400 is mentioned as
  407|       |             an edge number in the document "ISO C 200X Proposal: Timezone
  408|       |             Functions" at http://david.tribble.com/text/c0xtimezone.html If
  409|       |             anyone has a more authoritative source for the exact maximum time
  410|       |             zone offsets, please speak up! */
  411|    333|          found = TRUE;
  412|    333|          tzoff = (val/100 * 60 + val%100)*60;
  413|       |
  414|       |          /* the + and - prefix indicates the local time compared to GMT,
  415|       |             this we need their reversed math to get what we want */
  416|    333|          tzoff = date[-1]=='+'?-tzoff:tzoff;
  417|    333|        }
  418|       |
  419|  5.38k|        if(((end - date) == 8) &&
  420|  5.38k|           (yearnum == -1) &&
  421|  5.38k|           (monnum == -1) &&
  422|  5.38k|           (mdaynum == -1)) {
  423|       |          /* 8 digits, no year, month or day yet. This is YYYYMMDD */
  424|    167|          found = TRUE;
  425|    167|          yearnum = val/10000;
  426|    167|          monnum = (val%10000)/100-1; /* month is 0 - 11 */
  427|    167|          mdaynum = val%100;
  428|    167|        }
  429|       |
  430|  5.38k|        if(!found && (dignext == DATE_MDAY) && (mdaynum == -1)) {
  431|  2.64k|          if((val > 0) && (val<32)) {
  432|  2.39k|            mdaynum = val;
  433|  2.39k|            found = TRUE;
  434|  2.39k|          }
  435|  2.64k|          dignext = DATE_YEAR;
  436|  2.64k|        }
  437|       |
  438|  5.38k|        if(!found && (dignext == DATE_YEAR) && (yearnum == -1)) {
  439|  2.06k|          yearnum = val;
  440|  2.06k|          found = TRUE;
  441|  2.06k|          if(yearnum < 100) {
  442|    447|            if(yearnum > 70)
  443|     14|              yearnum += 1900;
  444|    433|            else
  445|    433|              yearnum += 2000;
  446|    447|          }
  447|  2.06k|          if(mdaynum == -1)
  448|    186|            dignext = DATE_MDAY;
  449|  2.06k|        }
  450|       |
  451|  5.38k|        if(!found)
  452|    421|          return PARSEDATE_FAIL;
  453|       |
  454|  4.96k|        date = end;
  455|  4.96k|      }
  456|  7.01k|    }
  457|       |
  458|  12.9k|    part++;
  459|  12.9k|  }
  460|       |
  461|  1.36k|  if(-1 == secnum)
  462|    342|    secnum = minnum = hournum = 0; /* no time, make it zero */
  463|       |
  464|  1.36k|  if((-1 == mdaynum) ||
  465|  1.36k|     (-1 == monnum) ||
  466|  1.36k|     (-1 == yearnum))
  467|       |    /* lacks vital info, fail */
  468|    185|    return PARSEDATE_FAIL;
  469|       |
  470|       |#ifdef HAVE_TIME_T_UNSIGNED
  471|       |  if(yearnum < 1970) {
  472|       |    /* only positive numbers cannot return earlier */
  473|       |    *output = TIME_T_MIN;
  474|       |    return PARSEDATE_SOONER;
  475|       |  }
  476|       |#endif
  477|       |
  478|       |#if (SIZEOF_TIME_T < 5)
  479|       |
  480|       |#ifdef HAVE_TIME_T_UNSIGNED
  481|       |  /* an unsigned 32 bit time_t can only hold dates to 2106 */
  482|       |  if(yearnum > 2105) {
  483|       |    *output = TIME_T_MAX;
  484|       |    return PARSEDATE_LATER;
  485|       |  }
  486|       |#else
  487|       |  /* a signed 32 bit time_t can only hold dates to the beginning of 2038 */
  488|       |  if(yearnum > 2037) {
  489|       |    *output = TIME_T_MAX;
  490|       |    return PARSEDATE_LATER;
  491|       |  }
  492|       |  if(yearnum < 1903) {
  493|       |    *output = TIME_T_MIN;
  494|       |    return PARSEDATE_SOONER;
  495|       |  }
  496|       |#endif
  497|       |
  498|       |#else
  499|       |  /* The Gregorian calendar was introduced 1582 */
  500|  1.17k|  if(yearnum < 1583)
  501|     72|    return PARSEDATE_FAIL;
  502|  1.10k|#endif
  503|       |
  504|  1.10k|  if((mdaynum > 31) || (monnum > 11) ||
  505|  1.10k|     (hournum > 23) || (minnum > 59) || (secnum > 60))
  506|    189|    return PARSEDATE_FAIL; /* clearly an illegal date */
  507|       |
  508|       |  /* time2epoch() returns a time_t. time_t is often 32 bits, sometimes even on
  509|       |     architectures that feature 64 bit 'long' but ultimately time_t is the
  510|       |     correct data type to use.
  511|       |  */
  512|    914|  t = time2epoch(secnum, minnum, hournum, mdaynum, monnum, yearnum);
  513|       |
  514|       |  /* Add the time zone diff between local time zone and GMT. */
  515|    914|  if(tzoff == -1)
  516|    197|    tzoff = 0;
  517|       |
  518|    914|  if((tzoff > 0) && (t > TIME_T_MAX - tzoff)) {
  519|      0|    *output = TIME_T_MAX;
  520|      0|    return PARSEDATE_LATER; /* time_t overflow */
  521|      0|  }
  522|       |
  523|    914|  t += tzoff;
  524|       |
  525|    914|  *output = t;
  526|       |
  527|    914|  return PARSEDATE_OK;
  528|    914|}
parsedate.c:skip:
  266|  14.5k|{
  267|       |  /* skip everything that aren't letters or digits */
  268|  29.5k|  while(**date && !ISALNUM(**date))
  269|  15.0k|    (*date)++;
  270|  14.5k|}
parsedate.c:checkday:
  210|  3.22k|{
  211|  3.22k|  int i;
  212|  3.22k|  const char * const *what;
  213|  3.22k|  bool found = FALSE;
  214|  3.22k|  if(len > 3)
  215|    127|    what = &weekday[0];
  216|  3.09k|  else
  217|  3.09k|    what = &Curl_wkday[0];
  218|  18.4k|  for(i = 0; i<7; i++) {
  219|  17.6k|    if(strcasecompare(check, what[0])) {
  220|  2.44k|      found = TRUE;
  221|  2.44k|      break;
  222|  2.44k|    }
  223|  15.1k|    what++;
  224|  15.1k|  }
  225|  3.22k|  return found?i:-1;
  226|  3.22k|}
parsedate.c:checkmonth:
  229|  3.07k|{
  230|  3.07k|  int i;
  231|  3.07k|  const char * const *what;
  232|  3.07k|  bool found = FALSE;
  233|       |
  234|  3.07k|  what = &Curl_month[0];
  235|  16.0k|  for(i = 0; i<12; i++) {
  236|  15.1k|    if(strcasecompare(check, what[0])) {
  237|  2.19k|      found = TRUE;
  238|  2.19k|      break;
  239|  2.19k|    }
  240|  12.9k|    what++;
  241|  12.9k|  }
  242|  3.07k|  return found?i:-1; /* return the offset or -1, no real offset is -1 */
  243|  3.07k|}
parsedate.c:checktz:
  249|  2.06k|{
  250|  2.06k|  unsigned int i;
  251|  2.06k|  const struct tzinfo *what;
  252|  2.06k|  bool found = FALSE;
  253|       |
  254|  2.06k|  what = tz;
  255|  82.0k|  for(i = 0; i< sizeof(tz)/sizeof(tz[0]); i++) {
  256|  81.3k|    if(strcasecompare(check, what->name)) {
  257|  1.41k|      found = TRUE;
  258|  1.41k|      break;
  259|  1.41k|    }
  260|  79.9k|    what++;
  261|  79.9k|  }
  262|  2.06k|  return found?what->offset*60:-1;
  263|  2.06k|}
parsedate.c:time2epoch:
  284|    914|{
  285|    914|  static const int month_days_cumulative [12] =
  286|    914|    { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
  287|    914|  int leap_days = year - (mon <= 1);
  288|    914|  leap_days = ((leap_days / 4) - (leap_days / 100) + (leap_days / 400)
  289|    914|               - (1969 / 4) + (1969 / 100) - (1969 / 400));
  290|    914|  return ((((time_t) (year - 1970) * 365
  291|    914|            + leap_days + month_days_cumulative[mon] + mday - 1) * 24
  292|    914|           + hour) * 60 + min) * 60 + sec;
  293|    914|}

Curl_pp_state_timeout:
   49|  6.71k|{
   50|  6.71k|  struct connectdata *conn = data->conn;
   51|  6.71k|  timediff_t timeout_ms; /* in milliseconds */
   52|  6.71k|  timediff_t response_time = (data->set.server_response_timeout)?
   53|  6.71k|    data->set.server_response_timeout: pp->response_time;
   54|       |
   55|       |  /* if CURLOPT_SERVER_RESPONSE_TIMEOUT is set, use that to determine
   56|       |     remaining time, or use pp->response because SERVER_RESPONSE_TIMEOUT is
   57|       |     supposed to govern the response for any given server response, not for
   58|       |     the time from connect to the given server response. */
   59|       |
   60|       |  /* Without a requested timeout, we only wait 'response_time' seconds for the
   61|       |     full response to arrive before we bail out */
   62|  6.71k|  timeout_ms = response_time -
   63|  6.71k|    Curl_timediff(Curl_now(), pp->response); /* spent time */
   64|       |
   65|  6.71k|  if(data->set.timeout && !disconnecting) {
   66|       |    /* if timeout is requested, find out how much remaining time we have */
   67|  5.03k|    timediff_t timeout2_ms = data->set.timeout - /* timeout time */
   68|  5.03k|      Curl_timediff(Curl_now(), conn->now); /* spent time */
   69|       |
   70|       |    /* pick the lowest number */
   71|  5.03k|    timeout_ms = CURLMIN(timeout_ms, timeout2_ms);
   72|  5.03k|  }
   73|       |
   74|  6.71k|  return timeout_ms;
   75|  6.71k|}
Curl_pp_statemach:
   83|  6.71k|{
   84|  6.71k|  struct connectdata *conn = data->conn;
   85|  6.71k|  curl_socket_t sock = conn->sock[FIRSTSOCKET];
   86|  6.71k|  int rc;
   87|  6.71k|  timediff_t interval_ms;
   88|  6.71k|  timediff_t timeout_ms = Curl_pp_state_timeout(data, pp, disconnecting);
   89|  6.71k|  CURLcode result = CURLE_OK;
   90|       |
   91|  6.71k|  if(timeout_ms <= 0) {
   92|     78|    failf(data, "server response timeout");
   93|     78|    return CURLE_OPERATION_TIMEDOUT; /* already too little time */
   94|     78|  }
   95|       |
   96|  6.63k|  if(block) {
   97|  1.74k|    interval_ms = 1000;  /* use 1 second timeout intervals */
   98|  1.74k|    if(timeout_ms < interval_ms)
   99|     99|      interval_ms = timeout_ms;
  100|  1.74k|  }
  101|  4.89k|  else
  102|  4.89k|    interval_ms = 0; /* immediate */
  103|       |
  104|  6.63k|  if(Curl_ssl_data_pending(conn, FIRSTSOCKET))
  105|      0|    rc = 1;
  106|  6.63k|  else if(Curl_pp_moredata(pp))
  107|       |    /* We are receiving and there is data in the cache so just read it */
  108|  4.02k|    rc = 1;
  109|  2.61k|  else if(!pp->sendleft && Curl_ssl_data_pending(conn, FIRSTSOCKET))
  110|       |    /* We are receiving and there is data ready in the SSL library */
  111|      0|    rc = 1;
  112|  2.61k|  else
  113|  2.61k|    rc = Curl_socket_check(pp->sendleft?CURL_SOCKET_BAD:sock, /* reading */
  114|  2.61k|                           CURL_SOCKET_BAD,
  115|  2.61k|                           pp->sendleft?sock:CURL_SOCKET_BAD, /* writing */
  116|  2.61k|                           interval_ms);
  117|       |
  118|  6.63k|  if(block) {
  119|       |    /* if we didn't wait, we don't have to spend time on this now */
  120|  1.74k|    if(Curl_pgrsUpdate(data))
  121|      0|      result = CURLE_ABORTED_BY_CALLBACK;
  122|  1.74k|    else
  123|  1.74k|      result = Curl_speedcheck(data, Curl_now());
  124|       |
  125|  1.74k|    if(result)
  126|      0|      return result;
  127|  1.74k|  }
  128|       |
  129|  6.63k|  if(rc == -1) {
  130|      1|    failf(data, "select/poll error");
  131|      1|    result = CURLE_OUT_OF_MEMORY;
  132|      1|  }
  133|  6.63k|  else if(rc)
  134|  6.42k|    result = pp->statemachine(data, data->conn);
  135|       |
  136|  6.63k|  return result;
  137|  6.63k|}
Curl_pp_init:
  141|  5.46k|{
  142|  5.46k|  DEBUGASSERT(data);
  143|  5.46k|  pp->nread_resp = 0;
  144|  5.46k|  pp->linestart_resp = data->state.buffer;
  145|  5.46k|  pp->pending_resp = TRUE;
  146|  5.46k|  pp->response = Curl_now(); /* start response time-out now! */
  147|  5.46k|}
Curl_pp_setup:
  151|  1.48k|{
  152|  1.48k|  Curl_dyn_init(&pp->sendbuf, DYN_PINGPPONG_CMD);
  153|  1.48k|}
Curl_pp_vsendf:
  169|  3.97k|{
  170|  3.97k|  ssize_t bytes_written = 0;
  171|  3.97k|  size_t write_len;
  172|  3.97k|  char *s;
  173|  3.97k|  CURLcode result;
  174|  3.97k|  struct connectdata *conn = data->conn;
  175|       |
  176|       |#ifdef HAVE_GSSAPI
  177|       |  enum protection_level data_sec;
  178|       |#endif
  179|       |
  180|  3.97k|  DEBUGASSERT(pp->sendleft == 0);
  181|  3.97k|  DEBUGASSERT(pp->sendsize == 0);
  182|  3.97k|  DEBUGASSERT(pp->sendthis == NULL);
  183|       |
  184|  3.97k|  if(!conn)
  185|       |    /* can't send without a connection! */
  186|      0|    return CURLE_SEND_ERROR;
  187|       |
  188|  3.97k|  Curl_dyn_reset(&pp->sendbuf);
  189|  3.97k|  result = Curl_dyn_vaddf(&pp->sendbuf, fmt, args);
  190|  3.97k|  if(result)
  191|      0|    return result;
  192|       |
  193|       |  /* append CRLF */
  194|  3.97k|  result = Curl_dyn_addn(&pp->sendbuf, "\r\n", 2);
  195|  3.97k|  if(result)
  196|      0|    return result;
  197|       |
  198|  3.97k|  write_len = Curl_dyn_len(&pp->sendbuf);
  199|  3.97k|  s = Curl_dyn_ptr(&pp->sendbuf);
  200|  3.97k|  Curl_pp_init(data, pp);
  201|       |
  202|  3.97k|  result = Curl_convert_to_network(data, s, write_len);
  203|       |  /* Curl_convert_to_network calls failf if unsuccessful */
  204|  3.97k|  if(result)
  205|      0|    return result;
  206|       |
  207|       |#ifdef HAVE_GSSAPI
  208|       |  conn->data_prot = PROT_CMD;
  209|       |#endif
  210|  3.97k|  result = Curl_write(data, conn->sock[FIRSTSOCKET], s, write_len,
  211|  3.97k|                      &bytes_written);
  212|  3.97k|  if(result)
  213|      0|    return result;
  214|       |#ifdef HAVE_GSSAPI
  215|       |  data_sec = conn->data_prot;
  216|       |  DEBUGASSERT(data_sec > PROT_NONE && data_sec < PROT_LAST);
  217|       |  conn->data_prot = data_sec;
  218|       |#endif
  219|       |
  220|  3.97k|  Curl_debug(data, CURLINFO_HEADER_OUT, s, (size_t)bytes_written);
  221|       |
  222|  3.97k|  if(bytes_written != (ssize_t)write_len) {
  223|       |    /* the whole chunk was not sent, keep it around and adjust sizes */
  224|      0|    pp->sendthis = s;
  225|      0|    pp->sendsize = write_len;
  226|      0|    pp->sendleft = write_len - bytes_written;
  227|      0|  }
  228|  3.97k|  else {
  229|  3.97k|    pp->sendthis = NULL;
  230|  3.97k|    pp->sendleft = pp->sendsize = 0;
  231|  3.97k|    pp->response = Curl_now();
  232|  3.97k|  }
  233|       |
  234|  3.97k|  return CURLE_OK;
  235|  3.97k|}
Curl_pp_sendf:
  250|  2.12k|{
  251|  2.12k|  CURLcode result;
  252|  2.12k|  va_list ap;
  253|  2.12k|  va_start(ap, fmt);
  254|       |
  255|  2.12k|  result = Curl_pp_vsendf(data, pp, fmt, ap);
  256|       |
  257|  2.12k|  va_end(ap);
  258|       |
  259|  2.12k|  return result;
  260|  2.12k|}
Curl_pp_readresp:
  272|  16.4k|{
  273|  16.4k|  ssize_t perline; /* count bytes per line */
  274|  16.4k|  bool keepon = TRUE;
  275|  16.4k|  ssize_t gotbytes;
  276|  16.4k|  char *ptr;
  277|  16.4k|  struct connectdata *conn = data->conn;
  278|  16.4k|  char * const buf = data->state.buffer;
  279|  16.4k|  CURLcode result = CURLE_OK;
  280|       |
  281|  16.4k|  *code = 0; /* 0 for errors or not done */
  282|  16.4k|  *size = 0;
  283|       |
  284|  16.4k|  ptr = buf + pp->nread_resp;
  285|       |
  286|       |  /* number of bytes in the current line, so far */
  287|  16.4k|  perline = (ssize_t)(ptr-pp->linestart_resp);
  288|       |
  289|  33.7k|  while((pp->nread_resp < (size_t)data->set.buffer_size) &&
  290|  33.7k|        (keepon && !result)) {
  291|       |
  292|  17.3k|    if(pp->cache) {
  293|       |      /* we had data in the "cache", copy that instead of doing an actual
  294|       |       * read
  295|       |       *
  296|       |       * pp->cache_size is cast to ssize_t here.  This should be safe, because
  297|       |       * it would have been populated with something of size int to begin
  298|       |       * with, even though its datatype may be larger than an int.
  299|       |       */
  300|  14.0k|      if((ptr + pp->cache_size) > (buf + data->set.buffer_size + 1)) {
  301|      2|        failf(data, "cached response data too big to handle");
  302|      2|        return CURLE_RECV_ERROR;
  303|      2|      }
  304|  14.0k|      memcpy(ptr, pp->cache, pp->cache_size);
  305|  14.0k|      gotbytes = (ssize_t)pp->cache_size;
  306|  14.0k|      free(pp->cache);    /* free the cache */
  307|  14.0k|      pp->cache = NULL;   /* clear the pointer */
  308|  14.0k|      pp->cache_size = 0; /* zero the size just in case */
  309|  14.0k|    }
  310|  3.34k|    else {
  311|       |#ifdef HAVE_GSSAPI
  312|       |      enum protection_level prot = conn->data_prot;
  313|       |      conn->data_prot = PROT_CLEAR;
  314|       |#endif
  315|  3.34k|      DEBUGASSERT((ptr + data->set.buffer_size - pp->nread_resp) <=
  316|  3.34k|                  (buf + data->set.buffer_size + 1));
  317|  3.34k|      result = Curl_read(data, sockfd, ptr,
  318|  3.34k|                         data->set.buffer_size - pp->nread_resp,
  319|  3.34k|                         &gotbytes);
  320|       |#ifdef HAVE_GSSAPI
  321|       |      DEBUGASSERT(prot  > PROT_NONE && prot < PROT_LAST);
  322|       |      conn->data_prot = prot;
  323|       |#endif
  324|  3.34k|      if(result == CURLE_AGAIN)
  325|     57|        return CURLE_OK; /* return */
  326|       |
  327|  3.28k|      if(!result && (gotbytes > 0))
  328|       |        /* convert from the network encoding */
  329|  1.82k|        result = Curl_convert_from_network(data, ptr, gotbytes);
  330|       |      /* Curl_convert_from_network calls failf if unsuccessful */
  331|       |
  332|  3.28k|      if(result)
  333|       |        /* Set outer result variable to this error. */
  334|      0|        keepon = FALSE;
  335|  3.28k|    }
  336|       |
  337|  17.3k|    if(!keepon)
  338|      0|      ;
  339|  17.3k|    else if(gotbytes <= 0) {
  340|  1.46k|      keepon = FALSE;
  341|  1.46k|      result = CURLE_RECV_ERROR;
  342|  1.46k|      failf(data, "response reading failed");
  343|  1.46k|    }
  344|  15.8k|    else {
  345|       |      /* we got a whole chunk of data, which can be anything from one
  346|       |       * byte to a set of lines and possible just a piece of the last
  347|       |       * line */
  348|  15.8k|      ssize_t i;
  349|  15.8k|      ssize_t clipamount = 0;
  350|  15.8k|      bool restart = FALSE;
  351|       |
  352|  15.8k|      data->req.headerbytecount += (long)gotbytes;
  353|       |
  354|  15.8k|      pp->nread_resp += gotbytes;
  355|   818k|      for(i = 0; i < gotbytes; ptr++, i++) {
  356|   817k|        perline++;
  357|   817k|        if(*ptr == '\n') {
  358|       |          /* a newline is CRLF in pp-talk, so the CR is ignored as
  359|       |             the line isn't really terminated until the LF comes */
  360|       |
  361|       |          /* output debug output if that is requested */
  362|       |#ifdef HAVE_GSSAPI
  363|       |          if(!conn->sec_complete)
  364|       |#endif
  365|  48.4k|            Curl_debug(data, CURLINFO_HEADER_IN,
  366|  48.4k|                       pp->linestart_resp, (size_t)perline);
  367|       |
  368|       |          /*
  369|       |           * We pass all response-lines to the callback function registered
  370|       |           * for "headers". The response lines can be seen as a kind of
  371|       |           * headers.
  372|       |           */
  373|  48.4k|          result = Curl_client_write(data, CLIENTWRITE_HEADER,
  374|  48.4k|                                     pp->linestart_resp, perline);
  375|  48.4k|          if(result)
  376|      0|            return result;
  377|       |
  378|  48.4k|          if(pp->endofresp(data, conn, pp->linestart_resp, perline, code)) {
  379|       |            /* This is the end of the last line, copy the last line to the
  380|       |               start of the buffer and null-terminate, for old times sake */
  381|  14.9k|            size_t n = ptr - pp->linestart_resp;
  382|  14.9k|            memmove(buf, pp->linestart_resp, n);
  383|  14.9k|            buf[n] = 0; /* null-terminate */
  384|  14.9k|            keepon = FALSE;
  385|  14.9k|            pp->linestart_resp = ptr + 1; /* advance pointer */
  386|  14.9k|            i++; /* skip this before getting out */
  387|       |
  388|  14.9k|            *size = pp->nread_resp; /* size of the response */
  389|  14.9k|            pp->nread_resp = 0; /* restart */
  390|  14.9k|            break;
  391|  14.9k|          }
  392|  33.5k|          perline = 0; /* line starts over here */
  393|  33.5k|          pp->linestart_resp = ptr + 1;
  394|  33.5k|        }
  395|   817k|      }
  396|       |
  397|  15.8k|      if(!keepon && (i != gotbytes)) {
  398|       |        /* We found the end of the response lines, but we didn't parse the
  399|       |           full chunk of data we have read from the server. We therefore need
  400|       |           to store the rest of the data to be checked on the next invoke as
  401|       |           it may actually contain another end of response already! */
  402|  14.3k|        clipamount = gotbytes - i;
  403|  14.3k|        restart = TRUE;
  404|  14.3k|        DEBUGF(infof(data, "Curl_pp_readresp_ %d bytes of trailing "
  405|  14.3k|                     "server response left",
  406|  14.3k|                     (int)clipamount));
  407|  14.3k|      }
  408|  1.53k|      else if(keepon) {
  409|       |
  410|    949|        if((perline == gotbytes) && (gotbytes > data->set.buffer_size/2)) {
  411|       |          /* We got an excessive line without newlines and we need to deal
  412|       |             with it. We keep the first bytes of the line then we throw
  413|       |             away the rest. */
  414|      0|          infof(data, "Excessive server response line length received, "
  415|      0|                "%zd bytes. Stripping", gotbytes);
  416|      0|          restart = TRUE;
  417|       |
  418|       |          /* we keep 40 bytes since all our pingpong protocols are only
  419|       |             interested in the first piece */
  420|      0|          clipamount = 40;
  421|      0|        }
  422|    949|        else if(pp->nread_resp > (size_t)data->set.buffer_size/2) {
  423|       |          /* We got a large chunk of data and there's potentially still
  424|       |             trailing data to take care of, so we put any such part in the
  425|       |             "cache", clear the buffer to make space and restart. */
  426|      3|          clipamount = perline;
  427|      3|          restart = TRUE;
  428|      3|        }
  429|    949|      }
  430|    587|      else if(i == gotbytes)
  431|    587|        restart = TRUE;
  432|       |
  433|  15.8k|      if(clipamount) {
  434|  14.3k|        pp->cache_size = clipamount;
  435|  14.3k|        pp->cache = malloc(pp->cache_size);
  436|  14.3k|        if(pp->cache)
  437|  14.3k|          memcpy(pp->cache, pp->linestart_resp, pp->cache_size);
  438|      0|        else
  439|      0|          return CURLE_OUT_OF_MEMORY;
  440|  14.3k|      }
  441|  15.8k|      if(restart) {
  442|       |        /* now reset a few variables to start over nicely from the start of
  443|       |           the big buffer */
  444|  14.9k|        pp->nread_resp = 0; /* start over from scratch in the buffer */
  445|  14.9k|        ptr = pp->linestart_resp = buf;
  446|  14.9k|        perline = 0;
  447|  14.9k|      }
  448|       |
  449|  15.8k|    } /* there was data */
  450|       |
  451|  17.3k|  } /* while there's buffer left and loop is requested */
  452|       |
  453|  16.3k|  pp->pending_resp = FALSE;
  454|       |
  455|  16.3k|  return result;
  456|  16.4k|}
Curl_pp_getsock:
  460|  2.64k|{
  461|  2.64k|  struct connectdata *conn = data->conn;
  462|  2.64k|  socks[0] = conn->sock[FIRSTSOCKET];
  463|       |
  464|  2.64k|  if(pp->sendleft) {
  465|       |    /* write mode */
  466|      0|    return GETSOCK_WRITESOCK(0);
  467|      0|  }
  468|       |
  469|       |  /* read mode */
  470|  2.64k|  return GETSOCK_READSOCK(0);
  471|  2.64k|}
Curl_pp_disconnect:
  498|  1.48k|{
  499|  1.48k|  Curl_dyn_free(&pp->sendbuf);
  500|  1.48k|  Curl_safefree(pp->cache);
  501|  1.48k|  return CURLE_OK;
  502|  1.48k|}
Curl_pp_moredata:
  505|  16.8k|{
  506|  16.8k|  return (!pp->sendleft && pp->cache && pp->nread_resp < pp->cache_size) ?
  507|  16.8k|    TRUE : FALSE;
  508|  16.8k|}

Curl_pop3_write:
 1456|     60|{
 1457|       |  /* This code could be made into a special function in the handler struct */
 1458|     60|  CURLcode result = CURLE_OK;
 1459|     60|  struct SingleRequest *k = &data->req;
 1460|     60|  struct connectdata *conn = data->conn;
 1461|     60|  struct pop3_conn *pop3c = &conn->proto.pop3c;
 1462|     60|  bool strip_dot = FALSE;
 1463|     60|  size_t last = 0;
 1464|     60|  size_t i;
 1465|       |
 1466|       |  /* Search through the buffer looking for the end-of-body marker which is
 1467|       |     5 bytes (0d 0a 2e 0d 0a). Note that a line starting with a dot matches
 1468|       |     the eob so the server will have prefixed it with an extra dot which we
 1469|       |     need to strip out. Additionally the marker could of course be spread out
 1470|       |     over 5 different data chunks. */
 1471|  39.2k|  for(i = 0; i < nread; i++) {
 1472|  39.1k|    size_t prev = pop3c->eob;
 1473|       |
 1474|  39.1k|    switch(str[i]) {
 1475|  3.38k|    case 0x0d:
 1476|  3.38k|      if(pop3c->eob == 0) {
 1477|  2.17k|        pop3c->eob++;
 1478|       |
 1479|  2.17k|        if(i) {
 1480|       |          /* Write out the body part that didn't match */
 1481|  2.17k|          result = Curl_client_write(data, CLIENTWRITE_BODY, &str[last],
 1482|  2.17k|                                     i - last);
 1483|       |
 1484|  2.17k|          if(result)
 1485|      0|            return result;
 1486|       |
 1487|  2.17k|          last = i;
 1488|  2.17k|        }
 1489|  2.17k|      }
 1490|  1.20k|      else if(pop3c->eob == 3)
 1491|    408|        pop3c->eob++;
 1492|    799|      else
 1493|       |        /* If the character match wasn't at position 0 or 3 then restart the
 1494|       |           pattern matching */
 1495|    799|        pop3c->eob = 1;
 1496|  3.38k|      break;
 1497|       |
 1498|  3.38k|    case 0x0a:
 1499|  3.24k|      if(pop3c->eob == 1 || pop3c->eob == 4)
 1500|  2.08k|        pop3c->eob++;
 1501|  1.16k|      else
 1502|       |        /* If the character match wasn't at position 1 or 4 then start the
 1503|       |           search again */
 1504|  1.16k|        pop3c->eob = 0;
 1505|  3.24k|      break;
 1506|       |
 1507|  2.08k|    case 0x2e:
 1508|  2.08k|      if(pop3c->eob == 2)
 1509|    713|        pop3c->eob++;
 1510|  1.37k|      else if(pop3c->eob == 3) {
 1511|       |        /* We have an extra dot after the CRLF which we need to strip off */
 1512|     43|        strip_dot = TRUE;
 1513|     43|        pop3c->eob = 0;
 1514|     43|      }
 1515|  1.32k|      else
 1516|       |        /* If the character match wasn't at position 2 then start the search
 1517|       |           again */
 1518|  1.32k|        pop3c->eob = 0;
 1519|  2.08k|      break;
 1520|       |
 1521|  30.4k|    default:
 1522|  30.4k|      pop3c->eob = 0;
 1523|  30.4k|      break;
 1524|  39.1k|    }
 1525|       |
 1526|       |    /* Did we have a partial match which has subsequently failed? */
 1527|  39.1k|    if(prev && prev >= pop3c->eob) {
 1528|       |      /* Strip can only be non-zero for the very first mismatch after CRLF
 1529|       |         and then both prev and strip are equal and nothing will be output
 1530|       |         below */
 1531|  3.13k|      while(prev && pop3c->strip) {
 1532|    112|        prev--;
 1533|    112|        pop3c->strip--;
 1534|    112|      }
 1535|       |
 1536|  3.02k|      if(prev) {
 1537|       |        /* If the partial match was the CRLF and dot then only write the CRLF
 1538|       |           as the server would have inserted the dot */
 1539|  2.97k|        if(strip_dot && prev - 1 > 0) {
 1540|     41|          result = Curl_client_write(data, CLIENTWRITE_BODY, (char *)POP3_EOB,
 1541|     41|                                     prev - 1);
 1542|     41|        }
 1543|  2.93k|        else if(!strip_dot) {
 1544|  2.93k|          result = Curl_client_write(data, CLIENTWRITE_BODY, (char *)POP3_EOB,
 1545|  2.93k|                                     prev);
 1546|  2.93k|        }
 1547|      2|        else {
 1548|      2|          result = CURLE_OK;
 1549|      2|        }
 1550|       |
 1551|  2.97k|        if(result)
 1552|      0|          return result;
 1553|       |
 1554|  2.97k|        last = i;
 1555|  2.97k|        strip_dot = FALSE;
 1556|  2.97k|      }
 1557|  3.02k|    }
 1558|  39.1k|  }
 1559|       |
 1560|     60|  if(pop3c->eob == POP3_EOB_LEN) {
 1561|       |    /* We have a full match so the transfer is done, however we must transfer
 1562|       |    the CRLF at the start of the EOB as this is considered to be part of the
 1563|       |    message as per RFC-1939, sect. 3 */
 1564|      1|    result = Curl_client_write(data, CLIENTWRITE_BODY, (char *)POP3_EOB, 2);
 1565|       |
 1566|      1|    k->keepon &= ~KEEP_RECV;
 1567|      1|    pop3c->eob = 0;
 1568|       |
 1569|      1|    return result;
 1570|      1|  }
 1571|       |
 1572|     59|  if(pop3c->eob)
 1573|       |    /* While EOB is matching nothing should be output */
 1574|      9|    return CURLE_OK;
 1575|       |
 1576|     50|  if(nread - last) {
 1577|     50|    result = Curl_client_write(data, CLIENTWRITE_BODY, &str[last],
 1578|     50|                               nread - last);
 1579|     50|  }
 1580|       |
 1581|     50|  return result;
 1582|     59|}
pop3.c:pop3_multi_statemach:
 1049|    367|{
 1050|    367|  CURLcode result = CURLE_OK;
 1051|    367|  struct connectdata *conn = data->conn;
 1052|    367|  struct pop3_conn *pop3c = &conn->proto.pop3c;
 1053|       |
 1054|    367|  if((conn->handler->flags & PROTOPT_SSL) && !pop3c->ssldone) {
 1055|      0|    result = Curl_ssl_connect_nonblocking(data, conn, FALSE,
 1056|      0|                                          FIRSTSOCKET, &pop3c->ssldone);
 1057|      0|    if(result || !pop3c->ssldone)
 1058|      0|      return result;
 1059|      0|  }
 1060|       |
 1061|    367|  result = Curl_pp_statemach(data, &pop3c->pp, FALSE, FALSE);
 1062|    367|  *done = (pop3c->state == POP3_STOP) ? TRUE : FALSE;
 1063|       |
 1064|    367|  return result;
 1065|    367|}
pop3.c:pop3_getsock:
 1097|     21|{
 1098|     21|  return Curl_pp_getsock(data, &conn->proto.pop3c.pp, socks);
 1099|     21|}
pop3.c:pop3_connect:
 1112|    280|{
 1113|    280|  CURLcode result = CURLE_OK;
 1114|    280|  struct connectdata *conn = data->conn;
 1115|    280|  struct pop3_conn *pop3c = &conn->proto.pop3c;
 1116|    280|  struct pingpong *pp = &pop3c->pp;
 1117|       |
 1118|    280|  *done = FALSE; /* default to not done yet */
 1119|       |
 1120|       |  /* We always support persistent connections in POP3 */
 1121|    280|  connkeep(conn, "POP3 default");
 1122|       |
 1123|    280|  PINGPONG_SETUP(pp, pop3_statemachine, pop3_endofresp);
 1124|       |
 1125|       |  /* Set the default preferred authentication type and mechanism */
 1126|    280|  pop3c->preftype = POP3_TYPE_ANY;
 1127|    280|  Curl_sasl_init(&pop3c->sasl, data, &saslpop3);
 1128|       |
 1129|       |  /* Initialise the pingpong layer */
 1130|    280|  Curl_pp_setup(pp);
 1131|    280|  Curl_pp_init(data, pp);
 1132|       |
 1133|       |  /* Parse the URL options */
 1134|    280|  result = pop3_parse_url_options(conn);
 1135|    280|  if(result)
 1136|     14|    return result;
 1137|       |
 1138|       |  /* Start off waiting for the server greeting response */
 1139|    266|  state(data, POP3_SERVERGREET);
 1140|       |
 1141|    266|  result = pop3_multi_statemach(data, done);
 1142|       |
 1143|    266|  return result;
 1144|    280|}
pop3.c:pop3_statemachine:
  971|    445|{
  972|    445|  CURLcode result = CURLE_OK;
  973|    445|  curl_socket_t sock = conn->sock[FIRSTSOCKET];
  974|    445|  int pop3code;
  975|    445|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  976|    445|  struct pingpong *pp = &pop3c->pp;
  977|    445|  size_t nread = 0;
  978|    445|  (void)data;
  979|       |
  980|       |  /* Busy upgrading the connection; right now all I/O is SSL/TLS, not POP3 */
  981|    445|  if(pop3c->state == POP3_UPGRADETLS)
  982|      0|    return pop3_perform_upgrade_tls(data, conn);
  983|       |
  984|       |  /* Flush any data that needs to be sent */
  985|    445|  if(pp->sendleft)
  986|      0|    return Curl_pp_flushsend(data, pp);
  987|       |
  988|  5.33k| do {
  989|       |    /* Read the response from the server */
  990|  5.33k|   result = Curl_pp_readresp(data, sock, pp, &pop3code, &nread);
  991|  5.33k|   if(result)
  992|    242|     return result;
  993|       |
  994|  5.09k|    if(!pop3code)
  995|      8|      break;
  996|       |
  997|       |    /* We have now received a full POP3 server response */
  998|  5.08k|    switch(pop3c->state) {
  999|    255|    case POP3_SERVERGREET:
 1000|    255|      result = pop3_state_servergreet_resp(data, pop3code, pop3c->state);
 1001|    255|      break;
 1002|       |
 1003|  4.60k|    case POP3_CAPA:
 1004|  4.60k|      result = pop3_state_capa_resp(data, pop3code, pop3c->state);
 1005|  4.60k|      break;
 1006|       |
 1007|      0|    case POP3_STARTTLS:
 1008|      0|      result = pop3_state_starttls_resp(data, conn, pop3code, pop3c->state);
 1009|      0|      break;
 1010|       |
 1011|    137|    case POP3_AUTH:
 1012|    137|      result = pop3_state_auth_resp(data, pop3code, pop3c->state);
 1013|    137|      break;
 1014|       |
 1015|      0|#ifndef CURL_DISABLE_CRYPTO_AUTH
 1016|      1|    case POP3_APOP:
 1017|      1|      result = pop3_state_apop_resp(data, pop3code, pop3c->state);
 1018|      1|      break;
 1019|      0|#endif
 1020|       |
 1021|     10|    case POP3_USER:
 1022|     10|      result = pop3_state_user_resp(data, pop3code, pop3c->state);
 1023|     10|      break;
 1024|       |
 1025|      4|    case POP3_PASS:
 1026|      4|      result = pop3_state_pass_resp(data, pop3code, pop3c->state);
 1027|      4|      break;
 1028|       |
 1029|     69|    case POP3_COMMAND:
 1030|     69|      result = pop3_state_command_resp(data, pop3code, pop3c->state);
 1031|     69|      break;
 1032|       |
 1033|      5|    case POP3_QUIT:
 1034|      5|      state(data, POP3_STOP);
 1035|      5|      break;
 1036|       |
 1037|      0|    default:
 1038|       |      /* internal error */
 1039|      0|      state(data, POP3_STOP);
 1040|      0|      break;
 1041|  5.08k|    }
 1042|  5.08k|  } while(!result && pop3c->state != POP3_STOP && Curl_pp_moredata(pp));
 1043|       |
 1044|    203|  return result;
 1045|    445|}
pop3.c:pop3_perform_capa:
  328|    251|{
  329|    251|  CURLcode result = CURLE_OK;
  330|    251|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  331|       |
  332|    251|  pop3c->sasl.authmechs = SASL_AUTH_NONE; /* No known auth. mechanisms yet */
  333|    251|  pop3c->sasl.authused = SASL_AUTH_NONE;  /* Clear the auth. mechanism used */
  334|    251|  pop3c->tls_supported = FALSE;           /* Clear the TLS capability */
  335|       |
  336|       |  /* Send the CAPA command */
  337|    251|  result = Curl_pp_sendf(data, &pop3c->pp, "%s", "CAPA");
  338|       |
  339|    251|  if(!result)
  340|    251|    state(data, POP3_CAPA);
  341|       |
  342|    251|  return result;
  343|    251|}
pop3.c:pop3_state_servergreet_resp:
  644|    255|{
  645|    255|  CURLcode result = CURLE_OK;
  646|    255|  struct connectdata *conn = data->conn;
  647|    255|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  648|    255|  const char *line = data->state.buffer;
  649|    255|  size_t len = strlen(line);
  650|       |
  651|    255|  (void)instate; /* no use for this yet */
  652|       |
  653|    255|  if(pop3code != '+') {
  654|      4|    failf(data, "Got unexpected pop3-server response");
  655|      4|    result = CURLE_WEIRD_SERVER_REPLY;
  656|      4|  }
  657|    251|  else {
  658|       |    /* Does the server support APOP authentication? */
  659|    251|    if(len >= 4 && line[len - 2] == '>') {
  660|       |      /* Look for the APOP timestamp */
  661|     15|      size_t i;
  662|    364|      for(i = 3; i < len - 2; ++i) {
  663|    355|        if(line[i] == '<') {
  664|       |          /* Calculate the length of the timestamp */
  665|      6|          size_t timestamplen = len - 1 - i;
  666|      6|          char *at;
  667|      6|          if(!timestamplen)
  668|      0|            break;
  669|       |
  670|       |          /* Allocate some memory for the timestamp */
  671|      6|          pop3c->apoptimestamp = (char *)calloc(1, timestamplen + 1);
  672|       |
  673|      6|          if(!pop3c->apoptimestamp)
  674|      0|            break;
  675|       |
  676|       |          /* Copy the timestamp */
  677|      6|          memcpy(pop3c->apoptimestamp, line + i, timestamplen);
  678|      6|          pop3c->apoptimestamp[timestamplen] = '\0';
  679|       |
  680|       |          /* If the timestamp does not contain '@' it is not (as required by
  681|       |             RFC-1939) conformant to the RFC-822 message id syntax, and we
  682|       |             therefore do not use APOP authentication. */
  683|      6|          at = strchr(pop3c->apoptimestamp, '@');
  684|      6|          if(!at)
  685|      1|            Curl_safefree(pop3c->apoptimestamp);
  686|      5|          else
  687|       |            /* Store the APOP capability */
  688|      5|            pop3c->authtypes |= POP3_TYPE_APOP;
  689|      6|          break;
  690|      6|        }
  691|    355|      }
  692|     15|    }
  693|       |
  694|    251|    result = pop3_perform_capa(data, conn);
  695|    251|  }
  696|       |
  697|    255|  return result;
  698|    255|}
pop3.c:pop3_state_capa_resp:
  703|  4.60k|{
  704|  4.60k|  CURLcode result = CURLE_OK;
  705|  4.60k|  struct connectdata *conn = data->conn;
  706|  4.60k|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  707|  4.60k|  const char *line = data->state.buffer;
  708|  4.60k|  size_t len = strlen(line);
  709|       |
  710|  4.60k|  (void)instate; /* no use for this yet */
  711|       |
  712|       |  /* Do we have a untagged continuation response? */
  713|  4.60k|  if(pop3code == '*') {
  714|       |    /* Does the server support the STLS capability? */
  715|  4.43k|    if(len >= 4 && !memcmp(line, "STLS", 4))
  716|     70|      pop3c->tls_supported = TRUE;
  717|       |
  718|       |    /* Does the server support clear text authentication? */
  719|  4.36k|    else if(len >= 4 && !memcmp(line, "USER", 4))
  720|     42|      pop3c->authtypes |= POP3_TYPE_CLEARTEXT;
  721|       |
  722|       |    /* Does the server support SASL based authentication? */
  723|  4.32k|    else if(len >= 5 && !memcmp(line, "SASL ", 5)) {
  724|  1.09k|      pop3c->authtypes |= POP3_TYPE_SASL;
  725|       |
  726|       |      /* Advance past the SASL keyword */
  727|  1.09k|      line += 5;
  728|  1.09k|      len -= 5;
  729|       |
  730|       |      /* Loop through the data line */
  731|  3.40k|      for(;;) {
  732|  3.40k|        size_t llen;
  733|  3.40k|        size_t wordlen;
  734|  3.40k|        unsigned short mechbit;
  735|       |
  736|  7.03k|        while(len &&
  737|  7.03k|              (*line == ' ' || *line == '\t' ||
  738|  5.94k|               *line == '\r' || *line == '\n')) {
  739|       |
  740|  3.63k|          line++;
  741|  3.63k|          len--;
  742|  3.63k|        }
  743|       |
  744|  3.40k|        if(!len)
  745|  1.09k|          break;
  746|       |
  747|       |        /* Extract the word */
  748|  16.4k|        for(wordlen = 0; wordlen < len && line[wordlen] != ' ' &&
  749|  16.4k|              line[wordlen] != '\t' && line[wordlen] != '\r' &&
  750|  16.4k|              line[wordlen] != '\n';)
  751|  14.1k|          wordlen++;
  752|       |
  753|       |        /* Test the word for a matching authentication mechanism */
  754|  2.31k|        mechbit = Curl_sasl_decode_mech(line, wordlen, &llen);
  755|  2.31k|        if(mechbit && llen == wordlen)
  756|    314|          pop3c->sasl.authmechs |= mechbit;
  757|       |
  758|  2.31k|        line += wordlen;
  759|  2.31k|        len -= wordlen;
  760|  2.31k|      }
  761|  1.09k|    }
  762|  4.43k|  }
  763|    170|  else {
  764|       |    /* Clear text is supported when CAPA isn't recognised */
  765|    170|    if(pop3code != '+')
  766|    105|      pop3c->authtypes |= POP3_TYPE_CLEARTEXT;
  767|       |
  768|    170|    if(!data->set.use_ssl || conn->ssl[FIRSTSOCKET].use)
  769|    170|      result = pop3_perform_authentication(data, conn);
  770|      0|    else if(pop3code == '+' && pop3c->tls_supported)
  771|       |      /* Switch to TLS connection now */
  772|      0|      result = pop3_perform_starttls(data, conn);
  773|      0|    else if(data->set.use_ssl <= CURLUSESSL_TRY)
  774|       |      /* Fallback and carry on with authentication */
  775|      0|      result = pop3_perform_authentication(data, conn);
  776|      0|    else {
  777|      0|      failf(data, "STLS not supported.");
  778|      0|      result = CURLE_USE_SSL_FAILED;
  779|      0|    }
  780|    170|  }
  781|       |
  782|  4.60k|  return result;
  783|  4.60k|}
pop3.c:pop3_perform_authentication:
  541|    170|{
  542|    170|  CURLcode result = CURLE_OK;
  543|    170|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  544|    170|  saslprogress progress = SASL_IDLE;
  545|       |
  546|       |  /* Check we have enough data to authenticate with and end the
  547|       |     connect phase if we don't */
  548|    170|  if(!Curl_sasl_can_authenticate(&pop3c->sasl, conn)) {
  549|     79|    state(data, POP3_STOP);
  550|     79|    return result;
  551|     79|  }
  552|       |
  553|     91|  if(pop3c->authtypes & pop3c->preftype & POP3_TYPE_SASL) {
  554|       |    /* Calculate the SASL login details */
  555|     80|    result = Curl_sasl_start(&pop3c->sasl, data, FALSE, &progress);
  556|       |
  557|     80|    if(!result)
  558|     80|      if(progress == SASL_INPROGRESS)
  559|     77|        state(data, POP3_AUTH);
  560|     80|  }
  561|       |
  562|     91|  if(!result && progress == SASL_IDLE) {
  563|     14|#ifndef CURL_DISABLE_CRYPTO_AUTH
  564|     14|    if(pop3c->authtypes & pop3c->preftype & POP3_TYPE_APOP)
  565|       |      /* Perform APOP authentication */
  566|      4|      result = pop3_perform_apop(data, conn);
  567|     10|    else
  568|     10|#endif
  569|     10|    if(pop3c->authtypes & pop3c->preftype & POP3_TYPE_CLEARTEXT)
  570|       |      /* Perform clear text authentication */
  571|      9|      result = pop3_perform_user(data, conn);
  572|      1|    else {
  573|       |      /* Other mechanisms not supported */
  574|      1|      infof(data, "No known authentication mechanisms supported!");
  575|      1|      result = CURLE_LOGIN_DENIED;
  576|      1|    }
  577|     14|  }
  578|       |
  579|     91|  return result;
  580|    170|}
pop3.c:pop3_perform_apop:
  428|      5|{
  429|      5|  CURLcode result = CURLE_OK;
  430|      5|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  431|      5|  size_t i;
  432|      5|  struct MD5_context *ctxt;
  433|      5|  unsigned char digest[MD5_DIGEST_LEN];
  434|      5|  char secret[2 * MD5_DIGEST_LEN + 1];
  435|       |
  436|       |  /* Check we have a username and password to authenticate with and end the
  437|       |     connect phase if we don't */
  438|      5|  if(!conn->bits.user_passwd) {
  439|      0|    state(data, POP3_STOP);
  440|       |
  441|      0|    return result;
  442|      0|  }
  443|       |
  444|       |  /* Create the digest */
  445|      5|  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  446|      5|  if(!ctxt)
  447|      0|    return CURLE_OUT_OF_MEMORY;
  448|       |
  449|      5|  Curl_MD5_update(ctxt, (const unsigned char *) pop3c->apoptimestamp,
  450|      5|                  curlx_uztoui(strlen(pop3c->apoptimestamp)));
  451|       |
  452|      5|  Curl_MD5_update(ctxt, (const unsigned char *) conn->passwd,
  453|      5|                  curlx_uztoui(strlen(conn->passwd)));
  454|       |
  455|       |  /* Finalise the digest */
  456|      5|  Curl_MD5_final(ctxt, digest);
  457|       |
  458|       |  /* Convert the calculated 16 octet digest into a 32 byte hex string */
  459|     85|  for(i = 0; i < MD5_DIGEST_LEN; i++)
  460|     80|    msnprintf(&secret[2 * i], 3, "%02x", digest[i]);
  461|       |
  462|      5|  result = Curl_pp_sendf(data, &pop3c->pp, "APOP %s %s", conn->user, secret);
  463|       |
  464|      5|  if(!result)
  465|      5|    state(data, POP3_APOP);
  466|       |
  467|      5|  return result;
  468|      5|}
pop3.c:pop3_perform_user:
  399|     23|{
  400|     23|  CURLcode result = CURLE_OK;
  401|       |
  402|       |  /* Check we have a username and password to authenticate with and end the
  403|       |     connect phase if we don't */
  404|     23|  if(!conn->bits.user_passwd) {
  405|      0|    state(data, POP3_STOP);
  406|       |
  407|      0|    return result;
  408|      0|  }
  409|       |
  410|       |  /* Send the USER command */
  411|     23|  result = Curl_pp_sendf(data, &conn->proto.pop3c.pp, "USER %s",
  412|     23|                         conn->user ? conn->user : "");
  413|     23|  if(!result)
  414|     23|    state(data, POP3_USER);
  415|       |
  416|     23|  return result;
  417|     23|}
pop3.c:pop3_state_auth_resp:
  816|    137|{
  817|    137|  CURLcode result = CURLE_OK;
  818|    137|  struct connectdata *conn = data->conn;
  819|    137|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  820|    137|  saslprogress progress;
  821|       |
  822|    137|  (void)instate; /* no use for this yet */
  823|       |
  824|    137|  result = Curl_sasl_continue(&pop3c->sasl, data, pop3code, &progress);
  825|    137|  if(!result)
  826|    123|    switch(progress) {
  827|      1|    case SASL_DONE:
  828|      1|      state(data, POP3_STOP);  /* Authenticated */
  829|      1|      break;
  830|     16|    case SASL_IDLE:            /* No mechanism left after cancellation */
  831|     16|#ifndef CURL_DISABLE_CRYPTO_AUTH
  832|     16|      if(pop3c->authtypes & pop3c->preftype & POP3_TYPE_APOP)
  833|       |        /* Perform APOP authentication */
  834|      1|        result = pop3_perform_apop(data, conn);
  835|     15|      else
  836|     15|#endif
  837|     15|      if(pop3c->authtypes & pop3c->preftype & POP3_TYPE_CLEARTEXT)
  838|       |        /* Perform clear text authentication */
  839|     14|        result = pop3_perform_user(data, conn);
  840|      1|      else {
  841|      1|        failf(data, "Authentication cancelled");
  842|      1|        result = CURLE_LOGIN_DENIED;
  843|      1|      }
  844|     16|      break;
  845|    106|    default:
  846|    106|      break;
  847|    123|    }
  848|       |
  849|    137|  return result;
  850|    137|}
pop3.c:pop3_state_apop_resp:
  856|      1|{
  857|      1|  CURLcode result = CURLE_OK;
  858|      1|  (void)instate; /* no use for this yet */
  859|       |
  860|      1|  if(pop3code != '+') {
  861|      1|    failf(data, "Authentication failed: %d", pop3code);
  862|      1|    result = CURLE_LOGIN_DENIED;
  863|      1|  }
  864|      0|  else
  865|       |    /* End of connect phase */
  866|      0|    state(data, POP3_STOP);
  867|       |
  868|      1|  return result;
  869|      1|}
pop3.c:pop3_state_user_resp:
  875|     10|{
  876|     10|  CURLcode result = CURLE_OK;
  877|     10|  struct connectdata *conn = data->conn;
  878|     10|  (void)instate; /* no use for this yet */
  879|       |
  880|     10|  if(pop3code != '+') {
  881|      4|    failf(data, "Access denied. %c", pop3code);
  882|      4|    result = CURLE_LOGIN_DENIED;
  883|      4|  }
  884|      6|  else
  885|       |    /* Send the PASS command */
  886|      6|    result = Curl_pp_sendf(data, &conn->proto.pop3c.pp, "PASS %s",
  887|      6|                           conn->passwd ? conn->passwd : "");
  888|     10|  if(!result)
  889|      6|    state(data, POP3_PASS);
  890|       |
  891|     10|  return result;
  892|     10|}
pop3.c:pop3_state_pass_resp:
  897|      4|{
  898|      4|  CURLcode result = CURLE_OK;
  899|      4|  (void)instate; /* no use for this yet */
  900|       |
  901|      4|  if(pop3code != '+') {
  902|      1|    failf(data, "Access denied. %c", pop3code);
  903|      1|    result = CURLE_LOGIN_DENIED;
  904|      1|  }
  905|      3|  else
  906|       |    /* End of connect phase */
  907|      3|    state(data, POP3_STOP);
  908|       |
  909|      4|  return result;
  910|      4|}
pop3.c:pop3_state_command_resp:
  916|     69|{
  917|     69|  CURLcode result = CURLE_OK;
  918|     69|  struct connectdata *conn = data->conn;
  919|     69|  struct POP3 *pop3 = data->req.p.pop3;
  920|     69|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  921|     69|  struct pingpong *pp = &pop3c->pp;
  922|       |
  923|     69|  (void)instate; /* no use for this yet */
  924|       |
  925|     69|  if(pop3code != '+') {
  926|      9|    state(data, POP3_STOP);
  927|      9|    return CURLE_RECV_ERROR;
  928|      9|  }
  929|       |
  930|       |  /* This 'OK' line ends with a CR LF pair which is the two first bytes of the
  931|       |     EOB string so count this is two matching bytes. This is necessary to make
  932|       |     the code detect the EOB if the only data than comes now is %2e CR LF like
  933|       |     when there is no body to return. */
  934|     60|  pop3c->eob = 2;
  935|       |
  936|       |  /* But since this initial CR LF pair is not part of the actual body, we set
  937|       |     the strip counter here so that these bytes won't be delivered. */
  938|     60|  pop3c->strip = 2;
  939|       |
  940|     60|  if(pop3->transfer == PPTRANSFER_BODY) {
  941|       |    /* POP3 download */
  942|     59|    Curl_setup_transfer(data, FIRSTSOCKET, -1, FALSE, -1);
  943|       |
  944|     59|    if(pp->cache) {
  945|       |      /* The header "cache" contains a bunch of data that is actually body
  946|       |         content so send it as such. Note that there may even be additional
  947|       |         "headers" after the body */
  948|       |
  949|     57|      if(!data->set.opt_no_body) {
  950|     57|        result = Curl_pop3_write(data, pp->cache, pp->cache_size);
  951|     57|        if(result)
  952|      0|          return result;
  953|     57|      }
  954|       |
  955|       |      /* Free the cache */
  956|     57|      Curl_safefree(pp->cache);
  957|       |
  958|       |      /* Reset the cache size */
  959|     57|      pp->cache_size = 0;
  960|     57|    }
  961|     59|  }
  962|       |
  963|       |  /* End of DO phase */
  964|     60|  state(data, POP3_STOP);
  965|       |
  966|     60|  return result;
  967|     60|}
pop3.c:pop3_endofresp:
  210|  6.05k|{
  211|  6.05k|  struct pop3_conn *pop3c = &conn->proto.pop3c;
  212|  6.05k|  (void)data;
  213|       |
  214|       |  /* Do we have an error response? */
  215|  6.05k|  if(len >= 4 && !memcmp("-ERR", line, 4)) {
  216|    128|    *resp = '-';
  217|       |
  218|    128|    return TRUE;
  219|    128|  }
  220|       |
  221|       |  /* Are we processing CAPA command responses? */
  222|  5.92k|  if(pop3c->state == POP3_CAPA) {
  223|       |    /* Do we have the terminating line? */
  224|  4.49k|    if(len >= 1 && line[0] == '.')
  225|       |      /* Treat the response as a success */
  226|     65|      *resp = '+';
  227|  4.43k|    else
  228|       |      /* Treat the response as an untagged continuation */
  229|  4.43k|      *resp = '*';
  230|       |
  231|  4.49k|    return TRUE;
  232|  4.49k|  }
  233|       |
  234|       |  /* Do we have a success response? */
  235|  1.43k|  if(len >= 3 && !memcmp("+OK", line, 3)) {
  236|    322|    *resp = '+';
  237|       |
  238|    322|    return TRUE;
  239|    322|  }
  240|       |
  241|       |  /* Do we have a continuation response? */
  242|  1.10k|  if(len >= 1 && line[0] == '+') {
  243|    136|    *resp = '*';
  244|       |
  245|    136|    return TRUE;
  246|    136|  }
  247|       |
  248|    973|  return FALSE; /* Nothing for us */
  249|  1.10k|}
pop3.c:pop3_perform_auth:
  481|     88|{
  482|     88|  CURLcode result = CURLE_OK;
  483|     88|  struct pop3_conn *pop3c = &data->conn->proto.pop3c;
  484|     88|  const char *ir = (const char *) Curl_bufref_ptr(initresp);
  485|       |
  486|     88|  if(ir) {                                  /* AUTH <mech> ...<crlf> */
  487|       |    /* Send the AUTH command with the initial response */
  488|      0|    result = Curl_pp_sendf(data, &pop3c->pp, "AUTH %s %s", mech, ir);
  489|      0|  }
  490|     88|  else {
  491|       |    /* Send the AUTH command */
  492|     88|    result = Curl_pp_sendf(data, &pop3c->pp, "AUTH %s", mech);
  493|     88|  }
  494|       |
  495|     88|  return result;
  496|     88|}
pop3.c:pop3_continue_auth:
  507|     46|{
  508|     46|  struct pop3_conn *pop3c = &data->conn->proto.pop3c;
  509|       |
  510|     46|  (void)mech;
  511|       |
  512|     46|  return Curl_pp_sendf(data, &pop3c->pp,
  513|     46|                       "%s", (const char *) Curl_bufref_ptr(resp));
  514|     46|}
pop3.c:pop3_cancel_auth:
  523|     49|{
  524|     49|  struct pop3_conn *pop3c = &data->conn->proto.pop3c;
  525|       |
  526|     49|  (void)mech;
  527|       |
  528|     49|  return Curl_pp_sendf(data, &pop3c->pp, "*");
  529|     49|}
pop3.c:pop3_get_message:
  258|     78|{
  259|     78|  char *message = data->state.buffer;
  260|     78|  size_t len = strlen(message);
  261|       |
  262|     78|  if(len > 2) {
  263|       |    /* Find the start of the message */
  264|     69|    len -= 2;
  265|    552|    for(message += 2; *message == ' ' || *message == '\t'; message++, len--)
  266|    483|      ;
  267|       |
  268|       |    /* Find the end of the message */
  269|    507|    while(len--)
  270|    501|      if(message[len] != '\r' && message[len] != '\n' && message[len] != ' ' &&
  271|    501|         message[len] != '\t')
  272|     63|        break;
  273|       |
  274|       |    /* Terminate the message */
  275|     69|    message[++len] = '\0';
  276|     69|    Curl_bufref_set(out, message, len, NULL);
  277|     69|  }
  278|      9|  else
  279|       |    /* junk input => zero length output */
  280|      9|    Curl_bufref_set(out, "", 0, NULL);
  281|       |
  282|     78|  return CURLE_OK;
  283|     78|}
pop3.c:pop3_parse_url_options:
 1363|    280|{
 1364|    280|  CURLcode result = CURLE_OK;
 1365|    280|  struct pop3_conn *pop3c = &conn->proto.pop3c;
 1366|    280|  const char *ptr = conn->options;
 1367|       |
 1368|    302|  while(!result && ptr && *ptr) {
 1369|     22|    const char *key = ptr;
 1370|     22|    const char *value;
 1371|       |
 1372|    165|    while(*ptr && *ptr != '=')
 1373|    143|        ptr++;
 1374|       |
 1375|     22|    value = ptr + 1;
 1376|       |
 1377|    132|    while(*ptr && *ptr != ';')
 1378|    110|      ptr++;
 1379|       |
 1380|     22|    if(strncasecompare(key, "AUTH=", 5)) {
 1381|     10|      result = Curl_sasl_parse_url_auth_option(&pop3c->sasl,
 1382|     10|                                               value, ptr - value);
 1383|       |
 1384|     10|      if(result && strncasecompare(value, "+APOP", ptr - value)) {
 1385|      4|        pop3c->preftype = POP3_TYPE_APOP;
 1386|      4|        pop3c->sasl.prefmech = SASL_AUTH_NONE;
 1387|      4|        result = CURLE_OK;
 1388|      4|      }
 1389|     10|    }
 1390|     12|    else
 1391|     12|      result = CURLE_URL_MALFORMAT;
 1392|       |
 1393|     22|    if(*ptr == ';')
 1394|      7|      ptr++;
 1395|     22|  }
 1396|       |
 1397|    280|  if(pop3c->preftype != POP3_TYPE_APOP)
 1398|    277|    switch(pop3c->sasl.prefmech) {
 1399|      2|    case SASL_AUTH_NONE:
 1400|      2|      pop3c->preftype = POP3_TYPE_NONE;
 1401|      2|      break;
 1402|    274|    case SASL_AUTH_DEFAULT:
 1403|    274|      pop3c->preftype = POP3_TYPE_ANY;
 1404|    274|      break;
 1405|      1|    default:
 1406|      1|      pop3c->preftype = POP3_TYPE_SASL;
 1407|      1|      break;
 1408|    277|    }
 1409|       |
 1410|    280|  return result;
 1411|    280|}
pop3.c:state:
  292|    948|{
  293|    948|  struct pop3_conn *pop3c = &data->conn->proto.pop3c;
  294|    948|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
  295|       |  /* for debug purposes */
  296|    948|  static const char * const names[] = {
  297|    948|    "STOP",
  298|    948|    "SERVERGREET",
  299|    948|    "CAPA",
  300|    948|    "STARTTLS",
  301|    948|    "UPGRADETLS",
  302|    948|    "AUTH",
  303|    948|    "APOP",
  304|    948|    "USER",
  305|    948|    "PASS",
  306|    948|    "COMMAND",
  307|    948|    "QUIT",
  308|       |    /* LAST */
  309|    948|  };
  310|       |
  311|    948|  if(pop3c->state != newstate)
  312|    948|    infof(data, "POP3 %p state change from %s to %s",
  313|    948|          (void *)pop3c, names[pop3c->state], names[newstate]);
  314|    948|#endif
  315|       |
  316|    948|  pop3c->state = newstate;
  317|    948|}
pop3.c:pop3_done:
 1157|    280|{
 1158|    280|  CURLcode result = CURLE_OK;
 1159|    280|  struct POP3 *pop3 = data->req.p.pop3;
 1160|       |
 1161|    280|  (void)premature;
 1162|       |
 1163|    280|  if(!pop3)
 1164|      0|    return CURLE_OK;
 1165|       |
 1166|    280|  if(status) {
 1167|    218|    connclose(data->conn, "POP3 done with bad status");
 1168|    218|    result = status;         /* use the already set error code */
 1169|    218|  }
 1170|       |
 1171|       |  /* Cleanup our per-request based variables */
 1172|    280|  Curl_safefree(pop3->id);
 1173|    280|  Curl_safefree(pop3->custom);
 1174|       |
 1175|       |  /* Clear the transfer mode for the next request */
 1176|    280|  pop3->transfer = PPTRANSFER_BODY;
 1177|       |
 1178|    280|  return result;
 1179|    280|}
pop3.c:pop3_do:
 1230|     83|{
 1231|     83|  CURLcode result = CURLE_OK;
 1232|     83|  *done = FALSE; /* default to false */
 1233|       |
 1234|       |  /* Parse the URL path */
 1235|     83|  result = pop3_parse_url_path(data);
 1236|     83|  if(result)
 1237|      0|    return result;
 1238|       |
 1239|       |  /* Parse the custom request */
 1240|     83|  result = pop3_parse_custom_request(data);
 1241|     83|  if(result)
 1242|      1|    return result;
 1243|       |
 1244|     82|  result = pop3_regular_transfer(data, done);
 1245|       |
 1246|     82|  return result;
 1247|     83|}
pop3.c:pop3_parse_url_path:
 1420|     83|{
 1421|       |  /* The POP3 struct is already initialised in pop3_connect() */
 1422|     83|  struct POP3 *pop3 = data->req.p.pop3;
 1423|     83|  const char *path = &data->state.up.path[1]; /* skip leading path */
 1424|       |
 1425|       |  /* URL decode the path for the message ID */
 1426|     83|  return Curl_urldecode(data, path, 0, &pop3->id, NULL, REJECT_CTRL);
 1427|     83|}
pop3.c:pop3_parse_custom_request:
 1436|     83|{
 1437|     83|  CURLcode result = CURLE_OK;
 1438|     83|  struct POP3 *pop3 = data->req.p.pop3;
 1439|     83|  const char *custom = data->set.str[STRING_CUSTOMREQUEST];
 1440|       |
 1441|       |  /* URL decode the custom request */
 1442|     83|  if(custom)
 1443|      5|    result = Curl_urldecode(data, custom, 0, &pop3->custom, NULL, REJECT_CTRL);
 1444|       |
 1445|     83|  return result;
 1446|     83|}
pop3.c:pop3_regular_transfer:
 1319|     82|{
 1320|     82|  CURLcode result = CURLE_OK;
 1321|     82|  bool connected = FALSE;
 1322|       |
 1323|       |  /* Make sure size is unknown at this point */
 1324|     82|  data->req.size = -1;
 1325|       |
 1326|       |  /* Set the progress data */
 1327|     82|  Curl_pgrsSetUploadCounter(data, 0);
 1328|     82|  Curl_pgrsSetDownloadCounter(data, 0);
 1329|     82|  Curl_pgrsSetUploadSize(data, -1);
 1330|     82|  Curl_pgrsSetDownloadSize(data, -1);
 1331|       |
 1332|       |  /* Carry out the perform */
 1333|     82|  result = pop3_perform(data, &connected, dophase_done);
 1334|       |
 1335|       |  /* Perform post DO phase operations if necessary */
 1336|     82|  if(!result && *dophase_done)
 1337|     59|    result = pop3_dophase_done(data, connected);
 1338|       |
 1339|     82|  return result;
 1340|     82|}
pop3.c:pop3_perform:
 1190|     82|{
 1191|       |  /* This is POP3 and no proxy */
 1192|     82|  CURLcode result = CURLE_OK;
 1193|     82|  struct connectdata *conn = data->conn;
 1194|     82|  struct POP3 *pop3 = data->req.p.pop3;
 1195|       |
 1196|     82|  DEBUGF(infof(data, "DO phase starts"));
 1197|       |
 1198|     82|  if(data->set.opt_no_body) {
 1199|       |    /* Requested no body means no transfer */
 1200|      2|    pop3->transfer = PPTRANSFER_INFO;
 1201|      2|  }
 1202|       |
 1203|     82|  *dophase_done = FALSE; /* not done yet */
 1204|       |
 1205|       |  /* Start the first command in the DO phase */
 1206|     82|  result = pop3_perform_command(data);
 1207|     82|  if(result)
 1208|      0|    return result;
 1209|       |
 1210|       |  /* Run the state-machine */
 1211|     82|  result = pop3_multi_statemach(data, dophase_done);
 1212|     82|  *connected = conn->bits.tcpconnect[FIRSTSOCKET];
 1213|       |
 1214|     82|  if(*dophase_done)
 1215|     68|    DEBUGF(infof(data, "DO phase is complete"));
 1216|       |
 1217|     82|  return result;
 1218|     82|}
pop3.c:pop3_perform_command:
  589|     82|{
  590|     82|  CURLcode result = CURLE_OK;
  591|     82|  struct connectdata *conn = data->conn;
  592|     82|  struct POP3 *pop3 = data->req.p.pop3;
  593|     82|  const char *command = NULL;
  594|       |
  595|       |  /* Calculate the default command */
  596|     82|  if(pop3->id[0] == '\0' || data->set.list_only) {
  597|     36|    command = "LIST";
  598|       |
  599|     36|    if(pop3->id[0] != '\0')
  600|       |      /* Message specific LIST so skip the BODY transfer */
  601|      0|      pop3->transfer = PPTRANSFER_INFO;
  602|     36|  }
  603|     46|  else
  604|     46|    command = "RETR";
  605|       |
  606|       |  /* Send the command */
  607|     82|  if(pop3->id[0] != '\0')
  608|     46|    result = Curl_pp_sendf(data, &conn->proto.pop3c.pp, "%s %s",
  609|     46|                           (pop3->custom && pop3->custom[0] != '\0' ?
  610|     45|                            pop3->custom : command), pop3->id);
  611|     36|  else
  612|     36|    result = Curl_pp_sendf(data, &conn->proto.pop3c.pp, "%s",
  613|     36|                           (pop3->custom && pop3->custom[0] != '\0' ?
  614|     35|                            pop3->custom : command));
  615|       |
  616|     82|  if(!result)
  617|     82|    state(data, POP3_COMMAND);
  618|       |
  619|     82|  return result;
  620|     82|}
pop3.c:pop3_dophase_done:
 1285|     60|{
 1286|     60|  (void)data;
 1287|     60|  (void)connected;
 1288|       |
 1289|     60|  return CURLE_OK;
 1290|     60|}
pop3.c:pop3_disconnect:
 1258|    280|{
 1259|    280|  struct pop3_conn *pop3c = &conn->proto.pop3c;
 1260|    280|  (void)data;
 1261|       |
 1262|       |  /* We cannot send quit unconditionally. If this connection is stale or
 1263|       |     bad in any way, sending quit and waiting around here will make the
 1264|       |     disconnect wait in vain and cause more problems than we need to. */
 1265|       |
 1266|    280|  if(!dead_connection && conn->bits.protoconnstart) {
 1267|     81|    if(!pop3_perform_quit(data, conn))
 1268|     81|      (void)pop3_block_statemach(data, conn, TRUE); /* ignore errors on QUIT */
 1269|     81|  }
 1270|       |
 1271|       |  /* Disconnect from the server */
 1272|    280|  Curl_pp_disconnect(&pop3c->pp);
 1273|       |
 1274|       |  /* Cleanup the SASL module */
 1275|    280|  Curl_sasl_cleanup(conn, pop3c->sasl.authused);
 1276|       |
 1277|       |  /* Cleanup our connection based variables */
 1278|    280|  Curl_safefree(pop3c->apoptimestamp);
 1279|       |
 1280|    280|  return CURLE_OK;
 1281|    280|}
pop3.c:pop3_perform_quit:
  630|     81|{
  631|       |  /* Send the QUIT command */
  632|     81|  CURLcode result = Curl_pp_sendf(data, &conn->proto.pop3c.pp, "%s", "QUIT");
  633|       |
  634|     81|  if(!result)
  635|     81|    state(data, POP3_QUIT);
  636|       |
  637|     81|  return result;
  638|     81|}
pop3.c:pop3_block_statemach:
 1070|     81|{
 1071|     81|  CURLcode result = CURLE_OK;
 1072|     81|  struct pop3_conn *pop3c = &conn->proto.pop3c;
 1073|       |
 1074|    165|  while(pop3c->state != POP3_STOP && !result)
 1075|     84|    result = Curl_pp_statemach(data, &pop3c->pp, TRUE, disconnecting);
 1076|       |
 1077|     81|  return result;
 1078|     81|}
pop3.c:pop3_doing:
 1294|      6|{
 1295|      6|  CURLcode result = pop3_multi_statemach(data, dophase_done);
 1296|       |
 1297|      6|  if(result)
 1298|      1|    DEBUGF(infof(data, "DO phase failed"));
 1299|      5|  else if(*dophase_done) {
 1300|      1|    result = pop3_dophase_done(data, FALSE /* not connected */);
 1301|       |
 1302|      1|    DEBUGF(infof(data, "DO phase is complete"));
 1303|      1|  }
 1304|       |
 1305|      6|  return result;
 1306|      6|}
pop3.c:pop3_setup_connection:
 1344|    280|{
 1345|       |  /* Initialise the POP3 layer */
 1346|    280|  CURLcode result = pop3_init(data);
 1347|    280|  if(result)
 1348|      0|    return result;
 1349|       |
 1350|       |  /* Clear the TLS upgraded flag */
 1351|    280|  conn->bits.tls_upgraded = FALSE;
 1352|       |
 1353|    280|  return CURLE_OK;
 1354|    280|}
pop3.c:pop3_init:
 1083|    280|{
 1084|    280|  CURLcode result = CURLE_OK;
 1085|    280|  struct POP3 *pop3;
 1086|       |
 1087|    280|  pop3 = data->req.p.pop3 = calloc(sizeof(struct POP3), 1);
 1088|    280|  if(!pop3)
 1089|      0|    result = CURLE_OUT_OF_MEMORY;
 1090|       |
 1091|    280|  return result;
 1092|    280|}

Curl_pgrsDone:
  141|  2.96k|{
  142|  2.96k|  int rc;
  143|  2.96k|  data->progress.lastshow = 0;
  144|  2.96k|  rc = Curl_pgrsUpdate(data); /* the final (forced) update */
  145|  2.96k|  if(rc)
  146|      0|    return rc;
  147|       |
  148|  2.96k|  if(!(data->progress.flags & PGRS_HIDE) &&
  149|  2.96k|     !data->progress.callback)
  150|       |    /* only output if we don't use a progress callback and we're not
  151|       |     * hidden */
  152|      0|    fprintf(data->set.err, "\n");
  153|       |
  154|  2.96k|  data->progress.speeder_c = 0; /* reset the progress meter display */
  155|  2.96k|  return 0;
  156|  2.96k|}
Curl_pgrsResetTransferSizes:
  160|  3.05k|{
  161|  3.05k|  Curl_pgrsSetDownloadSize(data, -1);
  162|  3.05k|  Curl_pgrsSetUploadSize(data, -1);
  163|  3.05k|}
Curl_pgrsTime:
  173|  5.79M|{
  174|  5.79M|  struct curltime now = Curl_now();
  175|  5.79M|  timediff_t *delta = NULL;
  176|       |
  177|  5.79M|  switch(timer) {
  178|      0|  default:
  179|      0|  case TIMER_NONE:
  180|       |    /* mistake filter */
  181|      0|    break;
  182|  2.94k|  case TIMER_STARTOP:
  183|       |    /* This is set at the start of a transfer */
  184|  2.94k|    data->progress.t_startop = now;
  185|  2.94k|    break;
  186|  3.05k|  case TIMER_STARTSINGLE:
  187|       |    /* This is set at the start of each single fetch */
  188|  3.05k|    data->progress.t_startsingle = now;
  189|  3.05k|    data->progress.is_t_startransfer_set = false;
  190|  3.05k|    break;
  191|      0|  case TIMER_STARTACCEPT:
  192|      0|    data->progress.t_acceptdata = now;
  193|      0|    break;
  194|  2.96k|  case TIMER_NAMELOOKUP:
  195|  2.96k|    delta = &data->progress.t_nslookup;
  196|  2.96k|    break;
  197|  2.92k|  case TIMER_CONNECT:
  198|  2.92k|    delta = &data->progress.t_connect;
  199|  2.92k|    break;
  200|      0|  case TIMER_APPCONNECT:
  201|      0|    delta = &data->progress.t_appconnect;
  202|      0|    break;
  203|  1.63k|  case TIMER_PRETRANSFER:
  204|  1.63k|    delta = &data->progress.t_pretransfer;
  205|  1.63k|    break;
  206|  5.78M|  case TIMER_STARTTRANSFER:
  207|  5.78M|    delta = &data->progress.t_starttransfer;
  208|       |    /* prevent updating t_starttransfer unless:
  209|       |     *   1) this is the first time we're setting t_starttransfer
  210|       |     *   2) a redirect has occurred since the last time t_starttransfer was set
  211|       |     * This prevents repeated invocations of the function from incorrectly
  212|       |     * changing the t_starttransfer time.
  213|       |     */
  214|  5.78M|    if(data->progress.is_t_startransfer_set) {
  215|  5.78M|      return now;
  216|  5.78M|    }
  217|  1.58k|    else {
  218|  1.58k|      data->progress.is_t_startransfer_set = true;
  219|  1.58k|      break;
  220|  1.58k|    }
  221|      0|  case TIMER_POSTRANSFER:
  222|       |    /* this is the normal end-of-transfer thing */
  223|      0|    break;
  224|    113|  case TIMER_REDIRECT:
  225|    113|    data->progress.t_redirect = Curl_timediff_us(now, data->progress.start);
  226|    113|    break;
  227|  5.79M|  }
  228|  15.2k|  if(delta) {
  229|  9.11k|    timediff_t us = Curl_timediff_us(now, data->progress.t_startsingle);
  230|  9.11k|    if(us < 1)
  231|      0|      us = 1; /* make sure at least one microsecond passed */
  232|  9.11k|    *delta += us;
  233|  9.11k|  }
  234|  15.2k|  return now;
  235|  5.79M|}
Curl_pgrsStartNow:
  238|  2.97k|{
  239|  2.97k|  data->progress.speeder_c = 0; /* reset the progress meter display */
  240|  2.97k|  data->progress.start = Curl_now();
  241|  2.97k|  data->progress.is_t_startransfer_set = false;
  242|  2.97k|  data->progress.ul_limit_start = data->progress.start;
  243|  2.97k|  data->progress.dl_limit_start = data->progress.start;
  244|  2.97k|  data->progress.ul_limit_size = 0;
  245|  2.97k|  data->progress.dl_limit_size = 0;
  246|  2.97k|  data->progress.downloaded = 0;
  247|  2.97k|  data->progress.uploaded = 0;
  248|       |  /* clear all bits except HIDE and HEADERS_OUT */
  249|  2.97k|  data->progress.flags &= PGRS_HIDE|PGRS_HEADERS_OUT;
  250|  2.97k|  Curl_ratelimit(data, data->progress.start);
  251|  2.97k|}
Curl_pgrsSetDownloadCounter:
  316|  4.35k|{
  317|  4.35k|  data->progress.downloaded = size;
  318|  4.35k|}
Curl_ratelimit:
  324|  2.97k|{
  325|       |  /* don't set a new stamp unless the time since last update is long enough */
  326|  2.97k|  if(data->set.max_recv_speed) {
  327|      0|    if(Curl_timediff(now, data->progress.dl_limit_start) >=
  328|      0|       MIN_RATE_LIMIT_PERIOD) {
  329|      0|      data->progress.dl_limit_start = now;
  330|      0|      data->progress.dl_limit_size = data->progress.downloaded;
  331|      0|    }
  332|      0|  }
  333|  2.97k|  if(data->set.max_send_speed) {
  334|      0|    if(Curl_timediff(now, data->progress.ul_limit_start) >=
  335|      0|       MIN_RATE_LIMIT_PERIOD) {
  336|      0|      data->progress.ul_limit_start = now;
  337|      0|      data->progress.ul_limit_size = data->progress.uploaded;
  338|      0|    }
  339|      0|  }
  340|  2.97k|}
Curl_pgrsSetUploadCounter:
  346|  5.44k|{
  347|  5.44k|  data->progress.uploaded = size;
  348|  5.44k|}
Curl_pgrsSetDownloadSize:
  351|  4.23k|{
  352|  4.23k|  if(size >= 0) {
  353|    265|    data->progress.size_dl = size;
  354|    265|    data->progress.flags |= PGRS_DL_SIZE_KNOWN;
  355|    265|  }
  356|  3.96k|  else {
  357|  3.96k|    data->progress.size_dl = 0;
  358|  3.96k|    data->progress.flags &= ~PGRS_DL_SIZE_KNOWN;
  359|  3.96k|  }
  360|  4.23k|}
Curl_pgrsSetUploadSize:
  363|  5.22k|{
  364|  5.22k|  if(size >= 0) {
  365|  1.28k|    data->progress.size_ul = size;
  366|  1.28k|    data->progress.flags |= PGRS_UL_SIZE_KNOWN;
  367|  1.28k|  }
  368|  3.94k|  else {
  369|  3.94k|    data->progress.size_ul = 0;
  370|  3.94k|    data->progress.flags &= ~PGRS_UL_SIZE_KNOWN;
  371|  3.94k|  }
  372|  5.22k|}
Curl_pgrsUpdate:
  577|  11.5M|{
  578|  11.5M|  struct curltime now = Curl_now(); /* what time is it */
  579|  11.5M|  bool showprogress = progress_calc(data, now);
  580|  11.5M|  if(!(data->progress.flags & PGRS_HIDE)) {
  581|      0|    if(data->set.fxferinfo) {
  582|      0|      int result;
  583|       |      /* There's a callback set, call that */
  584|      0|      Curl_set_in_callback(data, true);
  585|      0|      result = data->set.fxferinfo(data->set.progress_client,
  586|      0|                                   data->progress.size_dl,
  587|      0|                                   data->progress.downloaded,
  588|      0|                                   data->progress.size_ul,
  589|      0|                                   data->progress.uploaded);
  590|      0|      Curl_set_in_callback(data, false);
  591|      0|      if(result != CURL_PROGRESSFUNC_CONTINUE) {
  592|      0|        if(result)
  593|      0|          failf(data, "Callback aborted");
  594|      0|        return result;
  595|      0|      }
  596|      0|    }
  597|      0|    else if(data->set.fprogress) {
  598|      0|      int result;
  599|       |      /* The older deprecated callback is set, call that */
  600|      0|      Curl_set_in_callback(data, true);
  601|      0|      result = data->set.fprogress(data->set.progress_client,
  602|      0|                                   (double)data->progress.size_dl,
  603|      0|                                   (double)data->progress.downloaded,
  604|      0|                                   (double)data->progress.size_ul,
  605|      0|                                   (double)data->progress.uploaded);
  606|      0|      Curl_set_in_callback(data, false);
  607|      0|      if(result != CURL_PROGRESSFUNC_CONTINUE) {
  608|      0|        if(result)
  609|      0|          failf(data, "Callback aborted");
  610|      0|        return result;
  611|      0|      }
  612|      0|    }
  613|       |
  614|      0|    if(showprogress)
  615|      0|      progress_meter(data);
  616|      0|  }
  617|       |
  618|  11.5M|  return 0;
  619|  11.5M|}
progress.c:progress_calc:
  390|  11.5M|{
  391|  11.5M|  bool timetoshow = FALSE;
  392|  11.5M|  struct Progress * const p = &data->progress;
  393|       |
  394|       |  /* The time spent so far (from the start) in microseconds */
  395|  11.5M|  p->timespent = Curl_timediff_us(now, p->start);
  396|  11.5M|  p->dlspeed = trspeed(p->downloaded, p->timespent);
  397|  11.5M|  p->ulspeed = trspeed(p->uploaded, p->timespent);
  398|       |
  399|       |  /* Calculations done at most once a second, unless end is reached */
  400|  11.5M|  if(p->lastshow != now.tv_sec) {
  401|  6.08k|    int countindex; /* amount of seconds stored in the speeder array */
  402|  6.08k|    int nowindex = p->speeder_c% CURR_TIME;
  403|  6.08k|    p->lastshow = now.tv_sec;
  404|  6.08k|    timetoshow = TRUE;
  405|       |
  406|       |    /* Let's do the "current speed" thing, with the dl + ul speeds
  407|       |       combined. Store the speed at entry 'nowindex'. */
  408|  6.08k|    p->speeder[ nowindex ] = p->downloaded + p->uploaded;
  409|       |
  410|       |    /* remember the exact time for this moment */
  411|  6.08k|    p->speeder_time [ nowindex ] = now;
  412|       |
  413|       |    /* advance our speeder_c counter, which is increased every time we get
  414|       |       here and we expect it to never wrap as 2^32 is a lot of seconds! */
  415|  6.08k|    p->speeder_c++;
  416|       |
  417|       |    /* figure out how many index entries of data we have stored in our speeder
  418|       |       array. With N_ENTRIES filled in, we have about N_ENTRIES-1 seconds of
  419|       |       transfer. Imagine, after one second we have filled in two entries,
  420|       |       after two seconds we've filled in three entries etc. */
  421|  6.08k|    countindex = ((p->speeder_c >= CURR_TIME)? CURR_TIME:p->speeder_c) - 1;
  422|       |
  423|       |    /* first of all, we don't do this if there's no counted seconds yet */
  424|  6.08k|    if(countindex) {
  425|  2.85k|      int checkindex;
  426|  2.85k|      timediff_t span_ms;
  427|  2.85k|      curl_off_t amount;
  428|       |
  429|       |      /* Get the index position to compare with the 'nowindex' position.
  430|       |         Get the oldest entry possible. While we have less than CURR_TIME
  431|       |         entries, the first entry will remain the oldest. */
  432|  2.85k|      checkindex = (p->speeder_c >= CURR_TIME)? p->speeder_c%CURR_TIME:0;
  433|       |
  434|       |      /* Figure out the exact time for the time span */
  435|  2.85k|      span_ms = Curl_timediff(now, p->speeder_time[checkindex]);
  436|  2.85k|      if(0 == span_ms)
  437|  2.59k|        span_ms = 1; /* at least one millisecond MUST have passed */
  438|       |
  439|       |      /* Calculate the average speed the last 'span_ms' milliseconds */
  440|  2.85k|      amount = p->speeder[nowindex]- p->speeder[checkindex];
  441|       |
  442|  2.85k|      if(amount > CURL_OFF_T_C(4294967) /* 0xffffffff/1000 */)
  443|       |        /* the 'amount' value is bigger than would fit in 32 bits if
  444|       |           multiplied with 1000, so we use the double math for this */
  445|      0|        p->current_speed = (curl_off_t)
  446|      0|          ((double)amount/((double)span_ms/1000.0));
  447|  2.85k|      else
  448|       |        /* the 'amount' value is small enough to fit within 32 bits even
  449|       |           when multiplied with 1000 */
  450|  2.85k|        p->current_speed = amount*CURL_OFF_T_C(1000)/span_ms;
  451|  2.85k|    }
  452|  3.23k|    else
  453|       |      /* the first second we use the average */
  454|  3.23k|      p->current_speed = p->ulspeed + p->dlspeed;
  455|       |
  456|  6.08k|  } /* Calculations end */
  457|  11.5M|  return timetoshow;
  458|  11.5M|}
progress.c:trspeed:
  377|  23.1M|{
  378|  23.1M|  if(us < 1)
  379|      0|    return size * 1000000;
  380|  23.1M|  else if(size < CURL_OFF_T_MAX/1000000)
  381|  23.1M|    return (size * 1000000) / us;
  382|      0|  else if(us >= 1000000)
  383|      0|    return size / (us / 1000000);
  384|      0|  else
  385|      0|    return CURL_OFF_T_MAX;
  386|  23.1M|}

Curl_rand:
  120|  3.42k|{
  121|  3.42k|  CURLcode result = CURLE_BAD_FUNCTION_ARGUMENT;
  122|       |
  123|  3.42k|  DEBUGASSERT(num > 0);
  124|       |
  125|  7.26k|  while(num) {
  126|  3.84k|    unsigned int r;
  127|  3.84k|    size_t left = num < sizeof(unsigned int) ? num : sizeof(unsigned int);
  128|       |
  129|  3.84k|    result = randit(data, &r);
  130|  3.84k|    if(result)
  131|      0|      return result;
  132|       |
  133|  19.2k|    while(left) {
  134|  15.3k|      *rnd++ = (unsigned char)(r & 0xFF);
  135|  15.3k|      r >>= 8;
  136|  15.3k|      --num;
  137|  15.3k|      --left;
  138|  15.3k|    }
  139|  3.84k|  }
  140|       |
  141|  3.42k|  return result;
  142|  3.42k|}
Curl_rand_hex:
  152|  3.42k|{
  153|  3.42k|  CURLcode result = CURLE_BAD_FUNCTION_ARGUMENT;
  154|  3.42k|  const char *hex = "0123456789abcdef";
  155|  3.42k|  unsigned char buffer[128];
  156|  3.42k|  unsigned char *bufp = buffer;
  157|  3.42k|  DEBUGASSERT(num > 1);
  158|       |
  159|       |#ifdef __clang_analyzer__
  160|       |  /* This silences a scan-build warning about accessing this buffer with
  161|       |     uninitialized memory. */
  162|       |  memset(buffer, 0, sizeof(buffer));
  163|       |#endif
  164|       |
  165|  3.42k|  if((num/2 >= sizeof(buffer)) || !(num&1))
  166|       |    /* make sure it fits in the local buffer and that it is an odd number! */
  167|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
  168|       |
  169|  3.42k|  num--; /* save one for zero termination */
  170|       |
  171|  3.42k|  result = Curl_rand(data, buffer, num/2);
  172|  3.42k|  if(result)
  173|      0|    return result;
  174|       |
  175|  18.7k|  while(num) {
  176|       |    /* clang-tidy warns on this line without this comment: */
  177|       |    /* NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult) */
  178|  15.3k|    *rnd++ = hex[(*bufp & 0xF0)>>4];
  179|  15.3k|    *rnd++ = hex[*bufp & 0x0F];
  180|  15.3k|    bufp++;
  181|  15.3k|    num -= 2;
  182|  15.3k|  }
  183|  3.42k|  *rnd = 0;
  184|       |
  185|  3.42k|  return result;
  186|  3.42k|}
rand.c:randit:
   40|  3.84k|{
   41|  3.84k|  unsigned int r;
   42|  3.84k|  CURLcode result = CURLE_OK;
   43|  3.84k|  static unsigned int randseed;
   44|  3.84k|  static bool seeded = FALSE;
   45|       |
   46|  3.84k|#ifdef CURLDEBUG
   47|  3.84k|  char *force_entropy = getenv("CURL_ENTROPY");
   48|  3.84k|  if(force_entropy) {
   49|      0|    if(!seeded) {
   50|      0|      unsigned int seed = 0;
   51|      0|      size_t elen = strlen(force_entropy);
   52|      0|      size_t clen = sizeof(seed);
   53|      0|      size_t min = elen < clen ? elen : clen;
   54|      0|      memcpy((char *)&seed, force_entropy, min);
   55|      0|      randseed = ntohl(seed);
   56|      0|      seeded = TRUE;
   57|      0|    }
   58|      0|    else
   59|      0|      randseed++;
   60|      0|    *rnd = randseed;
   61|      0|    return CURLE_OK;
   62|      0|  }
   63|  3.84k|#endif
   64|       |
   65|       |  /* data may be NULL! */
   66|  3.84k|  result = Curl_ssl_random(data, (unsigned char *)rnd, sizeof(*rnd));
   67|  3.84k|  if(result != CURLE_NOT_BUILT_IN)
   68|       |    /* only if there is no random function in the TLS backend do the non crypto
   69|       |       version, otherwise return result */
   70|  3.84k|    return result;
   71|       |
   72|       |  /* ---- non-cryptographic version following ---- */
   73|       |
   74|      0|#ifdef RANDOM_FILE
   75|      0|  if(!seeded) {
   76|       |    /* if there's a random file to read a seed from, use it */
   77|      0|    int fd = open(RANDOM_FILE, O_RDONLY);
   78|      0|    if(fd > -1) {
   79|       |      /* read random data into the randseed variable */
   80|      0|      ssize_t nread = read(fd, &randseed, sizeof(randseed));
   81|      0|      if(nread == sizeof(randseed))
   82|      0|        seeded = TRUE;
   83|      0|      close(fd);
   84|      0|    }
   85|      0|  }
   86|      0|#endif
   87|       |
   88|      0|  if(!seeded) {
   89|      0|    struct curltime now = Curl_now();
   90|      0|    infof(data, "WARNING: Using weak random seed");
   91|      0|    randseed += (unsigned int)now.tv_usec + (unsigned int)now.tv_sec;
   92|      0|    randseed = randseed * 1103515245 + 12345;
   93|      0|    randseed = randseed * 1103515245 + 12345;
   94|      0|    randseed = randseed * 1103515245 + 12345;
   95|      0|    seeded = TRUE;
   96|      0|  }
   97|       |
   98|       |  /* Return an unsigned 32-bit pseudo-random number. */
   99|      0|  r = randseed = randseed * 1103515245 + 12345;
  100|      0|  *rnd = (r << 16) | ((r >> 16) & 0xFFFF);
  101|      0|  return CURLE_OK;
  102|  3.84k|}

Curl_rename:
   40|  3.09k|{
   41|       |#ifdef WIN32
   42|       |  /* rename() on Windows doesn't overwrite, so we can't use it here.
   43|       |     MoveFileEx() will overwrite and is usually atomic, however it fails
   44|       |     when there are open handles to the file. */
   45|       |  const int max_wait_ms = 1000;
   46|       |  struct curltime start = Curl_now();
   47|       |  TCHAR *tchar_oldpath = curlx_convert_UTF8_to_tchar((char *)oldpath);
   48|       |  TCHAR *tchar_newpath = curlx_convert_UTF8_to_tchar((char *)newpath);
   49|       |  for(;;) {
   50|       |    timediff_t diff;
   51|       |    if(MoveFileEx(tchar_oldpath, tchar_newpath, MOVEFILE_REPLACE_EXISTING)) {
   52|       |      curlx_unicodefree(tchar_oldpath);
   53|       |      curlx_unicodefree(tchar_newpath);
   54|       |      break;
   55|       |    }
   56|       |    diff = Curl_timediff(Curl_now(), start);
   57|       |    if(diff < 0 || diff > max_wait_ms) {
   58|       |      curlx_unicodefree(tchar_oldpath);
   59|       |      curlx_unicodefree(tchar_newpath);
   60|       |      return 1;
   61|       |    }
   62|       |    Sleep(1);
   63|       |  }
   64|       |#else
   65|  3.09k|  if(rename(oldpath, newpath))
   66|      0|    return 1;
   67|  3.09k|#endif
   68|  3.09k|  return 0;
   69|  3.09k|}

Curl_rtsp_parseheader:
  769|    371|{
  770|    371|  long CSeq = 0;
  771|       |
  772|    371|  if(checkprefix("CSeq:", header)) {
  773|       |    /* Store the received CSeq. Match is verified in rtsp_done */
  774|     47|    int nc = sscanf(&header[4], ": %ld", &CSeq);
  775|     47|    if(nc == 1) {
  776|     46|      struct RTSP *rtsp = data->req.p.rtsp;
  777|     46|      rtsp->CSeq_recv = CSeq; /* mark the request */
  778|     46|      data->state.rtsp_CSeq_recv = CSeq; /* update the handle */
  779|     46|    }
  780|      1|    else {
  781|      1|      failf(data, "Unable to read the CSeq header: [%s]", header);
  782|      1|      return CURLE_RTSP_CSEQ_ERROR;
  783|      1|    }
  784|     47|  }
  785|    324|  else if(checkprefix("Session:", header)) {
  786|      0|    char *start;
  787|      0|    char *end;
  788|      0|    size_t idlen;
  789|       |
  790|       |    /* Find the first non-space letter */
  791|      0|    start = header + 8;
  792|      0|    while(*start && ISSPACE(*start))
  793|      0|      start++;
  794|       |
  795|      0|    if(!*start) {
  796|      0|      failf(data, "Got a blank Session ID");
  797|      0|      return CURLE_RTSP_SESSION_ERROR;
  798|      0|    }
  799|       |
  800|       |    /* Find the end of Session ID
  801|       |     *
  802|       |     * Allow any non whitespace content, up to the field separator or end of
  803|       |     * line. RFC 2326 isn't 100% clear on the session ID and for example
  804|       |     * gstreamer does url-encoded session ID's not covered by the standard.
  805|       |     */
  806|      0|    end = start;
  807|      0|    while(*end && *end != ';' && !ISSPACE(*end))
  808|      0|      end++;
  809|      0|    idlen = end - start;
  810|       |
  811|      0|    if(data->set.str[STRING_RTSP_SESSION_ID]) {
  812|       |
  813|       |      /* If the Session ID is set, then compare */
  814|      0|      if(strlen(data->set.str[STRING_RTSP_SESSION_ID]) != idlen ||
  815|      0|         strncmp(start, data->set.str[STRING_RTSP_SESSION_ID], idlen) != 0) {
  816|      0|        failf(data, "Got RTSP Session ID Line [%s], but wanted ID [%s]",
  817|      0|              start, data->set.str[STRING_RTSP_SESSION_ID]);
  818|      0|        return CURLE_RTSP_SESSION_ERROR;
  819|      0|      }
  820|      0|    }
  821|      0|    else {
  822|       |      /* If the Session ID is not set, and we find it in a response, then set
  823|       |       * it.
  824|       |       */
  825|       |
  826|       |      /* Copy the id substring into a new buffer */
  827|      0|      data->set.str[STRING_RTSP_SESSION_ID] = malloc(idlen + 1);
  828|      0|      if(!data->set.str[STRING_RTSP_SESSION_ID])
  829|      0|        return CURLE_OUT_OF_MEMORY;
  830|      0|      memcpy(data->set.str[STRING_RTSP_SESSION_ID], start, idlen);
  831|      0|      (data->set.str[STRING_RTSP_SESSION_ID])[idlen] = '\0';
  832|      0|    }
  833|      0|  }
  834|    370|  return CURLE_OK;
  835|    371|}
rtsp.c:rtsp_setup_connection:
  122|    162|{
  123|    162|  struct RTSP *rtsp;
  124|    162|  (void)conn;
  125|       |
  126|    162|  data->req.p.rtsp = rtsp = calloc(1, sizeof(struct RTSP));
  127|    162|  if(!rtsp)
  128|      0|    return CURLE_OUT_OF_MEMORY;
  129|       |
  130|    162|  return CURLE_OK;
  131|    162|}
rtsp.c:rtsp_connect:
  184|    162|{
  185|    162|  CURLcode httpStatus;
  186|       |
  187|    162|  httpStatus = Curl_http_connect(data, done);
  188|       |
  189|       |  /* Initialize the CSeq if not already done */
  190|    162|  if(data->state.rtsp_next_client_CSeq == 0)
  191|    161|    data->state.rtsp_next_client_CSeq = 1;
  192|    162|  if(data->state.rtsp_next_server_CSeq == 0)
  193|    162|    data->state.rtsp_next_server_CSeq = 1;
  194|       |
  195|    162|  data->conn->proto.rtspc.rtp_channel = -1;
  196|       |
  197|    162|  return httpStatus;
  198|    162|}
rtsp.c:rtsp_disconnect:
  202|    162|{
  203|    162|  (void) dead;
  204|    162|  (void) data;
  205|    162|  Curl_safefree(conn->proto.rtspc.rtp_buf);
  206|    162|  return CURLE_OK;
  207|    162|}
rtsp.c:rtsp_done:
  212|    162|{
  213|    162|  struct RTSP *rtsp = data->req.p.rtsp;
  214|    162|  CURLcode httpStatus;
  215|       |
  216|       |  /* Bypass HTTP empty-reply checks on receive */
  217|    162|  if(data->set.rtspreq == RTSPREQ_RECEIVE)
  218|      0|    premature = TRUE;
  219|       |
  220|    162|  httpStatus = Curl_http_done(data, status, premature);
  221|       |
  222|    162|  if(rtsp) {
  223|       |    /* Check the sequence numbers */
  224|    162|    long CSeq_sent = rtsp->CSeq_sent;
  225|    162|    long CSeq_recv = rtsp->CSeq_recv;
  226|    162|    if((data->set.rtspreq != RTSPREQ_RECEIVE) && (CSeq_sent != CSeq_recv)) {
  227|    160|      failf(data,
  228|    160|            "The CSeq of this request %ld did not match the response %ld",
  229|    160|            CSeq_sent, CSeq_recv);
  230|    160|      return CURLE_RTSP_CSEQ_ERROR;
  231|    160|    }
  232|      2|    if(data->set.rtspreq == RTSPREQ_RECEIVE &&
  233|      2|            (data->conn->proto.rtspc.rtp_channel == -1)) {
  234|      0|      infof(data, "Got an RTP Receive with a CSeq of %ld", CSeq_recv);
  235|      0|    }
  236|      2|  }
  237|       |
  238|      2|  return httpStatus;
  239|    162|}
rtsp.c:rtsp_do:
  242|    162|{
  243|    162|  struct connectdata *conn = data->conn;
  244|    162|  CURLcode result = CURLE_OK;
  245|    162|  Curl_RtspReq rtspreq = data->set.rtspreq;
  246|    162|  struct RTSP *rtsp = data->req.p.rtsp;
  247|    162|  struct dynbuf req_buffer;
  248|    162|  curl_off_t postsize = 0; /* for ANNOUNCE and SET_PARAMETER */
  249|    162|  curl_off_t putsize = 0; /* for ANNOUNCE and SET_PARAMETER */
  250|       |
  251|    162|  const char *p_request = NULL;
  252|    162|  const char *p_session_id = NULL;
  253|    162|  const char *p_accept = NULL;
  254|    162|  const char *p_accept_encoding = NULL;
  255|    162|  const char *p_range = NULL;
  256|    162|  const char *p_referrer = NULL;
  257|    162|  const char *p_stream_uri = NULL;
  258|    162|  const char *p_transport = NULL;
  259|    162|  const char *p_uagent = NULL;
  260|    162|  const char *p_proxyuserpwd = NULL;
  261|    162|  const char *p_userpwd = NULL;
  262|       |
  263|    162|  *done = TRUE;
  264|       |
  265|    162|  rtsp->CSeq_sent = data->state.rtsp_next_client_CSeq;
  266|    162|  rtsp->CSeq_recv = 0;
  267|       |
  268|       |  /* Setup the 'p_request' pointer to the proper p_request string
  269|       |   * Since all RTSP requests are included here, there is no need to
  270|       |   * support custom requests like HTTP.
  271|       |   **/
  272|    162|  data->set.opt_no_body = TRUE; /* most requests don't contain a body */
  273|    162|  switch(rtspreq) {
  274|      1|  default:
  275|      1|    failf(data, "Got invalid RTSP request");
  276|      1|    return CURLE_BAD_FUNCTION_ARGUMENT;
  277|    161|  case RTSPREQ_OPTIONS:
  278|    161|    p_request = "OPTIONS";
  279|    161|    break;
  280|      0|  case RTSPREQ_DESCRIBE:
  281|      0|    p_request = "DESCRIBE";
  282|      0|    data->set.opt_no_body = FALSE;
  283|      0|    break;
  284|      0|  case RTSPREQ_ANNOUNCE:
  285|      0|    p_request = "ANNOUNCE";
  286|      0|    break;
  287|      0|  case RTSPREQ_SETUP:
  288|      0|    p_request = "SETUP";
  289|      0|    break;
  290|      0|  case RTSPREQ_PLAY:
  291|      0|    p_request = "PLAY";
  292|      0|    break;
  293|      0|  case RTSPREQ_PAUSE:
  294|      0|    p_request = "PAUSE";
  295|      0|    break;
  296|      0|  case RTSPREQ_TEARDOWN:
  297|      0|    p_request = "TEARDOWN";
  298|      0|    break;
  299|      0|  case RTSPREQ_GET_PARAMETER:
  300|       |    /* GET_PARAMETER's no_body status is determined later */
  301|      0|    p_request = "GET_PARAMETER";
  302|      0|    data->set.opt_no_body = FALSE;
  303|      0|    break;
  304|      0|  case RTSPREQ_SET_PARAMETER:
  305|      0|    p_request = "SET_PARAMETER";
  306|      0|    break;
  307|      0|  case RTSPREQ_RECORD:
  308|      0|    p_request = "RECORD";
  309|      0|    break;
  310|      0|  case RTSPREQ_RECEIVE:
  311|      0|    p_request = "";
  312|       |    /* Treat interleaved RTP as body*/
  313|      0|    data->set.opt_no_body = FALSE;
  314|      0|    break;
  315|      0|  case RTSPREQ_LAST:
  316|      0|    failf(data, "Got invalid RTSP request: RTSPREQ_LAST");
  317|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
  318|    162|  }
  319|       |
  320|    161|  if(rtspreq == RTSPREQ_RECEIVE) {
  321|      0|    Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE, -1);
  322|       |
  323|      0|    return result;
  324|      0|  }
  325|       |
  326|    161|  p_session_id = data->set.str[STRING_RTSP_SESSION_ID];
  327|    161|  if(!p_session_id &&
  328|    161|     (rtspreq & ~(RTSPREQ_OPTIONS | RTSPREQ_DESCRIBE | RTSPREQ_SETUP))) {
  329|      0|    failf(data, "Refusing to issue an RTSP request [%s] without a session ID.",
  330|      0|          p_request);
  331|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
  332|      0|  }
  333|       |
  334|       |  /* Stream URI. Default to server '*' if not specified */
  335|    161|  if(data->set.str[STRING_RTSP_STREAM_URI]) {
  336|      1|    p_stream_uri = data->set.str[STRING_RTSP_STREAM_URI];
  337|      1|  }
  338|    160|  else {
  339|    160|    p_stream_uri = "*";
  340|    160|  }
  341|       |
  342|       |  /* Transport Header for SETUP requests */
  343|    161|  p_transport = Curl_checkheaders(data, "Transport");
  344|    161|  if(rtspreq == RTSPREQ_SETUP && !p_transport) {
  345|       |    /* New Transport: setting? */
  346|      0|    if(data->set.str[STRING_RTSP_TRANSPORT]) {
  347|      0|      Curl_safefree(data->state.aptr.rtsp_transport);
  348|       |
  349|      0|      data->state.aptr.rtsp_transport =
  350|      0|        aprintf("Transport: %s\r\n",
  351|      0|                data->set.str[STRING_RTSP_TRANSPORT]);
  352|      0|      if(!data->state.aptr.rtsp_transport)
  353|      0|        return CURLE_OUT_OF_MEMORY;
  354|      0|    }
  355|      0|    else {
  356|      0|      failf(data,
  357|      0|            "Refusing to issue an RTSP SETUP without a Transport: header.");
  358|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  359|      0|    }
  360|       |
  361|      0|    p_transport = data->state.aptr.rtsp_transport;
  362|      0|  }
  363|       |
  364|       |  /* Accept Headers for DESCRIBE requests */
  365|    161|  if(rtspreq == RTSPREQ_DESCRIBE) {
  366|       |    /* Accept Header */
  367|      0|    p_accept = Curl_checkheaders(data, "Accept")?
  368|      0|      NULL:"Accept: application/sdp\r\n";
  369|       |
  370|       |    /* Accept-Encoding header */
  371|      0|    if(!Curl_checkheaders(data, "Accept-Encoding") &&
  372|      0|       data->set.str[STRING_ENCODING]) {
  373|      0|      Curl_safefree(data->state.aptr.accept_encoding);
  374|      0|      data->state.aptr.accept_encoding =
  375|      0|        aprintf("Accept-Encoding: %s\r\n", data->set.str[STRING_ENCODING]);
  376|       |
  377|      0|      if(!data->state.aptr.accept_encoding)
  378|      0|        return CURLE_OUT_OF_MEMORY;
  379|       |
  380|      0|      p_accept_encoding = data->state.aptr.accept_encoding;
  381|      0|    }
  382|      0|  }
  383|       |
  384|       |  /* The User-Agent string might have been allocated in url.c already, because
  385|       |     it might have been used in the proxy connect, but if we have got a header
  386|       |     with the user-agent string specified, we erase the previously made string
  387|       |     here. */
  388|    161|  if(Curl_checkheaders(data, "User-Agent") && data->state.aptr.uagent) {
  389|      0|    Curl_safefree(data->state.aptr.uagent);
  390|      0|    data->state.aptr.uagent = NULL;
  391|      0|  }
  392|    161|  else if(!Curl_checkheaders(data, "User-Agent") &&
  393|    161|          data->set.str[STRING_USERAGENT]) {
  394|      0|    p_uagent = data->state.aptr.uagent;
  395|      0|  }
  396|       |
  397|       |  /* setup the authentication headers */
  398|    161|  result = Curl_http_output_auth(data, conn, p_request, HTTPREQ_GET,
  399|    161|                                 p_stream_uri, FALSE);
  400|    161|  if(result)
  401|      0|    return result;
  402|       |
  403|    161|  p_proxyuserpwd = data->state.aptr.proxyuserpwd;
  404|    161|  p_userpwd = data->state.aptr.userpwd;
  405|       |
  406|       |  /* Referrer */
  407|    161|  Curl_safefree(data->state.aptr.ref);
  408|    161|  if(data->state.referer && !Curl_checkheaders(data, "Referer"))
  409|      0|    data->state.aptr.ref = aprintf("Referer: %s\r\n", data->state.referer);
  410|    161|  else
  411|    161|    data->state.aptr.ref = NULL;
  412|       |
  413|    161|  p_referrer = data->state.aptr.ref;
  414|       |
  415|       |  /*
  416|       |   * Range Header
  417|       |   * Only applies to PLAY, PAUSE, RECORD
  418|       |   *
  419|       |   * Go ahead and use the Range stuff supplied for HTTP
  420|       |   */
  421|    161|  if(data->state.use_range &&
  422|    161|     (rtspreq  & (RTSPREQ_PLAY | RTSPREQ_PAUSE | RTSPREQ_RECORD))) {
  423|       |
  424|       |    /* Check to see if there is a range set in the custom headers */
  425|      1|    if(!Curl_checkheaders(data, "Range") && data->state.range) {
  426|      1|      Curl_safefree(data->state.aptr.rangeline);
  427|      1|      data->state.aptr.rangeline = aprintf("Range: %s\r\n", data->state.range);
  428|      1|      p_range = data->state.aptr.rangeline;
  429|      1|    }
  430|      1|  }
  431|       |
  432|       |  /*
  433|       |   * Sanity check the custom headers
  434|       |   */
  435|    161|  if(Curl_checkheaders(data, "CSeq")) {
  436|      0|    failf(data, "CSeq cannot be set as a custom header.");
  437|      0|    return CURLE_RTSP_CSEQ_ERROR;
  438|      0|  }
  439|    161|  if(Curl_checkheaders(data, "Session")) {
  440|      0|    failf(data, "Session ID cannot be set as a custom header.");
  441|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
  442|      0|  }
  443|       |
  444|       |  /* Initialize a dynamic send buffer */
  445|    161|  Curl_dyn_init(&req_buffer, DYN_RTSP_REQ_HEADER);
  446|       |
  447|    161|  result =
  448|    161|    Curl_dyn_addf(&req_buffer,
  449|    161|                  "%s %s RTSP/1.0\r\n" /* Request Stream-URI RTSP/1.0 */
  450|    161|                  "CSeq: %ld\r\n", /* CSeq */
  451|    161|                  p_request, p_stream_uri, rtsp->CSeq_sent);
  452|    161|  if(result)
  453|      0|    return result;
  454|       |
  455|       |  /*
  456|       |   * Rather than do a normal alloc line, keep the session_id unformatted
  457|       |   * to make comparison easier
  458|       |   */
  459|    161|  if(p_session_id) {
  460|      1|    result = Curl_dyn_addf(&req_buffer, "Session: %s\r\n", p_session_id);
  461|      1|    if(result)
  462|      0|      return result;
  463|      1|  }
  464|       |
  465|       |  /*
  466|       |   * Shared HTTP-like options
  467|       |   */
  468|    161|  result = Curl_dyn_addf(&req_buffer,
  469|    161|                         "%s" /* transport */
  470|    161|                         "%s" /* accept */
  471|    161|                         "%s" /* accept-encoding */
  472|    161|                         "%s" /* range */
  473|    161|                         "%s" /* referrer */
  474|    161|                         "%s" /* user-agent */
  475|    161|                         "%s" /* proxyuserpwd */
  476|    161|                         "%s" /* userpwd */
  477|    161|                         ,
  478|    161|                         p_transport ? p_transport : "",
  479|    161|                         p_accept ? p_accept : "",
  480|    161|                         p_accept_encoding ? p_accept_encoding : "",
  481|    161|                         p_range ? p_range : "",
  482|    161|                         p_referrer ? p_referrer : "",
  483|    161|                         p_uagent ? p_uagent : "",
  484|    161|                         p_proxyuserpwd ? p_proxyuserpwd : "",
  485|    161|                         p_userpwd ? p_userpwd : "");
  486|       |
  487|       |  /*
  488|       |   * Free userpwd now --- cannot reuse this for Negotiate and possibly NTLM
  489|       |   * with basic and digest, it will be freed anyway by the next request
  490|       |   */
  491|    161|  Curl_safefree(data->state.aptr.userpwd);
  492|    161|  data->state.aptr.userpwd = NULL;
  493|       |
  494|    161|  if(result)
  495|      0|    return result;
  496|       |
  497|    161|  if((rtspreq == RTSPREQ_SETUP) || (rtspreq == RTSPREQ_DESCRIBE)) {
  498|      0|    result = Curl_add_timecondition(data, &req_buffer);
  499|      0|    if(result)
  500|      0|      return result;
  501|      0|  }
  502|       |
  503|    161|  result = Curl_add_custom_headers(data, FALSE, &req_buffer);
  504|    161|  if(result)
  505|      0|    return result;
  506|       |
  507|    161|  if(rtspreq == RTSPREQ_ANNOUNCE ||
  508|    161|     rtspreq == RTSPREQ_SET_PARAMETER ||
  509|    161|     rtspreq == RTSPREQ_GET_PARAMETER) {
  510|       |
  511|      0|    if(data->set.upload) {
  512|      0|      putsize = data->state.infilesize;
  513|      0|      data->state.httpreq = HTTPREQ_PUT;
  514|       |
  515|      0|    }
  516|      0|    else {
  517|      0|      postsize = (data->state.infilesize != -1)?
  518|      0|        data->state.infilesize:
  519|      0|        (data->set.postfields? (curl_off_t)strlen(data->set.postfields):0);
  520|      0|      data->state.httpreq = HTTPREQ_POST;
  521|      0|    }
  522|       |
  523|      0|    if(putsize > 0 || postsize > 0) {
  524|       |      /* As stated in the http comments, it is probably not wise to
  525|       |       * actually set a custom Content-Length in the headers */
  526|      0|      if(!Curl_checkheaders(data, "Content-Length")) {
  527|      0|        result =
  528|      0|          Curl_dyn_addf(&req_buffer,
  529|      0|                        "Content-Length: %" CURL_FORMAT_CURL_OFF_T"\r\n",
  530|      0|                        (data->set.upload ? putsize : postsize));
  531|      0|        if(result)
  532|      0|          return result;
  533|      0|      }
  534|       |
  535|      0|      if(rtspreq == RTSPREQ_SET_PARAMETER ||
  536|      0|         rtspreq == RTSPREQ_GET_PARAMETER) {
  537|      0|        if(!Curl_checkheaders(data, "Content-Type")) {
  538|      0|          result = Curl_dyn_addf(&req_buffer,
  539|      0|                                 "Content-Type: text/parameters\r\n");
  540|      0|          if(result)
  541|      0|            return result;
  542|      0|        }
  543|      0|      }
  544|       |
  545|      0|      if(rtspreq == RTSPREQ_ANNOUNCE) {
  546|      0|        if(!Curl_checkheaders(data, "Content-Type")) {
  547|      0|          result = Curl_dyn_addf(&req_buffer,
  548|      0|                                 "Content-Type: application/sdp\r\n");
  549|      0|          if(result)
  550|      0|            return result;
  551|      0|        }
  552|      0|      }
  553|       |
  554|      0|      data->state.expect100header = FALSE; /* RTSP posts are simple/small */
  555|      0|    }
  556|      0|    else if(rtspreq == RTSPREQ_GET_PARAMETER) {
  557|       |      /* Check for an empty GET_PARAMETER (heartbeat) request */
  558|      0|      data->state.httpreq = HTTPREQ_HEAD;
  559|      0|      data->set.opt_no_body = TRUE;
  560|      0|    }
  561|      0|  }
  562|       |
  563|       |  /* RTSP never allows chunked transfer */
  564|    161|  data->req.forbidchunk = TRUE;
  565|       |  /* Finish the request buffer */
  566|    161|  result = Curl_dyn_add(&req_buffer, "\r\n");
  567|    161|  if(result)
  568|      0|    return result;
  569|       |
  570|    161|  if(postsize > 0) {
  571|      0|    result = Curl_dyn_addn(&req_buffer, data->set.postfields,
  572|      0|                           (size_t)postsize);
  573|      0|    if(result)
  574|      0|      return result;
  575|      0|  }
  576|       |
  577|       |  /* issue the request */
  578|    161|  result = Curl_buffer_send(&req_buffer, data,
  579|    161|                            &data->info.request_size, 0, FIRSTSOCKET);
  580|    161|  if(result) {
  581|      0|    failf(data, "Failed sending RTSP request");
  582|      0|    return result;
  583|      0|  }
  584|       |
  585|    161|  Curl_setup_transfer(data, FIRSTSOCKET, -1, TRUE, putsize?FIRSTSOCKET:-1);
  586|       |
  587|       |  /* Increment the CSeq on success */
  588|    161|  data->state.rtsp_next_client_CSeq++;
  589|       |
  590|    161|  if(data->req.writebytecount) {
  591|       |    /* if a request-body has been sent off, we make sure this progress is
  592|       |       noted properly */
  593|      0|    Curl_pgrsSetUploadCounter(data, data->req.writebytecount);
  594|      0|    if(Curl_pgrsUpdate(data))
  595|      0|      result = CURLE_ABORTED_BY_CALLBACK;
  596|      0|  }
  597|       |
  598|    161|  return result;
  599|    161|}
rtsp.c:rtsp_rtp_readwrite:
  605|  5.77M|                                   bool *readmore) {
  606|  5.77M|  struct SingleRequest *k = &data->req;
  607|  5.77M|  struct rtsp_conn *rtspc = &(conn->proto.rtspc);
  608|       |
  609|  5.77M|  char *rtp; /* moving pointer to rtp data */
  610|  5.77M|  ssize_t rtp_dataleft; /* how much data left to parse in this round */
  611|  5.77M|  char *scratch;
  612|  5.77M|  CURLcode result;
  613|       |
  614|  5.77M|  if(rtspc->rtp_buf) {
  615|       |    /* There was some leftover data the last time. Merge buffers */
  616|  5.77M|    char *newptr = Curl_saferealloc(rtspc->rtp_buf,
  617|  5.77M|                                    rtspc->rtp_bufsize + *nread);
  618|  5.77M|    if(!newptr) {
  619|      0|      rtspc->rtp_buf = NULL;
  620|      0|      rtspc->rtp_bufsize = 0;
  621|      0|      return CURLE_OUT_OF_MEMORY;
  622|      0|    }
  623|  5.77M|    rtspc->rtp_buf = newptr;
  624|  5.77M|    memcpy(rtspc->rtp_buf + rtspc->rtp_bufsize, k->str, *nread);
  625|  5.77M|    rtspc->rtp_bufsize += *nread;
  626|  5.77M|    rtp = rtspc->rtp_buf;
  627|  5.77M|    rtp_dataleft = rtspc->rtp_bufsize;
  628|  5.77M|  }
  629|    228|  else {
  630|       |    /* Just parse the request buffer directly */
  631|    228|    rtp = k->str;
  632|    228|    rtp_dataleft = *nread;
  633|    228|  }
  634|       |
  635|  5.77M|  while((rtp_dataleft > 0) &&
  636|  5.77M|        (rtp[0] == '$')) {
  637|  5.77M|    if(rtp_dataleft > 4) {
  638|  4.87M|      int rtp_length;
  639|       |
  640|       |      /* Parse the header */
  641|       |      /* The channel identifier immediately follows and is 1 byte */
  642|  4.87M|      rtspc->rtp_channel = RTP_PKT_CHANNEL(rtp);
  643|       |
  644|       |      /* The length is two bytes */
  645|  4.87M|      rtp_length = RTP_PKT_LENGTH(rtp);
  646|       |
  647|  4.87M|      if(rtp_dataleft < rtp_length + 4) {
  648|       |        /* Need more - incomplete payload*/
  649|  4.87M|        *readmore = TRUE;
  650|  4.87M|        break;
  651|  4.87M|      }
  652|       |      /* We have the full RTP interleaved packet
  653|       |       * Write out the header including the leading '$' */
  654|     18|      DEBUGF(infof(data, "RTP write channel %d rtp_length %d",
  655|     18|             rtspc->rtp_channel, rtp_length));
  656|     18|      result = rtp_client_write(data, &rtp[0], rtp_length + 4);
  657|     18|      if(result) {
  658|      0|        failf(data, "Got an error writing an RTP packet");
  659|      0|        *readmore = FALSE;
  660|      0|        Curl_safefree(rtspc->rtp_buf);
  661|      0|        rtspc->rtp_buf = NULL;
  662|      0|        rtspc->rtp_bufsize = 0;
  663|      0|        return result;
  664|      0|      }
  665|       |
  666|       |      /* Move forward in the buffer */
  667|     18|      rtp_dataleft -= rtp_length + 4;
  668|     18|      rtp += rtp_length + 4;
  669|       |
  670|     18|      if(data->set.rtspreq == RTSPREQ_RECEIVE) {
  671|       |        /* If we are in a passive receive, give control back
  672|       |         * to the app as often as we can.
  673|       |         */
  674|      0|        k->keepon &= ~KEEP_RECV;
  675|      0|      }
  676|     18|    }
  677|   905k|    else {
  678|       |      /* Need more - incomplete header */
  679|   905k|      *readmore = TRUE;
  680|   905k|      break;
  681|   905k|    }
  682|  5.77M|  }
  683|       |
  684|  5.77M|  if(rtp_dataleft && rtp[0] == '$') {
  685|  5.77M|    DEBUGF(infof(data, "RTP Rewinding %zd %s", rtp_dataleft,
  686|  5.77M|          *readmore ? "(READMORE)" : ""));
  687|       |
  688|       |    /* Store the incomplete RTP packet for a "rewind" */
  689|  5.77M|    scratch = malloc(rtp_dataleft);
  690|  5.77M|    if(!scratch) {
  691|      0|      Curl_safefree(rtspc->rtp_buf);
  692|      0|      rtspc->rtp_buf = NULL;
  693|      0|      rtspc->rtp_bufsize = 0;
  694|      0|      return CURLE_OUT_OF_MEMORY;
  695|      0|    }
  696|  5.77M|    memcpy(scratch, rtp, rtp_dataleft);
  697|  5.77M|    Curl_safefree(rtspc->rtp_buf);
  698|  5.77M|    rtspc->rtp_buf = scratch;
  699|  5.77M|    rtspc->rtp_bufsize = rtp_dataleft;
  700|       |
  701|       |    /* As far as the transfer is concerned, this data is consumed */
  702|  5.77M|    *nread = 0;
  703|  5.77M|    return CURLE_OK;
  704|  5.77M|  }
  705|       |  /* Fix up k->str to point just after the last RTP packet */
  706|     91|  k->str += *nread - rtp_dataleft;
  707|       |
  708|       |  /* either all of the data has been read or...
  709|       |   * rtp now points at the next byte to parse
  710|       |   */
  711|     91|  if(rtp_dataleft > 0)
  712|     91|    DEBUGASSERT(k->str[0] == rtp[0]);
  713|       |
  714|     91|  DEBUGASSERT(rtp_dataleft <= *nread); /* sanity check */
  715|       |
  716|     91|  *nread = rtp_dataleft;
  717|       |
  718|       |  /* If we get here, we have finished with the leftover/merge buffer */
  719|     91|  Curl_safefree(rtspc->rtp_buf);
  720|     91|  rtspc->rtp_buf = NULL;
  721|     91|  rtspc->rtp_bufsize = 0;
  722|       |
  723|     91|  return CURLE_OK;
  724|     91|}
rtsp.c:rtp_client_write:
  728|     18|{
  729|     18|  size_t wrote;
  730|     18|  curl_write_callback writeit;
  731|     18|  void *user_ptr;
  732|       |
  733|     18|  if(len == 0) {
  734|      0|    failf(data, "Cannot write a 0 size RTP packet.");
  735|      0|    return CURLE_WRITE_ERROR;
  736|      0|  }
  737|       |
  738|       |  /* If the user has configured CURLOPT_INTERLEAVEFUNCTION then use that
  739|       |     function and any configured CURLOPT_INTERLEAVEDATA to write out the RTP
  740|       |     data. Otherwise, use the CURLOPT_WRITEFUNCTION with the CURLOPT_WRITEDATA
  741|       |     pointer to write out the RTP data. */
  742|     18|  if(data->set.fwrite_rtp) {
  743|      0|    writeit = data->set.fwrite_rtp;
  744|      0|    user_ptr = data->set.rtp_out;
  745|      0|  }
  746|     18|  else {
  747|     18|    writeit = data->set.fwrite_func;
  748|     18|    user_ptr = data->set.out;
  749|     18|  }
  750|       |
  751|     18|  Curl_set_in_callback(data, true);
  752|     18|  wrote = writeit(ptr, 1, len, user_ptr);
  753|     18|  Curl_set_in_callback(data, false);
  754|       |
  755|     18|  if(CURL_WRITEFUNC_PAUSE == wrote) {
  756|      0|    failf(data, "Cannot pause RTP");
  757|      0|    return CURLE_WRITE_ERROR;
  758|      0|  }
  759|       |
  760|     18|  if(wrote != len) {
  761|      0|    failf(data, "Failed writing RTP data");
  762|      0|    return CURLE_WRITE_ERROR;
  763|      0|  }
  764|       |
  765|     18|  return CURLE_OK;
  766|     18|}

Curl_wait_ms:
   75|     41|{
   76|     41|  int r = 0;
   77|       |
   78|     41|  if(!timeout_ms)
   79|     41|    return 0;
   80|      0|  if(timeout_ms < 0) {
   81|      0|    SET_SOCKERRNO(EINVAL);
   82|      0|    return -1;
   83|      0|  }
   84|       |#if defined(MSDOS)
   85|       |  delay(timeout_ms);
   86|       |#elif defined(WIN32)
   87|       |  /* prevent overflow, timeout_ms is typecast to ULONG/DWORD. */
   88|       |#if TIMEDIFF_T_MAX >= ULONG_MAX
   89|       |  if(timeout_ms >= ULONG_MAX)
   90|       |    timeout_ms = ULONG_MAX-1;
   91|       |    /* don't use ULONG_MAX, because that is equal to INFINITE */
   92|       |#endif
   93|       |  Sleep((ULONG)timeout_ms);
   94|       |#else
   95|      0|#if defined(HAVE_POLL_FINE)
   96|       |  /* prevent overflow, timeout_ms is typecast to int. */
   97|      0|#if TIMEDIFF_T_MAX > INT_MAX
   98|      0|  if(timeout_ms > INT_MAX)
   99|      0|    timeout_ms = INT_MAX;
  100|      0|#endif
  101|      0|  r = poll(NULL, 0, (int)timeout_ms);
  102|       |#else
  103|       |  {
  104|       |    struct timeval pending_tv;
  105|       |    timediff_t tv_sec = timeout_ms / 1000;
  106|       |    timediff_t tv_usec = (timeout_ms % 1000) * 1000; /* max=999999 */
  107|       |#ifdef HAVE_SUSECONDS_T
  108|       |#if TIMEDIFF_T_MAX > TIME_T_MAX
  109|       |    /* tv_sec overflow check in case time_t is signed */
  110|       |    if(tv_sec > TIME_T_MAX)
  111|       |      tv_sec = TIME_T_MAX;
  112|       |#endif
  113|       |    pending_tv.tv_sec = (time_t)tv_sec;
  114|       |    pending_tv.tv_usec = (suseconds_t)tv_usec;
  115|       |#else
  116|       |#if TIMEDIFF_T_MAX > INT_MAX
  117|       |    /* tv_sec overflow check in case time_t is signed */
  118|       |    if(tv_sec > INT_MAX)
  119|       |      tv_sec = INT_MAX;
  120|       |#endif
  121|       |    pending_tv.tv_sec = (int)tv_sec;
  122|       |    pending_tv.tv_usec = (int)tv_usec;
  123|       |#endif
  124|       |    r = select(0, NULL, NULL, NULL, &pending_tv);
  125|       |  }
  126|       |#endif /* HAVE_POLL_FINE */
  127|      0|#endif /* USE_WINSOCK */
  128|      0|  if(r)
  129|      0|    r = -1;
  130|      0|  return r;
  131|      0|}
Curl_socket_check:
  250|  5.78M|{
  251|  5.78M|  struct pollfd pfd[3];
  252|  5.78M|  int num;
  253|  5.78M|  int r;
  254|       |
  255|  5.78M|  if((readfd0 == CURL_SOCKET_BAD) && (readfd1 == CURL_SOCKET_BAD) &&
  256|  5.78M|     (writefd == CURL_SOCKET_BAD)) {
  257|       |    /* no sockets, just wait */
  258|     41|    return Curl_wait_ms(timeout_ms);
  259|     41|  }
  260|       |
  261|       |  /* Avoid initial timestamp, avoid Curl_now() call, when elapsed
  262|       |     time in this function does not need to be measured. This happens
  263|       |     when function is called with a zero timeout or a negative timeout
  264|       |     value indicating a blocking call should be performed. */
  265|       |
  266|  5.78M|  num = 0;
  267|  5.78M|  if(readfd0 != CURL_SOCKET_BAD) {
  268|  5.78M|    pfd[num].fd = readfd0;
  269|  5.78M|    pfd[num].events = POLLRDNORM|POLLIN|POLLRDBAND|POLLPRI;
  270|  5.78M|    pfd[num].revents = 0;
  271|  5.78M|    num++;
  272|  5.78M|  }
  273|  5.78M|  if(readfd1 != CURL_SOCKET_BAD) {
  274|      0|    pfd[num].fd = readfd1;
  275|      0|    pfd[num].events = POLLRDNORM|POLLIN|POLLRDBAND|POLLPRI;
  276|      0|    pfd[num].revents = 0;
  277|      0|    num++;
  278|      0|  }
  279|  5.78M|  if(writefd != CURL_SOCKET_BAD) {
  280|  3.16k|    pfd[num].fd = writefd;
  281|  3.16k|    pfd[num].events = POLLWRNORM|POLLOUT|POLLPRI;
  282|  3.16k|    pfd[num].revents = 0;
  283|  3.16k|    num++;
  284|  3.16k|  }
  285|       |
  286|  5.78M|  r = Curl_poll(pfd, num, timeout_ms);
  287|  5.78M|  if(r <= 0)
  288|    318|    return r;
  289|       |
  290|  5.78M|  r = 0;
  291|  5.78M|  num = 0;
  292|  5.78M|  if(readfd0 != CURL_SOCKET_BAD) {
  293|  5.78M|    if(pfd[num].revents & (POLLRDNORM|POLLIN|POLLERR|POLLHUP))
  294|  5.78M|      r |= CURL_CSELECT_IN;
  295|  5.78M|    if(pfd[num].revents & (POLLRDBAND|POLLPRI|POLLNVAL))
  296|      0|      r |= CURL_CSELECT_ERR;
  297|  5.78M|    num++;
  298|  5.78M|  }
  299|  5.78M|  if(readfd1 != CURL_SOCKET_BAD) {
  300|      0|    if(pfd[num].revents & (POLLRDNORM|POLLIN|POLLERR|POLLHUP))
  301|      0|      r |= CURL_CSELECT_IN2;
  302|      0|    if(pfd[num].revents & (POLLRDBAND|POLLPRI|POLLNVAL))
  303|      0|      r |= CURL_CSELECT_ERR;
  304|      0|    num++;
  305|      0|  }
  306|  5.78M|  if(writefd != CURL_SOCKET_BAD) {
  307|  3.16k|    if(pfd[num].revents & (POLLWRNORM|POLLOUT))
  308|  3.16k|      r |= CURL_CSELECT_OUT;
  309|  3.16k|    if(pfd[num].revents & (POLLERR|POLLHUP|POLLPRI|POLLNVAL))
  310|      0|      r |= CURL_CSELECT_ERR;
  311|  3.16k|  }
  312|       |
  313|  5.78M|  return r;
  314|  5.78M|}
Curl_poll:
  330|  5.78M|{
  331|  5.78M|#ifdef HAVE_POLL_FINE
  332|  5.78M|  int pending_ms;
  333|       |#else
  334|       |  fd_set fds_read;
  335|       |  fd_set fds_write;
  336|       |  fd_set fds_err;
  337|       |  curl_socket_t maxfd;
  338|       |#endif
  339|  5.78M|  bool fds_none = TRUE;
  340|  5.78M|  unsigned int i;
  341|  5.78M|  int r;
  342|       |
  343|  5.78M|  if(ufds) {
  344|  5.78M|    for(i = 0; i < nfds; i++) {
  345|  5.78M|      if(ufds[i].fd != CURL_SOCKET_BAD) {
  346|  5.78M|        fds_none = FALSE;
  347|  5.78M|        break;
  348|  5.78M|      }
  349|  5.78M|    }
  350|  5.78M|  }
  351|  5.78M|  if(fds_none) {
  352|       |    /* no sockets, just wait */
  353|      0|    return Curl_wait_ms(timeout_ms);
  354|      0|  }
  355|       |
  356|       |  /* Avoid initial timestamp, avoid Curl_now() call, when elapsed
  357|       |     time in this function does not need to be measured. This happens
  358|       |     when function is called with a zero timeout or a negative timeout
  359|       |     value indicating a blocking call should be performed. */
  360|       |
  361|  5.78M|#ifdef HAVE_POLL_FINE
  362|       |
  363|       |  /* prevent overflow, timeout_ms is typecast to int. */
  364|  5.78M|#if TIMEDIFF_T_MAX > INT_MAX
  365|  5.78M|  if(timeout_ms > INT_MAX)
  366|      0|    timeout_ms = INT_MAX;
  367|  5.78M|#endif
  368|  5.78M|  if(timeout_ms > 0)
  369|    589|    pending_ms = (int)timeout_ms;
  370|  5.78M|  else if(timeout_ms < 0)
  371|      0|    pending_ms = -1;
  372|  5.78M|  else
  373|  5.78M|    pending_ms = 0;
  374|  5.78M|  r = poll(ufds, nfds, pending_ms);
  375|  5.78M|  if(r <= 0)
  376|    318|    return r;
  377|       |
  378|  11.5M|  for(i = 0; i < nfds; i++) {
  379|  5.78M|    if(ufds[i].fd == CURL_SOCKET_BAD)
  380|      0|      continue;
  381|  5.78M|    if(ufds[i].revents & POLLHUP)
  382|      0|      ufds[i].revents |= POLLIN;
  383|  5.78M|    if(ufds[i].revents & POLLERR)
  384|      0|      ufds[i].revents |= POLLIN|POLLOUT;
  385|  5.78M|  }
  386|       |
  387|       |#else  /* HAVE_POLL_FINE */
  388|       |
  389|       |  FD_ZERO(&fds_read);
  390|       |  FD_ZERO(&fds_write);
  391|       |  FD_ZERO(&fds_err);
  392|       |  maxfd = (curl_socket_t)-1;
  393|       |
  394|       |  for(i = 0; i < nfds; i++) {
  395|       |    ufds[i].revents = 0;
  396|       |    if(ufds[i].fd == CURL_SOCKET_BAD)
  397|       |      continue;
  398|       |    VERIFY_SOCK(ufds[i].fd);
  399|       |    if(ufds[i].events & (POLLIN|POLLOUT|POLLPRI|
  400|       |                         POLLRDNORM|POLLWRNORM|POLLRDBAND)) {
  401|       |      if(ufds[i].fd > maxfd)
  402|       |        maxfd = ufds[i].fd;
  403|       |      if(ufds[i].events & (POLLRDNORM|POLLIN))
  404|       |        FD_SET(ufds[i].fd, &fds_read);
  405|       |      if(ufds[i].events & (POLLWRNORM|POLLOUT))
  406|       |        FD_SET(ufds[i].fd, &fds_write);
  407|       |      if(ufds[i].events & (POLLRDBAND|POLLPRI))
  408|       |        FD_SET(ufds[i].fd, &fds_err);
  409|       |    }
  410|       |  }
  411|       |
  412|       |  /*
  413|       |     Note also that WinSock ignores the first argument, so we don't worry
  414|       |     about the fact that maxfd is computed incorrectly with WinSock (since
  415|       |     curl_socket_t is unsigned in such cases and thus -1 is the largest
  416|       |     value).
  417|       |  */
  418|       |  r = our_select(maxfd, &fds_read, &fds_write, &fds_err, timeout_ms);
  419|       |  if(r <= 0)
  420|       |    return r;
  421|       |
  422|       |  r = 0;
  423|       |  for(i = 0; i < nfds; i++) {
  424|       |    ufds[i].revents = 0;
  425|       |    if(ufds[i].fd == CURL_SOCKET_BAD)
  426|       |      continue;
  427|       |    if(FD_ISSET(ufds[i].fd, &fds_read)) {
  428|       |      if(ufds[i].events & POLLRDNORM)
  429|       |        ufds[i].revents |= POLLRDNORM;
  430|       |      if(ufds[i].events & POLLIN)
  431|       |        ufds[i].revents |= POLLIN;
  432|       |    }
  433|       |    if(FD_ISSET(ufds[i].fd, &fds_write)) {
  434|       |      if(ufds[i].events & POLLWRNORM)
  435|       |        ufds[i].revents |= POLLWRNORM;
  436|       |      if(ufds[i].events & POLLOUT)
  437|       |        ufds[i].revents |= POLLOUT;
  438|       |    }
  439|       |    if(FD_ISSET(ufds[i].fd, &fds_err)) {
  440|       |      if(ufds[i].events & POLLRDBAND)
  441|       |        ufds[i].revents |= POLLRDBAND;
  442|       |      if(ufds[i].events & POLLPRI)
  443|       |        ufds[i].revents |= POLLPRI;
  444|       |    }
  445|       |    if(ufds[i].revents)
  446|       |      r++;
  447|       |  }
  448|       |
  449|       |#endif  /* HAVE_POLL_FINE */
  450|       |
  451|  5.78M|  return r;
  452|  5.78M|}

Curl_infof:
  242|  5.85M|{
  243|  5.85M|  DEBUGASSERT(!strchr(fmt, '\n'));
  244|  5.85M|  if(data && data->set.verbose) {
  245|      0|    va_list ap;
  246|      0|    size_t len;
  247|      0|    char buffer[MAXINFO + 2];
  248|      0|    va_start(ap, fmt);
  249|      0|    len = mvsnprintf(buffer, MAXINFO, fmt, ap);
  250|      0|    va_end(ap);
  251|      0|    buffer[len++] = '\n';
  252|      0|    buffer[len] = '\0';
  253|      0|    Curl_debug(data, CURLINFO_TEXT, buffer, len);
  254|      0|  }
  255|  5.85M|}
Curl_failf:
  262|  3.08k|{
  263|  3.08k|  DEBUGASSERT(!strchr(fmt, '\n'));
  264|  3.08k|  if(data->set.verbose || data->set.errorbuffer) {
  265|      0|    va_list ap;
  266|      0|    size_t len;
  267|      0|    char error[CURL_ERROR_SIZE + 2];
  268|      0|    va_start(ap, fmt);
  269|      0|    len = mvsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  270|       |
  271|      0|    if(data->set.errorbuffer && !data->state.errorbuf) {
  272|      0|      strcpy(data->set.errorbuffer, error);
  273|      0|      data->state.errorbuf = TRUE; /* wrote error string */
  274|      0|    }
  275|      0|    error[len++] = '\n';
  276|      0|    error[len] = '\0';
  277|      0|    Curl_debug(data, CURLINFO_TEXT, error, len);
  278|      0|    va_end(ap);
  279|      0|  }
  280|  3.08k|}
Curl_write:
  294|  5.64k|{
  295|  5.64k|  ssize_t bytes_written;
  296|  5.64k|  CURLcode result = CURLE_OK;
  297|  5.64k|  struct connectdata *conn;
  298|  5.64k|  int num;
  299|  5.64k|  DEBUGASSERT(data);
  300|  5.64k|  DEBUGASSERT(data->conn);
  301|  5.64k|  conn = data->conn;
  302|  5.64k|  num = (sockfd == conn->sock[SECONDARYSOCKET]);
  303|       |
  304|  5.64k|#ifdef CURLDEBUG
  305|  5.64k|  {
  306|       |    /* Allow debug builds to override this logic to force short sends
  307|       |    */
  308|  5.64k|    char *p = getenv("CURL_SMALLSENDS");
  309|  5.64k|    if(p) {
  310|      0|      size_t altsize = (size_t)strtoul(p, NULL, 10);
  311|      0|      if(altsize)
  312|      0|        len = CURLMIN(len, altsize);
  313|      0|    }
  314|  5.64k|  }
  315|  5.64k|#endif
  316|  5.64k|  bytes_written = conn->send[num](data, num, mem, len, &result);
  317|       |
  318|  5.64k|  *written = bytes_written;
  319|  5.64k|  if(bytes_written >= 0)
  320|       |    /* we completely ignore the curlcode value when subzero is not returned */
  321|  5.64k|    return CURLE_OK;
  322|       |
  323|       |  /* handle CURLE_AGAIN or a send failure */
  324|      1|  switch(result) {
  325|      0|  case CURLE_AGAIN:
  326|      0|    *written = 0;
  327|      0|    return CURLE_OK;
  328|       |
  329|      0|  case CURLE_OK:
  330|       |    /* general send failure */
  331|      0|    return CURLE_SEND_ERROR;
  332|       |
  333|      1|  default:
  334|       |    /* we got a specific curlcode, forward it */
  335|      1|    return result;
  336|      1|  }
  337|      1|}
Curl_send_plain:
  341|  5.64k|{
  342|  5.64k|  struct connectdata *conn;
  343|  5.64k|  curl_socket_t sockfd;
  344|  5.64k|  ssize_t bytes_written;
  345|       |
  346|  5.64k|  DEBUGASSERT(data);
  347|  5.64k|  DEBUGASSERT(data->conn);
  348|  5.64k|  conn = data->conn;
  349|  5.64k|  sockfd = conn->sock[num];
  350|       |  /* WinSock will destroy unread received data if send() is
  351|       |     failed.
  352|       |     To avoid lossage of received data, recv() must be
  353|       |     performed before every send() if any incoming data is
  354|       |     available. */
  355|  5.64k|  if(pre_receive_plain(data, conn, num)) {
  356|      0|    *code = CURLE_OUT_OF_MEMORY;
  357|      0|    return -1;
  358|      0|  }
  359|       |
  360|       |#if defined(MSG_FASTOPEN) && !defined(TCP_FASTOPEN_CONNECT) /* Linux */
  361|       |  if(conn->bits.tcp_fastopen) {
  362|       |    bytes_written = sendto(sockfd, mem, len, MSG_FASTOPEN,
  363|       |                           conn->ip_addr->ai_addr, conn->ip_addr->ai_addrlen);
  364|       |    conn->bits.tcp_fastopen = FALSE;
  365|       |  }
  366|       |  else
  367|       |#endif
  368|  5.64k|    bytes_written = swrite(sockfd, mem, len);
  369|       |
  370|  5.64k|  *code = CURLE_OK;
  371|  5.64k|  if(-1 == bytes_written) {
  372|      1|    int err = SOCKERRNO;
  373|       |
  374|      1|    if(
  375|       |#ifdef WSAEWOULDBLOCK
  376|       |      /* This is how Windows does it */
  377|       |      (WSAEWOULDBLOCK == err)
  378|       |#else
  379|       |      /* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned
  380|       |         due to its inability to send off data without blocking. We therefore
  381|       |         treat both error codes the same here */
  382|      1|      (EWOULDBLOCK == err) || (EAGAIN == err) || (EINTR == err) ||
  383|      1|      (EINPROGRESS == err)
  384|      1|#endif
  385|      1|      ) {
  386|       |      /* this is just a case of EWOULDBLOCK */
  387|      0|      bytes_written = 0;
  388|      0|      *code = CURLE_AGAIN;
  389|      0|    }
  390|      1|    else {
  391|      1|      char buffer[STRERROR_LEN];
  392|      1|      failf(data, "Send failure: %s",
  393|      1|            Curl_strerror(err, buffer, sizeof(buffer)));
  394|      1|      data->state.os_errno = err;
  395|      1|      *code = CURLE_SEND_ERROR;
  396|      1|    }
  397|      1|  }
  398|  5.64k|  return bytes_written;
  399|  5.64k|}
Curl_recv_plain:
  425|  5.78M|{
  426|  5.78M|  struct connectdata *conn;
  427|  5.78M|  curl_socket_t sockfd;
  428|  5.78M|  ssize_t nread;
  429|  5.78M|  DEBUGASSERT(data);
  430|  5.78M|  DEBUGASSERT(data->conn);
  431|  5.78M|  conn = data->conn;
  432|  5.78M|  sockfd = conn->sock[num];
  433|       |  /* Check and return data that already received and storied in internal
  434|       |     intermediate buffer */
  435|  5.78M|  nread = get_pre_recved(conn, num, buf, len);
  436|  5.78M|  if(nread > 0) {
  437|      0|    *code = CURLE_OK;
  438|      0|    return nread;
  439|      0|  }
  440|       |
  441|  5.78M|  nread = sread(sockfd, buf, len);
  442|       |
  443|  5.78M|  *code = CURLE_OK;
  444|  5.78M|  if(-1 == nread) {
  445|     58|    int err = SOCKERRNO;
  446|       |
  447|     58|    if(
  448|       |#ifdef WSAEWOULDBLOCK
  449|       |      /* This is how Windows does it */
  450|       |      (WSAEWOULDBLOCK == err)
  451|       |#else
  452|       |      /* errno may be EWOULDBLOCK or on some systems EAGAIN when it returned
  453|       |         due to its inability to send off data without blocking. We therefore
  454|       |         treat both error codes the same here */
  455|     58|      (EWOULDBLOCK == err) || (EAGAIN == err) || (EINTR == err)
  456|     58|#endif
  457|     58|      ) {
  458|       |      /* this is just a case of EWOULDBLOCK */
  459|     58|      *code = CURLE_AGAIN;
  460|     58|    }
  461|      0|    else {
  462|      0|      char buffer[STRERROR_LEN];
  463|      0|      failf(data, "Recv failure: %s",
  464|      0|            Curl_strerror(err, buffer, sizeof(buffer)));
  465|      0|      data->state.os_errno = err;
  466|      0|      *code = CURLE_RECV_ERROR;
  467|      0|    }
  468|     58|  }
  469|  5.78M|  return nread;
  470|  5.78M|}
Curl_client_write:
  621|  76.2k|{
  622|  76.2k|  struct connectdata *conn = data->conn;
  623|       |
  624|  76.2k|  DEBUGASSERT(!(type & ~CLIENTWRITE_BOTH));
  625|       |
  626|  76.2k|  if(!len)
  627|      0|    return CURLE_OK;
  628|       |
  629|       |  /* FTP data may need conversion. */
  630|  76.2k|  if((type & CLIENTWRITE_BODY) &&
  631|  76.2k|    (conn->handler->protocol & PROTO_FAMILY_FTP) &&
  632|  76.2k|    conn->proto.ftpc.transfertype == 'A') {
  633|       |    /* convert from the network encoding */
  634|      1|    CURLcode result = Curl_convert_from_network(data, ptr, len);
  635|       |    /* Curl_convert_from_network calls failf if unsuccessful */
  636|      1|    if(result)
  637|      0|      return result;
  638|       |
  639|      1|#ifdef CURL_DO_LINEEND_CONV
  640|       |    /* convert end-of-line markers */
  641|      1|    len = convert_lineends(data, ptr, len);
  642|      1|#endif /* CURL_DO_LINEEND_CONV */
  643|      1|    }
  644|       |
  645|  76.2k|  return chop_write(data, type, ptr, len);
  646|  76.2k|}
Curl_read:
  685|  5.78M|{
  686|  5.78M|  CURLcode result = CURLE_RECV_ERROR;
  687|  5.78M|  ssize_t nread = 0;
  688|  5.78M|  size_t bytesfromsocket = 0;
  689|  5.78M|  char *buffertofill = NULL;
  690|  5.78M|  struct connectdata *conn = data->conn;
  691|       |
  692|       |  /* Set 'num' to 0 or 1, depending on which socket that has been sent here.
  693|       |     If it is the second socket, we set num to 1. Otherwise to 0. This lets
  694|       |     us use the correct ssl handle. */
  695|  5.78M|  int num = (sockfd == conn->sock[SECONDARYSOCKET]);
  696|       |
  697|  5.78M|  *n = 0; /* reset amount to zero */
  698|       |
  699|  5.78M|  bytesfromsocket = CURLMIN(sizerequested, (size_t)data->set.buffer_size);
  700|  5.78M|  buffertofill = buf;
  701|       |
  702|  5.78M|  nread = conn->recv[num](data, num, buffertofill, bytesfromsocket, &result);
  703|  5.78M|  if(nread < 0)
  704|     58|    return result;
  705|       |
  706|  5.78M|  *n += nread;
  707|       |
  708|  5.78M|  return CURLE_OK;
  709|  5.78M|}
Curl_debug:
  714|  74.7k|{
  715|  74.7k|  int rc = 0;
  716|  74.7k|  if(data->set.verbose) {
  717|      0|    static const char s_infotype[CURLINFO_END][3] = {
  718|      0|      "* ", "< ", "> ", "{ ", "} ", "{ ", "} " };
  719|       |
  720|       |#ifdef CURL_DOES_CONVERSIONS
  721|       |    char *buf = NULL;
  722|       |    size_t conv_size = 0;
  723|       |
  724|       |    switch(type) {
  725|       |    case CURLINFO_HEADER_OUT:
  726|       |      buf = Curl_memdup(ptr, size);
  727|       |      if(!buf)
  728|       |        return 1;
  729|       |      conv_size = size;
  730|       |
  731|       |      /* Special processing is needed for this block if it
  732|       |       * contains both headers and data (separated by CRLFCRLF).
  733|       |       * We want to convert just the headers, leaving the data as-is.
  734|       |       */
  735|       |      if(size > 4) {
  736|       |        size_t i;
  737|       |        for(i = 0; i < size-4; i++) {
  738|       |          if(memcmp(&buf[i], "\x0d\x0a\x0d\x0a", 4) == 0) {
  739|       |            /* convert everything through this CRLFCRLF but no further */
  740|       |            conv_size = i + 4;
  741|       |            break;
  742|       |          }
  743|       |        }
  744|       |      }
  745|       |
  746|       |      Curl_convert_from_network(data, buf, conv_size);
  747|       |      /* Curl_convert_from_network calls failf if unsuccessful */
  748|       |      /* we might as well continue even if it fails...   */
  749|       |      ptr = buf; /* switch pointer to use my buffer instead */
  750|       |      break;
  751|       |    default:
  752|       |      /* leave everything else as-is */
  753|       |      break;
  754|       |    }
  755|       |#endif /* CURL_DOES_CONVERSIONS */
  756|       |
  757|      0|    if(data->set.fdebug) {
  758|      0|      Curl_set_in_callback(data, true);
  759|      0|      rc = (*data->set.fdebug)(data, type, ptr, size, data->set.debugdata);
  760|      0|      Curl_set_in_callback(data, false);
  761|      0|    }
  762|      0|    else {
  763|      0|      switch(type) {
  764|      0|      case CURLINFO_TEXT:
  765|      0|      case CURLINFO_HEADER_OUT:
  766|      0|      case CURLINFO_HEADER_IN:
  767|      0|        fwrite(s_infotype[type], 2, 1, data->set.err);
  768|      0|        fwrite(ptr, size, 1, data->set.err);
  769|       |#ifdef CURL_DOES_CONVERSIONS
  770|       |        if(size != conv_size) {
  771|       |          /* we had untranslated data so we need an explicit newline */
  772|       |          fwrite("\n", 1, 1, data->set.err);
  773|       |        }
  774|       |#endif
  775|      0|        break;
  776|      0|      default: /* nada */
  777|      0|        break;
  778|      0|      }
  779|      0|    }
  780|       |#ifdef CURL_DOES_CONVERSIONS
  781|       |    free(buf);
  782|       |#endif
  783|      0|  }
  784|  74.7k|  return rc;
  785|  74.7k|}
sendf.c:convert_lineends:
   64|      1|{
   65|      1|  char *inPtr, *outPtr;
   66|       |
   67|       |  /* sanity check */
   68|      1|  if(!startPtr || (size < 1)) {
   69|      0|    return size;
   70|      0|  }
   71|       |
   72|      1|  if(data->state.prev_block_had_trailing_cr) {
   73|       |    /* The previous block of incoming data
   74|       |       had a trailing CR, which was turned into a LF. */
   75|      0|    if(*startPtr == '\n') {
   76|       |      /* This block of incoming data starts with the
   77|       |         previous block's LF so get rid of it */
   78|      0|      memmove(startPtr, startPtr + 1, size-1);
   79|      0|      size--;
   80|       |      /* and it wasn't a bare CR but a CRLF conversion instead */
   81|      0|      data->state.crlf_conversions++;
   82|      0|    }
   83|      0|    data->state.prev_block_had_trailing_cr = FALSE; /* reset the flag */
   84|      0|  }
   85|       |
   86|       |  /* find 1st CR, if any */
   87|      1|  inPtr = outPtr = memchr(startPtr, '\r', size);
   88|      1|  if(inPtr) {
   89|       |    /* at least one CR, now look for CRLF */
   90|      2|    while(inPtr < (startPtr + size-1)) {
   91|       |      /* note that it's size-1, so we'll never look past the last byte */
   92|      1|      if(memcmp(inPtr, "\r\n", 2) == 0) {
   93|       |        /* CRLF found, bump past the CR and copy the NL */
   94|      1|        inPtr++;
   95|      1|        *outPtr = *inPtr;
   96|       |        /* keep track of how many CRLFs we converted */
   97|      1|        data->state.crlf_conversions++;
   98|      1|      }
   99|      0|      else {
  100|      0|        if(*inPtr == '\r') {
  101|       |          /* lone CR, move LF instead */
  102|      0|          *outPtr = '\n';
  103|      0|        }
  104|      0|        else {
  105|       |          /* not a CRLF nor a CR, just copy whatever it is */
  106|      0|          *outPtr = *inPtr;
  107|      0|        }
  108|      0|      }
  109|      1|      outPtr++;
  110|      1|      inPtr++;
  111|      1|    } /* end of while loop */
  112|       |
  113|      1|    if(inPtr < startPtr + size) {
  114|       |      /* handle last byte */
  115|      0|      if(*inPtr == '\r') {
  116|       |        /* deal with a CR at the end of the buffer */
  117|      0|        *outPtr = '\n'; /* copy a NL instead */
  118|       |        /* note that a CRLF might be split across two blocks */
  119|      0|        data->state.prev_block_had_trailing_cr = TRUE;
  120|      0|      }
  121|      0|      else {
  122|       |        /* copy last byte */
  123|      0|        *outPtr = *inPtr;
  124|      0|      }
  125|      0|      outPtr++;
  126|      0|    }
  127|      1|    if(outPtr < startPtr + size)
  128|       |      /* tidy up by null terminating the now shorter data */
  129|      1|      *outPtr = '\0';
  130|       |
  131|      1|    return (outPtr - startPtr);
  132|      1|  }
  133|      0|  return size;
  134|      1|}
sendf.c:chop_write:
  526|  76.2k|{
  527|  76.2k|  struct connectdata *conn = data->conn;
  528|  76.2k|  curl_write_callback writeheader = NULL;
  529|  76.2k|  curl_write_callback writebody = NULL;
  530|  76.2k|  char *ptr = optr;
  531|  76.2k|  size_t len = olen;
  532|       |
  533|  76.2k|  if(!len)
  534|      0|    return CURLE_OK;
  535|       |
  536|       |  /* If reading is paused, append this data to the already held data for this
  537|       |     type. */
  538|  76.2k|  if(data->req.keepon & KEEP_RECV_PAUSE)
  539|      0|    return pausewrite(data, type, ptr, len);
  540|       |
  541|       |  /* Determine the callback(s) to use. */
  542|  76.2k|  if(type & CLIENTWRITE_BODY)
  543|  7.02k|    writebody = data->set.fwrite_func;
  544|  76.2k|  if((type & CLIENTWRITE_HEADER) &&
  545|  76.2k|     (data->set.fwrite_header || data->set.writeheader)) {
  546|       |    /*
  547|       |     * Write headers to the same callback or to the especially setup
  548|       |     * header callback function (added after version 7.7.1).
  549|       |     */
  550|      0|    writeheader =
  551|      0|      data->set.fwrite_header? data->set.fwrite_header: data->set.fwrite_func;
  552|      0|  }
  553|       |
  554|       |  /* Chop data, write chunks. */
  555|   152k|  while(len) {
  556|  76.2k|    size_t chunklen = len <= CURL_MAX_WRITE_SIZE? len: CURL_MAX_WRITE_SIZE;
  557|       |
  558|  76.2k|    if(writebody) {
  559|  7.02k|      size_t wrote;
  560|  7.02k|      Curl_set_in_callback(data, true);
  561|  7.02k|      wrote = writebody(ptr, 1, chunklen, data->set.out);
  562|  7.02k|      Curl_set_in_callback(data, false);
  563|       |
  564|  7.02k|      if(CURL_WRITEFUNC_PAUSE == wrote) {
  565|      0|        if(conn->handler->flags & PROTOPT_NONETWORK) {
  566|       |          /* Protocols that work without network cannot be paused. This is
  567|       |             actually only FILE:// just now, and it can't pause since the
  568|       |             transfer isn't done using the "normal" procedure. */
  569|      0|          failf(data, "Write callback asked for PAUSE when not supported!");
  570|      0|          return CURLE_WRITE_ERROR;
  571|      0|        }
  572|      0|        return pausewrite(data, type, ptr, len);
  573|      0|      }
  574|  7.02k|      if(wrote != chunklen) {
  575|      0|        failf(data, "Failure writing output to destination");
  576|      0|        return CURLE_WRITE_ERROR;
  577|      0|      }
  578|  7.02k|    }
  579|       |
  580|  76.2k|    ptr += chunklen;
  581|  76.2k|    len -= chunklen;
  582|  76.2k|  }
  583|       |
  584|  76.2k|  if(writeheader) {
  585|      0|    size_t wrote;
  586|      0|    ptr = optr;
  587|      0|    len = olen;
  588|      0|    Curl_set_in_callback(data, true);
  589|      0|    wrote = writeheader(ptr, 1, len, data->set.writeheader);
  590|      0|    Curl_set_in_callback(data, false);
  591|       |
  592|      0|    if(CURL_WRITEFUNC_PAUSE == wrote)
  593|       |      /* here we pass in the HEADER bit only since if this was body as well
  594|       |         then it was passed already and clearly that didn't trigger the
  595|       |         pause, so this is saved for later with the HEADER bit only */
  596|      0|      return pausewrite(data, CLIENTWRITE_HEADER, ptr, len);
  597|       |
  598|      0|    if(wrote != len) {
  599|      0|      failf(data, "Failed writing header");
  600|      0|      return CURLE_WRITE_ERROR;
  601|      0|    }
  602|      0|  }
  603|       |
  604|  76.2k|  return CURLE_OK;
  605|  76.2k|}

Curl_setstropt:
   58|  31.7k|{
   59|       |  /* Release the previous storage at `charp' and replace by a dynamic storage
   60|       |     copy of `s'. Return CURLE_OK or CURLE_OUT_OF_MEMORY. */
   61|       |
   62|  31.7k|  Curl_safefree(*charp);
   63|       |
   64|  31.7k|  if(s) {
   65|  20.2k|    char *str = strdup(s);
   66|       |
   67|  20.2k|    if(str) {
   68|  20.2k|      size_t len = strlen(str);
   69|  20.2k|      if(len > CURL_MAX_INPUT_LENGTH) {
   70|      0|        free(str);
   71|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
   72|      0|      }
   73|  20.2k|    }
   74|  20.2k|    if(!str)
   75|      0|      return CURLE_OUT_OF_MEMORY;
   76|       |
   77|  20.2k|    *charp = str;
   78|  20.2k|  }
   79|       |
   80|  31.7k|  return CURLE_OK;
   81|  31.7k|}
Curl_vsetopt:
  161|  41.8k|{
  162|  41.8k|  char *argptr;
  163|  41.8k|  CURLcode result = CURLE_OK;
  164|  41.8k|  long arg;
  165|  41.8k|  unsigned long uarg;
  166|  41.8k|  curl_off_t bigsize;
  167|       |
  168|  41.8k|  switch(option) {
  169|      0|  case CURLOPT_DNS_CACHE_TIMEOUT:
  170|      0|    arg = va_arg(param, long);
  171|      0|    if(arg < -1)
  172|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  173|      0|    data->set.dns_cache_timeout = arg;
  174|      0|    break;
  175|      0|  case CURLOPT_DNS_USE_GLOBAL_CACHE:
  176|       |    /* deprecated */
  177|      0|    break;
  178|      0|  case CURLOPT_SSL_CIPHER_LIST:
  179|       |    /* set a list of cipher we want to use in the SSL connection */
  180|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER_LIST],
  181|      0|                            va_arg(param, char *));
  182|      0|    break;
  183|      0|#ifndef CURL_DISABLE_PROXY
  184|      0|  case CURLOPT_PROXY_SSL_CIPHER_LIST:
  185|       |    /* set a list of cipher we want to use in the SSL connection for proxy */
  186|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER_LIST_PROXY],
  187|      0|                            va_arg(param, char *));
  188|      0|    break;
  189|      0|#endif
  190|      0|  case CURLOPT_TLS13_CIPHERS:
  191|      0|    if(Curl_ssl_tls13_ciphersuites()) {
  192|       |      /* set preferred list of TLS 1.3 cipher suites */
  193|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER13_LIST],
  194|      0|                              va_arg(param, char *));
  195|      0|    }
  196|      0|    else
  197|      0|      return CURLE_NOT_BUILT_IN;
  198|      0|    break;
  199|      0|#ifndef CURL_DISABLE_PROXY
  200|      0|  case CURLOPT_PROXY_TLS13_CIPHERS:
  201|      0|    if(Curl_ssl_tls13_ciphersuites()) {
  202|       |      /* set preferred list of TLS 1.3 cipher suites for proxy */
  203|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER13_LIST_PROXY],
  204|      0|                              va_arg(param, char *));
  205|      0|    }
  206|      0|    else
  207|      0|      return CURLE_NOT_BUILT_IN;
  208|      0|    break;
  209|      0|#endif
  210|      0|  case CURLOPT_RANDOM_FILE:
  211|       |    /*
  212|       |     * This is the path name to a file that contains random data to seed
  213|       |     * the random SSL stuff with. The file is only used for reading.
  214|       |     */
  215|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_RANDOM_FILE],
  216|      0|                            va_arg(param, char *));
  217|      0|    break;
  218|      0|  case CURLOPT_EGDSOCKET:
  219|       |    /*
  220|       |     * The Entropy Gathering Daemon socket pathname
  221|       |     */
  222|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_EGDSOCKET],
  223|      0|                            va_arg(param, char *));
  224|      0|    break;
  225|      0|  case CURLOPT_MAXCONNECTS:
  226|       |    /*
  227|       |     * Set the absolute number of maximum simultaneous alive connection that
  228|       |     * libcurl is allowed to have.
  229|       |     */
  230|      0|    arg = va_arg(param, long);
  231|      0|    if(arg < 0)
  232|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  233|      0|    data->set.maxconnects = arg;
  234|      0|    break;
  235|      0|  case CURLOPT_FORBID_REUSE:
  236|       |    /*
  237|       |     * When this transfer is done, it must not be left to be reused by a
  238|       |     * subsequent transfer but shall be closed immediately.
  239|       |     */
  240|      0|    data->set.reuse_forbid = (0 != va_arg(param, long)) ? TRUE : FALSE;
  241|      0|    break;
  242|      0|  case CURLOPT_FRESH_CONNECT:
  243|       |    /*
  244|       |     * This transfer shall not use a previously cached connection but
  245|       |     * should be made with a fresh new connect!
  246|       |     */
  247|      0|    data->set.reuse_fresh = (0 != va_arg(param, long)) ? TRUE : FALSE;
  248|      0|    break;
  249|      0|  case CURLOPT_VERBOSE:
  250|       |    /*
  251|       |     * Verbose means infof() calls that give a lot of information about
  252|       |     * the connection and transfer procedures as well as internal choices.
  253|       |     */
  254|      0|    data->set.verbose = (0 != va_arg(param, long)) ? TRUE : FALSE;
  255|      0|    break;
  256|     10|  case CURLOPT_HEADER:
  257|       |    /*
  258|       |     * Set to include the header in the general data output stream.
  259|       |     */
  260|     10|    data->set.include_header = (0 != va_arg(param, long)) ? TRUE : FALSE;
  261|     10|    break;
  262|      0|  case CURLOPT_NOPROGRESS:
  263|       |    /*
  264|       |     * Shut off the internal supported progress meter
  265|       |     */
  266|      0|    data->set.hide_progress = (0 != va_arg(param, long)) ? TRUE : FALSE;
  267|      0|    if(data->set.hide_progress)
  268|      0|      data->progress.flags |= PGRS_HIDE;
  269|      0|    else
  270|      0|      data->progress.flags &= ~PGRS_HIDE;
  271|      0|    break;
  272|     32|  case CURLOPT_NOBODY:
  273|       |    /*
  274|       |     * Do not include the body part in the output data stream.
  275|       |     */
  276|     32|    data->set.opt_no_body = (0 != va_arg(param, long)) ? TRUE : FALSE;
  277|     32|#ifndef CURL_DISABLE_HTTP
  278|     32|    if(data->set.opt_no_body)
  279|       |      /* in HTTP lingo, no body means using the HEAD request... */
  280|     31|      data->set.method = HTTPREQ_HEAD;
  281|      1|    else if(data->set.method == HTTPREQ_HEAD)
  282|      0|      data->set.method = HTTPREQ_GET;
  283|     32|#endif
  284|     32|    break;
  285|      0|  case CURLOPT_FAILONERROR:
  286|       |    /*
  287|       |     * Don't output the >=400 error code HTML-page, but instead only
  288|       |     * return error.
  289|       |     */
  290|      0|    data->set.http_fail_on_error = (0 != va_arg(param, long)) ? TRUE : FALSE;
  291|      0|    break;
  292|      0|  case CURLOPT_KEEP_SENDING_ON_ERROR:
  293|      0|    data->set.http_keep_sending_on_error = (0 != va_arg(param, long)) ?
  294|      0|      TRUE : FALSE;
  295|      0|    break;
  296|    110|  case CURLOPT_UPLOAD:
  297|    110|  case CURLOPT_PUT:
  298|       |    /*
  299|       |     * We want to sent data to the remote host. If this is HTTP, that equals
  300|       |     * using the PUT request.
  301|       |     */
  302|    110|    data->set.upload = (0 != va_arg(param, long)) ? TRUE : FALSE;
  303|    110|    if(data->set.upload) {
  304|       |      /* If this is HTTP, PUT is what's needed to "upload" */
  305|    110|      data->set.method = HTTPREQ_PUT;
  306|    110|      data->set.opt_no_body = FALSE; /* this is implied */
  307|    110|    }
  308|      0|    else
  309|       |      /* In HTTP, the opposite of upload is GET (unless NOBODY is true as
  310|       |         then this can be changed to HEAD later on) */
  311|      0|      data->set.method = HTTPREQ_GET;
  312|    110|    break;
  313|      0|  case CURLOPT_REQUEST_TARGET:
  314|      0|    result = Curl_setstropt(&data->set.str[STRING_TARGET],
  315|      0|                            va_arg(param, char *));
  316|      0|    break;
  317|      0|  case CURLOPT_FILETIME:
  318|       |    /*
  319|       |     * Try to get the file time of the remote document. The time will
  320|       |     * later (possibly) become available using curl_easy_getinfo().
  321|       |     */
  322|      0|    data->set.get_filetime = (0 != va_arg(param, long)) ? TRUE : FALSE;
  323|      0|    break;
  324|  3.09k|  case CURLOPT_SERVER_RESPONSE_TIMEOUT:
  325|       |    /*
  326|       |     * Option that specifies how quickly an server response must be obtained
  327|       |     * before it is considered failure. For pingpong protocols.
  328|       |     */
  329|  3.09k|    arg = va_arg(param, long);
  330|  3.09k|    if((arg >= 0) && (arg <= (INT_MAX/1000)))
  331|  3.09k|      data->set.server_response_timeout = arg * 1000;
  332|      0|    else
  333|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  334|  3.09k|    break;
  335|  3.09k|#ifndef CURL_DISABLE_TFTP
  336|  3.09k|  case CURLOPT_TFTP_NO_OPTIONS:
  337|       |    /*
  338|       |     * Option that prevents libcurl from sending TFTP option requests to the
  339|       |     * server.
  340|       |     */
  341|      0|    data->set.tftp_no_options = va_arg(param, long) != 0;
  342|      0|    break;
  343|      0|  case CURLOPT_TFTP_BLKSIZE:
  344|       |    /*
  345|       |     * TFTP option that specifies the block size to use for data transmission.
  346|       |     */
  347|      0|    arg = va_arg(param, long);
  348|      0|    if(arg < 0)
  349|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  350|      0|    data->set.tftp_blksize = arg;
  351|      0|    break;
  352|      0|#endif
  353|      0|#ifndef CURL_DISABLE_NETRC
  354|      0|  case CURLOPT_NETRC:
  355|       |    /*
  356|       |     * Parse the $HOME/.netrc file
  357|       |     */
  358|      0|    arg = va_arg(param, long);
  359|      0|    if((arg < CURL_NETRC_IGNORED) || (arg >= CURL_NETRC_LAST))
  360|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  361|      0|    data->set.use_netrc = (enum CURL_NETRC_OPTION)arg;
  362|      0|    break;
  363|      0|  case CURLOPT_NETRC_FILE:
  364|       |    /*
  365|       |     * Use this file instead of the $HOME/.netrc file
  366|       |     */
  367|      0|    result = Curl_setstropt(&data->set.str[STRING_NETRC_FILE],
  368|      0|                            va_arg(param, char *));
  369|      0|    break;
  370|      0|#endif
  371|      0|  case CURLOPT_TRANSFERTEXT:
  372|       |    /*
  373|       |     * This option was previously named 'FTPASCII'. Renamed to work with
  374|       |     * more protocols than merely FTP.
  375|       |     *
  376|       |     * Transfer using ASCII (instead of BINARY).
  377|       |     */
  378|      0|    data->set.prefer_ascii = (0 != va_arg(param, long)) ? TRUE : FALSE;
  379|      0|    break;
  380|      0|  case CURLOPT_TIMECONDITION:
  381|       |    /*
  382|       |     * Set HTTP time condition. This must be one of the defines in the
  383|       |     * curl/curl.h header file.
  384|       |     */
  385|      0|    arg = va_arg(param, long);
  386|      0|    if((arg < CURL_TIMECOND_NONE) || (arg >= CURL_TIMECOND_LAST))
  387|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  388|      0|    data->set.timecondition = (curl_TimeCond)arg;
  389|      0|    break;
  390|      0|  case CURLOPT_TIMEVALUE:
  391|       |    /*
  392|       |     * This is the value to compare with the remote document with the
  393|       |     * method set with CURLOPT_TIMECONDITION
  394|       |     */
  395|      0|    data->set.timevalue = (time_t)va_arg(param, long);
  396|      0|    break;
  397|       |
  398|      0|  case CURLOPT_TIMEVALUE_LARGE:
  399|       |    /*
  400|       |     * This is the value to compare with the remote document with the
  401|       |     * method set with CURLOPT_TIMECONDITION
  402|       |     */
  403|      0|    data->set.timevalue = (time_t)va_arg(param, curl_off_t);
  404|      0|    break;
  405|       |
  406|      0|  case CURLOPT_SSLVERSION:
  407|      0|#ifndef CURL_DISABLE_PROXY
  408|      0|  case CURLOPT_PROXY_SSLVERSION:
  409|      0|#endif
  410|       |    /*
  411|       |     * Set explicit SSL version to try to connect with, as some SSL
  412|       |     * implementations are lame.
  413|       |     */
  414|      0|#ifdef USE_SSL
  415|      0|    {
  416|      0|      long version, version_max;
  417|      0|      struct ssl_primary_config *primary = &data->set.ssl.primary;
  418|      0|#ifndef CURL_DISABLE_PROXY
  419|      0|      if(option != CURLOPT_SSLVERSION)
  420|      0|        primary = &data->set.proxy_ssl.primary;
  421|      0|#endif
  422|       |
  423|      0|      arg = va_arg(param, long);
  424|       |
  425|      0|      version = C_SSLVERSION_VALUE(arg);
  426|      0|      version_max = C_SSLVERSION_MAX_VALUE(arg);
  427|       |
  428|      0|      if(version < CURL_SSLVERSION_DEFAULT ||
  429|      0|         version == CURL_SSLVERSION_SSLv2 ||
  430|      0|         version == CURL_SSLVERSION_SSLv3 ||
  431|      0|         version >= CURL_SSLVERSION_LAST ||
  432|      0|         version_max < CURL_SSLVERSION_MAX_NONE ||
  433|      0|         version_max >= CURL_SSLVERSION_MAX_LAST)
  434|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
  435|       |
  436|      0|      primary->version = version;
  437|      0|      primary->version_max = version_max;
  438|      0|    }
  439|       |#else
  440|       |    result = CURLE_NOT_BUILT_IN;
  441|       |#endif
  442|      0|    break;
  443|       |
  444|       |    /* MQTT "borrows" some of the HTTP options */
  445|      0|#if !defined(CURL_DISABLE_HTTP) || !defined(CURL_DISABLE_MQTT)
  446|      0|  case CURLOPT_COPYPOSTFIELDS:
  447|       |    /*
  448|       |     * A string with POST data. Makes curl HTTP POST. Even if it is NULL.
  449|       |     * If needed, CURLOPT_POSTFIELDSIZE must have been set prior to
  450|       |     *  CURLOPT_COPYPOSTFIELDS and not altered later.
  451|       |     */
  452|      0|    argptr = va_arg(param, char *);
  453|       |
  454|      0|    if(!argptr || data->set.postfieldsize == -1)
  455|      0|      result = Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], argptr);
  456|      0|    else {
  457|       |      /*
  458|       |       *  Check that requested length does not overflow the size_t type.
  459|       |       */
  460|       |
  461|      0|      if((data->set.postfieldsize < 0) ||
  462|      0|         ((sizeof(curl_off_t) != sizeof(size_t)) &&
  463|      0|          (data->set.postfieldsize > (curl_off_t)((size_t)-1))))
  464|      0|        result = CURLE_OUT_OF_MEMORY;
  465|      0|      else {
  466|      0|        char *p;
  467|       |
  468|      0|        (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  469|       |
  470|       |        /* Allocate even when size == 0. This satisfies the need of possible
  471|       |           later address compare to detect the COPYPOSTFIELDS mode, and
  472|       |           to mark that postfields is used rather than read function or
  473|       |           form data.
  474|       |        */
  475|      0|        p = malloc((size_t)(data->set.postfieldsize?
  476|      0|                            data->set.postfieldsize:1));
  477|       |
  478|      0|        if(!p)
  479|      0|          result = CURLE_OUT_OF_MEMORY;
  480|      0|        else {
  481|      0|          if(data->set.postfieldsize)
  482|      0|            memcpy(p, argptr, (size_t)data->set.postfieldsize);
  483|       |
  484|      0|          data->set.str[STRING_COPYPOSTFIELDS] = p;
  485|      0|        }
  486|      0|      }
  487|      0|    }
  488|       |
  489|      0|    data->set.postfields = data->set.str[STRING_COPYPOSTFIELDS];
  490|      0|    data->set.method = HTTPREQ_POST;
  491|      0|    break;
  492|       |
  493|     27|  case CURLOPT_POSTFIELDS:
  494|       |    /*
  495|       |     * Like above, but use static data instead of copying it.
  496|       |     */
  497|     27|    data->set.postfields = va_arg(param, void *);
  498|       |    /* Release old copied data. */
  499|     27|    (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  500|     27|    data->set.method = HTTPREQ_POST;
  501|     27|    break;
  502|       |
  503|      0|  case CURLOPT_POSTFIELDSIZE:
  504|       |    /*
  505|       |     * The size of the POSTFIELD data to prevent libcurl to do strlen() to
  506|       |     * figure it out. Enables binary posts.
  507|       |     */
  508|      0|    bigsize = va_arg(param, long);
  509|      0|    if(bigsize < -1)
  510|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  511|       |
  512|      0|    if(data->set.postfieldsize < bigsize &&
  513|      0|       data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {
  514|       |      /* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */
  515|      0|      (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  516|      0|      data->set.postfields = NULL;
  517|      0|    }
  518|       |
  519|      0|    data->set.postfieldsize = bigsize;
  520|      0|    break;
  521|       |
  522|      0|  case CURLOPT_POSTFIELDSIZE_LARGE:
  523|       |    /*
  524|       |     * The size of the POSTFIELD data to prevent libcurl to do strlen() to
  525|       |     * figure it out. Enables binary posts.
  526|       |     */
  527|      0|    bigsize = va_arg(param, curl_off_t);
  528|      0|    if(bigsize < -1)
  529|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  530|       |
  531|      0|    if(data->set.postfieldsize < bigsize &&
  532|      0|       data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {
  533|       |      /* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */
  534|      0|      (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  535|      0|      data->set.postfields = NULL;
  536|      0|    }
  537|       |
  538|      0|    data->set.postfieldsize = bigsize;
  539|      0|    break;
  540|      0|#endif
  541|      0|#ifndef CURL_DISABLE_HTTP
  542|      0|  case CURLOPT_AUTOREFERER:
  543|       |    /*
  544|       |     * Switch on automatic referer that gets set if curl follows locations.
  545|       |     */
  546|      0|    data->set.http_auto_referer = (0 != va_arg(param, long)) ? TRUE : FALSE;
  547|      0|    break;
  548|       |
  549|    117|  case CURLOPT_ACCEPT_ENCODING:
  550|       |    /*
  551|       |     * String to use at the value of Accept-Encoding header.
  552|       |     *
  553|       |     * If the encoding is set to "" we use an Accept-Encoding header that
  554|       |     * encompasses all the encodings we support.
  555|       |     * If the encoding is set to NULL we don't send an Accept-Encoding header
  556|       |     * and ignore an received Content-Encoding header.
  557|       |     *
  558|       |     */
  559|    117|    argptr = va_arg(param, char *);
  560|    117|    if(argptr && !*argptr) {
  561|    114|      argptr = Curl_all_content_encodings();
  562|    114|      if(!argptr)
  563|      0|        result = CURLE_OUT_OF_MEMORY;
  564|    114|      else {
  565|    114|        result = Curl_setstropt(&data->set.str[STRING_ENCODING], argptr);
  566|    114|        free(argptr);
  567|    114|      }
  568|    114|    }
  569|      3|    else
  570|      3|      result = Curl_setstropt(&data->set.str[STRING_ENCODING], argptr);
  571|    117|    break;
  572|       |
  573|      0|  case CURLOPT_TRANSFER_ENCODING:
  574|      0|    data->set.http_transfer_encoding = (0 != va_arg(param, long)) ?
  575|      0|      TRUE : FALSE;
  576|      0|    break;
  577|       |
  578|     64|  case CURLOPT_FOLLOWLOCATION:
  579|       |    /*
  580|       |     * Follow Location: header hints on a HTTP-server.
  581|       |     */
  582|     64|    data->set.http_follow_location = (0 != va_arg(param, long)) ? TRUE : FALSE;
  583|     64|    break;
  584|       |
  585|      0|  case CURLOPT_UNRESTRICTED_AUTH:
  586|       |    /*
  587|       |     * Send authentication (user+password) when following locations, even when
  588|       |     * hostname changed.
  589|       |     */
  590|      0|    data->set.allow_auth_to_other_hosts =
  591|      0|      (0 != va_arg(param, long)) ? TRUE : FALSE;
  592|      0|    break;
  593|       |
  594|      0|  case CURLOPT_MAXREDIRS:
  595|       |    /*
  596|       |     * The maximum amount of hops you allow curl to follow Location:
  597|       |     * headers. This should mostly be used to detect never-ending loops.
  598|       |     */
  599|      0|    arg = va_arg(param, long);
  600|      0|    if(arg < -1)
  601|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  602|      0|    data->set.maxredirs = arg;
  603|      0|    break;
  604|       |
  605|      0|  case CURLOPT_POSTREDIR:
  606|       |    /*
  607|       |     * Set the behavior of POST when redirecting
  608|       |     * CURL_REDIR_GET_ALL - POST is changed to GET after 301 and 302
  609|       |     * CURL_REDIR_POST_301 - POST is kept as POST after 301
  610|       |     * CURL_REDIR_POST_302 - POST is kept as POST after 302
  611|       |     * CURL_REDIR_POST_303 - POST is kept as POST after 303
  612|       |     * CURL_REDIR_POST_ALL - POST is kept as POST after 301, 302 and 303
  613|       |     * other - POST is kept as POST after 301 and 302
  614|       |     */
  615|      0|    arg = va_arg(param, long);
  616|      0|    if(arg < CURL_REDIR_GET_ALL)
  617|       |      /* no return error on too high numbers since the bitmask could be
  618|       |         extended in a future */
  619|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  620|      0|    data->set.keep_post = arg & CURL_REDIR_POST_ALL;
  621|      0|    break;
  622|       |
  623|      0|  case CURLOPT_POST:
  624|       |    /* Does this option serve a purpose anymore? Yes it does, when
  625|       |       CURLOPT_POSTFIELDS isn't used and the POST data is read off the
  626|       |       callback! */
  627|      0|    if(va_arg(param, long)) {
  628|      0|      data->set.method = HTTPREQ_POST;
  629|      0|      data->set.opt_no_body = FALSE; /* this is implied */
  630|      0|    }
  631|      0|    else
  632|      0|      data->set.method = HTTPREQ_GET;
  633|      0|    break;
  634|       |
  635|      0|  case CURLOPT_HTTPPOST:
  636|       |    /*
  637|       |     * Set to make us do HTTP POST
  638|       |     */
  639|      0|    data->set.httppost = va_arg(param, struct curl_httppost *);
  640|      0|    data->set.method = HTTPREQ_POST_FORM;
  641|      0|    data->set.opt_no_body = FALSE; /* this is implied */
  642|      0|    break;
  643|       |
  644|      0|  case CURLOPT_AWS_SIGV4:
  645|       |    /*
  646|       |     * String that is merged to some authentication
  647|       |     * parameters are used by the algorithm.
  648|       |     */
  649|      0|    result = Curl_setstropt(&data->set.str[STRING_AWS_SIGV4],
  650|      0|                            va_arg(param, char *));
  651|       |    /*
  652|       |     * Basic been set by default it need to be unset here
  653|       |     */
  654|      0|    if(data->set.str[STRING_AWS_SIGV4])
  655|      0|      data->set.httpauth = CURLAUTH_AWS_SIGV4;
  656|      0|    break;
  657|       |
  658|    270|  case CURLOPT_MIMEPOST:
  659|       |    /*
  660|       |     * Set to make us do MIME/form POST
  661|       |     */
  662|    270|    result = Curl_mime_set_subparts(&data->set.mimepost,
  663|    270|                                    va_arg(param, curl_mime *), FALSE);
  664|    270|    if(!result) {
  665|    270|      data->set.method = HTTPREQ_POST_MIME;
  666|    270|      data->set.opt_no_body = FALSE; /* this is implied */
  667|    270|    }
  668|    270|    break;
  669|       |
  670|      0|  case CURLOPT_REFERER:
  671|       |    /*
  672|       |     * String to set in the HTTP Referer: field.
  673|       |     */
  674|      0|    if(data->state.referer_alloc) {
  675|      0|      Curl_safefree(data->state.referer);
  676|      0|      data->state.referer_alloc = FALSE;
  677|      0|    }
  678|      0|    result = Curl_setstropt(&data->set.str[STRING_SET_REFERER],
  679|      0|                            va_arg(param, char *));
  680|      0|    data->state.referer = data->set.str[STRING_SET_REFERER];
  681|      0|    break;
  682|       |
  683|      0|  case CURLOPT_USERAGENT:
  684|       |    /*
  685|       |     * String to use in the HTTP User-Agent field
  686|       |     */
  687|      0|    result = Curl_setstropt(&data->set.str[STRING_USERAGENT],
  688|      0|                            va_arg(param, char *));
  689|      0|    break;
  690|       |
  691|    148|  case CURLOPT_HTTPHEADER:
  692|       |    /*
  693|       |     * Set a list with HTTP headers to use (or replace internals with)
  694|       |     */
  695|    148|    data->set.headers = va_arg(param, struct curl_slist *);
  696|    148|    break;
  697|       |
  698|      0|#ifndef CURL_DISABLE_PROXY
  699|      0|  case CURLOPT_PROXYHEADER:
  700|       |    /*
  701|       |     * Set a list with proxy headers to use (or replace internals with)
  702|       |     *
  703|       |     * Since CURLOPT_HTTPHEADER was the only way to set HTTP headers for a
  704|       |     * long time we remain doing it this way until CURLOPT_PROXYHEADER is
  705|       |     * used. As soon as this option has been used, if set to anything but
  706|       |     * NULL, custom headers for proxies are only picked from this list.
  707|       |     *
  708|       |     * Set this option to NULL to restore the previous behavior.
  709|       |     */
  710|      0|    data->set.proxyheaders = va_arg(param, struct curl_slist *);
  711|      0|    break;
  712|      0|#endif
  713|      0|  case CURLOPT_HEADEROPT:
  714|       |    /*
  715|       |     * Set header option.
  716|       |     */
  717|      0|    arg = va_arg(param, long);
  718|      0|    data->set.sep_headers = (bool)((arg & CURLHEADER_SEPARATE)? TRUE: FALSE);
  719|      0|    break;
  720|       |
  721|      0|  case CURLOPT_HTTP200ALIASES:
  722|       |    /*
  723|       |     * Set a list of aliases for HTTP 200 in response header
  724|       |     */
  725|      0|    data->set.http200aliases = va_arg(param, struct curl_slist *);
  726|      0|    break;
  727|       |
  728|      0|#if !defined(CURL_DISABLE_COOKIES)
  729|      7|  case CURLOPT_COOKIE:
  730|       |    /*
  731|       |     * Cookie string to send to the remote server in the request.
  732|       |     */
  733|      7|    result = Curl_setstropt(&data->set.str[STRING_COOKIE],
  734|      7|                            va_arg(param, char *));
  735|      7|    break;
  736|       |
  737|      0|  case CURLOPT_COOKIEFILE:
  738|       |    /*
  739|       |     * Set cookie file to read and parse. Can be used multiple times.
  740|       |     */
  741|      0|    argptr = (char *)va_arg(param, void *);
  742|      0|    if(argptr) {
  743|      0|      struct curl_slist *cl;
  744|       |      /* general protection against mistakes and abuse */
  745|      0|      if(strlen(argptr) > CURL_MAX_INPUT_LENGTH)
  746|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
  747|       |      /* append the cookie file name to the list of file names, and deal with
  748|       |         them later */
  749|      0|      cl = curl_slist_append(data->state.cookielist, argptr);
  750|      0|      if(!cl) {
  751|      0|        curl_slist_free_all(data->state.cookielist);
  752|      0|        data->state.cookielist = NULL;
  753|      0|        return CURLE_OUT_OF_MEMORY;
  754|      0|      }
  755|      0|      data->state.cookielist = cl; /* store the list for later use */
  756|      0|    }
  757|      0|    else {
  758|       |      /* clear the list of cookie files */
  759|      0|      curl_slist_free_all(data->state.cookielist);
  760|      0|      data->state.cookielist = NULL;
  761|       |
  762|      0|      if(!data->share || !data->share->cookies) {
  763|       |        /* throw away all existing cookies if this isn't a shared cookie
  764|       |           container */
  765|      0|        Curl_cookie_clearall(data->cookies);
  766|      0|        Curl_cookie_cleanup(data->cookies);
  767|      0|      }
  768|       |      /* disable the cookie engine */
  769|      0|      data->cookies = NULL;
  770|      0|    }
  771|      0|    break;
  772|       |
  773|  3.09k|  case CURLOPT_COOKIEJAR:
  774|       |    /*
  775|       |     * Set cookie file name to dump all cookies to when we're done.
  776|       |     */
  777|  3.09k|  {
  778|  3.09k|    struct CookieInfo *newcookies;
  779|  3.09k|    result = Curl_setstropt(&data->set.str[STRING_COOKIEJAR],
  780|  3.09k|                            va_arg(param, char *));
  781|       |
  782|       |    /*
  783|       |     * Activate the cookie parser. This may or may not already
  784|       |     * have been made.
  785|       |     */
  786|  3.09k|    newcookies = Curl_cookie_init(data, NULL, data->cookies,
  787|  3.09k|                                  data->set.cookiesession);
  788|  3.09k|    if(!newcookies)
  789|      0|      result = CURLE_OUT_OF_MEMORY;
  790|  3.09k|    data->cookies = newcookies;
  791|  3.09k|  }
  792|  3.09k|  break;
  793|       |
  794|      0|  case CURLOPT_COOKIESESSION:
  795|       |    /*
  796|       |     * Set this option to TRUE to start a new "cookie session". It will
  797|       |     * prevent the forthcoming read-cookies-from-file actions to accept
  798|       |     * cookies that are marked as being session cookies, as they belong to a
  799|       |     * previous session.
  800|       |     *
  801|       |     * In the original Netscape cookie spec, "session cookies" are cookies
  802|       |     * with no expire date set. RFC2109 describes the same action if no
  803|       |     * 'Max-Age' is set and RFC2965 includes the RFC2109 description and adds
  804|       |     * a 'Discard' action that can enforce the discard even for cookies that
  805|       |     * have a Max-Age.
  806|       |     *
  807|       |     * We run mostly with the original cookie spec, as hardly anyone implements
  808|       |     * anything else.
  809|       |     */
  810|      0|    data->set.cookiesession = (0 != va_arg(param, long)) ? TRUE : FALSE;
  811|      0|    break;
  812|       |
  813|      0|  case CURLOPT_COOKIELIST:
  814|      0|    argptr = va_arg(param, char *);
  815|       |
  816|      0|    if(!argptr)
  817|      0|      break;
  818|       |
  819|      0|    if(strcasecompare(argptr, "ALL")) {
  820|       |      /* clear all cookies */
  821|      0|      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
  822|      0|      Curl_cookie_clearall(data->cookies);
  823|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
  824|      0|    }
  825|      0|    else if(strcasecompare(argptr, "SESS")) {
  826|       |      /* clear session cookies */
  827|      0|      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
  828|      0|      Curl_cookie_clearsess(data->cookies);
  829|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
  830|      0|    }
  831|      0|    else if(strcasecompare(argptr, "FLUSH")) {
  832|       |      /* flush cookies to file, takes care of the locking */
  833|      0|      Curl_flush_cookies(data, FALSE);
  834|      0|    }
  835|      0|    else if(strcasecompare(argptr, "RELOAD")) {
  836|       |      /* reload cookies from file */
  837|      0|      Curl_cookie_loadfiles(data);
  838|      0|      break;
  839|      0|    }
  840|      0|    else {
  841|      0|      if(!data->cookies)
  842|       |        /* if cookie engine was not running, activate it */
  843|      0|        data->cookies = Curl_cookie_init(data, NULL, NULL, TRUE);
  844|       |
  845|       |      /* general protection against mistakes and abuse */
  846|      0|      if(strlen(argptr) > CURL_MAX_INPUT_LENGTH)
  847|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
  848|      0|      argptr = strdup(argptr);
  849|      0|      if(!argptr || !data->cookies) {
  850|      0|        result = CURLE_OUT_OF_MEMORY;
  851|      0|        free(argptr);
  852|      0|      }
  853|      0|      else {
  854|      0|        Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
  855|       |
  856|      0|        if(checkprefix("Set-Cookie:", argptr))
  857|       |          /* HTTP Header format line */
  858|      0|          Curl_cookie_add(data, data->cookies, TRUE, FALSE, argptr + 11, NULL,
  859|      0|                          NULL, TRUE);
  860|       |
  861|      0|        else
  862|       |          /* Netscape format line */
  863|      0|          Curl_cookie_add(data, data->cookies, FALSE, FALSE, argptr, NULL,
  864|      0|                          NULL, TRUE);
  865|       |
  866|      0|        Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
  867|      0|        free(argptr);
  868|      0|      }
  869|      0|    }
  870|       |
  871|      0|    break;
  872|      0|#endif /* !CURL_DISABLE_COOKIES */
  873|       |
  874|      0|  case CURLOPT_HTTPGET:
  875|       |    /*
  876|       |     * Set to force us do HTTP GET
  877|       |     */
  878|      0|    if(va_arg(param, long)) {
  879|      0|      data->set.method = HTTPREQ_GET;
  880|      0|      data->set.upload = FALSE; /* switch off upload */
  881|      0|      data->set.opt_no_body = FALSE; /* this is implied */
  882|      0|    }
  883|      0|    break;
  884|       |
  885|      4|  case CURLOPT_HTTP_VERSION:
  886|       |    /*
  887|       |     * This sets a requested HTTP version to be used. The value is one of
  888|       |     * the listed enums in curl/curl.h.
  889|       |     */
  890|      4|    arg = va_arg(param, long);
  891|      4|    if(arg < CURL_HTTP_VERSION_NONE)
  892|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  893|       |#ifdef ENABLE_QUIC
  894|       |    if(arg == CURL_HTTP_VERSION_3)
  895|       |      ;
  896|       |    else
  897|       |#endif
  898|       |#if !defined(USE_NGHTTP2) && !defined(USE_HYPER)
  899|       |    if(arg >= CURL_HTTP_VERSION_2)
  900|       |      return CURLE_UNSUPPORTED_PROTOCOL;
  901|       |#else
  902|      4|    if(arg >= CURL_HTTP_VERSION_LAST)
  903|      1|      return CURLE_UNSUPPORTED_PROTOCOL;
  904|      3|    if(arg == CURL_HTTP_VERSION_NONE)
  905|      1|      arg = CURL_HTTP_VERSION_2TLS;
  906|      3|#endif
  907|      3|    data->set.httpwant = (unsigned char)arg;
  908|      3|    break;
  909|       |
  910|      0|  case CURLOPT_EXPECT_100_TIMEOUT_MS:
  911|       |    /*
  912|       |     * Time to wait for a response to a HTTP request containing an
  913|       |     * Expect: 100-continue header before sending the data anyway.
  914|       |     */
  915|      0|    arg = va_arg(param, long);
  916|      0|    if(arg < 0)
  917|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  918|      0|    data->set.expect_100_timeout = arg;
  919|      0|    break;
  920|       |
  921|      0|  case CURLOPT_HTTP09_ALLOWED:
  922|      0|    arg = va_arg(param, unsigned long);
  923|      0|    if(arg > 1L)
  924|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  925|       |#ifdef USE_HYPER
  926|       |    /* Hyper does not support HTTP/0.9 */
  927|       |    if(arg)
  928|       |      return CURLE_BAD_FUNCTION_ARGUMENT;
  929|       |#else
  930|      0|    data->set.http09_allowed = arg ? TRUE : FALSE;
  931|      0|#endif
  932|      0|    break;
  933|      0|#endif   /* CURL_DISABLE_HTTP */
  934|       |
  935|    103|  case CURLOPT_HTTPAUTH:
  936|       |    /*
  937|       |     * Set HTTP Authentication type BITMASK.
  938|       |     */
  939|    103|  {
  940|    103|    int bitcheck;
  941|    103|    bool authbits;
  942|    103|    unsigned long auth = va_arg(param, unsigned long);
  943|       |
  944|    103|    if(auth == CURLAUTH_NONE) {
  945|      5|      data->set.httpauth = auth;
  946|      5|      break;
  947|      5|    }
  948|       |
  949|       |    /* the DIGEST_IE bit is only used to set a special marker, for all the
  950|       |       rest we need to handle it as normal DIGEST */
  951|     98|    data->state.authhost.iestyle =
  952|     98|      (bool)((auth & CURLAUTH_DIGEST_IE) ? TRUE : FALSE);
  953|       |
  954|     98|    if(auth & CURLAUTH_DIGEST_IE) {
  955|     27|      auth |= CURLAUTH_DIGEST; /* set standard digest bit */
  956|     27|      auth &= ~CURLAUTH_DIGEST_IE; /* unset ie digest bit */
  957|     27|    }
  958|       |
  959|       |    /* switch off bits we can't support */
  960|       |#ifndef USE_NTLM
  961|       |    auth &= ~CURLAUTH_NTLM;    /* no NTLM support */
  962|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
  963|       |#elif !defined(NTLM_WB_ENABLED)
  964|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
  965|       |#endif
  966|     98|#ifndef USE_SPNEGO
  967|     98|    auth &= ~CURLAUTH_NEGOTIATE; /* no Negotiate (SPNEGO) auth without
  968|       |                                    GSS-API or SSPI */
  969|     98|#endif
  970|       |
  971|       |    /* check if any auth bit lower than CURLAUTH_ONLY is still set */
  972|     98|    bitcheck = 0;
  973|     98|    authbits = FALSE;
  974|    298|    while(bitcheck < 31) {
  975|    297|      if(auth & (1UL << bitcheck++)) {
  976|     97|        authbits = TRUE;
  977|     97|        break;
  978|     97|      }
  979|    297|    }
  980|     98|    if(!authbits)
  981|      1|      return CURLE_NOT_BUILT_IN; /* no supported types left! */
  982|       |
  983|     97|    data->set.httpauth = auth;
  984|     97|  }
  985|      0|  break;
  986|       |
  987|    197|  case CURLOPT_CUSTOMREQUEST:
  988|       |    /*
  989|       |     * Set a custom string to use as request
  990|       |     */
  991|    197|    result = Curl_setstropt(&data->set.str[STRING_CUSTOMREQUEST],
  992|    197|                            va_arg(param, char *));
  993|       |
  994|       |    /* we don't set
  995|       |       data->set.method = HTTPREQ_CUSTOM;
  996|       |       here, we continue as if we were using the already set type
  997|       |       and this just changes the actual request keyword */
  998|    197|    break;
  999|       |
 1000|      0|#ifndef CURL_DISABLE_PROXY
 1001|      0|  case CURLOPT_HTTPPROXYTUNNEL:
 1002|       |    /*
 1003|       |     * Tunnel operations through the proxy instead of normal proxy use
 1004|       |     */
 1005|      0|    data->set.tunnel_thru_httpproxy = (0 != va_arg(param, long)) ?
 1006|      0|      TRUE : FALSE;
 1007|      0|    break;
 1008|       |
 1009|      0|  case CURLOPT_PROXYPORT:
 1010|       |    /*
 1011|       |     * Explicitly set HTTP proxy port number.
 1012|       |     */
 1013|      0|    arg = va_arg(param, long);
 1014|      0|    if((arg < 0) || (arg > 65535))
 1015|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1016|      0|    data->set.proxyport = arg;
 1017|      0|    break;
 1018|       |
 1019|      0|  case CURLOPT_PROXYAUTH:
 1020|       |    /*
 1021|       |     * Set HTTP Authentication type BITMASK.
 1022|       |     */
 1023|      0|  {
 1024|      0|    int bitcheck;
 1025|      0|    bool authbits;
 1026|      0|    unsigned long auth = va_arg(param, unsigned long);
 1027|       |
 1028|      0|    if(auth == CURLAUTH_NONE) {
 1029|      0|      data->set.proxyauth = auth;
 1030|      0|      break;
 1031|      0|    }
 1032|       |
 1033|       |    /* the DIGEST_IE bit is only used to set a special marker, for all the
 1034|       |       rest we need to handle it as normal DIGEST */
 1035|      0|    data->state.authproxy.iestyle =
 1036|      0|      (bool)((auth & CURLAUTH_DIGEST_IE) ? TRUE : FALSE);
 1037|       |
 1038|      0|    if(auth & CURLAUTH_DIGEST_IE) {
 1039|      0|      auth |= CURLAUTH_DIGEST; /* set standard digest bit */
 1040|      0|      auth &= ~CURLAUTH_DIGEST_IE; /* unset ie digest bit */
 1041|      0|    }
 1042|       |    /* switch off bits we can't support */
 1043|       |#ifndef USE_NTLM
 1044|       |    auth &= ~CURLAUTH_NTLM;    /* no NTLM support */
 1045|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
 1046|       |#elif !defined(NTLM_WB_ENABLED)
 1047|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
 1048|       |#endif
 1049|      0|#ifndef USE_SPNEGO
 1050|      0|    auth &= ~CURLAUTH_NEGOTIATE; /* no Negotiate (SPNEGO) auth without
 1051|       |                                    GSS-API or SSPI */
 1052|      0|#endif
 1053|       |
 1054|       |    /* check if any auth bit lower than CURLAUTH_ONLY is still set */
 1055|      0|    bitcheck = 0;
 1056|      0|    authbits = FALSE;
 1057|      0|    while(bitcheck < 31) {
 1058|      0|      if(auth & (1UL << bitcheck++)) {
 1059|      0|        authbits = TRUE;
 1060|      0|        break;
 1061|      0|      }
 1062|      0|    }
 1063|      0|    if(!authbits)
 1064|      0|      return CURLE_NOT_BUILT_IN; /* no supported types left! */
 1065|       |
 1066|      0|    data->set.proxyauth = auth;
 1067|      0|  }
 1068|      0|  break;
 1069|       |
 1070|      0|  case CURLOPT_PROXY:
 1071|       |    /*
 1072|       |     * Set proxy server:port to use as proxy.
 1073|       |     *
 1074|       |     * If the proxy is set to "" (and CURLOPT_SOCKS_PROXY is set to "" or NULL)
 1075|       |     * we explicitly say that we don't want to use a proxy
 1076|       |     * (even though there might be environment variables saying so).
 1077|       |     *
 1078|       |     * Setting it to NULL, means no proxy but allows the environment variables
 1079|       |     * to decide for us (if CURLOPT_SOCKS_PROXY setting it to NULL).
 1080|       |     */
 1081|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXY],
 1082|      0|                            va_arg(param, char *));
 1083|      0|    break;
 1084|       |
 1085|      0|  case CURLOPT_PRE_PROXY:
 1086|       |    /*
 1087|       |     * Set proxy server:port to use as SOCKS proxy.
 1088|       |     *
 1089|       |     * If the proxy is set to "" or NULL we explicitly say that we don't want
 1090|       |     * to use the socks proxy.
 1091|       |     */
 1092|      0|    result = Curl_setstropt(&data->set.str[STRING_PRE_PROXY],
 1093|      0|                            va_arg(param, char *));
 1094|      0|    break;
 1095|       |
 1096|      0|  case CURLOPT_PROXYTYPE:
 1097|       |    /*
 1098|       |     * Set proxy type. HTTP/HTTP_1_0/SOCKS4/SOCKS4a/SOCKS5/SOCKS5_HOSTNAME
 1099|       |     */
 1100|      0|    arg = va_arg(param, long);
 1101|      0|    if((arg < CURLPROXY_HTTP) || (arg > CURLPROXY_SOCKS5_HOSTNAME))
 1102|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1103|      0|    data->set.proxytype = (curl_proxytype)arg;
 1104|      0|    break;
 1105|       |
 1106|      0|  case CURLOPT_PROXY_TRANSFER_MODE:
 1107|       |    /*
 1108|       |     * set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy
 1109|       |     */
 1110|      0|    switch(va_arg(param, long)) {
 1111|      0|    case 0:
 1112|      0|      data->set.proxy_transfer_mode = FALSE;
 1113|      0|      break;
 1114|      0|    case 1:
 1115|      0|      data->set.proxy_transfer_mode = TRUE;
 1116|      0|      break;
 1117|      0|    default:
 1118|       |      /* reserve other values for future use */
 1119|      0|      result = CURLE_BAD_FUNCTION_ARGUMENT;
 1120|      0|      break;
 1121|      0|    }
 1122|      0|    break;
 1123|      0|#endif   /* CURL_DISABLE_PROXY */
 1124|       |
 1125|      0|  case CURLOPT_SOCKS5_AUTH:
 1126|      0|    data->set.socks5auth = va_arg(param, unsigned long);
 1127|      0|    if(data->set.socks5auth & ~(CURLAUTH_BASIC | CURLAUTH_GSSAPI))
 1128|      0|      result = CURLE_NOT_BUILT_IN;
 1129|      0|    break;
 1130|       |#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
 1131|       |  case CURLOPT_SOCKS5_GSSAPI_NEC:
 1132|       |    /*
 1133|       |     * Set flag for NEC SOCK5 support
 1134|       |     */
 1135|       |    data->set.socks5_gssapi_nec = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1136|       |    break;
 1137|       |#endif
 1138|      0|#ifndef CURL_DISABLE_PROXY
 1139|      0|  case CURLOPT_SOCKS5_GSSAPI_SERVICE:
 1140|      0|  case CURLOPT_PROXY_SERVICE_NAME:
 1141|       |    /*
 1142|       |     * Set proxy authentication service name for Kerberos 5 and SPNEGO
 1143|       |     */
 1144|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXY_SERVICE_NAME],
 1145|      0|                            va_arg(param, char *));
 1146|      0|    break;
 1147|      0|#endif
 1148|      0|  case CURLOPT_SERVICE_NAME:
 1149|       |    /*
 1150|       |     * Set authentication service name for DIGEST-MD5, Kerberos 5 and SPNEGO
 1151|       |     */
 1152|      0|    result = Curl_setstropt(&data->set.str[STRING_SERVICE_NAME],
 1153|      0|                            va_arg(param, char *));
 1154|      0|    break;
 1155|       |
 1156|      0|  case CURLOPT_HEADERDATA:
 1157|       |    /*
 1158|       |     * Custom pointer to pass the header write callback function
 1159|       |     */
 1160|      0|    data->set.writeheader = (void *)va_arg(param, void *);
 1161|      0|    break;
 1162|      0|  case CURLOPT_ERRORBUFFER:
 1163|       |    /*
 1164|       |     * Error buffer provided by the caller to get the human readable
 1165|       |     * error string in.
 1166|       |     */
 1167|      0|    data->set.errorbuffer = va_arg(param, char *);
 1168|      0|    break;
 1169|  3.09k|  case CURLOPT_WRITEDATA:
 1170|       |    /*
 1171|       |     * FILE pointer to write to. Or possibly
 1172|       |     * used as argument to the write callback.
 1173|       |     */
 1174|  3.09k|    data->set.out = va_arg(param, void *);
 1175|  3.09k|    break;
 1176|       |
 1177|      0|  case CURLOPT_DIRLISTONLY:
 1178|       |    /*
 1179|       |     * An option that changes the command to one that asks for a list only, no
 1180|       |     * file info details. Used for FTP, POP3 and SFTP.
 1181|       |     */
 1182|      0|    data->set.list_only = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1183|      0|    break;
 1184|       |
 1185|      0|  case CURLOPT_APPEND:
 1186|       |    /*
 1187|       |     * We want to upload and append to an existing file. Used for FTP and
 1188|       |     * SFTP.
 1189|       |     */
 1190|      0|    data->set.remote_append = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1191|      0|    break;
 1192|       |
 1193|      0|#ifndef CURL_DISABLE_FTP
 1194|      0|  case CURLOPT_FTP_FILEMETHOD:
 1195|       |    /*
 1196|       |     * How do access files over FTP.
 1197|       |     */
 1198|      0|    arg = va_arg(param, long);
 1199|      0|    if((arg < CURLFTPMETHOD_DEFAULT) || (arg >= CURLFTPMETHOD_LAST))
 1200|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1201|      0|    data->set.ftp_filemethod = (curl_ftpfile)arg;
 1202|      0|    break;
 1203|      0|  case CURLOPT_FTPPORT:
 1204|       |    /*
 1205|       |     * Use FTP PORT, this also specifies which IP address to use
 1206|       |     */
 1207|      0|    result = Curl_setstropt(&data->set.str[STRING_FTPPORT],
 1208|      0|                            va_arg(param, char *));
 1209|      0|    data->set.ftp_use_port = (data->set.str[STRING_FTPPORT]) ? TRUE : FALSE;
 1210|      0|    break;
 1211|       |
 1212|      0|  case CURLOPT_FTP_USE_EPRT:
 1213|      0|    data->set.ftp_use_eprt = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1214|      0|    break;
 1215|       |
 1216|      0|  case CURLOPT_FTP_USE_EPSV:
 1217|      0|    data->set.ftp_use_epsv = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1218|      0|    break;
 1219|       |
 1220|      0|  case CURLOPT_FTP_USE_PRET:
 1221|      0|    data->set.ftp_use_pret = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1222|      0|    break;
 1223|       |
 1224|      0|  case CURLOPT_FTP_SSL_CCC:
 1225|      0|    arg = va_arg(param, long);
 1226|      0|    if((arg < CURLFTPSSL_CCC_NONE) || (arg >= CURLFTPSSL_CCC_LAST))
 1227|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1228|      0|    data->set.ftp_ccc = (curl_ftpccc)arg;
 1229|      0|    break;
 1230|       |
 1231|      0|  case CURLOPT_FTP_SKIP_PASV_IP:
 1232|       |    /*
 1233|       |     * Enable or disable FTP_SKIP_PASV_IP, which will disable/enable the
 1234|       |     * bypass of the IP address in PASV responses.
 1235|       |     */
 1236|      0|    data->set.ftp_skip_ip = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1237|      0|    break;
 1238|       |
 1239|      0|  case CURLOPT_FTP_ACCOUNT:
 1240|      0|    result = Curl_setstropt(&data->set.str[STRING_FTP_ACCOUNT],
 1241|      0|                            va_arg(param, char *));
 1242|      0|    break;
 1243|       |
 1244|      0|  case CURLOPT_FTP_ALTERNATIVE_TO_USER:
 1245|      0|    result = Curl_setstropt(&data->set.str[STRING_FTP_ALTERNATIVE_TO_USER],
 1246|      0|                            va_arg(param, char *));
 1247|      0|    break;
 1248|       |
 1249|      0|  case CURLOPT_FTPSSLAUTH:
 1250|       |    /*
 1251|       |     * Set a specific auth for FTP-SSL transfers.
 1252|       |     */
 1253|      0|    arg = va_arg(param, long);
 1254|      0|    if((arg < CURLFTPAUTH_DEFAULT) || (arg >= CURLFTPAUTH_LAST))
 1255|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1256|      0|    data->set.ftpsslauth = (curl_ftpauth)arg;
 1257|      0|    break;
 1258|      0|  case CURLOPT_KRBLEVEL:
 1259|       |    /*
 1260|       |     * A string that defines the kerberos security level.
 1261|       |     */
 1262|      0|    result = Curl_setstropt(&data->set.str[STRING_KRB_LEVEL],
 1263|      0|                            va_arg(param, char *));
 1264|      0|    data->set.krb = (data->set.str[STRING_KRB_LEVEL]) ? TRUE : FALSE;
 1265|      0|    break;
 1266|      0|#endif
 1267|      0|  case CURLOPT_FTP_CREATE_MISSING_DIRS:
 1268|       |    /*
 1269|       |     * An FTP/SFTP option that modifies an upload to create missing
 1270|       |     * directories on the server.
 1271|       |     */
 1272|      0|    arg = va_arg(param, long);
 1273|       |    /* reserve other values for future use */
 1274|      0|    if((arg < CURLFTP_CREATE_DIR_NONE) ||
 1275|      0|       (arg > CURLFTP_CREATE_DIR_RETRY))
 1276|      0|      result = CURLE_BAD_FUNCTION_ARGUMENT;
 1277|      0|    else
 1278|      0|      data->set.ftp_create_missing_dirs = (int)arg;
 1279|      0|    break;
 1280|  3.09k|  case CURLOPT_READDATA:
 1281|       |    /*
 1282|       |     * FILE pointer to read the file to be uploaded from. Or possibly
 1283|       |     * used as argument to the read callback.
 1284|       |     */
 1285|  3.09k|    data->set.in_set = va_arg(param, void *);
 1286|  3.09k|    break;
 1287|      0|  case CURLOPT_INFILESIZE:
 1288|       |    /*
 1289|       |     * If known, this should inform curl about the file size of the
 1290|       |     * to-be-uploaded file.
 1291|       |     */
 1292|      0|    arg = va_arg(param, long);
 1293|      0|    if(arg < -1)
 1294|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1295|      0|    data->set.filesize = arg;
 1296|      0|    break;
 1297|    110|  case CURLOPT_INFILESIZE_LARGE:
 1298|       |    /*
 1299|       |     * If known, this should inform curl about the file size of the
 1300|       |     * to-be-uploaded file.
 1301|       |     */
 1302|    110|    bigsize = va_arg(param, curl_off_t);
 1303|    110|    if(bigsize < -1)
 1304|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1305|    110|    data->set.filesize = bigsize;
 1306|    110|    break;
 1307|      0|  case CURLOPT_LOW_SPEED_LIMIT:
 1308|       |    /*
 1309|       |     * The low speed limit that if transfers are below this for
 1310|       |     * CURLOPT_LOW_SPEED_TIME, the transfer is aborted.
 1311|       |     */
 1312|      0|    arg = va_arg(param, long);
 1313|      0|    if(arg < 0)
 1314|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1315|      0|    data->set.low_speed_limit = arg;
 1316|      0|    break;
 1317|      0|  case CURLOPT_MAX_SEND_SPEED_LARGE:
 1318|       |    /*
 1319|       |     * When transfer uploads are faster then CURLOPT_MAX_SEND_SPEED_LARGE
 1320|       |     * bytes per second the transfer is throttled..
 1321|       |     */
 1322|      0|    bigsize = va_arg(param, curl_off_t);
 1323|      0|    if(bigsize < 0)
 1324|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1325|      0|    data->set.max_send_speed = bigsize;
 1326|      0|    break;
 1327|      0|  case CURLOPT_MAX_RECV_SPEED_LARGE:
 1328|       |    /*
 1329|       |     * When receiving data faster than CURLOPT_MAX_RECV_SPEED_LARGE bytes per
 1330|       |     * second the transfer is throttled..
 1331|       |     */
 1332|      0|    bigsize = va_arg(param, curl_off_t);
 1333|      0|    if(bigsize < 0)
 1334|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1335|      0|    data->set.max_recv_speed = bigsize;
 1336|      0|    break;
 1337|      0|  case CURLOPT_LOW_SPEED_TIME:
 1338|       |    /*
 1339|       |     * The low speed time that if transfers are below the set
 1340|       |     * CURLOPT_LOW_SPEED_LIMIT during this time, the transfer is aborted.
 1341|       |     */
 1342|      0|    arg = va_arg(param, long);
 1343|      0|    if(arg < 0)
 1344|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1345|      0|    data->set.low_speed_time = arg;
 1346|      0|    break;
 1347|      0|  case CURLOPT_CURLU:
 1348|       |    /*
 1349|       |     * pass CURLU to set URL
 1350|       |     */
 1351|      0|    data->set.uh = va_arg(param, CURLU *);
 1352|      0|    break;
 1353|  2.95k|  case CURLOPT_URL:
 1354|       |    /*
 1355|       |     * The URL to fetch.
 1356|       |     */
 1357|  2.95k|    if(data->state.url_alloc) {
 1358|       |      /* the already set URL is allocated, free it first! */
 1359|      0|      Curl_safefree(data->state.url);
 1360|      0|      data->state.url_alloc = FALSE;
 1361|      0|    }
 1362|  2.95k|    result = Curl_setstropt(&data->set.str[STRING_SET_URL],
 1363|  2.95k|                            va_arg(param, char *));
 1364|  2.95k|    data->state.url = data->set.str[STRING_SET_URL];
 1365|  2.95k|    break;
 1366|      0|  case CURLOPT_PORT:
 1367|       |    /*
 1368|       |     * The port number to use when getting the URL
 1369|       |     */
 1370|      0|    arg = va_arg(param, long);
 1371|      0|    if((arg < 0) || (arg > 65535))
 1372|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1373|      0|    data->set.use_port = arg;
 1374|      0|    break;
 1375|      0|  case CURLOPT_TIMEOUT:
 1376|       |    /*
 1377|       |     * The maximum time you allow curl to use for a single transfer
 1378|       |     * operation.
 1379|       |     */
 1380|      0|    arg = va_arg(param, long);
 1381|      0|    if((arg >= 0) && (arg <= (INT_MAX/1000)))
 1382|      0|      data->set.timeout = arg * 1000;
 1383|      0|    else
 1384|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1385|      0|    break;
 1386|       |
 1387|  3.09k|  case CURLOPT_TIMEOUT_MS:
 1388|  3.09k|    arg = va_arg(param, long);
 1389|  3.09k|    if(arg < 0)
 1390|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1391|  3.09k|    data->set.timeout = arg;
 1392|  3.09k|    break;
 1393|       |
 1394|      0|  case CURLOPT_CONNECTTIMEOUT:
 1395|       |    /*
 1396|       |     * The maximum time you allow curl to use to connect.
 1397|       |     */
 1398|      0|    arg = va_arg(param, long);
 1399|      0|    if((arg >= 0) && (arg <= (INT_MAX/1000)))
 1400|      0|      data->set.connecttimeout = arg * 1000;
 1401|      0|    else
 1402|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1403|      0|    break;
 1404|       |
 1405|      0|  case CURLOPT_CONNECTTIMEOUT_MS:
 1406|      0|    arg = va_arg(param, long);
 1407|      0|    if(arg < 0)
 1408|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1409|      0|    data->set.connecttimeout = arg;
 1410|      0|    break;
 1411|       |
 1412|      0|  case CURLOPT_ACCEPTTIMEOUT_MS:
 1413|       |    /*
 1414|       |     * The maximum time you allow curl to wait for server connect
 1415|       |     */
 1416|      0|    arg = va_arg(param, long);
 1417|      0|    if(arg < 0)
 1418|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1419|      0|    data->set.accepttimeout = arg;
 1420|      0|    break;
 1421|       |
 1422|      0|  case CURLOPT_USERPWD:
 1423|       |    /*
 1424|       |     * user:password to use in the operation
 1425|       |     */
 1426|      0|    result = setstropt_userpwd(va_arg(param, char *),
 1427|      0|                               &data->set.str[STRING_USERNAME],
 1428|      0|                               &data->set.str[STRING_PASSWORD]);
 1429|      0|    break;
 1430|       |
 1431|    206|  case CURLOPT_USERNAME:
 1432|       |    /*
 1433|       |     * authentication user name to use in the operation
 1434|       |     */
 1435|    206|    result = Curl_setstropt(&data->set.str[STRING_USERNAME],
 1436|    206|                            va_arg(param, char *));
 1437|    206|    break;
 1438|     52|  case CURLOPT_PASSWORD:
 1439|       |    /*
 1440|       |     * authentication password to use in the operation
 1441|       |     */
 1442|     52|    result = Curl_setstropt(&data->set.str[STRING_PASSWORD],
 1443|     52|                            va_arg(param, char *));
 1444|     52|    break;
 1445|       |
 1446|      0|  case CURLOPT_LOGIN_OPTIONS:
 1447|       |    /*
 1448|       |     * authentication options to use in the operation
 1449|       |     */
 1450|      0|    result = Curl_setstropt(&data->set.str[STRING_OPTIONS],
 1451|      0|                            va_arg(param, char *));
 1452|      0|    break;
 1453|       |
 1454|      0|  case CURLOPT_XOAUTH2_BEARER:
 1455|       |    /*
 1456|       |     * OAuth 2.0 bearer token to use in the operation
 1457|       |     */
 1458|      0|    result = Curl_setstropt(&data->set.str[STRING_BEARER],
 1459|      0|                            va_arg(param, char *));
 1460|      0|    break;
 1461|       |
 1462|      0|  case CURLOPT_POSTQUOTE:
 1463|       |    /*
 1464|       |     * List of RAW FTP commands to use after a transfer
 1465|       |     */
 1466|      0|    data->set.postquote = va_arg(param, struct curl_slist *);
 1467|      0|    break;
 1468|      0|  case CURLOPT_PREQUOTE:
 1469|       |    /*
 1470|       |     * List of RAW FTP commands to use prior to RETR (Wesley Laxton)
 1471|       |     */
 1472|      0|    data->set.prequote = va_arg(param, struct curl_slist *);
 1473|      0|    break;
 1474|      0|  case CURLOPT_QUOTE:
 1475|       |    /*
 1476|       |     * List of RAW FTP commands to use before a transfer
 1477|       |     */
 1478|      0|    data->set.quote = va_arg(param, struct curl_slist *);
 1479|      0|    break;
 1480|      0|  case CURLOPT_RESOLVE:
 1481|       |    /*
 1482|       |     * List of HOST:PORT:[addresses] strings to populate the DNS cache with
 1483|       |     * Entries added this way will remain in the cache until explicitly
 1484|       |     * removed or the handle is cleaned up.
 1485|       |     *
 1486|       |     * Prefix the HOST with plus sign (+) to have the entry expire just like
 1487|       |     * automatically added entries.
 1488|       |     *
 1489|       |     * Prefix the HOST with dash (-) to _remove_ the entry from the cache.
 1490|       |     *
 1491|       |     * This API can remove any entry from the DNS cache, but only entries
 1492|       |     * that aren't actually in use right now will be pruned immediately.
 1493|       |     */
 1494|      0|    data->set.resolve = va_arg(param, struct curl_slist *);
 1495|      0|    data->state.resolve = data->set.resolve;
 1496|      0|    break;
 1497|      0|  case CURLOPT_PROGRESSFUNCTION:
 1498|       |    /*
 1499|       |     * Progress callback function
 1500|       |     */
 1501|      0|    data->set.fprogress = va_arg(param, curl_progress_callback);
 1502|      0|    if(data->set.fprogress)
 1503|      0|      data->progress.callback = TRUE; /* no longer internal */
 1504|      0|    else
 1505|      0|      data->progress.callback = FALSE; /* NULL enforces internal */
 1506|      0|    break;
 1507|       |
 1508|      0|  case CURLOPT_XFERINFOFUNCTION:
 1509|       |    /*
 1510|       |     * Transfer info callback function
 1511|       |     */
 1512|      0|    data->set.fxferinfo = va_arg(param, curl_xferinfo_callback);
 1513|      0|    if(data->set.fxferinfo)
 1514|      0|      data->progress.callback = TRUE; /* no longer internal */
 1515|      0|    else
 1516|      0|      data->progress.callback = FALSE; /* NULL enforces internal */
 1517|       |
 1518|      0|    break;
 1519|       |
 1520|      0|  case CURLOPT_PROGRESSDATA:
 1521|       |    /*
 1522|       |     * Custom client data to pass to the progress callback
 1523|       |     */
 1524|      0|    data->set.progress_client = va_arg(param, void *);
 1525|      0|    break;
 1526|       |
 1527|      0|#ifndef CURL_DISABLE_PROXY
 1528|      0|  case CURLOPT_PROXYUSERPWD:
 1529|       |    /*
 1530|       |     * user:password needed to use the proxy
 1531|       |     */
 1532|      0|    result = setstropt_userpwd(va_arg(param, char *),
 1533|      0|                               &data->set.str[STRING_PROXYUSERNAME],
 1534|      0|                               &data->set.str[STRING_PROXYPASSWORD]);
 1535|      0|    break;
 1536|      0|  case CURLOPT_PROXYUSERNAME:
 1537|       |    /*
 1538|       |     * authentication user name to use in the operation
 1539|       |     */
 1540|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXYUSERNAME],
 1541|      0|                            va_arg(param, char *));
 1542|      0|    break;
 1543|      0|  case CURLOPT_PROXYPASSWORD:
 1544|       |    /*
 1545|       |     * authentication password to use in the operation
 1546|       |     */
 1547|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXYPASSWORD],
 1548|      0|                            va_arg(param, char *));
 1549|      0|    break;
 1550|      0|  case CURLOPT_NOPROXY:
 1551|       |    /*
 1552|       |     * proxy exception list
 1553|       |     */
 1554|      0|    result = Curl_setstropt(&data->set.str[STRING_NOPROXY],
 1555|      0|                            va_arg(param, char *));
 1556|      0|    break;
 1557|      0|#endif
 1558|       |
 1559|     53|  case CURLOPT_RANGE:
 1560|       |    /*
 1561|       |     * What range of the file you want to transfer
 1562|       |     */
 1563|     53|    result = Curl_setstropt(&data->set.str[STRING_SET_RANGE],
 1564|     53|                            va_arg(param, char *));
 1565|     53|    break;
 1566|      0|  case CURLOPT_RESUME_FROM:
 1567|       |    /*
 1568|       |     * Resume transfer at the given file position
 1569|       |     */
 1570|      0|    arg = va_arg(param, long);
 1571|      0|    if(arg < -1)
 1572|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1573|      0|    data->set.set_resume_from = arg;
 1574|      0|    break;
 1575|      0|  case CURLOPT_RESUME_FROM_LARGE:
 1576|       |    /*
 1577|       |     * Resume transfer at the given file position
 1578|       |     */
 1579|      0|    bigsize = va_arg(param, curl_off_t);
 1580|      0|    if(bigsize < -1)
 1581|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1582|      0|    data->set.set_resume_from = bigsize;
 1583|      0|    break;
 1584|      0|  case CURLOPT_DEBUGFUNCTION:
 1585|       |    /*
 1586|       |     * stderr write callback.
 1587|       |     */
 1588|      0|    data->set.fdebug = va_arg(param, curl_debug_callback);
 1589|       |    /*
 1590|       |     * if the callback provided is NULL, it'll use the default callback
 1591|       |     */
 1592|      0|    break;
 1593|      0|  case CURLOPT_DEBUGDATA:
 1594|       |    /*
 1595|       |     * Set to a void * that should receive all error writes. This
 1596|       |     * defaults to CURLOPT_STDERR for normal operations.
 1597|       |     */
 1598|      0|    data->set.debugdata = va_arg(param, void *);
 1599|      0|    break;
 1600|      0|  case CURLOPT_STDERR:
 1601|       |    /*
 1602|       |     * Set to a FILE * that should receive all error writes. This
 1603|       |     * defaults to stderr for normal operations.
 1604|       |     */
 1605|      0|    data->set.err = va_arg(param, FILE *);
 1606|      0|    if(!data->set.err)
 1607|      0|      data->set.err = stderr;
 1608|      0|    break;
 1609|      0|  case CURLOPT_HEADERFUNCTION:
 1610|       |    /*
 1611|       |     * Set header write callback
 1612|       |     */
 1613|      0|    data->set.fwrite_header = va_arg(param, curl_write_callback);
 1614|      0|    break;
 1615|  3.09k|  case CURLOPT_WRITEFUNCTION:
 1616|       |    /*
 1617|       |     * Set data write callback
 1618|       |     */
 1619|  3.09k|    data->set.fwrite_func = va_arg(param, curl_write_callback);
 1620|  3.09k|    if(!data->set.fwrite_func) {
 1621|      0|      data->set.is_fwrite_set = 0;
 1622|       |      /* When set to NULL, reset to our internal default function */
 1623|      0|      data->set.fwrite_func = (curl_write_callback)fwrite;
 1624|      0|    }
 1625|  3.09k|    else
 1626|  3.09k|      data->set.is_fwrite_set = 1;
 1627|  3.09k|    break;
 1628|  3.09k|  case CURLOPT_READFUNCTION:
 1629|       |    /*
 1630|       |     * Read data callback
 1631|       |     */
 1632|  3.09k|    data->set.fread_func_set = va_arg(param, curl_read_callback);
 1633|  3.09k|    if(!data->set.fread_func_set) {
 1634|      0|      data->set.is_fread_set = 0;
 1635|       |      /* When set to NULL, reset to our internal default function */
 1636|      0|      data->set.fread_func_set = (curl_read_callback)fread;
 1637|      0|    }
 1638|  3.09k|    else
 1639|  3.09k|      data->set.is_fread_set = 1;
 1640|  3.09k|    break;
 1641|      0|  case CURLOPT_SEEKFUNCTION:
 1642|       |    /*
 1643|       |     * Seek callback. Might be NULL.
 1644|       |     */
 1645|      0|    data->set.seek_func = va_arg(param, curl_seek_callback);
 1646|      0|    break;
 1647|      0|  case CURLOPT_SEEKDATA:
 1648|       |    /*
 1649|       |     * Seek control callback. Might be NULL.
 1650|       |     */
 1651|      0|    data->set.seek_client = va_arg(param, void *);
 1652|      0|    break;
 1653|      0|  case CURLOPT_CONV_FROM_NETWORK_FUNCTION:
 1654|       |    /*
 1655|       |     * "Convert from network encoding" callback
 1656|       |     */
 1657|      0|    data->set.convfromnetwork = va_arg(param, curl_conv_callback);
 1658|      0|    break;
 1659|      0|  case CURLOPT_CONV_TO_NETWORK_FUNCTION:
 1660|       |    /*
 1661|       |     * "Convert to network encoding" callback
 1662|       |     */
 1663|      0|    data->set.convtonetwork = va_arg(param, curl_conv_callback);
 1664|      0|    break;
 1665|      0|  case CURLOPT_CONV_FROM_UTF8_FUNCTION:
 1666|       |    /*
 1667|       |     * "Convert from UTF-8 encoding" callback
 1668|       |     */
 1669|      0|    data->set.convfromutf8 = va_arg(param, curl_conv_callback);
 1670|      0|    break;
 1671|      0|  case CURLOPT_IOCTLFUNCTION:
 1672|       |    /*
 1673|       |     * I/O control callback. Might be NULL.
 1674|       |     */
 1675|      0|    data->set.ioctl_func = va_arg(param, curl_ioctl_callback);
 1676|      0|    break;
 1677|      0|  case CURLOPT_IOCTLDATA:
 1678|       |    /*
 1679|       |     * I/O control data pointer. Might be NULL.
 1680|       |     */
 1681|      0|    data->set.ioctl_client = va_arg(param, void *);
 1682|      0|    break;
 1683|      0|  case CURLOPT_SSLCERT:
 1684|       |    /*
 1685|       |     * String that holds file name of the SSL certificate to use
 1686|       |     */
 1687|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT],
 1688|      0|                            va_arg(param, char *));
 1689|      0|    break;
 1690|      0|  case CURLOPT_SSLCERT_BLOB:
 1691|       |    /*
 1692|       |     * Blob that holds file content of the SSL certificate to use
 1693|       |     */
 1694|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_CERT],
 1695|      0|                             va_arg(param, struct curl_blob *));
 1696|      0|    break;
 1697|      0|#ifndef CURL_DISABLE_PROXY
 1698|      0|  case CURLOPT_PROXY_SSLCERT:
 1699|       |    /*
 1700|       |     * String that holds file name of the SSL certificate to use for proxy
 1701|       |     */
 1702|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT_PROXY],
 1703|      0|                            va_arg(param, char *));
 1704|      0|    break;
 1705|      0|  case CURLOPT_PROXY_SSLCERT_BLOB:
 1706|       |    /*
 1707|       |     * Blob that holds file content of the SSL certificate to use for proxy
 1708|       |     */
 1709|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_CERT_PROXY],
 1710|      0|                             va_arg(param, struct curl_blob *));
 1711|      0|    break;
 1712|      0|#endif
 1713|      0|  case CURLOPT_SSLCERTTYPE:
 1714|       |    /*
 1715|       |     * String that holds file type of the SSL certificate to use
 1716|       |     */
 1717|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT_TYPE],
 1718|      0|                            va_arg(param, char *));
 1719|      0|    break;
 1720|      0|#ifndef CURL_DISABLE_PROXY
 1721|      0|  case CURLOPT_PROXY_SSLCERTTYPE:
 1722|       |    /*
 1723|       |     * String that holds file type of the SSL certificate to use for proxy
 1724|       |     */
 1725|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT_TYPE_PROXY],
 1726|      0|                            va_arg(param, char *));
 1727|      0|    break;
 1728|      0|#endif
 1729|      0|  case CURLOPT_SSLKEY:
 1730|       |    /*
 1731|       |     * String that holds file name of the SSL key to use
 1732|       |     */
 1733|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY],
 1734|      0|                            va_arg(param, char *));
 1735|      0|    break;
 1736|      0|  case CURLOPT_SSLKEY_BLOB:
 1737|       |    /*
 1738|       |     * Blob that holds file content of the SSL key to use
 1739|       |     */
 1740|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_KEY],
 1741|      0|                             va_arg(param, struct curl_blob *));
 1742|      0|    break;
 1743|      0|#ifndef CURL_DISABLE_PROXY
 1744|      0|  case CURLOPT_PROXY_SSLKEY:
 1745|       |    /*
 1746|       |     * String that holds file name of the SSL key to use for proxy
 1747|       |     */
 1748|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_PROXY],
 1749|      0|                            va_arg(param, char *));
 1750|      0|    break;
 1751|      0|  case CURLOPT_PROXY_SSLKEY_BLOB:
 1752|       |    /*
 1753|       |     * Blob that holds file content of the SSL key to use for proxy
 1754|       |     */
 1755|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_KEY_PROXY],
 1756|      0|                             va_arg(param, struct curl_blob *));
 1757|      0|    break;
 1758|      0|#endif
 1759|      0|  case CURLOPT_SSLKEYTYPE:
 1760|       |    /*
 1761|       |     * String that holds file type of the SSL key to use
 1762|       |     */
 1763|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_TYPE],
 1764|      0|                            va_arg(param, char *));
 1765|      0|    break;
 1766|      0|#ifndef CURL_DISABLE_PROXY
 1767|      0|  case CURLOPT_PROXY_SSLKEYTYPE:
 1768|       |    /*
 1769|       |     * String that holds file type of the SSL key to use for proxy
 1770|       |     */
 1771|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_TYPE_PROXY],
 1772|      0|                            va_arg(param, char *));
 1773|      0|    break;
 1774|      0|#endif
 1775|      0|  case CURLOPT_KEYPASSWD:
 1776|       |    /*
 1777|       |     * String that holds the SSL or SSH private key password.
 1778|       |     */
 1779|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_PASSWD],
 1780|      0|                            va_arg(param, char *));
 1781|      0|    break;
 1782|      0|#ifndef CURL_DISABLE_PROXY
 1783|      0|  case CURLOPT_PROXY_KEYPASSWD:
 1784|       |    /*
 1785|       |     * String that holds the SSL private key password for proxy.
 1786|       |     */
 1787|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_PASSWD_PROXY],
 1788|      0|                            va_arg(param, char *));
 1789|      0|    break;
 1790|      0|#endif
 1791|      0|  case CURLOPT_SSLENGINE:
 1792|       |    /*
 1793|       |     * String that holds the SSL crypto engine.
 1794|       |     */
 1795|      0|    argptr = va_arg(param, char *);
 1796|      0|    if(argptr && argptr[0]) {
 1797|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_ENGINE], argptr);
 1798|      0|      if(!result) {
 1799|      0|        result = Curl_ssl_set_engine(data, argptr);
 1800|      0|      }
 1801|      0|    }
 1802|      0|    break;
 1803|       |
 1804|      0|  case CURLOPT_SSLENGINE_DEFAULT:
 1805|       |    /*
 1806|       |     * flag to set engine as default.
 1807|       |     */
 1808|      0|    Curl_setstropt(&data->set.str[STRING_SSL_ENGINE], NULL);
 1809|      0|    result = Curl_ssl_set_engine_default(data);
 1810|      0|    break;
 1811|      0|  case CURLOPT_CRLF:
 1812|       |    /*
 1813|       |     * Kludgy option to enable CRLF conversions. Subject for removal.
 1814|       |     */
 1815|      0|    data->set.crlf = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1816|      0|    break;
 1817|      0|#ifndef CURL_DISABLE_PROXY
 1818|      0|  case CURLOPT_HAPROXYPROTOCOL:
 1819|       |    /*
 1820|       |     * Set to send the HAProxy Proxy Protocol header
 1821|       |     */
 1822|      0|    data->set.haproxyprotocol = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1823|      0|    break;
 1824|      0|#endif
 1825|      0|  case CURLOPT_INTERFACE:
 1826|       |    /*
 1827|       |     * Set what interface or address/hostname to bind the socket to when
 1828|       |     * performing an operation and thus what from-IP your connection will use.
 1829|       |     */
 1830|      0|    result = Curl_setstropt(&data->set.str[STRING_DEVICE],
 1831|      0|                            va_arg(param, char *));
 1832|      0|    break;
 1833|      0|  case CURLOPT_LOCALPORT:
 1834|       |    /*
 1835|       |     * Set what local port to bind the socket to when performing an operation.
 1836|       |     */
 1837|      0|    arg = va_arg(param, long);
 1838|      0|    if((arg < 0) || (arg > 65535))
 1839|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1840|      0|    data->set.localport = curlx_sltous(arg);
 1841|      0|    break;
 1842|      0|  case CURLOPT_LOCALPORTRANGE:
 1843|       |    /*
 1844|       |     * Set number of local ports to try, starting with CURLOPT_LOCALPORT.
 1845|       |     */
 1846|      0|    arg = va_arg(param, long);
 1847|      0|    if((arg < 0) || (arg > 65535))
 1848|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1849|      0|    data->set.localportrange = curlx_sltosi(arg);
 1850|      0|    break;
 1851|      0|  case CURLOPT_GSSAPI_DELEGATION:
 1852|       |    /*
 1853|       |     * GSS-API credential delegation bitmask
 1854|       |     */
 1855|      0|    arg = va_arg(param, long);
 1856|      0|    if(arg < CURLGSSAPI_DELEGATION_NONE)
 1857|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1858|      0|    data->set.gssapi_delegation = arg;
 1859|      0|    break;
 1860|      0|  case CURLOPT_SSL_VERIFYPEER:
 1861|       |    /*
 1862|       |     * Enable peer SSL verifying.
 1863|       |     */
 1864|      0|    data->set.ssl.primary.verifypeer = (0 != va_arg(param, long)) ?
 1865|      0|      TRUE : FALSE;
 1866|       |
 1867|       |    /* Update the current connection ssl_config. */
 1868|      0|    if(data->conn) {
 1869|      0|      data->conn->ssl_config.verifypeer =
 1870|      0|        data->set.ssl.primary.verifypeer;
 1871|      0|    }
 1872|      0|    break;
 1873|      0|  case CURLOPT_DOH_SSL_VERIFYPEER:
 1874|       |    /*
 1875|       |     * Enable peer SSL verifying for DoH.
 1876|       |     */
 1877|      0|    data->set.doh_verifypeer = (0 != va_arg(param, long)) ?
 1878|      0|      TRUE : FALSE;
 1879|      0|    break;
 1880|      0|#ifndef CURL_DISABLE_PROXY
 1881|      0|  case CURLOPT_PROXY_SSL_VERIFYPEER:
 1882|       |    /*
 1883|       |     * Enable peer SSL verifying for proxy.
 1884|       |     */
 1885|      0|    data->set.proxy_ssl.primary.verifypeer =
 1886|      0|      (0 != va_arg(param, long))?TRUE:FALSE;
 1887|       |
 1888|       |    /* Update the current connection proxy_ssl_config. */
 1889|      0|    if(data->conn) {
 1890|      0|      data->conn->proxy_ssl_config.verifypeer =
 1891|      0|        data->set.proxy_ssl.primary.verifypeer;
 1892|      0|    }
 1893|      0|    break;
 1894|      0|#endif
 1895|      0|  case CURLOPT_SSL_VERIFYHOST:
 1896|       |    /*
 1897|       |     * Enable verification of the host name in the peer certificate
 1898|       |     */
 1899|      0|    arg = va_arg(param, long);
 1900|       |
 1901|       |    /* Obviously people are not reading documentation and too many thought
 1902|       |       this argument took a boolean when it wasn't and misused it.
 1903|       |       Treat 1 and 2 the same */
 1904|      0|    data->set.ssl.primary.verifyhost = (bool)((arg & 3) ? TRUE : FALSE);
 1905|       |
 1906|       |    /* Update the current connection ssl_config. */
 1907|      0|    if(data->conn) {
 1908|      0|      data->conn->ssl_config.verifyhost =
 1909|      0|        data->set.ssl.primary.verifyhost;
 1910|      0|    }
 1911|      0|    break;
 1912|      0|  case CURLOPT_DOH_SSL_VERIFYHOST:
 1913|       |    /*
 1914|       |     * Enable verification of the host name in the peer certificate for DoH
 1915|       |     */
 1916|      0|    arg = va_arg(param, long);
 1917|       |
 1918|       |    /* Treat both 1 and 2 as TRUE */
 1919|      0|    data->set.doh_verifyhost = (bool)((arg & 3) ? TRUE : FALSE);
 1920|      0|    break;
 1921|      0|#ifndef CURL_DISABLE_PROXY
 1922|      0|  case CURLOPT_PROXY_SSL_VERIFYHOST:
 1923|       |    /*
 1924|       |     * Enable verification of the host name in the peer certificate for proxy
 1925|       |     */
 1926|      0|    arg = va_arg(param, long);
 1927|       |
 1928|       |    /* Treat both 1 and 2 as TRUE */
 1929|      0|    data->set.proxy_ssl.primary.verifyhost = (bool)((arg & 3)?TRUE:FALSE);
 1930|       |
 1931|       |    /* Update the current connection proxy_ssl_config. */
 1932|      0|    if(data->conn) {
 1933|      0|      data->conn->proxy_ssl_config.verifyhost =
 1934|      0|        data->set.proxy_ssl.primary.verifyhost;
 1935|      0|    }
 1936|      0|    break;
 1937|      0|#endif
 1938|      0|  case CURLOPT_SSL_VERIFYSTATUS:
 1939|       |    /*
 1940|       |     * Enable certificate status verifying.
 1941|       |     */
 1942|      0|    if(!Curl_ssl_cert_status_request()) {
 1943|      0|      result = CURLE_NOT_BUILT_IN;
 1944|      0|      break;
 1945|      0|    }
 1946|       |
 1947|      0|    data->set.ssl.primary.verifystatus = (0 != va_arg(param, long)) ?
 1948|      0|      TRUE : FALSE;
 1949|       |
 1950|       |    /* Update the current connection ssl_config. */
 1951|      0|    if(data->conn) {
 1952|      0|      data->conn->ssl_config.verifystatus =
 1953|      0|        data->set.ssl.primary.verifystatus;
 1954|      0|    }
 1955|      0|    break;
 1956|      0|  case CURLOPT_DOH_SSL_VERIFYSTATUS:
 1957|       |    /*
 1958|       |     * Enable certificate status verifying for DoH.
 1959|       |     */
 1960|      0|    if(!Curl_ssl_cert_status_request()) {
 1961|      0|      result = CURLE_NOT_BUILT_IN;
 1962|      0|      break;
 1963|      0|    }
 1964|       |
 1965|      0|    data->set.doh_verifystatus = (0 != va_arg(param, long)) ?
 1966|      0|      TRUE : FALSE;
 1967|      0|    break;
 1968|      0|  case CURLOPT_SSL_CTX_FUNCTION:
 1969|       |    /*
 1970|       |     * Set a SSL_CTX callback
 1971|       |     */
 1972|      0|#ifdef USE_SSL
 1973|      0|    if(Curl_ssl->supports & SSLSUPP_SSL_CTX)
 1974|      0|      data->set.ssl.fsslctx = va_arg(param, curl_ssl_ctx_callback);
 1975|      0|    else
 1976|      0|#endif
 1977|      0|      result = CURLE_NOT_BUILT_IN;
 1978|      0|    break;
 1979|      0|  case CURLOPT_SSL_CTX_DATA:
 1980|       |    /*
 1981|       |     * Set a SSL_CTX callback parameter pointer
 1982|       |     */
 1983|      0|#ifdef USE_SSL
 1984|      0|    if(Curl_ssl->supports & SSLSUPP_SSL_CTX)
 1985|      0|      data->set.ssl.fsslctxp = va_arg(param, void *);
 1986|      0|    else
 1987|      0|#endif
 1988|      0|      result = CURLE_NOT_BUILT_IN;
 1989|      0|    break;
 1990|      0|  case CURLOPT_SSL_FALSESTART:
 1991|       |    /*
 1992|       |     * Enable TLS false start.
 1993|       |     */
 1994|      0|    if(!Curl_ssl_false_start()) {
 1995|      0|      result = CURLE_NOT_BUILT_IN;
 1996|      0|      break;
 1997|      0|    }
 1998|       |
 1999|      0|    data->set.ssl.falsestart = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2000|      0|    break;
 2001|      0|  case CURLOPT_CERTINFO:
 2002|      0|#ifdef USE_SSL
 2003|      0|    if(Curl_ssl->supports & SSLSUPP_CERTINFO)
 2004|      0|      data->set.ssl.certinfo = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2005|      0|    else
 2006|      0|#endif
 2007|      0|      result = CURLE_NOT_BUILT_IN;
 2008|      0|        break;
 2009|      0|  case CURLOPT_PINNEDPUBLICKEY:
 2010|       |    /*
 2011|       |     * Set pinned public key for SSL connection.
 2012|       |     * Specify file name of the public key in DER format.
 2013|       |     */
 2014|      0|#ifdef USE_SSL
 2015|      0|    if(Curl_ssl->supports & SSLSUPP_PINNEDPUBKEY)
 2016|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_PINNEDPUBLICKEY],
 2017|      0|                              va_arg(param, char *));
 2018|      0|    else
 2019|      0|#endif
 2020|      0|      result = CURLE_NOT_BUILT_IN;
 2021|      0|    break;
 2022|      0|#ifndef CURL_DISABLE_PROXY
 2023|      0|  case CURLOPT_PROXY_PINNEDPUBLICKEY:
 2024|       |    /*
 2025|       |     * Set pinned public key for SSL connection.
 2026|       |     * Specify file name of the public key in DER format.
 2027|       |     */
 2028|      0|#ifdef USE_SSL
 2029|      0|    if(Curl_ssl->supports & SSLSUPP_PINNEDPUBKEY)
 2030|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY],
 2031|      0|                              va_arg(param, char *));
 2032|      0|    else
 2033|      0|#endif
 2034|      0|      result = CURLE_NOT_BUILT_IN;
 2035|      0|    break;
 2036|      0|#endif
 2037|      0|  case CURLOPT_CAINFO:
 2038|       |    /*
 2039|       |     * Set CA info for SSL connection. Specify file name of the CA certificate
 2040|       |     */
 2041|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE],
 2042|      0|                            va_arg(param, char *));
 2043|      0|    break;
 2044|      0|  case CURLOPT_CAINFO_BLOB:
 2045|       |    /*
 2046|       |     * Blob that holds CA info for SSL connection.
 2047|       |     * Specify entire PEM of the CA certificate
 2048|       |     */
 2049|      0|#ifdef USE_SSL
 2050|      0|    if(Curl_ssl->supports & SSLSUPP_CAINFO_BLOB)
 2051|      0|      result = Curl_setblobopt(&data->set.blobs[BLOB_CAINFO],
 2052|      0|                               va_arg(param, struct curl_blob *));
 2053|      0|    else
 2054|      0|#endif
 2055|      0|      return CURLE_NOT_BUILT_IN;
 2056|       |
 2057|      0|    break;
 2058|      0|#ifndef CURL_DISABLE_PROXY
 2059|      0|  case CURLOPT_PROXY_CAINFO:
 2060|       |    /*
 2061|       |     * Set CA info SSL connection for proxy. Specify file name of the
 2062|       |     * CA certificate
 2063|       |     */
 2064|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE_PROXY],
 2065|      0|                            va_arg(param, char *));
 2066|      0|    break;
 2067|      0|  case CURLOPT_PROXY_CAINFO_BLOB:
 2068|       |    /*
 2069|       |     * Blob that holds CA info for SSL connection proxy.
 2070|       |     * Specify entire PEM of the CA certificate
 2071|       |     */
 2072|      0|#ifdef USE_SSL
 2073|      0|    if(Curl_ssl->supports & SSLSUPP_CAINFO_BLOB)
 2074|      0|      result = Curl_setblobopt(&data->set.blobs[BLOB_CAINFO_PROXY],
 2075|      0|                               va_arg(param, struct curl_blob *));
 2076|      0|    else
 2077|      0|#endif
 2078|      0|      return CURLE_NOT_BUILT_IN;
 2079|      0|    break;
 2080|      0|#endif
 2081|      0|  case CURLOPT_CAPATH:
 2082|       |    /*
 2083|       |     * Set CA path info for SSL connection. Specify directory name of the CA
 2084|       |     * certificates which have been prepared using openssl c_rehash utility.
 2085|       |     */
 2086|      0|#ifdef USE_SSL
 2087|      0|    if(Curl_ssl->supports & SSLSUPP_CA_PATH)
 2088|       |      /* This does not work on windows. */
 2089|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CAPATH],
 2090|      0|                              va_arg(param, char *));
 2091|      0|    else
 2092|      0|#endif
 2093|      0|      result = CURLE_NOT_BUILT_IN;
 2094|      0|    break;
 2095|      0|#ifndef CURL_DISABLE_PROXY
 2096|      0|  case CURLOPT_PROXY_CAPATH:
 2097|       |    /*
 2098|       |     * Set CA path info for SSL connection proxy. Specify directory name of the
 2099|       |     * CA certificates which have been prepared using openssl c_rehash utility.
 2100|       |     */
 2101|      0|#ifdef USE_SSL
 2102|      0|    if(Curl_ssl->supports & SSLSUPP_CA_PATH)
 2103|       |      /* This does not work on windows. */
 2104|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CAPATH_PROXY],
 2105|      0|                              va_arg(param, char *));
 2106|      0|    else
 2107|      0|#endif
 2108|      0|      result = CURLE_NOT_BUILT_IN;
 2109|      0|    break;
 2110|      0|#endif
 2111|      0|  case CURLOPT_CRLFILE:
 2112|       |    /*
 2113|       |     * Set CRL file info for SSL connection. Specify file name of the CRL
 2114|       |     * to check certificates revocation
 2115|       |     */
 2116|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CRLFILE],
 2117|      0|                            va_arg(param, char *));
 2118|      0|    break;
 2119|      0|#ifndef CURL_DISABLE_PROXY
 2120|      0|  case CURLOPT_PROXY_CRLFILE:
 2121|       |    /*
 2122|       |     * Set CRL file info for SSL connection for proxy. Specify file name of the
 2123|       |     * CRL to check certificates revocation
 2124|       |     */
 2125|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CRLFILE_PROXY],
 2126|      0|                            va_arg(param, char *));
 2127|      0|    break;
 2128|      0|#endif
 2129|      0|  case CURLOPT_ISSUERCERT:
 2130|       |    /*
 2131|       |     * Set Issuer certificate file
 2132|       |     * to check certificates issuer
 2133|       |     */
 2134|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_ISSUERCERT],
 2135|      0|                            va_arg(param, char *));
 2136|      0|    break;
 2137|      0|  case CURLOPT_ISSUERCERT_BLOB:
 2138|       |    /*
 2139|       |     * Blob that holds Issuer certificate to check certificates issuer
 2140|       |     */
 2141|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_SSL_ISSUERCERT],
 2142|      0|                             va_arg(param, struct curl_blob *));
 2143|      0|    break;
 2144|      0|#ifndef CURL_DISABLE_PROXY
 2145|      0|  case CURLOPT_PROXY_ISSUERCERT:
 2146|       |    /*
 2147|       |     * Set Issuer certificate file
 2148|       |     * to check certificates issuer
 2149|       |     */
 2150|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_ISSUERCERT_PROXY],
 2151|      0|                            va_arg(param, char *));
 2152|      0|    break;
 2153|      0|  case CURLOPT_PROXY_ISSUERCERT_BLOB:
 2154|       |    /*
 2155|       |     * Blob that holds Issuer certificate to check certificates issuer
 2156|       |     */
 2157|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_SSL_ISSUERCERT_PROXY],
 2158|      0|                             va_arg(param, struct curl_blob *));
 2159|      0|    break;
 2160|      0|#endif
 2161|      0|#ifndef CURL_DISABLE_TELNET
 2162|      0|  case CURLOPT_TELNETOPTIONS:
 2163|       |    /*
 2164|       |     * Set a linked list of telnet options
 2165|       |     */
 2166|      0|    data->set.telnet_options = va_arg(param, struct curl_slist *);
 2167|      0|    break;
 2168|      0|#endif
 2169|      0|  case CURLOPT_BUFFERSIZE:
 2170|       |    /*
 2171|       |     * The application kindly asks for a differently sized receive buffer.
 2172|       |     * If it seems reasonable, we'll use it.
 2173|       |     */
 2174|      0|    if(data->state.buffer)
 2175|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2176|       |
 2177|      0|    arg = va_arg(param, long);
 2178|       |
 2179|      0|    if(arg > READBUFFER_MAX)
 2180|      0|      arg = READBUFFER_MAX;
 2181|      0|    else if(arg < 1)
 2182|      0|      arg = READBUFFER_SIZE;
 2183|      0|    else if(arg < READBUFFER_MIN)
 2184|      0|      arg = READBUFFER_MIN;
 2185|       |
 2186|      0|    data->set.buffer_size = arg;
 2187|      0|    break;
 2188|       |
 2189|      0|  case CURLOPT_UPLOAD_BUFFERSIZE:
 2190|       |    /*
 2191|       |     * The application kindly asks for a differently sized upload buffer.
 2192|       |     * Cap it to sensible.
 2193|       |     */
 2194|      0|    arg = va_arg(param, long);
 2195|       |
 2196|      0|    if(arg > UPLOADBUFFER_MAX)
 2197|      0|      arg = UPLOADBUFFER_MAX;
 2198|      0|    else if(arg < UPLOADBUFFER_MIN)
 2199|      0|      arg = UPLOADBUFFER_MIN;
 2200|       |
 2201|      0|    data->set.upload_buffer_size = (unsigned int)arg;
 2202|      0|    Curl_safefree(data->state.ulbuf); /* force a realloc next opportunity */
 2203|      0|    break;
 2204|       |
 2205|      0|  case CURLOPT_NOSIGNAL:
 2206|       |    /*
 2207|       |     * The application asks not to set any signal() or alarm() handlers,
 2208|       |     * even when using a timeout.
 2209|       |     */
 2210|      0|    data->set.no_signal = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2211|      0|    break;
 2212|       |
 2213|      0|  case CURLOPT_SHARE:
 2214|      0|  {
 2215|      0|    struct Curl_share *set;
 2216|      0|    set = va_arg(param, struct Curl_share *);
 2217|       |
 2218|       |    /* disconnect from old share, if any */
 2219|      0|    if(data->share) {
 2220|      0|      Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
 2221|       |
 2222|      0|      if(data->dns.hostcachetype == HCACHE_SHARED) {
 2223|      0|        data->dns.hostcache = NULL;
 2224|      0|        data->dns.hostcachetype = HCACHE_NONE;
 2225|      0|      }
 2226|       |
 2227|      0|#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
 2228|      0|      if(data->share->cookies == data->cookies)
 2229|      0|        data->cookies = NULL;
 2230|      0|#endif
 2231|       |
 2232|      0|      if(data->share->sslsession == data->state.session)
 2233|      0|        data->state.session = NULL;
 2234|       |
 2235|       |#ifdef USE_LIBPSL
 2236|       |      if(data->psl == &data->share->psl)
 2237|       |        data->psl = data->multi? &data->multi->psl: NULL;
 2238|       |#endif
 2239|       |
 2240|      0|      data->share->dirty--;
 2241|       |
 2242|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
 2243|      0|      data->share = NULL;
 2244|      0|    }
 2245|       |
 2246|      0|    if(GOOD_SHARE_HANDLE(set))
 2247|       |      /* use new share if it set */
 2248|      0|      data->share = set;
 2249|      0|    if(data->share) {
 2250|       |
 2251|      0|      Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
 2252|       |
 2253|      0|      data->share->dirty++;
 2254|       |
 2255|      0|      if(data->share->specifier & (1<< CURL_LOCK_DATA_DNS)) {
 2256|       |        /* use shared host cache */
 2257|      0|        data->dns.hostcache = &data->share->hostcache;
 2258|      0|        data->dns.hostcachetype = HCACHE_SHARED;
 2259|      0|      }
 2260|      0|#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
 2261|      0|      if(data->share->cookies) {
 2262|       |        /* use shared cookie list, first free own one if any */
 2263|      0|        Curl_cookie_cleanup(data->cookies);
 2264|       |        /* enable cookies since we now use a share that uses cookies! */
 2265|      0|        data->cookies = data->share->cookies;
 2266|      0|      }
 2267|      0|#endif   /* CURL_DISABLE_HTTP */
 2268|      0|      if(data->share->sslsession) {
 2269|      0|        data->set.general_ssl.max_ssl_sessions = data->share->max_ssl_sessions;
 2270|      0|        data->state.session = data->share->sslsession;
 2271|      0|      }
 2272|       |#ifdef USE_LIBPSL
 2273|       |      if(data->share->specifier & (1 << CURL_LOCK_DATA_PSL))
 2274|       |        data->psl = &data->share->psl;
 2275|       |#endif
 2276|       |
 2277|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
 2278|      0|    }
 2279|       |    /* check for host cache not needed,
 2280|       |     * it will be done by curl_easy_perform */
 2281|      0|  }
 2282|      0|  break;
 2283|       |
 2284|      0|  case CURLOPT_PRIVATE:
 2285|       |    /*
 2286|       |     * Set private data pointer.
 2287|       |     */
 2288|      0|    data->set.private_data = va_arg(param, void *);
 2289|      0|    break;
 2290|       |
 2291|      0|  case CURLOPT_MAXFILESIZE:
 2292|       |    /*
 2293|       |     * Set the maximum size of a file to download.
 2294|       |     */
 2295|      0|    arg = va_arg(param, long);
 2296|      0|    if(arg < 0)
 2297|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2298|      0|    data->set.max_filesize = arg;
 2299|      0|    break;
 2300|       |
 2301|      0|#ifdef USE_SSL
 2302|      0|  case CURLOPT_USE_SSL:
 2303|       |    /*
 2304|       |     * Make transfers attempt to use SSL/TLS.
 2305|       |     */
 2306|      0|    arg = va_arg(param, long);
 2307|      0|    if((arg < CURLUSESSL_NONE) || (arg >= CURLUSESSL_LAST))
 2308|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2309|      0|    data->set.use_ssl = (curl_usessl)arg;
 2310|      0|    break;
 2311|       |
 2312|      0|  case CURLOPT_SSL_OPTIONS:
 2313|      0|    arg = va_arg(param, long);
 2314|      0|    data->set.ssl.enable_beast = !!(arg & CURLSSLOPT_ALLOW_BEAST);
 2315|      0|    data->set.ssl.no_revoke = !!(arg & CURLSSLOPT_NO_REVOKE);
 2316|      0|    data->set.ssl.no_partialchain = !!(arg & CURLSSLOPT_NO_PARTIALCHAIN);
 2317|      0|    data->set.ssl.revoke_best_effort = !!(arg & CURLSSLOPT_REVOKE_BEST_EFFORT);
 2318|      0|    data->set.ssl.native_ca_store = !!(arg & CURLSSLOPT_NATIVE_CA);
 2319|      0|    data->set.ssl.auto_client_cert = !!(arg & CURLSSLOPT_AUTO_CLIENT_CERT);
 2320|       |    /* If a setting is added here it should also be added in dohprobe()
 2321|       |       which sets its own CURLOPT_SSL_OPTIONS based on these settings. */
 2322|      0|    break;
 2323|       |
 2324|      0|#ifndef CURL_DISABLE_PROXY
 2325|      0|  case CURLOPT_PROXY_SSL_OPTIONS:
 2326|      0|    arg = va_arg(param, long);
 2327|      0|    data->set.proxy_ssl.enable_beast = !!(arg & CURLSSLOPT_ALLOW_BEAST);
 2328|      0|    data->set.proxy_ssl.no_revoke = !!(arg & CURLSSLOPT_NO_REVOKE);
 2329|      0|    data->set.proxy_ssl.no_partialchain = !!(arg & CURLSSLOPT_NO_PARTIALCHAIN);
 2330|      0|    data->set.proxy_ssl.revoke_best_effort =
 2331|      0|      !!(arg & CURLSSLOPT_REVOKE_BEST_EFFORT);
 2332|      0|    data->set.proxy_ssl.native_ca_store = !!(arg & CURLSSLOPT_NATIVE_CA);
 2333|      0|    data->set.proxy_ssl.auto_client_cert =
 2334|      0|      !!(arg & CURLSSLOPT_AUTO_CLIENT_CERT);
 2335|      0|    break;
 2336|      0|#endif
 2337|       |
 2338|      0|  case CURLOPT_SSL_EC_CURVES:
 2339|       |    /*
 2340|       |     * Set accepted curves in SSL connection setup.
 2341|       |     * Specify colon-delimited list of curve algorithm names.
 2342|       |     */
 2343|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_EC_CURVES],
 2344|      0|                            va_arg(param, char *));
 2345|      0|    break;
 2346|      0|#endif
 2347|      0|  case CURLOPT_IPRESOLVE:
 2348|      0|    arg = va_arg(param, long);
 2349|      0|    if((arg < CURL_IPRESOLVE_WHATEVER) || (arg > CURL_IPRESOLVE_V6))
 2350|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2351|      0|    data->set.ipver = (unsigned char) arg;
 2352|      0|    break;
 2353|       |
 2354|      0|  case CURLOPT_MAXFILESIZE_LARGE:
 2355|       |    /*
 2356|       |     * Set the maximum size of a file to download.
 2357|       |     */
 2358|      0|    bigsize = va_arg(param, curl_off_t);
 2359|      0|    if(bigsize < 0)
 2360|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2361|      0|    data->set.max_filesize = bigsize;
 2362|      0|    break;
 2363|       |
 2364|      0|  case CURLOPT_TCP_NODELAY:
 2365|       |    /*
 2366|       |     * Enable or disable TCP_NODELAY, which will disable/enable the Nagle
 2367|       |     * algorithm
 2368|       |     */
 2369|      0|    data->set.tcp_nodelay = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2370|      0|    break;
 2371|       |
 2372|      0|  case CURLOPT_IGNORE_CONTENT_LENGTH:
 2373|      0|    data->set.ignorecl = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2374|      0|    break;
 2375|       |
 2376|      0|  case CURLOPT_CONNECT_ONLY:
 2377|       |    /*
 2378|       |     * No data transfer, set up connection and let application use the socket
 2379|       |     */
 2380|      0|    data->set.connect_only = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2381|      0|    break;
 2382|       |
 2383|  3.09k|  case CURLOPT_SOCKOPTFUNCTION:
 2384|       |    /*
 2385|       |     * socket callback function: called after socket() but before connect()
 2386|       |     */
 2387|  3.09k|    data->set.fsockopt = va_arg(param, curl_sockopt_callback);
 2388|  3.09k|    break;
 2389|       |
 2390|      0|  case CURLOPT_SOCKOPTDATA:
 2391|       |    /*
 2392|       |     * socket callback data pointer. Might be NULL.
 2393|       |     */
 2394|      0|    data->set.sockopt_client = va_arg(param, void *);
 2395|      0|    break;
 2396|       |
 2397|  3.09k|  case CURLOPT_OPENSOCKETFUNCTION:
 2398|       |    /*
 2399|       |     * open/create socket callback function: called instead of socket(),
 2400|       |     * before connect()
 2401|       |     */
 2402|  3.09k|    data->set.fopensocket = va_arg(param, curl_opensocket_callback);
 2403|  3.09k|    break;
 2404|       |
 2405|  3.09k|  case CURLOPT_OPENSOCKETDATA:
 2406|       |    /*
 2407|       |     * socket callback data pointer. Might be NULL.
 2408|       |     */
 2409|  3.09k|    data->set.opensocket_client = va_arg(param, void *);
 2410|  3.09k|    break;
 2411|       |
 2412|      0|  case CURLOPT_CLOSESOCKETFUNCTION:
 2413|       |    /*
 2414|       |     * close socket callback function: called instead of close()
 2415|       |     * when shutting down a connection
 2416|       |     */
 2417|      0|    data->set.fclosesocket = va_arg(param, curl_closesocket_callback);
 2418|      0|    break;
 2419|       |
 2420|      0|  case CURLOPT_RESOLVER_START_FUNCTION:
 2421|       |    /*
 2422|       |     * resolver start callback function: called before a new resolver request
 2423|       |     * is started
 2424|       |     */
 2425|      0|    data->set.resolver_start = va_arg(param, curl_resolver_start_callback);
 2426|      0|    break;
 2427|       |
 2428|      0|  case CURLOPT_RESOLVER_START_DATA:
 2429|       |    /*
 2430|       |     * resolver start callback data pointer. Might be NULL.
 2431|       |     */
 2432|      0|    data->set.resolver_start_client = va_arg(param, void *);
 2433|      0|    break;
 2434|       |
 2435|      0|  case CURLOPT_CLOSESOCKETDATA:
 2436|       |    /*
 2437|       |     * socket callback data pointer. Might be NULL.
 2438|       |     */
 2439|      0|    data->set.closesocket_client = va_arg(param, void *);
 2440|      0|    break;
 2441|       |
 2442|      0|  case CURLOPT_SSL_SESSIONID_CACHE:
 2443|      0|    data->set.ssl.primary.sessionid = (0 != va_arg(param, long)) ?
 2444|      0|      TRUE : FALSE;
 2445|      0|#ifndef CURL_DISABLE_PROXY
 2446|      0|    data->set.proxy_ssl.primary.sessionid = data->set.ssl.primary.sessionid;
 2447|      0|#endif
 2448|      0|    break;
 2449|       |
 2450|       |#ifdef USE_SSH
 2451|       |    /* we only include SSH options if explicitly built to support SSH */
 2452|       |  case CURLOPT_SSH_AUTH_TYPES:
 2453|       |    data->set.ssh_auth_types = va_arg(param, long);
 2454|       |    break;
 2455|       |
 2456|       |  case CURLOPT_SSH_PUBLIC_KEYFILE:
 2457|       |    /*
 2458|       |     * Use this file instead of the $HOME/.ssh/id_dsa.pub file
 2459|       |     */
 2460|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_PUBLIC_KEY],
 2461|       |                            va_arg(param, char *));
 2462|       |    break;
 2463|       |
 2464|       |  case CURLOPT_SSH_PRIVATE_KEYFILE:
 2465|       |    /*
 2466|       |     * Use this file instead of the $HOME/.ssh/id_dsa file
 2467|       |     */
 2468|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_PRIVATE_KEY],
 2469|       |                            va_arg(param, char *));
 2470|       |    break;
 2471|       |  case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
 2472|       |    /*
 2473|       |     * Option to allow for the MD5 of the host public key to be checked
 2474|       |     * for validation purposes.
 2475|       |     */
 2476|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5],
 2477|       |                            va_arg(param, char *));
 2478|       |    break;
 2479|       |
 2480|       |  case CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256:
 2481|       |    /*
 2482|       |     * Option to allow for the SHA256 of the host public key to be checked
 2483|       |     * for validation purposes.
 2484|       |     */
 2485|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_HOST_PUBLIC_KEY_SHA256],
 2486|       |                            va_arg(param, char *));
 2487|       |    break;
 2488|       |
 2489|       |  case CURLOPT_SSH_KNOWNHOSTS:
 2490|       |    /*
 2491|       |     * Store the file name to read known hosts from.
 2492|       |     */
 2493|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_KNOWNHOSTS],
 2494|       |                            va_arg(param, char *));
 2495|       |    break;
 2496|       |
 2497|       |  case CURLOPT_SSH_KEYFUNCTION:
 2498|       |    /* setting to NULL is fine since the ssh.c functions themselves will
 2499|       |       then revert to use the internal default */
 2500|       |    data->set.ssh_keyfunc = va_arg(param, curl_sshkeycallback);
 2501|       |    break;
 2502|       |
 2503|       |  case CURLOPT_SSH_KEYDATA:
 2504|       |    /*
 2505|       |     * Custom client data to pass to the SSH keyfunc callback
 2506|       |     */
 2507|       |    data->set.ssh_keyfunc_userp = va_arg(param, void *);
 2508|       |    break;
 2509|       |
 2510|       |  case CURLOPT_SSH_COMPRESSION:
 2511|       |    data->set.ssh_compression = (0 != va_arg(param, long))?TRUE:FALSE;
 2512|       |    break;
 2513|       |#endif /* USE_SSH */
 2514|       |
 2515|      0|  case CURLOPT_HTTP_TRANSFER_DECODING:
 2516|       |    /*
 2517|       |     * disable libcurl transfer encoding is used
 2518|       |     */
 2519|      0|#ifndef USE_HYPER
 2520|      0|    data->set.http_te_skip = (0 == va_arg(param, long)) ? TRUE : FALSE;
 2521|      0|    break;
 2522|       |#else
 2523|       |    return CURLE_NOT_BUILT_IN; /* hyper doesn't support */
 2524|       |#endif
 2525|       |
 2526|      0|  case CURLOPT_HTTP_CONTENT_DECODING:
 2527|       |    /*
 2528|       |     * raw data passed to the application when content encoding is used
 2529|       |     */
 2530|      0|    data->set.http_ce_skip = (0 == va_arg(param, long)) ? TRUE : FALSE;
 2531|      0|    break;
 2532|       |
 2533|      0|#if !defined(CURL_DISABLE_FTP) || defined(USE_SSH)
 2534|      0|  case CURLOPT_NEW_FILE_PERMS:
 2535|       |    /*
 2536|       |     * Uses these permissions instead of 0644
 2537|       |     */
 2538|      0|    arg = va_arg(param, long);
 2539|      0|    if((arg < 0) || (arg > 0777))
 2540|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2541|      0|    data->set.new_file_perms = arg;
 2542|      0|    break;
 2543|       |
 2544|      0|  case CURLOPT_NEW_DIRECTORY_PERMS:
 2545|       |    /*
 2546|       |     * Uses these permissions instead of 0755
 2547|       |     */
 2548|      0|    arg = va_arg(param, long);
 2549|      0|    if((arg < 0) || (arg > 0777))
 2550|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2551|      0|    data->set.new_directory_perms = arg;
 2552|      0|    break;
 2553|      0|#endif
 2554|       |
 2555|      0|  case CURLOPT_ADDRESS_SCOPE:
 2556|       |    /*
 2557|       |     * Use this scope id when using IPv6
 2558|       |     * We always get longs when passed plain numericals so we should check
 2559|       |     * that the value fits into an unsigned 32 bit integer.
 2560|       |     */
 2561|      0|    uarg = va_arg(param, unsigned long);
 2562|      0|#if SIZEOF_LONG > 4
 2563|      0|    if(uarg > UINT_MAX)
 2564|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2565|      0|#endif
 2566|      0|    data->set.scope_id = (unsigned int)uarg;
 2567|      0|    break;
 2568|       |
 2569|  3.09k|  case CURLOPT_PROTOCOLS:
 2570|       |    /* set the bitmask for the protocols that are allowed to be used for the
 2571|       |       transfer, which thus helps the app which takes URLs from users or other
 2572|       |       external inputs and want to restrict what protocol(s) to deal
 2573|       |       with. Defaults to CURLPROTO_ALL. */
 2574|  3.09k|    data->set.allowed_protocols = va_arg(param, long);
 2575|  3.09k|    break;
 2576|       |
 2577|      0|  case CURLOPT_REDIR_PROTOCOLS:
 2578|       |    /* set the bitmask for the protocols that libcurl is allowed to follow to,
 2579|       |       as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs
 2580|       |       to be set in both bitmasks to be allowed to get redirected to. */
 2581|      0|    data->set.redir_protocols = va_arg(param, long);
 2582|      0|    break;
 2583|       |
 2584|      0|  case CURLOPT_DEFAULT_PROTOCOL:
 2585|       |    /* Set the protocol to use when the URL doesn't include any protocol */
 2586|      0|    result = Curl_setstropt(&data->set.str[STRING_DEFAULT_PROTOCOL],
 2587|      0|                            va_arg(param, char *));
 2588|      0|    break;
 2589|      0|#ifndef CURL_DISABLE_SMTP
 2590|     63|  case CURLOPT_MAIL_FROM:
 2591|       |    /* Set the SMTP mail originator */
 2592|     63|    result = Curl_setstropt(&data->set.str[STRING_MAIL_FROM],
 2593|     63|                            va_arg(param, char *));
 2594|     63|    break;
 2595|       |
 2596|      3|  case CURLOPT_MAIL_AUTH:
 2597|       |    /* Set the SMTP auth originator */
 2598|      3|    result = Curl_setstropt(&data->set.str[STRING_MAIL_AUTH],
 2599|      3|                            va_arg(param, char *));
 2600|      3|    break;
 2601|       |
 2602|    131|  case CURLOPT_MAIL_RCPT:
 2603|       |    /* Set the list of mail recipients */
 2604|    131|    data->set.mail_rcpt = va_arg(param, struct curl_slist *);
 2605|    131|    break;
 2606|      0|  case CURLOPT_MAIL_RCPT_ALLLOWFAILS:
 2607|       |    /* allow RCPT TO command to fail for some recipients */
 2608|      0|    data->set.mail_rcpt_allowfails = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2609|      0|    break;
 2610|      0|#endif
 2611|       |
 2612|      0|  case CURLOPT_SASL_AUTHZID:
 2613|       |    /* Authorisation identity (identity to act as) */
 2614|      0|    result = Curl_setstropt(&data->set.str[STRING_SASL_AUTHZID],
 2615|      0|                            va_arg(param, char *));
 2616|      0|    break;
 2617|       |
 2618|      0|  case CURLOPT_SASL_IR:
 2619|       |    /* Enable/disable SASL initial response */
 2620|      0|    data->set.sasl_ir = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2621|      0|    break;
 2622|      0|#ifndef CURL_DISABLE_RTSP
 2623|      4|  case CURLOPT_RTSP_REQUEST:
 2624|      4|  {
 2625|       |    /*
 2626|       |     * Set the RTSP request method (OPTIONS, SETUP, PLAY, etc...)
 2627|       |     * Would this be better if the RTSPREQ_* were just moved into here?
 2628|       |     */
 2629|      4|    long in_rtspreq = va_arg(param, long);
 2630|      4|    Curl_RtspReq rtspreq = RTSPREQ_NONE;
 2631|      4|    switch(in_rtspreq) {
 2632|      0|    case CURL_RTSPREQ_OPTIONS:
 2633|      0|      rtspreq = RTSPREQ_OPTIONS;
 2634|      0|      break;
 2635|       |
 2636|      0|    case CURL_RTSPREQ_DESCRIBE:
 2637|      0|      rtspreq = RTSPREQ_DESCRIBE;
 2638|      0|      break;
 2639|       |
 2640|      0|    case CURL_RTSPREQ_ANNOUNCE:
 2641|      0|      rtspreq = RTSPREQ_ANNOUNCE;
 2642|      0|      break;
 2643|       |
 2644|      0|    case CURL_RTSPREQ_SETUP:
 2645|      0|      rtspreq = RTSPREQ_SETUP;
 2646|      0|      break;
 2647|       |
 2648|      0|    case CURL_RTSPREQ_PLAY:
 2649|      0|      rtspreq = RTSPREQ_PLAY;
 2650|      0|      break;
 2651|       |
 2652|      0|    case CURL_RTSPREQ_PAUSE:
 2653|      0|      rtspreq = RTSPREQ_PAUSE;
 2654|      0|      break;
 2655|       |
 2656|      0|    case CURL_RTSPREQ_TEARDOWN:
 2657|      0|      rtspreq = RTSPREQ_TEARDOWN;
 2658|      0|      break;
 2659|       |
 2660|      0|    case CURL_RTSPREQ_GET_PARAMETER:
 2661|      0|      rtspreq = RTSPREQ_GET_PARAMETER;
 2662|      0|      break;
 2663|       |
 2664|      0|    case CURL_RTSPREQ_SET_PARAMETER:
 2665|      0|      rtspreq = RTSPREQ_SET_PARAMETER;
 2666|      0|      break;
 2667|       |
 2668|      1|    case CURL_RTSPREQ_RECORD:
 2669|      1|      rtspreq = RTSPREQ_RECORD;
 2670|      1|      break;
 2671|       |
 2672|      0|    case CURL_RTSPREQ_RECEIVE:
 2673|      0|      rtspreq = RTSPREQ_RECEIVE;
 2674|      0|      break;
 2675|      3|    default:
 2676|      3|      rtspreq = RTSPREQ_NONE;
 2677|      4|    }
 2678|       |
 2679|      4|    data->set.rtspreq = rtspreq;
 2680|      4|    break;
 2681|      4|  }
 2682|       |
 2683|       |
 2684|      3|  case CURLOPT_RTSP_SESSION_ID:
 2685|       |    /*
 2686|       |     * Set the RTSP Session ID manually. Useful if the application is
 2687|       |     * resuming a previously established RTSP session
 2688|       |     */
 2689|      3|    result = Curl_setstropt(&data->set.str[STRING_RTSP_SESSION_ID],
 2690|      3|                            va_arg(param, char *));
 2691|      3|    break;
 2692|       |
 2693|      6|  case CURLOPT_RTSP_STREAM_URI:
 2694|       |    /*
 2695|       |     * Set the Stream URI for the RTSP request. Unless the request is
 2696|       |     * for generic server options, the application will need to set this.
 2697|       |     */
 2698|      6|    result = Curl_setstropt(&data->set.str[STRING_RTSP_STREAM_URI],
 2699|      6|                            va_arg(param, char *));
 2700|      6|    break;
 2701|       |
 2702|      1|  case CURLOPT_RTSP_TRANSPORT:
 2703|       |    /*
 2704|       |     * The content of the Transport: header for the RTSP request
 2705|       |     */
 2706|      1|    result = Curl_setstropt(&data->set.str[STRING_RTSP_TRANSPORT],
 2707|      1|                            va_arg(param, char *));
 2708|      1|    break;
 2709|       |
 2710|      3|  case CURLOPT_RTSP_CLIENT_CSEQ:
 2711|       |    /*
 2712|       |     * Set the CSEQ number to issue for the next RTSP request. Useful if the
 2713|       |     * application is resuming a previously broken connection. The CSEQ
 2714|       |     * will increment from this new number henceforth.
 2715|       |     */
 2716|      3|    data->state.rtsp_next_client_CSeq = va_arg(param, long);
 2717|      3|    break;
 2718|       |
 2719|      0|  case CURLOPT_RTSP_SERVER_CSEQ:
 2720|       |    /* Same as the above, but for server-initiated requests */
 2721|      0|    data->state.rtsp_next_server_CSeq = va_arg(param, long);
 2722|      0|    break;
 2723|       |
 2724|      0|  case CURLOPT_INTERLEAVEDATA:
 2725|      0|    data->set.rtp_out = va_arg(param, void *);
 2726|      0|    break;
 2727|      0|  case CURLOPT_INTERLEAVEFUNCTION:
 2728|       |    /* Set the user defined RTP write function */
 2729|      0|    data->set.fwrite_rtp = va_arg(param, curl_write_callback);
 2730|      0|    break;
 2731|      0|#endif
 2732|      0|#ifndef CURL_DISABLE_FTP
 2733|     37|  case CURLOPT_WILDCARDMATCH:
 2734|     37|    data->set.wildcard_enabled = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2735|     37|    break;
 2736|      0|  case CURLOPT_CHUNK_BGN_FUNCTION:
 2737|      0|    data->set.chunk_bgn = va_arg(param, curl_chunk_bgn_callback);
 2738|      0|    break;
 2739|      0|  case CURLOPT_CHUNK_END_FUNCTION:
 2740|      0|    data->set.chunk_end = va_arg(param, curl_chunk_end_callback);
 2741|      0|    break;
 2742|      0|  case CURLOPT_FNMATCH_FUNCTION:
 2743|      0|    data->set.fnmatch = va_arg(param, curl_fnmatch_callback);
 2744|      0|    break;
 2745|      0|  case CURLOPT_CHUNK_DATA:
 2746|      0|    data->wildcard.customptr = va_arg(param, void *);
 2747|      0|    break;
 2748|      0|  case CURLOPT_FNMATCH_DATA:
 2749|      0|    data->set.fnmatch_data = va_arg(param, void *);
 2750|      0|    break;
 2751|      0|#endif
 2752|      0|#ifdef USE_TLS_SRP
 2753|      0|  case CURLOPT_TLSAUTH_USERNAME:
 2754|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_USERNAME],
 2755|      0|                            va_arg(param, char *));
 2756|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME] && !data->set.ssl.authtype)
 2757|      0|      data->set.ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2758|      0|    break;
 2759|      0|  case CURLOPT_PROXY_TLSAUTH_USERNAME:
 2760|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_USERNAME_PROXY],
 2761|      0|                            va_arg(param, char *));
 2762|      0|#ifndef CURL_DISABLE_PROXY
 2763|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME_PROXY] &&
 2764|      0|       !data->set.proxy_ssl.authtype)
 2765|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2766|      0|#endif
 2767|      0|    break;
 2768|      0|  case CURLOPT_TLSAUTH_PASSWORD:
 2769|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_PASSWORD],
 2770|      0|                            va_arg(param, char *));
 2771|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME] && !data->set.ssl.authtype)
 2772|      0|      data->set.ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2773|      0|    break;
 2774|      0|  case CURLOPT_PROXY_TLSAUTH_PASSWORD:
 2775|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_PASSWORD_PROXY],
 2776|      0|                            va_arg(param, char *));
 2777|      0|#ifndef CURL_DISABLE_PROXY
 2778|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME_PROXY] &&
 2779|      0|       !data->set.proxy_ssl.authtype)
 2780|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2781|      0|#endif
 2782|      0|    break;
 2783|      0|  case CURLOPT_TLSAUTH_TYPE:
 2784|      0|    argptr = va_arg(param, char *);
 2785|      0|    if(!argptr ||
 2786|      0|       strncasecompare(argptr, "SRP", strlen("SRP")))
 2787|      0|      data->set.ssl.authtype = CURL_TLSAUTH_SRP;
 2788|      0|    else
 2789|      0|      data->set.ssl.authtype = CURL_TLSAUTH_NONE;
 2790|      0|    break;
 2791|      0|#ifndef CURL_DISABLE_PROXY
 2792|      0|  case CURLOPT_PROXY_TLSAUTH_TYPE:
 2793|      0|    argptr = va_arg(param, char *);
 2794|      0|    if(!argptr ||
 2795|      0|       strncasecompare(argptr, "SRP", strlen("SRP")))
 2796|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_SRP;
 2797|      0|    else
 2798|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_NONE;
 2799|      0|    break;
 2800|      0|#endif
 2801|      0|#endif
 2802|       |#ifdef USE_ARES
 2803|       |  case CURLOPT_DNS_SERVERS:
 2804|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_SERVERS],
 2805|       |                            va_arg(param, char *));
 2806|       |    if(result)
 2807|       |      return result;
 2808|       |    result = Curl_set_dns_servers(data, data->set.str[STRING_DNS_SERVERS]);
 2809|       |    break;
 2810|       |  case CURLOPT_DNS_INTERFACE:
 2811|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_INTERFACE],
 2812|       |                            va_arg(param, char *));
 2813|       |    if(result)
 2814|       |      return result;
 2815|       |    result = Curl_set_dns_interface(data, data->set.str[STRING_DNS_INTERFACE]);
 2816|       |    break;
 2817|       |  case CURLOPT_DNS_LOCAL_IP4:
 2818|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_LOCAL_IP4],
 2819|       |                            va_arg(param, char *));
 2820|       |    if(result)
 2821|       |      return result;
 2822|       |    result = Curl_set_dns_local_ip4(data, data->set.str[STRING_DNS_LOCAL_IP4]);
 2823|       |    break;
 2824|       |  case CURLOPT_DNS_LOCAL_IP6:
 2825|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_LOCAL_IP6],
 2826|       |                            va_arg(param, char *));
 2827|       |    if(result)
 2828|       |      return result;
 2829|       |    result = Curl_set_dns_local_ip6(data, data->set.str[STRING_DNS_LOCAL_IP6]);
 2830|       |    break;
 2831|       |#endif
 2832|      0|  case CURLOPT_TCP_KEEPALIVE:
 2833|      0|    data->set.tcp_keepalive = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2834|      0|    break;
 2835|      0|  case CURLOPT_TCP_KEEPIDLE:
 2836|      0|    arg = va_arg(param, long);
 2837|      0|    if(arg < 0)
 2838|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2839|      0|    data->set.tcp_keepidle = arg;
 2840|      0|    break;
 2841|      0|  case CURLOPT_TCP_KEEPINTVL:
 2842|      0|    arg = va_arg(param, long);
 2843|      0|    if(arg < 0)
 2844|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2845|      0|    data->set.tcp_keepintvl = arg;
 2846|      0|    break;
 2847|      0|  case CURLOPT_TCP_FASTOPEN:
 2848|      0|#if defined(CONNECT_DATA_IDEMPOTENT) || defined(MSG_FASTOPEN) || \
 2849|      0|   defined(TCP_FASTOPEN_CONNECT)
 2850|      0|    data->set.tcp_fastopen = (0 != va_arg(param, long))?TRUE:FALSE;
 2851|       |#else
 2852|       |    result = CURLE_NOT_BUILT_IN;
 2853|       |#endif
 2854|      0|    break;
 2855|      0|  case CURLOPT_SSL_ENABLE_NPN:
 2856|      0|    data->set.ssl_enable_npn = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2857|      0|    break;
 2858|      0|  case CURLOPT_SSL_ENABLE_ALPN:
 2859|      0|    data->set.ssl_enable_alpn = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2860|      0|    break;
 2861|      0|#ifdef USE_UNIX_SOCKETS
 2862|      0|  case CURLOPT_UNIX_SOCKET_PATH:
 2863|      0|    data->set.abstract_unix_socket = FALSE;
 2864|      0|    result = Curl_setstropt(&data->set.str[STRING_UNIX_SOCKET_PATH],
 2865|      0|                            va_arg(param, char *));
 2866|      0|    break;
 2867|      0|  case CURLOPT_ABSTRACT_UNIX_SOCKET:
 2868|      0|    data->set.abstract_unix_socket = TRUE;
 2869|      0|    result = Curl_setstropt(&data->set.str[STRING_UNIX_SOCKET_PATH],
 2870|      0|                            va_arg(param, char *));
 2871|      0|    break;
 2872|      0|#endif
 2873|       |
 2874|      0|  case CURLOPT_PATH_AS_IS:
 2875|      0|    data->set.path_as_is = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2876|      0|    break;
 2877|      0|  case CURLOPT_PIPEWAIT:
 2878|      0|    data->set.pipewait = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2879|      0|    break;
 2880|      0|  case CURLOPT_STREAM_WEIGHT:
 2881|       |#ifndef USE_NGHTTP2
 2882|       |    return CURLE_NOT_BUILT_IN;
 2883|       |#else
 2884|      0|    arg = va_arg(param, long);
 2885|      0|    if((arg >= 1) && (arg <= 256))
 2886|      0|      data->set.stream_weight = (int)arg;
 2887|      0|    break;
 2888|      0|#endif
 2889|      0|  case CURLOPT_STREAM_DEPENDS:
 2890|      0|  case CURLOPT_STREAM_DEPENDS_E:
 2891|      0|  {
 2892|       |#ifndef USE_NGHTTP2
 2893|       |    return CURLE_NOT_BUILT_IN;
 2894|       |#else
 2895|      0|    struct Curl_easy *dep = va_arg(param, struct Curl_easy *);
 2896|      0|    if(!dep || GOOD_EASY_HANDLE(dep)) {
 2897|      0|      if(data->set.stream_depends_on) {
 2898|      0|        Curl_http2_remove_child(data->set.stream_depends_on, data);
 2899|      0|      }
 2900|      0|      Curl_http2_add_child(dep, data, (option == CURLOPT_STREAM_DEPENDS_E));
 2901|      0|    }
 2902|      0|    break;
 2903|      0|#endif
 2904|      0|  }
 2905|  3.09k|  case CURLOPT_CONNECT_TO:
 2906|  3.09k|    data->set.connect_to = va_arg(param, struct curl_slist *);
 2907|  3.09k|    break;
 2908|      0|  case CURLOPT_SUPPRESS_CONNECT_HEADERS:
 2909|      0|    data->set.suppress_connect_headers = (0 != va_arg(param, long))?TRUE:FALSE;
 2910|      0|    break;
 2911|      0|  case CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS:
 2912|      0|    arg = va_arg(param, long);
 2913|      0|    if(arg < 0)
 2914|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2915|      0|    data->set.happy_eyeballs_timeout = arg;
 2916|      0|    break;
 2917|      0|#ifndef CURL_DISABLE_SHUFFLE_DNS
 2918|      0|  case CURLOPT_DNS_SHUFFLE_ADDRESSES:
 2919|      0|    data->set.dns_shuffle_addresses = (0 != va_arg(param, long)) ? TRUE:FALSE;
 2920|      0|    break;
 2921|      0|#endif
 2922|      0|  case CURLOPT_DISALLOW_USERNAME_IN_URL:
 2923|      0|    data->set.disallow_username_in_url =
 2924|      0|      (0 != va_arg(param, long)) ? TRUE : FALSE;
 2925|      0|    break;
 2926|      0|#ifndef CURL_DISABLE_DOH
 2927|      2|  case CURLOPT_DOH_URL:
 2928|      2|    result = Curl_setstropt(&data->set.str[STRING_DOH],
 2929|      2|                            va_arg(param, char *));
 2930|      2|    data->set.doh = data->set.str[STRING_DOH]?TRUE:FALSE;
 2931|      2|    break;
 2932|      0|#endif
 2933|      0|  case CURLOPT_UPKEEP_INTERVAL_MS:
 2934|      0|    arg = va_arg(param, long);
 2935|      0|    if(arg < 0)
 2936|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2937|      0|    data->set.upkeep_interval_ms = arg;
 2938|      0|    break;
 2939|      0|  case CURLOPT_MAXAGE_CONN:
 2940|      0|    arg = va_arg(param, long);
 2941|      0|    if(arg < 0)
 2942|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2943|      0|    data->set.maxage_conn = arg;
 2944|      0|    break;
 2945|      0|  case CURLOPT_MAXLIFETIME_CONN:
 2946|      0|    arg = va_arg(param, long);
 2947|      0|    if(arg < 0)
 2948|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2949|      0|    data->set.maxlifetime_conn = arg;
 2950|      0|    break;
 2951|      0|  case CURLOPT_TRAILERFUNCTION:
 2952|      0|#ifndef CURL_DISABLE_HTTP
 2953|      0|    data->set.trailer_callback = va_arg(param, curl_trailer_callback);
 2954|      0|#endif
 2955|      0|    break;
 2956|      0|  case CURLOPT_TRAILERDATA:
 2957|      0|#ifndef CURL_DISABLE_HTTP
 2958|      0|    data->set.trailer_data = va_arg(param, void *);
 2959|      0|#endif
 2960|      0|    break;
 2961|      0|#ifndef CURL_DISABLE_HSTS
 2962|      0|  case CURLOPT_HSTSREADFUNCTION:
 2963|      0|    data->set.hsts_read = va_arg(param, curl_hstsread_callback);
 2964|      0|    break;
 2965|      0|  case CURLOPT_HSTSREADDATA:
 2966|      0|    data->set.hsts_read_userp = va_arg(param, void *);
 2967|      0|    break;
 2968|      0|  case CURLOPT_HSTSWRITEFUNCTION:
 2969|      0|    data->set.hsts_write = va_arg(param, curl_hstswrite_callback);
 2970|      0|    break;
 2971|      0|  case CURLOPT_HSTSWRITEDATA:
 2972|      0|    data->set.hsts_write_userp = va_arg(param, void *);
 2973|      0|    break;
 2974|      0|  case CURLOPT_HSTS:
 2975|      0|    if(!data->hsts) {
 2976|      0|      data->hsts = Curl_hsts_init();
 2977|      0|      if(!data->hsts)
 2978|      0|        return CURLE_OUT_OF_MEMORY;
 2979|      0|    }
 2980|      0|    argptr = va_arg(param, char *);
 2981|      0|    result = Curl_setstropt(&data->set.str[STRING_HSTS], argptr);
 2982|      0|    if(result)
 2983|      0|      return result;
 2984|      0|    if(argptr)
 2985|      0|      (void)Curl_hsts_loadfile(data, data->hsts, argptr);
 2986|      0|    break;
 2987|      0|  case CURLOPT_HSTS_CTRL:
 2988|      0|    arg = va_arg(param, long);
 2989|      0|    if(arg & CURLHSTS_ENABLE) {
 2990|      0|      if(!data->hsts) {
 2991|      0|        data->hsts = Curl_hsts_init();
 2992|      0|        if(!data->hsts)
 2993|      0|          return CURLE_OUT_OF_MEMORY;
 2994|      0|      }
 2995|      0|    }
 2996|      0|    else
 2997|      0|      Curl_hsts_cleanup(&data->hsts);
 2998|      0|    break;
 2999|      0|#endif
 3000|      0|#ifndef CURL_DISABLE_ALTSVC
 3001|      0|  case CURLOPT_ALTSVC:
 3002|      0|    if(!data->asi) {
 3003|      0|      data->asi = Curl_altsvc_init();
 3004|      0|      if(!data->asi)
 3005|      0|        return CURLE_OUT_OF_MEMORY;
 3006|      0|    }
 3007|      0|    argptr = va_arg(param, char *);
 3008|      0|    result = Curl_setstropt(&data->set.str[STRING_ALTSVC], argptr);
 3009|      0|    if(result)
 3010|      0|      return result;
 3011|      0|    if(argptr)
 3012|      0|      (void)Curl_altsvc_load(data->asi, argptr);
 3013|      0|    break;
 3014|      0|  case CURLOPT_ALTSVC_CTRL:
 3015|      0|    if(!data->asi) {
 3016|      0|      data->asi = Curl_altsvc_init();
 3017|      0|      if(!data->asi)
 3018|      0|        return CURLE_OUT_OF_MEMORY;
 3019|      0|    }
 3020|      0|    arg = va_arg(param, long);
 3021|      0|    result = Curl_altsvc_ctrl(data->asi, arg);
 3022|      0|    if(result)
 3023|      0|      return result;
 3024|      0|    break;
 3025|      0|#endif
 3026|      0|  case CURLOPT_PREREQFUNCTION:
 3027|      0|    data->set.fprereq = va_arg(param, curl_prereq_callback);
 3028|      0|    break;
 3029|      0|  case CURLOPT_PREREQDATA:
 3030|      0|    data->set.prereq_userp = va_arg(param, void *);
 3031|      0|    break;
 3032|      0|  default:
 3033|       |    /* unknown tag and its companion, just ignore: */
 3034|      0|    result = CURLE_UNKNOWN_OPTION;
 3035|      0|    break;
 3036|  41.8k|  }
 3037|       |
 3038|  41.8k|  return result;
 3039|  41.8k|}
curl_easy_setopt:
 3051|  41.8k|{
 3052|  41.8k|  va_list arg;
 3053|  41.8k|  CURLcode result;
 3054|       |
 3055|  41.8k|  if(!data)
 3056|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 3057|       |
 3058|  41.8k|  va_start(arg, tag);
 3059|       |
 3060|  41.8k|  result = Curl_vsetopt(data, tag, arg);
 3061|       |
 3062|  41.8k|  va_end(arg);
 3063|  41.8k|  return result;
 3064|  41.8k|}

Curl_sha256it:
  497|     18|{
  498|     18|  my_sha256_ctx ctx;
  499|       |
  500|     18|  my_sha256_init(&ctx);
  501|     18|  my_sha256_update(&ctx, input, curlx_uztoui(length));
  502|     18|  my_sha256_final(output, &ctx);
  503|     18|}
sha256.c:my_sha256_init:
   86|    108|{
   87|    108|  ctx->openssl_ctx = EVP_MD_CTX_create();
   88|    108|  EVP_DigestInit_ex(ctx->openssl_ctx, EVP_sha256(), NULL);
   89|    108|}
sha256.c:my_sha256_update:
   94|  5.86k|{
   95|  5.86k|  EVP_DigestUpdate(ctx->openssl_ctx, data, length);
   96|  5.86k|}
sha256.c:my_sha256_final:
   99|    108|{
  100|    108|  EVP_DigestFinal_ex(ctx->openssl_ctx, digest, NULL);
  101|    108|  EVP_MD_CTX_destroy(ctx->openssl_ctx);
  102|    108|}

Curl_share_lock:
  235|  15.6k|{
  236|  15.6k|  struct Curl_share *share = data->share;
  237|       |
  238|  15.6k|  if(!share)
  239|  15.6k|    return CURLSHE_INVALID;
  240|       |
  241|      0|  if(share->specifier & (1<<type)) {
  242|      0|    if(share->lockfunc) /* only call this if set! */
  243|      0|      share->lockfunc(data, type, accesstype, share->clientdata);
  244|      0|  }
  245|       |  /* else if we don't share this, pretend successful lock */
  246|       |
  247|      0|  return CURLSHE_OK;
  248|  15.6k|}
Curl_share_unlock:
  252|  15.6k|{
  253|  15.6k|  struct Curl_share *share = data->share;
  254|       |
  255|  15.6k|  if(!share)
  256|  15.6k|    return CURLSHE_INVALID;
  257|       |
  258|      0|  if(share->specifier & (1<<type)) {
  259|      0|    if(share->unlockfunc) /* only call this if set! */
  260|      0|      share->unlockfunc (data, type, share->clientdata);
  261|      0|  }
  262|       |
  263|      0|  return CURLSHE_OK;
  264|  15.6k|}

Curl_slist_append_nodup:
   60|  13.7k|{
   61|  13.7k|  struct curl_slist     *last;
   62|  13.7k|  struct curl_slist     *new_item;
   63|       |
   64|  13.7k|  DEBUGASSERT(data);
   65|       |
   66|  13.7k|  new_item = malloc(sizeof(struct curl_slist));
   67|  13.7k|  if(!new_item)
   68|      0|    return NULL;
   69|       |
   70|  13.7k|  new_item->next = NULL;
   71|  13.7k|  new_item->data = data;
   72|       |
   73|       |  /* if this is the first item, then new_item *is* the list */
   74|  13.7k|  if(!list)
   75|  6.79k|    return new_item;
   76|       |
   77|  6.97k|  last = slist_get_last(list);
   78|  6.97k|  last->next = new_item;
   79|  6.97k|  return list;
   80|  13.7k|}
curl_slist_append:
   91|  10.2k|{
   92|  10.2k|  char *dupdata = strdup(data);
   93|       |
   94|  10.2k|  if(!dupdata)
   95|      0|    return NULL;
   96|       |
   97|  10.2k|  list = Curl_slist_append_nodup(list, dupdata);
   98|  10.2k|  if(!list)
   99|      0|    free(dupdata);
  100|       |
  101|  10.2k|  return list;
  102|  10.2k|}
curl_slist_free_all:
  130|  54.9k|{
  131|  54.9k|  struct curl_slist     *next;
  132|  54.9k|  struct curl_slist     *item;
  133|       |
  134|  54.9k|  if(!list)
  135|  48.1k|    return;
  136|       |
  137|  6.79k|  item = list;
  138|  13.7k|  do {
  139|  13.7k|    next = item->next;
  140|  13.7k|    Curl_safefree(item->data);
  141|  13.7k|    free(item);
  142|  13.7k|    item = next;
  143|  13.7k|  } while(next);
  144|  6.79k|}
slist.c:slist_get_last:
   35|  6.97k|{
   36|  6.97k|  struct curl_slist     *item;
   37|       |
   38|       |  /* if caller passed us a NULL, return now */
   39|  6.97k|  if(!list)
   40|      0|    return NULL;
   41|       |
   42|       |  /* loop through to find the last item */
   43|  6.97k|  item = list;
   44|   549k|  while(item->next) {
   45|   542k|    item = item->next;
   46|   542k|  }
   47|  6.97k|  return item;
   48|  6.97k|}

Curl_smtp_escape_eob:
 1823|     51|{
 1824|       |  /* When sending a SMTP payload we must detect CRLF. sequences making sure
 1825|       |     they are sent as CRLF.. instead, as a . on the beginning of a line will
 1826|       |     be deleted by the server when not part of an EOB terminator and a
 1827|       |     genuine CRLF.CRLF which isn't escaped will wrongly be detected as end of
 1828|       |     data by the server
 1829|       |  */
 1830|     51|  ssize_t i;
 1831|     51|  ssize_t si;
 1832|     51|  struct SMTP *smtp = data->req.p.smtp;
 1833|     51|  char *scratch = data->state.scratch;
 1834|     51|  char *newscratch = NULL;
 1835|     51|  char *oldscratch = NULL;
 1836|     51|  size_t eob_sent;
 1837|       |
 1838|       |  /* Do we need to allocate a scratch buffer? */
 1839|     51|  if(!scratch || data->set.crlf) {
 1840|     50|    oldscratch = scratch;
 1841|       |
 1842|     50|    scratch = newscratch = malloc(2 * data->set.upload_buffer_size);
 1843|     50|    if(!newscratch) {
 1844|      0|      failf(data, "Failed to alloc scratch buffer!");
 1845|       |
 1846|      0|      return CURLE_OUT_OF_MEMORY;
 1847|      0|    }
 1848|     50|  }
 1849|     51|  DEBUGASSERT((size_t)data->set.upload_buffer_size >= (size_t)nread);
 1850|       |
 1851|       |  /* Have we already sent part of the EOB? */
 1852|     51|  eob_sent = smtp->eob;
 1853|       |
 1854|       |  /* This loop can be improved by some kind of Boyer-Moore style of
 1855|       |     approach but that is saved for later... */
 1856|   831k|  for(i = 0, si = 0; i < nread; i++) {
 1857|   831k|    if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) {
 1858|  69.2k|      smtp->eob++;
 1859|       |
 1860|       |      /* Is the EOB potentially the terminating CRLF? */
 1861|  69.2k|      if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob)
 1862|  51.7k|        smtp->trailing_crlf = TRUE;
 1863|  17.5k|      else
 1864|  17.5k|        smtp->trailing_crlf = FALSE;
 1865|  69.2k|    }
 1866|   762k|    else if(smtp->eob) {
 1867|       |      /* A previous substring matched so output that first */
 1868|  51.8k|      memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);
 1869|  51.8k|      si += smtp->eob - eob_sent;
 1870|       |
 1871|       |      /* Then compare the first byte */
 1872|  51.8k|      if(SMTP_EOB[0] == data->req.upload_fromhere[i])
 1873|  34.3k|        smtp->eob = 1;
 1874|  17.5k|      else
 1875|  17.5k|        smtp->eob = 0;
 1876|       |
 1877|  51.8k|      eob_sent = 0;
 1878|       |
 1879|       |      /* Reset the trailing CRLF flag as there was more data */
 1880|  51.8k|      smtp->trailing_crlf = FALSE;
 1881|  51.8k|    }
 1882|       |
 1883|       |    /* Do we have a match for CRLF. as per RFC-5321, sect. 4.5.2 */
 1884|   831k|    if(SMTP_EOB_FIND_LEN == smtp->eob) {
 1885|       |      /* Copy the replacement data to the target buffer */
 1886|     43|      memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent],
 1887|     43|             SMTP_EOB_REPL_LEN - eob_sent);
 1888|     43|      si += SMTP_EOB_REPL_LEN - eob_sent;
 1889|     43|      smtp->eob = 0;
 1890|     43|      eob_sent = 0;
 1891|     43|    }
 1892|   831k|    else if(!smtp->eob)
 1893|   728k|      scratch[si++] = data->req.upload_fromhere[i];
 1894|   831k|  }
 1895|       |
 1896|     51|  if(smtp->eob - eob_sent) {
 1897|       |    /* A substring matched before processing ended so output that now */
 1898|     41|    memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent);
 1899|     41|    si += smtp->eob - eob_sent;
 1900|     41|  }
 1901|       |
 1902|       |  /* Only use the new buffer if we replaced something */
 1903|     51|  if(si != nread) {
 1904|       |    /* Upload from the new (replaced) buffer instead */
 1905|     22|    data->req.upload_fromhere = scratch;
 1906|       |
 1907|       |    /* Save the buffer so it can be freed later */
 1908|     22|    data->state.scratch = scratch;
 1909|       |
 1910|       |    /* Free the old scratch buffer */
 1911|     22|    free(oldscratch);
 1912|       |
 1913|       |    /* Set the new amount too */
 1914|     22|    data->req.upload_present = si;
 1915|     22|  }
 1916|     29|  else
 1917|     29|    free(newscratch);
 1918|       |
 1919|     51|  return CURLE_OK;
 1920|     51|}
smtp.c:smtp_multi_statemach:
 1280|  2.09k|{
 1281|  2.09k|  CURLcode result = CURLE_OK;
 1282|  2.09k|  struct connectdata *conn = data->conn;
 1283|  2.09k|  struct smtp_conn *smtpc = &conn->proto.smtpc;
 1284|       |
 1285|  2.09k|  if((conn->handler->flags & PROTOPT_SSL) && !smtpc->ssldone) {
 1286|      0|    result = Curl_ssl_connect_nonblocking(data, conn, FALSE,
 1287|      0|                                          FIRSTSOCKET, &smtpc->ssldone);
 1288|      0|    if(result || !smtpc->ssldone)
 1289|      0|      return result;
 1290|      0|  }
 1291|       |
 1292|  2.09k|  result = Curl_pp_statemach(data, &smtpc->pp, FALSE, FALSE);
 1293|  2.09k|  *done = (smtpc->state == SMTP_STOP) ? TRUE : FALSE;
 1294|       |
 1295|  2.09k|  return result;
 1296|  2.09k|}
smtp.c:smtp_getsock:
 1328|  1.64k|{
 1329|  1.64k|  return Curl_pp_getsock(data, &conn->proto.smtpc.pp, socks);
 1330|  1.64k|}
smtp.c:smtp_connect:
 1343|    300|{
 1344|    300|  CURLcode result = CURLE_OK;
 1345|    300|  struct connectdata *conn = data->conn;
 1346|    300|  struct smtp_conn *smtpc = &conn->proto.smtpc;
 1347|    300|  struct pingpong *pp = &smtpc->pp;
 1348|       |
 1349|    300|  *done = FALSE; /* default to not done yet */
 1350|       |
 1351|       |  /* We always support persistent connections in SMTP */
 1352|    300|  connkeep(conn, "SMTP default");
 1353|       |
 1354|    300|  PINGPONG_SETUP(pp, smtp_statemachine, smtp_endofresp);
 1355|       |
 1356|       |  /* Initialize the SASL storage */
 1357|    300|  Curl_sasl_init(&smtpc->sasl, data, &saslsmtp);
 1358|       |
 1359|       |  /* Initialise the pingpong layer */
 1360|    300|  Curl_pp_setup(pp);
 1361|    300|  Curl_pp_init(data, pp);
 1362|       |
 1363|       |  /* Parse the URL options */
 1364|    300|  result = smtp_parse_url_options(conn);
 1365|    300|  if(result)
 1366|     18|    return result;
 1367|       |
 1368|       |  /* Parse the URL path */
 1369|    282|  result = smtp_parse_url_path(data);
 1370|    282|  if(result)
 1371|      1|    return result;
 1372|       |
 1373|       |  /* Start off waiting for the server greeting response */
 1374|    281|  state(data, SMTP_SERVERGREET);
 1375|       |
 1376|    281|  result = smtp_multi_statemach(data, done);
 1377|       |
 1378|    281|  return result;
 1379|    282|}
smtp.c:smtp_statemachine:
 1195|  2.81k|{
 1196|  2.81k|  CURLcode result = CURLE_OK;
 1197|  2.81k|  curl_socket_t sock = conn->sock[FIRSTSOCKET];
 1198|  2.81k|  int smtpcode;
 1199|  2.81k|  struct smtp_conn *smtpc = &conn->proto.smtpc;
 1200|  2.81k|  struct pingpong *pp = &smtpc->pp;
 1201|  2.81k|  size_t nread = 0;
 1202|       |
 1203|       |  /* Busy upgrading the connection; right now all I/O is SSL/TLS, not SMTP */
 1204|  2.81k|  if(smtpc->state == SMTP_UPGRADETLS)
 1205|      0|    return smtp_perform_upgrade_tls(data);
 1206|       |
 1207|       |  /* Flush any data that needs to be sent */
 1208|  2.81k|  if(pp->sendleft)
 1209|      0|    return Curl_pp_flushsend(data, pp);
 1210|       |
 1211|  6.05k|  do {
 1212|       |    /* Read the response from the server */
 1213|  6.05k|    result = Curl_pp_readresp(data, sock, pp, &smtpcode, &nread);
 1214|  6.05k|    if(result)
 1215|    278|      return result;
 1216|       |
 1217|       |    /* Store the latest response for later retrieval if necessary */
 1218|  5.77k|    if(smtpc->state != SMTP_QUIT && smtpcode != 1)
 1219|  2.40k|      data->info.httpcode = smtpcode;
 1220|       |
 1221|  5.77k|    if(!smtpcode)
 1222|  2.02k|      break;
 1223|       |
 1224|       |    /* We have now received a full SMTP server response */
 1225|  3.74k|    switch(smtpc->state) {
 1226|    245|    case SMTP_SERVERGREET:
 1227|    245|      result = smtp_state_servergreet_resp(data, smtpcode, smtpc->state);
 1228|    245|      break;
 1229|       |
 1230|  2.21k|    case SMTP_EHLO:
 1231|  2.21k|      result = smtp_state_ehlo_resp(data, conn, smtpcode, smtpc->state);
 1232|  2.21k|      break;
 1233|       |
 1234|     13|    case SMTP_HELO:
 1235|     13|      result = smtp_state_helo_resp(data, smtpcode, smtpc->state);
 1236|     13|      break;
 1237|       |
 1238|      0|    case SMTP_STARTTLS:
 1239|      0|      result = smtp_state_starttls_resp(data, smtpcode, smtpc->state);
 1240|      0|      break;
 1241|       |
 1242|      0|    case SMTP_AUTH:
 1243|      0|      result = smtp_state_auth_resp(data, smtpcode, smtpc->state);
 1244|      0|      break;
 1245|       |
 1246|    938|    case SMTP_COMMAND:
 1247|    938|      result = smtp_state_command_resp(data, smtpcode, smtpc->state);
 1248|    938|      break;
 1249|       |
 1250|     68|    case SMTP_MAIL:
 1251|     68|      result = smtp_state_mail_resp(data, smtpcode, smtpc->state);
 1252|     68|      break;
 1253|       |
 1254|    179|    case SMTP_RCPT:
 1255|    179|      result = smtp_state_rcpt_resp(data, conn, smtpcode, smtpc->state);
 1256|    179|      break;
 1257|       |
 1258|     51|    case SMTP_DATA:
 1259|     51|      result = smtp_state_data_resp(data, smtpcode, smtpc->state);
 1260|     51|      break;
 1261|       |
 1262|     22|    case SMTP_POSTDATA:
 1263|     22|      result = smtp_state_postdata_resp(data, smtpcode, smtpc->state);
 1264|     22|      break;
 1265|       |
 1266|     21|    case SMTP_QUIT:
 1267|       |      /* fallthrough, just stop! */
 1268|     21|    default:
 1269|       |      /* internal error */
 1270|     21|      state(data, SMTP_STOP);
 1271|     21|      break;
 1272|  3.74k|    }
 1273|  3.74k|  } while(!result && smtpc->state != SMTP_STOP && Curl_pp_moredata(pp));
 1274|       |
 1275|  2.53k|  return result;
 1276|  2.81k|}
smtp.c:smtp_perform_ehlo:
  327|    244|{
  328|    244|  CURLcode result = CURLE_OK;
  329|    244|  struct connectdata *conn = data->conn;
  330|    244|  struct smtp_conn *smtpc = &conn->proto.smtpc;
  331|       |
  332|    244|  smtpc->sasl.authmechs = SASL_AUTH_NONE; /* No known auth. mechanism yet */
  333|    244|  smtpc->sasl.authused = SASL_AUTH_NONE;  /* Clear the authentication mechanism
  334|       |                                             used for esmtp connections */
  335|    244|  smtpc->tls_supported = FALSE;           /* Clear the TLS capability */
  336|    244|  smtpc->auth_supported = FALSE;          /* Clear the AUTH capability */
  337|       |
  338|       |  /* Send the EHLO command */
  339|    244|  result = Curl_pp_sendf(data, &smtpc->pp, "EHLO %s", smtpc->domain);
  340|       |
  341|    244|  if(!result)
  342|    244|    state(data, SMTP_EHLO);
  343|       |
  344|    244|  return result;
  345|    244|}
smtp.c:smtp_state_servergreet_resp:
  836|    245|{
  837|    245|  CURLcode result = CURLE_OK;
  838|    245|  (void)instate; /* no use for this yet */
  839|       |
  840|    245|  if(smtpcode/100 != 2) {
  841|      1|    failf(data, "Got unexpected smtp-server response: %d", smtpcode);
  842|      1|    result = CURLE_WEIRD_SERVER_REPLY;
  843|      1|  }
  844|    244|  else
  845|    244|    result = smtp_perform_ehlo(data);
  846|       |
  847|    245|  return result;
  848|    245|}
smtp.c:smtp_state_ehlo_resp:
  880|  2.21k|{
  881|  2.21k|  CURLcode result = CURLE_OK;
  882|  2.21k|  struct smtp_conn *smtpc = &conn->proto.smtpc;
  883|  2.21k|  const char *line = data->state.buffer;
  884|  2.21k|  size_t len = strlen(line);
  885|       |
  886|  2.21k|  (void)instate; /* no use for this yet */
  887|       |
  888|  2.21k|  if(smtpcode/100 != 2 && smtpcode != 1) {
  889|     18|    if(data->set.use_ssl <= CURLUSESSL_TRY || conn->ssl[FIRSTSOCKET].use)
  890|     18|      result = smtp_perform_helo(data, conn);
  891|      0|    else {
  892|      0|      failf(data, "Remote access denied: %d", smtpcode);
  893|      0|      result = CURLE_REMOTE_ACCESS_DENIED;
  894|      0|    }
  895|     18|  }
  896|  2.19k|  else if(len >= 4) {
  897|  2.18k|    line += 4;
  898|  2.18k|    len -= 4;
  899|       |
  900|       |    /* Does the server support the STARTTLS capability? */
  901|  2.18k|    if(len >= 8 && !memcmp(line, "STARTTLS", 8))
  902|     39|      smtpc->tls_supported = TRUE;
  903|       |
  904|       |    /* Does the server support the SIZE capability? */
  905|  2.14k|    else if(len >= 4 && !memcmp(line, "SIZE", 4))
  906|     39|      smtpc->size_supported = TRUE;
  907|       |
  908|       |    /* Does the server support the UTF-8 capability? */
  909|  2.10k|    else if(len >= 8 && !memcmp(line, "SMTPUTF8", 8))
  910|     10|      smtpc->utf8_supported = TRUE;
  911|       |
  912|       |    /* Does the server support authentication? */
  913|  2.09k|    else if(len >= 5 && !memcmp(line, "AUTH ", 5)) {
  914|    862|      smtpc->auth_supported = TRUE;
  915|       |
  916|       |      /* Advance past the AUTH keyword */
  917|    862|      line += 5;
  918|    862|      len -= 5;
  919|       |
  920|       |      /* Loop through the data line */
  921|  2.88k|      for(;;) {
  922|  2.88k|        size_t llen;
  923|  2.88k|        size_t wordlen;
  924|  2.88k|        unsigned short mechbit;
  925|       |
  926|  14.0k|        while(len &&
  927|  14.0k|              (*line == ' ' || *line == '\t' ||
  928|  13.1k|               *line == '\r' || *line == '\n')) {
  929|       |
  930|  11.1k|          line++;
  931|  11.1k|          len--;
  932|  11.1k|        }
  933|       |
  934|  2.88k|        if(!len)
  935|    862|          break;
  936|       |
  937|       |        /* Extract the word */
  938|  12.2k|        for(wordlen = 0; wordlen < len && line[wordlen] != ' ' &&
  939|  12.2k|              line[wordlen] != '\t' && line[wordlen] != '\r' &&
  940|  12.2k|              line[wordlen] != '\n';)
  941|  10.2k|          wordlen++;
  942|       |
  943|       |        /* Test the word for a matching authentication mechanism */
  944|  2.01k|        mechbit = Curl_sasl_decode_mech(line, wordlen, &llen);
  945|  2.01k|        if(mechbit && llen == wordlen)
  946|     57|          smtpc->sasl.authmechs |= mechbit;
  947|       |
  948|  2.01k|        line += wordlen;
  949|  2.01k|        len -= wordlen;
  950|  2.01k|      }
  951|    862|    }
  952|       |
  953|  2.18k|    if(smtpcode != 1) {
  954|    164|      if(data->set.use_ssl && !conn->ssl[FIRSTSOCKET].use) {
  955|       |        /* We don't have a SSL/TLS connection yet, but SSL is requested */
  956|      0|        if(smtpc->tls_supported)
  957|       |          /* Switch to TLS connection now */
  958|      0|          result = smtp_perform_starttls(data, conn);
  959|      0|        else if(data->set.use_ssl == CURLUSESSL_TRY)
  960|       |          /* Fallback and carry on with authentication */
  961|      0|          result = smtp_perform_authentication(data);
  962|      0|        else {
  963|      0|          failf(data, "STARTTLS not supported.");
  964|      0|          result = CURLE_USE_SSL_FAILED;
  965|      0|        }
  966|      0|      }
  967|    164|      else
  968|    164|        result = smtp_perform_authentication(data);
  969|    164|    }
  970|  2.18k|  }
  971|      7|  else {
  972|      7|    failf(data, "Unexpectedly short EHLO response");
  973|      7|    result = CURLE_WEIRD_SERVER_REPLY;
  974|      7|  }
  975|       |
  976|  2.21k|  return result;
  977|  2.21k|}
smtp.c:smtp_perform_helo:
  355|     18|{
  356|     18|  CURLcode result = CURLE_OK;
  357|     18|  struct smtp_conn *smtpc = &conn->proto.smtpc;
  358|       |
  359|     18|  smtpc->sasl.authused = SASL_AUTH_NONE; /* No authentication mechanism used
  360|       |                                            in smtp connections */
  361|       |
  362|       |  /* Send the HELO command */
  363|     18|  result = Curl_pp_sendf(data, &smtpc->pp, "HELO %s", smtpc->domain);
  364|       |
  365|     18|  if(!result)
  366|     18|    state(data, SMTP_HELO);
  367|       |
  368|     18|  return result;
  369|     18|}
smtp.c:smtp_perform_authentication:
  486|    164|{
  487|    164|  CURLcode result = CURLE_OK;
  488|    164|  struct connectdata *conn = data->conn;
  489|    164|  struct smtp_conn *smtpc = &conn->proto.smtpc;
  490|    164|  saslprogress progress;
  491|       |
  492|       |  /* Check we have enough data to authenticate with, and the
  493|       |     server supports authentication, and end the connect phase if not */
  494|    164|  if(!smtpc->auth_supported ||
  495|    164|     !Curl_sasl_can_authenticate(&smtpc->sasl, conn)) {
  496|    160|    state(data, SMTP_STOP);
  497|    160|    return result;
  498|    160|  }
  499|       |
  500|       |  /* Calculate the SASL login details */
  501|      4|  result = Curl_sasl_start(&smtpc->sasl, data, FALSE, &progress);
  502|       |
  503|      4|  if(!result) {
  504|      4|    if(progress == SASL_INPROGRESS)
  505|      3|      state(data, SMTP_AUTH);
  506|      1|    else {
  507|       |      /* Other mechanisms not supported */
  508|      1|      infof(data, "No known authentication mechanisms supported!");
  509|      1|      result = CURLE_LOGIN_DENIED;
  510|      1|    }
  511|      4|  }
  512|       |
  513|      4|  return result;
  514|    164|}
smtp.c:smtp_state_helo_resp:
  982|     13|{
  983|     13|  CURLcode result = CURLE_OK;
  984|     13|  (void)instate; /* no use for this yet */
  985|       |
  986|     13|  if(smtpcode/100 != 2) {
  987|      1|    failf(data, "Remote access denied: %d", smtpcode);
  988|      1|    result = CURLE_REMOTE_ACCESS_DENIED;
  989|      1|  }
  990|     12|  else
  991|       |    /* End of connect phase */
  992|     12|    state(data, SMTP_STOP);
  993|       |
  994|     13|  return result;
  995|     13|}
smtp.c:smtp_state_command_resp:
 1029|    938|{
 1030|    938|  CURLcode result = CURLE_OK;
 1031|    938|  struct SMTP *smtp = data->req.p.smtp;
 1032|    938|  char *line = data->state.buffer;
 1033|    938|  size_t len = strlen(line);
 1034|       |
 1035|    938|  (void)instate; /* no use for this yet */
 1036|       |
 1037|    938|  if((smtp->rcpt && smtpcode/100 != 2 && smtpcode != 553 && smtpcode != 1) ||
 1038|    938|     (!smtp->rcpt && smtpcode/100 != 2 && smtpcode != 1)) {
 1039|     23|    failf(data, "Command failed: %d", smtpcode);
 1040|     23|    result = CURLE_RECV_ERROR;
 1041|     23|  }
 1042|    915|  else {
 1043|       |    /* Temporarily add the LF character back and send as body to the client */
 1044|    915|    if(!data->set.opt_no_body) {
 1045|    857|      line[len] = '\n';
 1046|    857|      result = Curl_client_write(data, CLIENTWRITE_BODY, line, len + 1);
 1047|    857|      line[len] = '\0';
 1048|    857|    }
 1049|       |
 1050|    915|    if(smtpcode != 1) {
 1051|    213|      if(smtp->rcpt) {
 1052|    204|        smtp->rcpt = smtp->rcpt->next;
 1053|       |
 1054|    204|        if(smtp->rcpt) {
 1055|       |          /* Send the next command */
 1056|    190|          result = smtp_perform_command(data);
 1057|    190|        }
 1058|     14|        else
 1059|       |          /* End of DO phase */
 1060|     14|          state(data, SMTP_STOP);
 1061|    204|      }
 1062|      9|      else
 1063|       |        /* End of DO phase */
 1064|      9|        state(data, SMTP_STOP);
 1065|    213|    }
 1066|    915|  }
 1067|       |
 1068|    938|  return result;
 1069|    938|}
smtp.c:smtp_perform_command:
  523|    287|{
  524|    287|  CURLcode result = CURLE_OK;
  525|    287|  struct connectdata *conn = data->conn;
  526|    287|  struct SMTP *smtp = data->req.p.smtp;
  527|       |
  528|    287|  if(smtp->rcpt) {
  529|       |    /* We notify the server we are sending UTF-8 data if a) it supports the
  530|       |       SMTPUTF8 extension and b) The mailbox contains UTF-8 characters, in
  531|       |       either the local address or host name parts. This is regardless of
  532|       |       whether the host name is encoded using IDN ACE */
  533|    223|    bool utf8 = FALSE;
  534|       |
  535|    223|    if((!smtp->custom) || (!smtp->custom[0])) {
  536|    209|      char *address = NULL;
  537|    209|      struct hostname host = { NULL, NULL, NULL, NULL };
  538|       |
  539|       |      /* Parse the mailbox to verify into the local address and host name
  540|       |         parts, converting the host name to an IDN A-label if necessary */
  541|    209|      result = smtp_parse_address(data, smtp->rcpt->data,
  542|    209|                                  &address, &host);
  543|    209|      if(result)
  544|      0|        return result;
  545|       |
  546|       |      /* Establish whether we should report SMTPUTF8 to the server for this
  547|       |         mailbox as per RFC-6531 sect. 3.1 point 6 */
  548|    209|      utf8 = (conn->proto.smtpc.utf8_supported) &&
  549|    209|             ((host.encalloc) || (!Curl_is_ASCII_name(address)) ||
  550|      0|              (!Curl_is_ASCII_name(host.name)));
  551|       |
  552|       |      /* Send the VRFY command (Note: The host name part may be absent when the
  553|       |         host is a local system) */
  554|    209|      result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "VRFY %s%s%s%s",
  555|    209|                             address,
  556|    209|                             host.name ? "@" : "",
  557|    209|                             host.name ? host.name : "",
  558|    209|                             utf8 ? " SMTPUTF8" : "");
  559|       |
  560|    209|      Curl_free_idnconverted_hostname(&host);
  561|    209|      free(address);
  562|    209|    }
  563|     14|    else {
  564|       |      /* Establish whether we should report that we support SMTPUTF8 for EXPN
  565|       |         commands to the server as per RFC-6531 sect. 3.1 point 6 */
  566|     14|      utf8 = (conn->proto.smtpc.utf8_supported) &&
  567|     14|             (!strcmp(smtp->custom, "EXPN"));
  568|       |
  569|       |      /* Send the custom recipient based command such as the EXPN command */
  570|     14|      result = Curl_pp_sendf(data, &conn->proto.smtpc.pp,
  571|     14|                             "%s %s%s", smtp->custom,
  572|     14|                             smtp->rcpt->data,
  573|     14|                             utf8 ? " SMTPUTF8" : "");
  574|     14|    }
  575|    223|  }
  576|     64|  else
  577|       |    /* Send the non-recipient based command such as HELP */
  578|     64|    result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "%s",
  579|     64|                           smtp->custom && smtp->custom[0] != '\0' ?
  580|     63|                           smtp->custom : "HELP");
  581|       |
  582|    287|  if(!result)
  583|    287|    state(data, SMTP_COMMAND);
  584|       |
  585|    287|  return result;
  586|    287|}
smtp.c:smtp_parse_address:
 1786|    451|{
 1787|    451|  CURLcode result = CURLE_OK;
 1788|    451|  size_t length;
 1789|       |
 1790|       |  /* Duplicate the fully qualified email address so we can manipulate it,
 1791|       |     ensuring it doesn't contain the delimiters if specified */
 1792|    451|  char *dup = strdup(fqma[0] == '<' ? fqma + 1  : fqma);
 1793|    451|  if(!dup)
 1794|      0|    return CURLE_OUT_OF_MEMORY;
 1795|       |
 1796|    451|  length = strlen(dup);
 1797|    451|  if(length) {
 1798|    120|    if(dup[length - 1] == '>')
 1799|      0|      dup[length - 1] = '\0';
 1800|    120|  }
 1801|       |
 1802|       |  /* Extract the host name from the address (if we can) */
 1803|    451|  host->name = strpbrk(dup, "@");
 1804|    451|  if(host->name) {
 1805|    107|    *host->name = '\0';
 1806|    107|    host->name = host->name + 1;
 1807|       |
 1808|       |    /* Attempt to convert the host name to IDN ACE */
 1809|    107|    (void) Curl_idnconvert_hostname(data, host);
 1810|       |
 1811|       |    /* If Curl_idnconvert_hostname() fails then we shall attempt to continue
 1812|       |       and send the host name using UTF-8 rather than as 7-bit ACE (which is
 1813|       |       our preference) */
 1814|    107|  }
 1815|       |
 1816|       |  /* Extract the local address from the mailbox */
 1817|    451|  *address = dup;
 1818|       |
 1819|    451|  return result;
 1820|    451|}
smtp.c:smtp_state_mail_resp:
 1074|     68|{
 1075|     68|  CURLcode result = CURLE_OK;
 1076|     68|  (void)instate; /* no use for this yet */
 1077|       |
 1078|     68|  if(smtpcode/100 != 2) {
 1079|      2|    failf(data, "MAIL failed: %d", smtpcode);
 1080|      2|    result = CURLE_SEND_ERROR;
 1081|      2|  }
 1082|     66|  else
 1083|       |    /* Start the RCPT TO command */
 1084|     66|    result = smtp_perform_rcpt_to(data);
 1085|       |
 1086|     68|  return result;
 1087|     68|}
smtp.c:smtp_perform_rcpt_to:
  781|    183|{
  782|    183|  CURLcode result = CURLE_OK;
  783|    183|  struct connectdata *conn = data->conn;
  784|    183|  struct SMTP *smtp = data->req.p.smtp;
  785|    183|  char *address = NULL;
  786|    183|  struct hostname host = { NULL, NULL, NULL, NULL };
  787|       |
  788|       |  /* Parse the recipient mailbox into the local address and host name parts,
  789|       |     converting the host name to an IDN A-label if necessary */
  790|    183|  result = smtp_parse_address(data, smtp->rcpt->data,
  791|    183|                              &address, &host);
  792|    183|  if(result)
  793|      0|    return result;
  794|       |
  795|       |  /* Send the RCPT TO command */
  796|    183|  if(host.name)
  797|     53|    result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "RCPT TO:<%s@%s>",
  798|     53|                           address, host.name);
  799|    130|  else
  800|       |    /* An invalid mailbox was provided but we'll simply let the server worry
  801|       |       about that and reply with a 501 error */
  802|    130|    result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "RCPT TO:<%s>",
  803|    130|                           address);
  804|       |
  805|    183|  Curl_free_idnconverted_hostname(&host);
  806|    183|  free(address);
  807|       |
  808|    183|  if(!result)
  809|    183|    state(data, SMTP_RCPT);
  810|       |
  811|    183|  return result;
  812|    183|}
smtp.c:smtp_state_rcpt_resp:
 1093|    179|{
 1094|    179|  CURLcode result = CURLE_OK;
 1095|    179|  struct SMTP *smtp = data->req.p.smtp;
 1096|    179|  bool is_smtp_err = FALSE;
 1097|    179|  bool is_smtp_blocking_err = FALSE;
 1098|       |
 1099|    179|  (void)instate; /* no use for this yet */
 1100|       |
 1101|    179|  is_smtp_err = (smtpcode/100 != 2) ? TRUE : FALSE;
 1102|       |
 1103|       |  /* If there's multiple RCPT TO to be issued, it's possible to ignore errors
 1104|       |     and proceed with only the valid addresses. */
 1105|    179|  is_smtp_blocking_err =
 1106|    179|    (is_smtp_err && !data->set.mail_rcpt_allowfails) ? TRUE : FALSE;
 1107|       |
 1108|    179|  if(is_smtp_err) {
 1109|       |    /* Remembering the last failure which we can report if all "RCPT TO" have
 1110|       |       failed and we cannot proceed. */
 1111|      8|    smtp->rcpt_last_error = smtpcode;
 1112|       |
 1113|      8|    if(is_smtp_blocking_err) {
 1114|      8|      failf(data, "RCPT failed: %d", smtpcode);
 1115|      8|      result = CURLE_SEND_ERROR;
 1116|      8|    }
 1117|      8|  }
 1118|    171|  else {
 1119|       |    /* Some RCPT TO commands have succeeded. */
 1120|    171|    smtp->rcpt_had_ok = TRUE;
 1121|    171|  }
 1122|       |
 1123|    179|  if(!is_smtp_blocking_err) {
 1124|    171|    smtp->rcpt = smtp->rcpt->next;
 1125|       |
 1126|    171|    if(smtp->rcpt)
 1127|       |      /* Send the next RCPT TO command */
 1128|    117|      result = smtp_perform_rcpt_to(data);
 1129|     54|    else {
 1130|       |      /* We weren't able to issue a successful RCPT TO command while going
 1131|       |         over recipients (potentially multiple). Sending back last error. */
 1132|     54|      if(!smtp->rcpt_had_ok) {
 1133|      0|        failf(data, "RCPT failed: %d (last error)", smtp->rcpt_last_error);
 1134|      0|        result = CURLE_SEND_ERROR;
 1135|      0|      }
 1136|     54|      else {
 1137|       |        /* Send the DATA command */
 1138|     54|        result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "%s", "DATA");
 1139|       |
 1140|     54|        if(!result)
 1141|     54|          state(data, SMTP_DATA);
 1142|     54|      }
 1143|     54|    }
 1144|    171|  }
 1145|       |
 1146|    179|  return result;
 1147|    179|}
smtp.c:smtp_state_data_resp:
 1152|     51|{
 1153|     51|  CURLcode result = CURLE_OK;
 1154|     51|  (void)instate; /* no use for this yet */
 1155|       |
 1156|     51|  if(smtpcode != 354) {
 1157|      1|    failf(data, "DATA failed: %d", smtpcode);
 1158|      1|    result = CURLE_SEND_ERROR;
 1159|      1|  }
 1160|     50|  else {
 1161|       |    /* Set the progress upload size */
 1162|     50|    Curl_pgrsSetUploadSize(data, data->state.infilesize);
 1163|       |
 1164|       |    /* SMTP upload */
 1165|     50|    Curl_setup_transfer(data, -1, -1, FALSE, FIRSTSOCKET);
 1166|       |
 1167|       |    /* End of DO phase */
 1168|     50|    state(data, SMTP_STOP);
 1169|     50|  }
 1170|       |
 1171|     51|  return result;
 1172|     51|}
smtp.c:smtp_state_postdata_resp:
 1179|     22|{
 1180|     22|  CURLcode result = CURLE_OK;
 1181|       |
 1182|     22|  (void)instate; /* no use for this yet */
 1183|       |
 1184|     22|  if(smtpcode != 250)
 1185|      1|    result = CURLE_RECV_ERROR;
 1186|       |
 1187|       |  /* End of DONE phase */
 1188|     22|  state(data, SMTP_STOP);
 1189|       |
 1190|     22|  return result;
 1191|     22|}
smtp.c:smtp_endofresp:
  214|  20.2k|{
  215|  20.2k|  struct smtp_conn *smtpc = &conn->proto.smtpc;
  216|  20.2k|  bool result = FALSE;
  217|  20.2k|  (void)data;
  218|       |
  219|       |  /* Nothing for us */
  220|  20.2k|  if(len < 4 || !ISDIGIT(line[0]) || !ISDIGIT(line[1]) || !ISDIGIT(line[2]))
  221|  12.9k|    return FALSE;
  222|       |
  223|       |  /* Do we have a command response? This should be the response code followed
  224|       |     by a space and optionally some text as per RFC-5321 and as outlined in
  225|       |     Section 4. Examples of RFC-4954 but some e-mail servers ignore this and
  226|       |     only send the response code instead as per Section 4.2. */
  227|  7.27k|  if(line[3] == ' ' || len == 5) {
  228|  3.04k|    char tmpline[6];
  229|       |
  230|  3.04k|    result = TRUE;
  231|  3.04k|    memset(tmpline, '\0', sizeof(tmpline));
  232|  3.04k|    memcpy(tmpline, line, (len == 5 ? 5 : 3));
  233|  3.04k|    *resp = curlx_sltosi(strtol(tmpline, NULL, 10));
  234|       |
  235|       |    /* Make sure real server never sends internal value */
  236|  3.04k|    if(*resp == 1)
  237|     70|      *resp = 0;
  238|  3.04k|  }
  239|       |  /* Do we have a multiline (continuation) response? */
  240|  4.22k|  else if(line[3] == '-' &&
  241|  4.22k|          (smtpc->state == SMTP_EHLO || smtpc->state == SMTP_COMMAND)) {
  242|  2.72k|    result = TRUE;
  243|  2.72k|    *resp = 1;  /* Internal response code */
  244|  2.72k|  }
  245|       |
  246|  7.27k|  return result;
  247|  20.2k|}
smtp.c:smtp_perform_auth:
  428|      3|{
  429|      3|  CURLcode result = CURLE_OK;
  430|      3|  struct smtp_conn *smtpc = &data->conn->proto.smtpc;
  431|      3|  const char *ir = (const char *) Curl_bufref_ptr(initresp);
  432|       |
  433|      3|  if(ir) {                                  /* AUTH <mech> ...<crlf> */
  434|       |    /* Send the AUTH command with the initial response */
  435|      0|    result = Curl_pp_sendf(data, &smtpc->pp, "AUTH %s %s", mech, ir);
  436|      0|  }
  437|      3|  else {
  438|       |    /* Send the AUTH command */
  439|      3|    result = Curl_pp_sendf(data, &smtpc->pp, "AUTH %s", mech);
  440|      3|  }
  441|       |
  442|      3|  return result;
  443|      3|}
smtp.c:smtp_parse_url_options:
 1674|    300|{
 1675|    300|  CURLcode result = CURLE_OK;
 1676|    300|  struct smtp_conn *smtpc = &conn->proto.smtpc;
 1677|    300|  const char *ptr = conn->options;
 1678|       |
 1679|    324|  while(!result && ptr && *ptr) {
 1680|     24|    const char *key = ptr;
 1681|     24|    const char *value;
 1682|       |
 1683|    492|    while(*ptr && *ptr != '=')
 1684|    468|      ptr++;
 1685|       |
 1686|     24|    value = ptr + 1;
 1687|       |
 1688|    323|    while(*ptr && *ptr != ';')
 1689|    299|      ptr++;
 1690|       |
 1691|     24|    if(strncasecompare(key, "AUTH=", 5))
 1692|     11|      result = Curl_sasl_parse_url_auth_option(&smtpc->sasl,
 1693|     11|                                               value, ptr - value);
 1694|     13|    else
 1695|     13|      result = CURLE_URL_MALFORMAT;
 1696|       |
 1697|     24|    if(*ptr == ';')
 1698|      5|      ptr++;
 1699|     24|  }
 1700|       |
 1701|    300|  return result;
 1702|    300|}
smtp.c:smtp_parse_url_path:
 1711|    282|{
 1712|       |  /* The SMTP struct is already initialised in smtp_connect() */
 1713|    282|  struct connectdata *conn = data->conn;
 1714|    282|  struct smtp_conn *smtpc = &conn->proto.smtpc;
 1715|    282|  const char *path = &data->state.up.path[1]; /* skip leading path */
 1716|    282|  char localhost[HOSTNAME_MAX + 1];
 1717|       |
 1718|       |  /* Calculate the path if necessary */
 1719|    282|  if(!*path) {
 1720|     21|    if(!Curl_gethostname(localhost, sizeof(localhost)))
 1721|     21|      path = localhost;
 1722|      0|    else
 1723|      0|      path = "localhost";
 1724|     21|  }
 1725|       |
 1726|       |  /* URL decode the path and use it as the domain in our EHLO */
 1727|    282|  return Curl_urldecode(data, path, 0, &smtpc->domain, NULL,
 1728|    282|                        REJECT_CTRL);
 1729|    282|}
smtp.c:state:
  290|  1.65k|{
  291|  1.65k|  struct smtp_conn *smtpc = &data->conn->proto.smtpc;
  292|  1.65k|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
  293|       |  /* for debug purposes */
  294|  1.65k|  static const char * const names[] = {
  295|  1.65k|    "STOP",
  296|  1.65k|    "SERVERGREET",
  297|  1.65k|    "EHLO",
  298|  1.65k|    "HELO",
  299|  1.65k|    "STARTTLS",
  300|  1.65k|    "UPGRADETLS",
  301|  1.65k|    "AUTH",
  302|  1.65k|    "COMMAND",
  303|  1.65k|    "MAIL",
  304|  1.65k|    "RCPT",
  305|  1.65k|    "DATA",
  306|  1.65k|    "POSTDATA",
  307|  1.65k|    "QUIT",
  308|       |    /* LAST */
  309|  1.65k|  };
  310|       |
  311|  1.65k|  if(smtpc->state != newstate)
  312|  1.34k|    infof(data, "SMTP %p state change from %s to %s",
  313|  1.34k|          (void *)smtpc, names[smtpc->state], names[newstate]);
  314|  1.65k|#endif
  315|       |
  316|  1.65k|  smtpc->state = newstate;
  317|  1.65k|}
smtp.c:smtp_done:
 1392|    300|{
 1393|    300|  CURLcode result = CURLE_OK;
 1394|    300|  struct connectdata *conn = data->conn;
 1395|    300|  struct SMTP *smtp = data->req.p.smtp;
 1396|    300|  struct pingpong *pp = &conn->proto.smtpc.pp;
 1397|    300|  char *eob;
 1398|    300|  ssize_t len;
 1399|    300|  ssize_t bytes_written;
 1400|       |
 1401|    300|  (void)premature;
 1402|       |
 1403|    300|  if(!smtp)
 1404|      0|    return CURLE_OK;
 1405|       |
 1406|       |  /* Cleanup our per-request based variables */
 1407|    300|  Curl_safefree(smtp->custom);
 1408|       |
 1409|    300|  if(status) {
 1410|    222|    connclose(conn, "SMTP done with bad status"); /* marked for closure */
 1411|    222|    result = status;         /* use the already set error code */
 1412|    222|  }
 1413|     78|  else if(!data->set.connect_only && data->set.mail_rcpt &&
 1414|     78|          (data->set.upload || data->set.mimepost.kind)) {
 1415|       |    /* Calculate the EOB taking into account any terminating CRLF from the
 1416|       |       previous line of the email or the CRLF of the DATA command when there
 1417|       |       is "no mail data". RFC-5321, sect. 4.1.1.4.
 1418|       |
 1419|       |       Note: As some SSL backends, such as OpenSSL, will cause Curl_write() to
 1420|       |       fail when using a different pointer following a previous write, that
 1421|       |       returned CURLE_AGAIN, we duplicate the EOB now rather than when the
 1422|       |       bytes written doesn't equal len. */
 1423|     55|    if(smtp->trailing_crlf || !data->state.infilesize) {
 1424|     46|      eob = strdup(&SMTP_EOB[2]);
 1425|     46|      len = SMTP_EOB_LEN - 2;
 1426|     46|    }
 1427|      9|    else {
 1428|      9|      eob = strdup(SMTP_EOB);
 1429|      9|      len = SMTP_EOB_LEN;
 1430|      9|    }
 1431|       |
 1432|     55|    if(!eob)
 1433|      0|      return CURLE_OUT_OF_MEMORY;
 1434|       |
 1435|       |    /* Send the end of block data */
 1436|     55|    result = Curl_write(data, conn->writesockfd, eob, len, &bytes_written);
 1437|     55|    if(result) {
 1438|      1|      free(eob);
 1439|      1|      return result;
 1440|      1|    }
 1441|       |
 1442|     54|    if(bytes_written != len) {
 1443|       |      /* The whole chunk was not sent so keep it around and adjust the
 1444|       |         pingpong structure accordingly */
 1445|      0|      pp->sendthis = eob;
 1446|      0|      pp->sendsize = len;
 1447|      0|      pp->sendleft = len - bytes_written;
 1448|      0|    }
 1449|     54|    else {
 1450|       |      /* Successfully sent so adjust the response timeout relative to now */
 1451|     54|      pp->response = Curl_now();
 1452|       |
 1453|     54|      free(eob);
 1454|     54|    }
 1455|       |
 1456|     54|    state(data, SMTP_POSTDATA);
 1457|       |
 1458|       |    /* Run the state-machine */
 1459|     54|    result = smtp_block_statemach(data, conn, FALSE);
 1460|     54|  }
 1461|       |
 1462|       |  /* Clear the transfer mode for the next request */
 1463|    299|  smtp->transfer = PPTRANSFER_BODY;
 1464|       |
 1465|    299|  return result;
 1466|    300|}
smtp.c:smtp_block_statemach:
 1301|    222|{
 1302|    222|  CURLcode result = CURLE_OK;
 1303|    222|  struct smtp_conn *smtpc = &conn->proto.smtpc;
 1304|       |
 1305|  1.12k|  while(smtpc->state != SMTP_STOP && !result)
 1306|    905|    result = Curl_pp_statemach(data, &smtpc->pp, TRUE, disconnecting);
 1307|       |
 1308|    222|  return result;
 1309|    222|}
smtp.c:smtp_do:
 1538|    172|{
 1539|    172|  CURLcode result = CURLE_OK;
 1540|    172|  *done = FALSE; /* default to false */
 1541|       |
 1542|       |  /* Parse the custom request */
 1543|    172|  result = smtp_parse_custom_request(data);
 1544|    172|  if(result)
 1545|      1|    return result;
 1546|       |
 1547|    171|  result = smtp_regular_transfer(data, done);
 1548|       |
 1549|    171|  return result;
 1550|    172|}
smtp.c:smtp_parse_custom_request:
 1738|    172|{
 1739|    172|  CURLcode result = CURLE_OK;
 1740|    172|  struct SMTP *smtp = data->req.p.smtp;
 1741|    172|  const char *custom = data->set.str[STRING_CUSTOMREQUEST];
 1742|       |
 1743|       |  /* URL decode the custom request */
 1744|    172|  if(custom)
 1745|     16|    result = Curl_urldecode(data, custom, 0, &smtp->custom, NULL, REJECT_CTRL);
 1746|       |
 1747|    172|  return result;
 1748|    172|}
smtp.c:smtp_regular_transfer:
 1628|    171|{
 1629|    171|  CURLcode result = CURLE_OK;
 1630|    171|  bool connected = FALSE;
 1631|       |
 1632|       |  /* Make sure size is unknown at this point */
 1633|    171|  data->req.size = -1;
 1634|       |
 1635|       |  /* Set the progress data */
 1636|    171|  Curl_pgrsSetUploadCounter(data, 0);
 1637|    171|  Curl_pgrsSetDownloadCounter(data, 0);
 1638|    171|  Curl_pgrsSetUploadSize(data, -1);
 1639|    171|  Curl_pgrsSetDownloadSize(data, -1);
 1640|       |
 1641|       |  /* Carry out the perform */
 1642|    171|  result = smtp_perform(data, &connected, dophase_done);
 1643|       |
 1644|       |  /* Perform post DO phase operations if necessary */
 1645|    171|  if(!result && *dophase_done)
 1646|     18|    result = smtp_dophase_done(data, connected);
 1647|       |
 1648|    171|  return result;
 1649|    171|}
smtp.c:smtp_perform:
 1477|    171|{
 1478|       |  /* This is SMTP and no proxy */
 1479|    171|  CURLcode result = CURLE_OK;
 1480|    171|  struct connectdata *conn = data->conn;
 1481|    171|  struct SMTP *smtp = data->req.p.smtp;
 1482|       |
 1483|    171|  DEBUGF(infof(data, "DO phase starts"));
 1484|       |
 1485|    171|  if(data->set.opt_no_body) {
 1486|       |    /* Requested no body means no transfer */
 1487|      4|    smtp->transfer = PPTRANSFER_INFO;
 1488|      4|  }
 1489|       |
 1490|    171|  *dophase_done = FALSE; /* not done yet */
 1491|       |
 1492|       |  /* Store the first recipient (or NULL if not specified) */
 1493|    171|  smtp->rcpt = data->set.mail_rcpt;
 1494|       |
 1495|       |  /* Track of whether we've successfully sent at least one RCPT TO command */
 1496|    171|  smtp->rcpt_had_ok = FALSE;
 1497|       |
 1498|       |  /* Track of the last error we've received by sending RCPT TO command */
 1499|    171|  smtp->rcpt_last_error = 0;
 1500|       |
 1501|       |  /* Initial data character is the first character in line: it is implicitly
 1502|       |     preceded by a virtual CRLF. */
 1503|    171|  smtp->trailing_crlf = TRUE;
 1504|    171|  smtp->eob = 2;
 1505|       |
 1506|       |  /* Start the first command in the DO phase */
 1507|    171|  if((data->set.upload || data->set.mimepost.kind) && data->set.mail_rcpt)
 1508|       |    /* MAIL transfer */
 1509|     74|    result = smtp_perform_mail(data);
 1510|     97|  else
 1511|       |    /* SMTP based command (VRFY, EXPN, NOOP, RSET or HELP) */
 1512|     97|    result = smtp_perform_command(data);
 1513|       |
 1514|    171|  if(result)
 1515|      0|    return result;
 1516|       |
 1517|       |  /* Run the state-machine */
 1518|    171|  result = smtp_multi_statemach(data, dophase_done);
 1519|       |
 1520|    171|  *connected = conn->bits.tcpconnect[FIRSTSOCKET];
 1521|       |
 1522|    171|  if(*dophase_done)
 1523|     18|    DEBUGF(infof(data, "DO phase is complete"));
 1524|       |
 1525|    171|  return result;
 1526|    171|}
smtp.c:smtp_perform_mail:
  595|     74|{
  596|     74|  char *from = NULL;
  597|     74|  char *auth = NULL;
  598|     74|  char *size = NULL;
  599|     74|  CURLcode result = CURLE_OK;
  600|     74|  struct connectdata *conn = data->conn;
  601|       |
  602|       |  /* We notify the server we are sending UTF-8 data if a) it supports the
  603|       |     SMTPUTF8 extension and b) The mailbox contains UTF-8 characters, in
  604|       |     either the local address or host name parts. This is regardless of
  605|       |     whether the host name is encoded using IDN ACE */
  606|     74|  bool utf8 = FALSE;
  607|       |
  608|       |  /* Calculate the FROM parameter */
  609|     74|  if(data->set.str[STRING_MAIL_FROM]) {
  610|     59|    char *address = NULL;
  611|     59|    struct hostname host = { NULL, NULL, NULL, NULL };
  612|       |
  613|       |    /* Parse the FROM mailbox into the local address and host name parts,
  614|       |       converting the host name to an IDN A-label if necessary */
  615|     59|    result = smtp_parse_address(data, data->set.str[STRING_MAIL_FROM],
  616|     59|                                &address, &host);
  617|     59|    if(result)
  618|      0|      return result;
  619|       |
  620|       |    /* Establish whether we should report SMTPUTF8 to the server for this
  621|       |       mailbox as per RFC-6531 sect. 3.1 point 4 and sect. 3.4 */
  622|     59|    utf8 = (conn->proto.smtpc.utf8_supported) &&
  623|     59|           ((host.encalloc) || (!Curl_is_ASCII_name(address)) ||
  624|      9|            (!Curl_is_ASCII_name(host.name)));
  625|       |
  626|     59|    if(host.name) {
  627|     53|      from = aprintf("<%s@%s>", address, host.name);
  628|       |
  629|     53|      Curl_free_idnconverted_hostname(&host);
  630|     53|    }
  631|      6|    else
  632|       |      /* An invalid mailbox was provided but we'll simply let the server worry
  633|       |         about that and reply with a 501 error */
  634|      6|      from = aprintf("<%s>", address);
  635|       |
  636|     59|    free(address);
  637|     59|  }
  638|     15|  else
  639|       |    /* Null reverse-path, RFC-5321, sect. 3.6.3 */
  640|     15|    from = strdup("<>");
  641|       |
  642|     74|  if(!from)
  643|      0|    return CURLE_OUT_OF_MEMORY;
  644|       |
  645|       |  /* Calculate the optional AUTH parameter */
  646|     74|  if(data->set.str[STRING_MAIL_AUTH] && conn->proto.smtpc.sasl.authused) {
  647|      0|    if(data->set.str[STRING_MAIL_AUTH][0] != '\0') {
  648|      0|      char *address = NULL;
  649|      0|      struct hostname host = { NULL, NULL, NULL, NULL };
  650|       |
  651|       |      /* Parse the AUTH mailbox into the local address and host name parts,
  652|       |         converting the host name to an IDN A-label if necessary */
  653|      0|      result = smtp_parse_address(data, data->set.str[STRING_MAIL_AUTH],
  654|      0|                                  &address, &host);
  655|      0|      if(result) {
  656|      0|        free(from);
  657|      0|        return result;
  658|      0|      }
  659|       |
  660|       |      /* Establish whether we should report SMTPUTF8 to the server for this
  661|       |         mailbox as per RFC-6531 sect. 3.1 point 4 and sect. 3.4 */
  662|      0|      if((!utf8) && (conn->proto.smtpc.utf8_supported) &&
  663|      0|         ((host.encalloc) || (!Curl_is_ASCII_name(address)) ||
  664|      0|          (!Curl_is_ASCII_name(host.name))))
  665|      0|        utf8 = TRUE;
  666|       |
  667|      0|      if(host.name) {
  668|      0|        auth = aprintf("<%s@%s>", address, host.name);
  669|       |
  670|      0|        Curl_free_idnconverted_hostname(&host);
  671|      0|      }
  672|      0|      else
  673|       |        /* An invalid mailbox was provided but we'll simply let the server
  674|       |           worry about it */
  675|      0|        auth = aprintf("<%s>", address);
  676|       |
  677|      0|      free(address);
  678|      0|    }
  679|      0|    else
  680|       |      /* Empty AUTH, RFC-2554, sect. 5 */
  681|      0|      auth = strdup("<>");
  682|       |
  683|      0|    if(!auth) {
  684|      0|      free(from);
  685|       |
  686|      0|      return CURLE_OUT_OF_MEMORY;
  687|      0|    }
  688|      0|  }
  689|       |
  690|       |  /* Prepare the mime data if some. */
  691|     74|  if(data->set.mimepost.kind != MIMEKIND_NONE) {
  692|       |    /* Use the whole structure as data. */
  693|     48|    data->set.mimepost.flags &= ~MIME_BODY_ONLY;
  694|       |
  695|       |    /* Add external headers and mime version. */
  696|     48|    curl_mime_headers(&data->set.mimepost, data->set.headers, 0);
  697|     48|    result = Curl_mime_prepare_headers(&data->set.mimepost, NULL,
  698|     48|                                       NULL, MIMESTRATEGY_MAIL);
  699|       |
  700|     48|    if(!result)
  701|     48|      if(!Curl_checkheaders(data, "Mime-Version"))
  702|     48|        result = Curl_mime_add_header(&data->set.mimepost.curlheaders,
  703|     48|                                      "Mime-Version: 1.0");
  704|       |
  705|       |    /* Make sure we will read the entire mime structure. */
  706|     48|    if(!result)
  707|     48|      result = Curl_mime_rewind(&data->set.mimepost);
  708|       |
  709|     48|    if(result) {
  710|      0|      free(from);
  711|      0|      free(auth);
  712|       |
  713|      0|      return result;
  714|      0|    }
  715|       |
  716|     48|    data->state.infilesize = Curl_mime_size(&data->set.mimepost);
  717|       |
  718|       |    /* Read from mime structure. */
  719|     48|    data->state.fread_func = (curl_read_callback) Curl_mime_read;
  720|     48|    data->state.in = (void *) &data->set.mimepost;
  721|     48|  }
  722|       |
  723|       |  /* Calculate the optional SIZE parameter */
  724|     74|  if(conn->proto.smtpc.size_supported && data->state.infilesize > 0) {
  725|     18|    size = aprintf("%" CURL_FORMAT_CURL_OFF_T, data->state.infilesize);
  726|       |
  727|     18|    if(!size) {
  728|      0|      free(from);
  729|      0|      free(auth);
  730|       |
  731|      0|      return CURLE_OUT_OF_MEMORY;
  732|      0|    }
  733|     18|  }
  734|       |
  735|       |  /* If the mailboxes in the FROM and AUTH parameters don't include a UTF-8
  736|       |     based address then quickly scan through the recipient list and check if
  737|       |     any there do, as we need to correctly identify our support for SMTPUTF8
  738|       |     in the envelope, as per RFC-6531 sect. 3.4 */
  739|     74|  if(conn->proto.smtpc.utf8_supported && !utf8) {
  740|      3|    struct SMTP *smtp = data->req.p.smtp;
  741|      3|    struct curl_slist *rcpt = smtp->rcpt;
  742|       |
  743|      6|    while(rcpt && !utf8) {
  744|       |      /* Does the host name contain non-ASCII characters? */
  745|      3|      if(!Curl_is_ASCII_name(rcpt->data))
  746|      1|        utf8 = TRUE;
  747|       |
  748|      3|      rcpt = rcpt->next;
  749|      3|    }
  750|      3|  }
  751|       |
  752|       |  /* Send the MAIL command */
  753|     74|  result = Curl_pp_sendf(data, &conn->proto.smtpc.pp,
  754|     74|                         "MAIL FROM:%s%s%s%s%s%s",
  755|     74|                         from,                 /* Mandatory                 */
  756|     74|                         auth ? " AUTH=" : "", /* Optional on AUTH support  */
  757|     74|                         auth ? auth : "",     /*                           */
  758|     74|                         size ? " SIZE=" : "", /* Optional on SIZE support  */
  759|     74|                         size ? size : "",     /*                           */
  760|     74|                         utf8 ? " SMTPUTF8"    /* Internationalised mailbox */
  761|     74|                               : "");          /* included in our envelope  */
  762|       |
  763|     74|  free(from);
  764|     74|  free(auth);
  765|     74|  free(size);
  766|       |
  767|     74|  if(!result)
  768|     74|    state(data, SMTP_MAIL);
  769|       |
  770|     74|  return result;
  771|     74|}
smtp.c:smtp_dophase_done:
 1589|     73|{
 1590|     73|  struct SMTP *smtp = data->req.p.smtp;
 1591|       |
 1592|     73|  (void)connected;
 1593|       |
 1594|     73|  if(smtp->transfer != PPTRANSFER_BODY)
 1595|       |    /* no data to transfer */
 1596|      2|    Curl_setup_transfer(data, -1, -1, FALSE, -1);
 1597|       |
 1598|     73|  return CURLE_OK;
 1599|     73|}
smtp.c:smtp_disconnect:
 1562|    301|{
 1563|    301|  struct smtp_conn *smtpc = &conn->proto.smtpc;
 1564|    301|  (void)data;
 1565|       |
 1566|       |  /* We cannot send quit unconditionally. If this connection is stale or
 1567|       |     bad in any way, sending quit and waiting around here will make the
 1568|       |     disconnect wait in vain and cause more problems than we need to. */
 1569|       |
 1570|    301|  if(!dead_connection && conn->bits.protoconnstart) {
 1571|    168|    if(!smtp_perform_quit(data, conn))
 1572|    168|      (void)smtp_block_statemach(data, conn, TRUE); /* ignore errors on QUIT */
 1573|    168|  }
 1574|       |
 1575|       |  /* Disconnect from the server */
 1576|    301|  Curl_pp_disconnect(&smtpc->pp);
 1577|       |
 1578|       |  /* Cleanup the SASL module */
 1579|    301|  Curl_sasl_cleanup(conn, smtpc->sasl.authused);
 1580|       |
 1581|       |  /* Cleanup our connection based variables */
 1582|    301|  Curl_safefree(smtpc->domain);
 1583|       |
 1584|    301|  return CURLE_OK;
 1585|    301|}
smtp.c:smtp_perform_quit:
  822|    168|{
  823|       |  /* Send the QUIT command */
  824|    168|  CURLcode result = Curl_pp_sendf(data, &conn->proto.smtpc.pp, "%s", "QUIT");
  825|       |
  826|    168|  if(!result)
  827|    168|    state(data, SMTP_QUIT);
  828|       |
  829|    168|  return result;
  830|    168|}
smtp.c:smtp_doing:
 1603|    586|{
 1604|    586|  CURLcode result = smtp_multi_statemach(data, dophase_done);
 1605|       |
 1606|    586|  if(result)
 1607|     32|    DEBUGF(infof(data, "DO phase failed"));
 1608|    554|  else if(*dophase_done) {
 1609|     55|    result = smtp_dophase_done(data, FALSE /* not connected */);
 1610|       |
 1611|     55|    DEBUGF(infof(data, "DO phase is complete"));
 1612|     55|  }
 1613|       |
 1614|    586|  return result;
 1615|    586|}
smtp.c:smtp_setup_connection:
 1653|    300|{
 1654|    300|  CURLcode result;
 1655|       |
 1656|       |  /* Clear the TLS upgraded flag */
 1657|    300|  conn->bits.tls_upgraded = FALSE;
 1658|       |
 1659|       |  /* Initialise the SMTP layer */
 1660|    300|  result = smtp_init(data);
 1661|    300|  if(result)
 1662|      0|    return result;
 1663|       |
 1664|    300|  return CURLE_OK;
 1665|    300|}
smtp.c:smtp_init:
 1314|    300|{
 1315|    300|  CURLcode result = CURLE_OK;
 1316|    300|  struct SMTP *smtp;
 1317|       |
 1318|    300|  smtp = data->req.p.smtp = calloc(sizeof(struct SMTP), 1);
 1319|    300|  if(!smtp)
 1320|      0|    result = CURLE_OUT_OF_MEMORY;
 1321|       |
 1322|    300|  return result;
 1323|    300|}

Curl_speedinit:
   32|  2.97k|{
   33|  2.97k|  memset(&data->state.keeps_speed, 0, sizeof(struct curltime));
   34|  2.97k|}
Curl_speedcheck:
   41|  5.78M|{
   42|  5.78M|  if(data->req.keepon & KEEP_RECV_PAUSE)
   43|       |    /* A paused transfer is not qualified for speed checks */
   44|      0|    return CURLE_OK;
   45|       |
   46|  5.78M|  if((data->progress.current_speed >= 0) && data->set.low_speed_time) {
   47|      0|    if(data->progress.current_speed < data->set.low_speed_limit) {
   48|      0|      if(!data->state.keeps_speed.tv_sec)
   49|       |        /* under the limit at this very moment */
   50|      0|        data->state.keeps_speed = now;
   51|      0|      else {
   52|       |        /* how long has it been under the limit */
   53|      0|        timediff_t howlong = Curl_timediff(now, data->state.keeps_speed);
   54|       |
   55|      0|        if(howlong >= data->set.low_speed_time * 1000) {
   56|       |          /* too long */
   57|      0|          failf(data,
   58|      0|                "Operation too slow. "
   59|      0|                "Less than %ld bytes/sec transferred the last %ld seconds",
   60|      0|                data->set.low_speed_limit,
   61|      0|                data->set.low_speed_time);
   62|      0|          return CURLE_OPERATION_TIMEDOUT;
   63|      0|        }
   64|      0|      }
   65|      0|    }
   66|      0|    else
   67|       |      /* faster right now */
   68|      0|      data->state.keeps_speed.tv_sec = 0;
   69|      0|  }
   70|       |
   71|  5.78M|  if(data->set.low_speed_limit)
   72|       |    /* if low speed limit is enabled, set the expire timer to make this
   73|       |       connection's speed get checked again in a second */
   74|      0|    Curl_expire(data, 1000, EXPIRE_SPEEDCHECK);
   75|       |
   76|  5.78M|  return CURLE_OK;
   77|  5.78M|}

Curl_splay:
   42|  5.78M|{
   43|  5.78M|  struct Curl_tree N, *l, *r, *y;
   44|       |
   45|  5.78M|  if(!t)
   46|      0|    return t;
   47|  5.78M|  N.smaller = N.larger = NULL;
   48|  5.78M|  l = r = &N;
   49|       |
   50|  5.78M|  for(;;) {
   51|  5.78M|    long comp = compare(i, t->key);
   52|  5.78M|    if(comp < 0) {
   53|  5.78M|      if(!t->smaller)
   54|  5.78M|        break;
   55|      0|      if(compare(i, t->smaller->key) < 0) {
   56|      0|        y = t->smaller;                           /* rotate smaller */
   57|      0|        t->smaller = y->larger;
   58|      0|        y->larger = t;
   59|      0|        t = y;
   60|      0|        if(!t->smaller)
   61|      0|          break;
   62|      0|      }
   63|      0|      r->smaller = t;                               /* link smaller */
   64|      0|      r = t;
   65|      0|      t = t->smaller;
   66|      0|    }
   67|  3.21k|    else if(comp > 0) {
   68|      0|      if(!t->larger)
   69|      0|        break;
   70|      0|      if(compare(i, t->larger->key) > 0) {
   71|      0|        y = t->larger;                          /* rotate larger */
   72|      0|        t->larger = y->smaller;
   73|      0|        y->smaller = t;
   74|      0|        t = y;
   75|      0|        if(!t->larger)
   76|      0|          break;
   77|      0|      }
   78|      0|      l->larger = t;                              /* link larger */
   79|      0|      l = t;
   80|      0|      t = t->larger;
   81|      0|    }
   82|  3.21k|    else
   83|  3.21k|      break;
   84|  5.78M|  }
   85|       |
   86|  5.78M|  l->larger = t->smaller;                                /* assemble */
   87|  5.78M|  r->smaller = t->larger;
   88|  5.78M|  t->smaller = N.larger;
   89|  5.78M|  t->larger = N.smaller;
   90|       |
   91|  5.78M|  return t;
   92|  5.78M|}
Curl_splayinsert:
  102|  4.25k|{
  103|  4.25k|  static const struct curltime KEY_NOTUSED = {
  104|  4.25k|    (time_t)-1, (unsigned int)-1
  105|  4.25k|  }; /* will *NEVER* appear */
  106|       |
  107|  4.25k|  if(!node)
  108|      0|    return t;
  109|       |
  110|  4.25k|  if(t != NULL) {
  111|      0|    t = Curl_splay(i, t);
  112|      0|    if(compare(i, t->key) == 0) {
  113|       |      /* There already exists a node in the tree with the very same key. Build
  114|       |         a doubly-linked circular list of nodes. We add the new 'node' struct
  115|       |         to the end of this list. */
  116|       |
  117|      0|      node->key = KEY_NOTUSED; /* we set the key in the sub node to NOTUSED
  118|       |                                  to quickly identify this node as a subnode */
  119|      0|      node->samen = t;
  120|      0|      node->samep = t->samep;
  121|      0|      t->samep->samen = node;
  122|      0|      t->samep = node;
  123|       |
  124|      0|      return t; /* the root node always stays the same */
  125|      0|    }
  126|      0|  }
  127|       |
  128|  4.25k|  if(!t) {
  129|  4.25k|    node->smaller = node->larger = NULL;
  130|  4.25k|  }
  131|      0|  else if(compare(i, t->key) < 0) {
  132|      0|    node->smaller = t->smaller;
  133|      0|    node->larger = t;
  134|      0|    t->smaller = NULL;
  135|       |
  136|      0|  }
  137|      0|  else {
  138|      0|    node->larger = t->larger;
  139|      0|    node->smaller = t;
  140|      0|    t->larger = NULL;
  141|      0|  }
  142|  4.25k|  node->key = i;
  143|       |
  144|       |  /* no identical nodes (yet), we are the only one in the list of nodes */
  145|  4.25k|  node->samen = node;
  146|  4.25k|  node->samep = node;
  147|  4.25k|  return node;
  148|  4.25k|}
Curl_splaygetbest:
  156|  5.78M|{
  157|  5.78M|  static const struct curltime tv_zero = {0, 0};
  158|  5.78M|  struct Curl_tree *x;
  159|       |
  160|  5.78M|  if(!t) {
  161|  3.06k|    *removed = NULL; /* none removed since there was no root */
  162|  3.06k|    return NULL;
  163|  3.06k|  }
  164|       |
  165|       |  /* find smallest */
  166|  5.78M|  t = Curl_splay(tv_zero, t);
  167|  5.78M|  if(compare(i, t->key) < 0) {
  168|       |    /* even the smallest is too big */
  169|  5.78M|    *removed = NULL;
  170|  5.78M|    return t;
  171|  5.78M|  }
  172|       |
  173|       |  /* FIRST! Check if there is a list with identical keys */
  174|  1.03k|  x = t->samen;
  175|  1.03k|  if(x != t) {
  176|       |    /* there is, pick one from the list */
  177|       |
  178|       |    /* 'x' is the new root node */
  179|       |
  180|      0|    x->key = t->key;
  181|      0|    x->larger = t->larger;
  182|      0|    x->smaller = t->smaller;
  183|      0|    x->samep = t->samep;
  184|      0|    t->samep->samen = x;
  185|       |
  186|      0|    *removed = t;
  187|      0|    return x; /* new root */
  188|      0|  }
  189|       |
  190|       |  /* we splayed the tree to the smallest element, there is no smaller */
  191|  1.03k|  x = t->larger;
  192|  1.03k|  *removed = t;
  193|       |
  194|  1.03k|  return x;
  195|  1.03k|}
Curl_splayremove:
  212|  3.21k|{
  213|  3.21k|  static const struct curltime KEY_NOTUSED = {
  214|  3.21k|    (time_t)-1, (unsigned int)-1
  215|  3.21k|  }; /* will *NEVER* appear */
  216|  3.21k|  struct Curl_tree *x;
  217|       |
  218|  3.21k|  if(!t || !removenode)
  219|      0|    return 1;
  220|       |
  221|  3.21k|  if(compare(KEY_NOTUSED, removenode->key) == 0) {
  222|       |    /* Key set to NOTUSED means it is a subnode within a 'same' linked list
  223|       |       and thus we can unlink it easily. */
  224|      0|    if(removenode->samen == removenode)
  225|       |      /* A non-subnode should never be set to KEY_NOTUSED */
  226|      0|      return 3;
  227|       |
  228|      0|    removenode->samep->samen = removenode->samen;
  229|      0|    removenode->samen->samep = removenode->samep;
  230|       |
  231|       |    /* Ensures that double-remove gets caught. */
  232|      0|    removenode->samen = removenode;
  233|       |
  234|      0|    *newroot = t; /* return the same root */
  235|      0|    return 0;
  236|      0|  }
  237|       |
  238|  3.21k|  t = Curl_splay(removenode->key, t);
  239|       |
  240|       |  /* First make sure that we got the same root node as the one we want
  241|       |     to remove, as otherwise we might be trying to remove a node that
  242|       |     isn't actually in the tree.
  243|       |
  244|       |     We cannot just compare the keys here as a double remove in quick
  245|       |     succession of a node with key != KEY_NOTUSED && same != NULL
  246|       |     could return the same key but a different node. */
  247|  3.21k|  if(t != removenode)
  248|      0|    return 2;
  249|       |
  250|       |  /* Check if there is a list with identical sizes, as then we're trying to
  251|       |     remove the root node of a list of nodes with identical keys. */
  252|  3.21k|  x = t->samen;
  253|  3.21k|  if(x != t) {
  254|       |    /* 'x' is the new root node, we just make it use the root node's
  255|       |       smaller/larger links */
  256|       |
  257|      0|    x->key = t->key;
  258|      0|    x->larger = t->larger;
  259|      0|    x->smaller = t->smaller;
  260|      0|    x->samep = t->samep;
  261|      0|    t->samep->samen = x;
  262|      0|  }
  263|  3.21k|  else {
  264|       |    /* Remove the root node */
  265|  3.21k|    if(!t->smaller)
  266|  3.21k|      x = t->larger;
  267|      0|    else {
  268|      0|      x = Curl_splay(removenode->key, t->smaller);
  269|      0|      x->larger = t->larger;
  270|      0|    }
  271|  3.21k|  }
  272|       |
  273|  3.21k|  *newroot = x; /* store new root pointer */
  274|       |
  275|  3.21k|  return 0;
  276|  3.21k|}

Curl_raw_toupper:
   34|  3.07M|{
   35|  3.07M|#if !defined(CURL_DOES_CONVERSIONS)
   36|  3.07M|  if(in >= 'a' && in <= 'z')
   37|  1.24M|    return (char)('A' + in - 'a');
   38|       |#else
   39|       |  switch(in) {
   40|       |  case 'a':
   41|       |    return 'A';
   42|       |  case 'b':
   43|       |    return 'B';
   44|       |  case 'c':
   45|       |    return 'C';
   46|       |  case 'd':
   47|       |    return 'D';
   48|       |  case 'e':
   49|       |    return 'E';
   50|       |  case 'f':
   51|       |    return 'F';
   52|       |  case 'g':
   53|       |    return 'G';
   54|       |  case 'h':
   55|       |    return 'H';
   56|       |  case 'i':
   57|       |    return 'I';
   58|       |  case 'j':
   59|       |    return 'J';
   60|       |  case 'k':
   61|       |    return 'K';
   62|       |  case 'l':
   63|       |    return 'L';
   64|       |  case 'm':
   65|       |    return 'M';
   66|       |  case 'n':
   67|       |    return 'N';
   68|       |  case 'o':
   69|       |    return 'O';
   70|       |  case 'p':
   71|       |    return 'P';
   72|       |  case 'q':
   73|       |    return 'Q';
   74|       |  case 'r':
   75|       |    return 'R';
   76|       |  case 's':
   77|       |    return 'S';
   78|       |  case 't':
   79|       |    return 'T';
   80|       |  case 'u':
   81|       |    return 'U';
   82|       |  case 'v':
   83|       |    return 'V';
   84|       |  case 'w':
   85|       |    return 'W';
   86|       |  case 'x':
   87|       |    return 'X';
   88|       |  case 'y':
   89|       |    return 'Y';
   90|       |  case 'z':
   91|       |    return 'Z';
   92|       |  }
   93|       |#endif
   94|       |
   95|  1.83M|  return in;
   96|  3.07M|}
Curl_strcasecompare:
  181|   292k|{
  182|   628k|  while(*first && *second) {
  183|   559k|    if(Curl_raw_toupper(*first) != Curl_raw_toupper(*second))
  184|       |      /* get out of the loop as soon as they don't match */
  185|   224k|      break;
  186|   335k|    first++;
  187|   335k|    second++;
  188|   335k|  }
  189|       |  /* we do the comparison here (possibly again), just to make sure that if the
  190|       |     loop above is skipped because one of the strings reached zero, we must not
  191|       |     return this as a successful match */
  192|   292k|  return (Curl_raw_toupper(*first) == Curl_raw_toupper(*second));
  193|   292k|}
Curl_strncasecompare:
  209|   227k|{
  210|   495k|  while(*first && *second && max) {
  211|   462k|    if(Curl_raw_toupper(*first) != Curl_raw_toupper(*second)) {
  212|   194k|      break;
  213|   194k|    }
  214|   268k|    max--;
  215|   268k|    first++;
  216|   268k|    second++;
  217|   268k|  }
  218|   227k|  if(0 == max)
  219|  16.7k|    return 1; /* they are equal this far */
  220|       |
  221|   210k|  return Curl_raw_toupper(*first) == Curl_raw_toupper(*second);
  222|   227k|}
Curl_strntoupper:
  230|  1.75k|{
  231|  1.75k|  if(n < 1)
  232|      0|    return;
  233|       |
  234|  19.0k|  do {
  235|  19.0k|    *dest++ = Curl_raw_toupper(*src);
  236|  19.0k|  } while(*src++ && --n);
  237|  1.75k|}
Curl_strntolower:
  245|  11.8k|{
  246|  11.8k|  if(n < 1)
  247|      2|    return;
  248|       |
  249|   177k|  do {
  250|   177k|    *dest++ = raw_tolower(*src);
  251|   177k|  } while(*src++ && --n);
  252|  11.8k|}
curl_strequal:
  257|  3.20k|{
  258|  3.20k|  return Curl_strcasecompare(first, second);
  259|  3.20k|}
curl_strnequal:
  261|   160k|{
  262|   160k|  return Curl_strncasecompare(first, second, max);
  263|   160k|}
strcase.c:raw_tolower:
  102|   177k|{
  103|   177k|#if !defined(CURL_DOES_CONVERSIONS)
  104|   177k|  if(in >= 'A' && in <= 'Z')
  105|     19|    return (char)('a' + in - 'A');
  106|       |#else
  107|       |  switch(in) {
  108|       |  case 'A':
  109|       |    return 'a';
  110|       |  case 'B':
  111|       |    return 'b';
  112|       |  case 'C':
  113|       |    return 'c';
  114|       |  case 'D':
  115|       |    return 'd';
  116|       |  case 'E':
  117|       |    return 'e';
  118|       |  case 'F':
  119|       |    return 'f';
  120|       |  case 'G':
  121|       |    return 'g';
  122|       |  case 'H':
  123|       |    return 'h';
  124|       |  case 'I':
  125|       |    return 'i';
  126|       |  case 'J':
  127|       |    return 'j';
  128|       |  case 'K':
  129|       |    return 'k';
  130|       |  case 'L':
  131|       |    return 'l';
  132|       |  case 'M':
  133|       |    return 'm';
  134|       |  case 'N':
  135|       |    return 'n';
  136|       |  case 'O':
  137|       |    return 'o';
  138|       |  case 'P':
  139|       |    return 'p';
  140|       |  case 'Q':
  141|       |    return 'q';
  142|       |  case 'R':
  143|       |    return 'r';
  144|       |  case 'S':
  145|       |    return 's';
  146|       |  case 'T':
  147|       |    return 't';
  148|       |  case 'U':
  149|       |    return 'u';
  150|       |  case 'V':
  151|       |    return 'v';
  152|       |  case 'W':
  153|       |    return 'w';
  154|       |  case 'X':
  155|       |    return 'x';
  156|       |  case 'Y':
  157|       |    return 'y';
  158|       |  case 'Z':
  159|       |    return 'z';
  160|       |  }
  161|       |#endif
  162|       |
  163|   177k|  return in;
  164|   177k|}

Curl_memdup:
   90|     19|{
   91|     19|  void *buffer = malloc(length);
   92|     19|  if(!buffer)
   93|      0|    return NULL; /* fail */
   94|       |
   95|     19|  memcpy(buffer, src, length);
   96|       |
   97|     19|  return buffer;
   98|     19|}
Curl_saferealloc:
  115|  5.77M|{
  116|  5.77M|  void *datap = realloc(ptr, size);
  117|  5.77M|  if(size && !datap)
  118|       |    /* only free 'ptr' if size was non-zero */
  119|      0|    free(ptr);
  120|  5.77M|  return datap;
  121|  5.77M|}

curl_url_strerror:
  458|     64|{
  459|     64|#ifndef CURL_DISABLE_VERBOSE_STRINGS
  460|     64|  switch(error) {
  461|      0|  case CURLUE_OK:
  462|      0|    return "No error";
  463|       |
  464|      0|  case CURLUE_BAD_HANDLE:
  465|      0|    return "An invalid CURLU pointer was passed as argument";
  466|       |
  467|      0|  case CURLUE_BAD_PARTPOINTER:
  468|      0|    return "An invalid 'part' argument was passed as argument";
  469|       |
  470|     45|  case CURLUE_MALFORMED_INPUT:
  471|     45|    return "A malformed input was passed to a URL API function";
  472|       |
  473|     12|  case CURLUE_BAD_PORT_NUMBER:
  474|     12|    return "The port number was not a decimal number between 0 and 65535";
  475|       |
  476|      0|  case CURLUE_UNSUPPORTED_SCHEME:
  477|      0|    return "This libcurl build doesn't support the given URL scheme";
  478|       |
  479|      0|  case CURLUE_URLDECODE:
  480|      0|    return "URL decode error, most likely because of rubbish in the input";
  481|       |
  482|      0|  case CURLUE_OUT_OF_MEMORY:
  483|      0|    return "A memory function failed";
  484|       |
  485|      0|  case CURLUE_USER_NOT_ALLOWED:
  486|      0|    return "Credentials was passed in the URL when prohibited";
  487|       |
  488|      0|  case CURLUE_UNKNOWN_PART:
  489|      0|    return "An unknown part ID was passed to a URL API function";
  490|       |
  491|      0|  case CURLUE_NO_SCHEME:
  492|      0|    return "There is no scheme part in the URL";
  493|       |
  494|      0|  case CURLUE_NO_USER:
  495|      0|    return "There is no user part in the URL";
  496|       |
  497|      0|  case CURLUE_NO_PASSWORD:
  498|      0|    return "There is no password part in the URL";
  499|       |
  500|      0|  case CURLUE_NO_OPTIONS:
  501|      0|    return "There is no options part in the URL";
  502|       |
  503|      7|  case CURLUE_NO_HOST:
  504|      7|    return "There is no host part in the URL";
  505|       |
  506|      0|  case CURLUE_NO_PORT:
  507|      0|    return "There is no port part in the URL";
  508|       |
  509|      0|  case CURLUE_NO_QUERY:
  510|      0|    return "There is no query part in the URL";
  511|       |
  512|      0|  case CURLUE_NO_FRAGMENT:
  513|      0|    return "There is no fragment part in the URL";
  514|       |
  515|      0|  case CURLUE_LAST:
  516|      0|    break;
  517|     64|  }
  518|       |
  519|      0|  return "CURLUcode unknown";
  520|       |#else
  521|       |  if(error == CURLUE_OK)
  522|       |    return "No error";
  523|       |  else
  524|       |    return "Error";
  525|       |#endif
  526|     64|}
Curl_strerror:
  788|  2.92k|{
  789|       |#ifdef PRESERVE_WINDOWS_ERROR_CODE
  790|       |  DWORD old_win_err = GetLastError();
  791|       |#endif
  792|  2.92k|  int old_errno = errno;
  793|  2.92k|  char *p;
  794|  2.92k|  size_t max;
  795|       |
  796|  2.92k|  if(!buflen)
  797|      0|    return NULL;
  798|       |
  799|  2.92k|#ifndef WIN32
  800|  2.92k|  DEBUGASSERT(err >= 0);
  801|  2.92k|#endif
  802|       |
  803|  2.92k|  max = buflen - 1;
  804|  2.92k|  *buf = '\0';
  805|       |
  806|       |#if defined(WIN32) || defined(_WIN32_WCE)
  807|       |#if defined(WIN32)
  808|       |  /* 'sys_nerr' is the maximum errno number, it is not widely portable */
  809|       |  if(err >= 0 && err < sys_nerr)
  810|       |    strncpy(buf, sys_errlist[err], max);
  811|       |  else
  812|       |#endif
  813|       |  {
  814|       |    if(
  815|       |#ifdef USE_WINSOCK
  816|       |       !get_winsock_error(err, buf, max) &&
  817|       |#endif
  818|       |       !get_winapi_error((DWORD)err, buf, max))
  819|       |      msnprintf(buf, max, "Unknown error %d (%#x)", err, err);
  820|       |  }
  821|       |#else /* not Windows coming up */
  822|       |
  823|  2.92k|#if defined(HAVE_STRERROR_R) && defined(HAVE_POSIX_STRERROR_R)
  824|       | /*
  825|       |  * The POSIX-style strerror_r() may set errno to ERANGE if insufficient
  826|       |  * storage is supplied via 'strerrbuf' and 'buflen' to hold the generated
  827|       |  * message string, or EINVAL if 'errnum' is not a valid error number.
  828|       |  */
  829|  2.92k|  if(0 != strerror_r(err, buf, max)) {
  830|      0|    if('\0' == buf[0])
  831|      0|      msnprintf(buf, max, "Unknown error %d", err);
  832|      0|  }
  833|       |#elif defined(HAVE_STRERROR_R) && defined(HAVE_GLIBC_STRERROR_R)
  834|       | /*
  835|       |  * The glibc-style strerror_r() only *might* use the buffer we pass to
  836|       |  * the function, but it always returns the error message as a pointer,
  837|       |  * so we must copy that string unconditionally (if non-NULL).
  838|       |  */
  839|       |  {
  840|       |    char buffer[256];
  841|       |    char *msg = strerror_r(err, buffer, sizeof(buffer));
  842|       |    if(msg)
  843|       |      strncpy(buf, msg, max);
  844|       |    else
  845|       |      msnprintf(buf, max, "Unknown error %d", err);
  846|       |  }
  847|       |#elif defined(HAVE_STRERROR_R) && defined(HAVE_VXWORKS_STRERROR_R)
  848|       | /*
  849|       |  * The vxworks-style strerror_r() does use the buffer we pass to the function.
  850|       |  * The buffer size should be at least NAME_MAX (256)
  851|       |  */
  852|       |  {
  853|       |    char buffer[256];
  854|       |    if(OK == strerror_r(err, buffer))
  855|       |      strncpy(buf, buffer, max);
  856|       |    else
  857|       |      msnprintf(buf, max, "Unknown error %d", err);
  858|       |  }
  859|       |#else
  860|       |  {
  861|       |    /* !checksrc! disable STRERROR 1 */
  862|       |    const char *msg = strerror(err);
  863|       |    if(msg)
  864|       |      strncpy(buf, msg, max);
  865|       |    else
  866|       |      msnprintf(buf, max, "Unknown error %d", err);
  867|       |  }
  868|       |#endif
  869|       |
  870|  2.92k|#endif /* end of not Windows */
  871|       |
  872|  2.92k|  buf[max] = '\0'; /* make sure the string is null-terminated */
  873|       |
  874|       |  /* strip trailing '\r\n' or '\n'. */
  875|  2.92k|  p = strrchr(buf, '\n');
  876|  2.92k|  if(p && (p - buf) >= 2)
  877|      0|    *p = '\0';
  878|  2.92k|  p = strrchr(buf, '\r');
  879|  2.92k|  if(p && (p - buf) >= 1)
  880|      0|    *p = '\0';
  881|       |
  882|  2.92k|  if(errno != old_errno)
  883|      0|    errno = old_errno;
  884|       |
  885|       |#ifdef PRESERVE_WINDOWS_ERROR_CODE
  886|       |  if(old_win_err != GetLastError())
  887|       |    SetLastError(old_win_err);
  888|       |#endif
  889|       |
  890|  2.92k|  return buf;
  891|  2.92k|}

curlx_strtoofft:
  217|    678|{
  218|    678|  char *end;
  219|    678|  curl_off_t number;
  220|    678|  errno = 0;
  221|    678|  *num = 0; /* clear by default */
  222|       |
  223|  1.27k|  while(*str && ISSPACE(*str))
  224|    592|    str++;
  225|    678|  if('-' == *str) {
  226|      9|    if(endp)
  227|      6|      *endp = (char *)str; /* didn't actually move */
  228|      9|    return CURL_OFFT_INVAL; /* nothing parsed */
  229|      9|  }
  230|    669|  number = strtooff(str, &end, base);
  231|    669|  if(endp)
  232|     67|    *endp = end;
  233|    669|  if(errno == ERANGE)
  234|       |    /* overflow/underflow */
  235|     67|    return CURL_OFFT_FLOW;
  236|    602|  else if(str == end)
  237|       |    /* nothing parsed */
  238|     26|    return CURL_OFFT_INVAL;
  239|       |
  240|    576|  *num = number;
  241|    576|  return CURL_OFFT_OK;
  242|    669|}

tftp.c:tftp_disconnect:
  942|      5|{
  943|      5|  struct tftp_state_data *state = conn->proto.tftpc;
  944|      5|  (void) data;
  945|      5|  (void) dead_connection;
  946|       |
  947|       |  /* done, free dynamically allocated pkt buffers */
  948|      5|  if(state) {
  949|      5|    Curl_safefree(state->rpacket.data);
  950|      5|    Curl_safefree(state->spacket.data);
  951|      5|    free(state);
  952|      5|  }
  953|       |
  954|      5|  return CURLE_OK;
  955|      5|}
tftp.c:tftp_connect:
  965|      5|{
  966|      5|  struct tftp_state_data *state;
  967|      5|  int blksize;
  968|      5|  int need_blksize;
  969|      5|  struct connectdata *conn = data->conn;
  970|       |
  971|      5|  blksize = TFTP_BLKSIZE_DEFAULT;
  972|       |
  973|      5|  state = conn->proto.tftpc = calloc(1, sizeof(struct tftp_state_data));
  974|      5|  if(!state)
  975|      0|    return CURLE_OUT_OF_MEMORY;
  976|       |
  977|       |  /* alloc pkt buffers based on specified blksize */
  978|      5|  if(data->set.tftp_blksize) {
  979|      0|    blksize = (int)data->set.tftp_blksize;
  980|      0|    if(blksize > TFTP_BLKSIZE_MAX || blksize < TFTP_BLKSIZE_MIN)
  981|      0|      return CURLE_TFTP_ILLEGAL;
  982|      0|  }
  983|       |
  984|      5|  need_blksize = blksize;
  985|       |  /* default size is the fallback when no OACK is received */
  986|      5|  if(need_blksize < TFTP_BLKSIZE_DEFAULT)
  987|      0|    need_blksize = TFTP_BLKSIZE_DEFAULT;
  988|       |
  989|      5|  if(!state->rpacket.data) {
  990|      5|    state->rpacket.data = calloc(1, need_blksize + 2 + 2);
  991|       |
  992|      5|    if(!state->rpacket.data)
  993|      0|      return CURLE_OUT_OF_MEMORY;
  994|      5|  }
  995|       |
  996|      5|  if(!state->spacket.data) {
  997|      5|    state->spacket.data = calloc(1, need_blksize + 2 + 2);
  998|       |
  999|      5|    if(!state->spacket.data)
 1000|      0|      return CURLE_OUT_OF_MEMORY;
 1001|      5|  }
 1002|       |
 1003|       |  /* we don't keep TFTP connections up basically because there's none or very
 1004|       |   * little gain for UDP */
 1005|      5|  connclose(conn, "TFTP");
 1006|       |
 1007|      5|  state->data = data;
 1008|      5|  state->sockfd = conn->sock[FIRSTSOCKET];
 1009|      5|  state->state = TFTP_STATE_START;
 1010|      5|  state->error = TFTP_ERR_NONE;
 1011|      5|  state->blksize = TFTP_BLKSIZE_DEFAULT; /* Unless updated by OACK response */
 1012|      5|  state->requested_blksize = blksize;
 1013|       |
 1014|      5|  ((struct sockaddr *)&state->local_addr)->sa_family =
 1015|      5|    (CURL_SA_FAMILY_T)(conn->ip_addr->ai_family);
 1016|       |
 1017|      5|  tftp_set_timeouts(state);
 1018|       |
 1019|      5|  if(!conn->bits.bound) {
 1020|       |    /* If not already bound, bind to any interface, random UDP port. If it is
 1021|       |     * reused or a custom local port was desired, this has already been done!
 1022|       |     *
 1023|       |     * We once used the size of the local_addr struct as the third argument
 1024|       |     * for bind() to better work with IPv6 or whatever size the struct could
 1025|       |     * have, but we learned that at least Tru64, AIX and IRIX *requires* the
 1026|       |     * size of that argument to match the exact size of a 'sockaddr_in' struct
 1027|       |     * when running IPv4-only.
 1028|       |     *
 1029|       |     * Therefore we use the size from the address we connected to, which we
 1030|       |     * assume uses the same IP version and thus hopefully this works for both
 1031|       |     * IPv4 and IPv6...
 1032|       |     */
 1033|      5|    int rc = bind(state->sockfd, (struct sockaddr *)&state->local_addr,
 1034|      5|                  conn->ip_addr->ai_addrlen);
 1035|      5|    if(rc) {
 1036|      5|      char buffer[STRERROR_LEN];
 1037|      5|      failf(data, "bind() failed; %s",
 1038|      5|            Curl_strerror(SOCKERRNO, buffer, sizeof(buffer)));
 1039|      5|      return CURLE_COULDNT_CONNECT;
 1040|      5|    }
 1041|      0|    conn->bits.bound = TRUE;
 1042|      0|  }
 1043|       |
 1044|      0|  Curl_pgrsStartNow(data);
 1045|       |
 1046|      0|  *done = TRUE;
 1047|       |
 1048|      0|  return CURLE_OK;
 1049|      5|}
tftp.c:tftp_set_timeouts:
  203|      5|{
  204|      5|  time_t maxtime, timeout;
  205|      5|  timediff_t timeout_ms;
  206|      5|  bool start = (state->state == TFTP_STATE_START) ? TRUE : FALSE;
  207|       |
  208|       |  /* Compute drop-dead time */
  209|      5|  timeout_ms = Curl_timeleft(state->data, NULL, start);
  210|       |
  211|      5|  if(timeout_ms < 0) {
  212|       |    /* time-out, bail out, go home */
  213|      0|    failf(state->data, "Connection time-out");
  214|      0|    return CURLE_OPERATION_TIMEDOUT;
  215|      0|  }
  216|       |
  217|      5|  if(timeout_ms > 0)
  218|      5|    maxtime = (time_t)(timeout_ms + 500) / 1000;
  219|      0|  else
  220|      0|    maxtime = 3600; /* use for calculating block timeouts */
  221|       |
  222|       |  /* Set per-block timeout to total */
  223|      5|  timeout = maxtime;
  224|       |
  225|       |  /* Average reposting an ACK after 5 seconds */
  226|      5|  state->retry_max = (int)timeout/5;
  227|       |
  228|       |  /* But bound the total number */
  229|      5|  if(state->retry_max<3)
  230|      5|    state->retry_max = 3;
  231|       |
  232|      5|  if(state->retry_max>50)
  233|      0|    state->retry_max = 50;
  234|       |
  235|       |  /* Compute the re-ACK interval to suit the timeout */
  236|      5|  state->retry_time = (int)(timeout/state->retry_max);
  237|      5|  if(state->retry_time<1)
  238|      5|    state->retry_time = 1;
  239|       |
  240|      5|  infof(state->data,
  241|      5|        "set timeouts for state %d; Total % " CURL_FORMAT_CURL_OFF_T
  242|      5|        ", retry %d maxtry %d",
  243|      5|        (int)state->state, timeout_ms, state->retry_time, state->retry_max);
  244|       |
  245|       |  /* init RX time */
  246|      5|  time(&state->rx_time);
  247|       |
  248|      5|  return CURLE_OK;
  249|      5|}
tftp.c:tftp_done:
 1060|      5|{
 1061|      5|  CURLcode result = CURLE_OK;
 1062|      5|  struct connectdata *conn = data->conn;
 1063|      5|  struct tftp_state_data *state = conn->proto.tftpc;
 1064|       |
 1065|      5|  (void)status; /* unused */
 1066|      5|  (void)premature; /* not used */
 1067|       |
 1068|      5|  if(Curl_pgrsDone(data))
 1069|      0|    return CURLE_ABORTED_BY_CALLBACK;
 1070|       |
 1071|       |  /* If we have encountered an error */
 1072|      5|  if(state)
 1073|      5|    result = tftp_translate_code(state->error);
 1074|       |
 1075|      5|  return result;
 1076|      5|}
tftp.c:tftp_translate_code:
  850|      5|{
  851|      5|  CURLcode result = CURLE_OK;
  852|       |
  853|      5|  if(error != TFTP_ERR_NONE) {
  854|      0|    switch(error) {
  855|      0|    case TFTP_ERR_NOTFOUND:
  856|      0|      result = CURLE_TFTP_NOTFOUND;
  857|      0|      break;
  858|      0|    case TFTP_ERR_PERM:
  859|      0|      result = CURLE_TFTP_PERM;
  860|      0|      break;
  861|      0|    case TFTP_ERR_DISKFULL:
  862|      0|      result = CURLE_REMOTE_DISK_FULL;
  863|      0|      break;
  864|      0|    case TFTP_ERR_UNDEF:
  865|      0|    case TFTP_ERR_ILLEGAL:
  866|      0|      result = CURLE_TFTP_ILLEGAL;
  867|      0|      break;
  868|      0|    case TFTP_ERR_UNKNOWNID:
  869|      0|      result = CURLE_TFTP_UNKNOWNID;
  870|      0|      break;
  871|      0|    case TFTP_ERR_EXISTS:
  872|      0|      result = CURLE_REMOTE_FILE_EXISTS;
  873|      0|      break;
  874|      0|    case TFTP_ERR_NOSUCHUSER:
  875|      0|      result = CURLE_TFTP_NOSUCHUSER;
  876|      0|      break;
  877|      0|    case TFTP_ERR_TIMEOUT:
  878|      0|      result = CURLE_OPERATION_TIMEDOUT;
  879|      0|      break;
  880|      0|    case TFTP_ERR_NORESPONSE:
  881|      0|      result = CURLE_COULDNT_CONNECT;
  882|      0|      break;
  883|      0|    default:
  884|      0|      result = CURLE_ABORTED_BY_CALLBACK;
  885|      0|      break;
  886|      0|    }
  887|      0|  }
  888|      5|  else
  889|      5|    result = CURLE_OK;
  890|       |
  891|      5|  return result;
  892|      5|}
tftp.c:tftp_setup_connection:
 1375|      5|{
 1376|      5|  char *type;
 1377|       |
 1378|      5|  conn->transport = TRNSPRT_UDP;
 1379|       |
 1380|       |  /* TFTP URLs support an extension like ";mode=<typecode>" that
 1381|       |   * we'll try to get now! */
 1382|      5|  type = strstr(data->state.up.path, ";mode=");
 1383|       |
 1384|      5|  if(!type)
 1385|      3|    type = strstr(conn->host.rawalloc, ";mode=");
 1386|       |
 1387|      5|  if(type) {
 1388|      3|    char command;
 1389|      3|    *type = 0;                   /* it was in the middle of the hostname */
 1390|      3|    command = Curl_raw_toupper(type[6]);
 1391|       |
 1392|      3|    switch(command) {
 1393|      1|    case 'A': /* ASCII mode */
 1394|      2|    case 'N': /* NETASCII mode */
 1395|      2|      data->state.prefer_ascii = TRUE;
 1396|      2|      break;
 1397|       |
 1398|      0|    case 'O': /* octet mode */
 1399|      0|    case 'I': /* binary mode */
 1400|      1|    default:
 1401|       |      /* switch off ASCII */
 1402|      1|      data->state.prefer_ascii = FALSE;
 1403|      1|      break;
 1404|      3|    }
 1405|      3|  }
 1406|       |
 1407|      5|  return CURLE_OK;
 1408|      5|}

Curl_now:
   62|  29.0M|{
   63|       |  /*
   64|       |  ** clock_gettime() is granted to be increased monotonically when the
   65|       |  ** monotonic clock is queried. Time starting point is unspecified, it
   66|       |  ** could be the system start-up time, the Epoch, or something else,
   67|       |  ** in any case the time starting point does not change once that the
   68|       |  ** system has started up.
   69|       |  */
   70|  29.0M|#ifdef HAVE_GETTIMEOFDAY
   71|  29.0M|  struct timeval now;
   72|  29.0M|#endif
   73|  29.0M|  struct curltime cnow;
   74|  29.0M|  struct timespec tsnow;
   75|       |
   76|       |  /*
   77|       |  ** clock_gettime() may be defined by Apple's SDK as weak symbol thus
   78|       |  ** code compiles but fails during run-time if clock_gettime() is
   79|       |  ** called on unsupported OS version.
   80|       |  */
   81|       |#if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) && \
   82|       |        (HAVE_BUILTIN_AVAILABLE == 1)
   83|       |  bool have_clock_gettime = FALSE;
   84|       |  if(__builtin_available(macOS 10.12, iOS 10, tvOS 10, watchOS 3, *))
   85|       |    have_clock_gettime = TRUE;
   86|       |#endif
   87|       |
   88|  29.0M|  if(
   89|       |#if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) && \
   90|       |        (HAVE_BUILTIN_AVAILABLE == 1)
   91|       |    have_clock_gettime &&
   92|       |#endif
   93|  29.0M|    (0 == clock_gettime(CLOCK_MONOTONIC, &tsnow))) {
   94|  29.0M|    cnow.tv_sec = tsnow.tv_sec;
   95|  29.0M|    cnow.tv_usec = (unsigned int)(tsnow.tv_nsec / 1000);
   96|  29.0M|  }
   97|       |  /*
   98|       |  ** Even when the configure process has truly detected monotonic clock
   99|       |  ** availability, it might happen that it is not actually available at
  100|       |  ** run-time. When this occurs simply fallback to other time source.
  101|       |  */
  102|      0|#ifdef HAVE_GETTIMEOFDAY
  103|      0|  else {
  104|      0|    (void)gettimeofday(&now, NULL);
  105|      0|    cnow.tv_sec = now.tv_sec;
  106|      0|    cnow.tv_usec = (unsigned int)now.tv_usec;
  107|      0|  }
  108|       |#else
  109|       |  else {
  110|       |    cnow.tv_sec = time(NULL);
  111|       |    cnow.tv_usec = 0;
  112|       |  }
  113|       |#endif
  114|  29.0M|  return cnow;
  115|  29.0M|}
Curl_timediff:
  187|  11.6M|{
  188|  11.6M|  timediff_t diff = (timediff_t)newer.tv_sec-older.tv_sec;
  189|  11.6M|  if(diff >= (TIMEDIFF_T_MAX/1000))
  190|      0|    return TIMEDIFF_T_MAX;
  191|  11.6M|  else if(diff <= (TIMEDIFF_T_MIN/1000))
  192|      0|    return TIMEDIFF_T_MIN;
  193|  11.6M|  return diff * 1000 + (newer.tv_usec-older.tv_usec)/1000;
  194|  11.6M|}
Curl_timediff_us:
  201|  11.5M|{
  202|  11.5M|  timediff_t diff = (timediff_t)newer.tv_sec-older.tv_sec;
  203|  11.5M|  if(diff >= (TIMEDIFF_T_MAX/1000000))
  204|      0|    return TIMEDIFF_T_MAX;
  205|  11.5M|  else if(diff <= (TIMEDIFF_T_MIN/1000000))
  206|      0|    return TIMEDIFF_T_MIN;
  207|  11.5M|  return diff * 1000000 + newer.tv_usec-older.tv_usec;
  208|  11.5M|}

Curl_checkheaders:
   99|  8.93k|{
  100|  8.93k|  struct curl_slist *head;
  101|  8.93k|  size_t thislen = strlen(thisheader);
  102|  8.93k|  DEBUGASSERT(thislen);
  103|  8.93k|  DEBUGASSERT(thisheader[thislen-1] != ':');
  104|       |
  105|  34.0k|  for(head = data->set.headers; head; head = head->next) {
  106|  25.2k|    if(strncasecompare(head->data, thisheader, thislen) &&
  107|  25.2k|       Curl_headersep(head->data[thislen]) )
  108|     74|      return head->data;
  109|  25.2k|  }
  110|       |
  111|  8.86k|  return NULL;
  112|  8.93k|}
Curl_get_upload_buffer:
  116|    399|{
  117|    399|  if(!data->state.ulbuf) {
  118|    184|    data->state.ulbuf = malloc(data->set.upload_buffer_size);
  119|    184|    if(!data->state.ulbuf)
  120|      0|      return CURLE_OUT_OF_MEMORY;
  121|    184|  }
  122|    399|  return CURLE_OK;
  123|    399|}
Curl_fillreadbuffer:
  161|    215|{
  162|    215|  size_t buffersize = bytes;
  163|    215|  size_t nread;
  164|       |
  165|    215|  curl_read_callback readfunc = NULL;
  166|    215|  void *extra_data = NULL;
  167|       |
  168|       |#ifdef CURL_DOES_CONVERSIONS
  169|       |  bool sending_http_headers = FALSE;
  170|       |  struct connectdata *conn = data->conn;
  171|       |
  172|       |  if(conn->handler->protocol&(PROTO_FAMILY_HTTP|CURLPROTO_RTSP)) {
  173|       |    const struct HTTP *http = data->req.p.http;
  174|       |
  175|       |    if(http->sending == HTTPSEND_REQUEST)
  176|       |      /* We're sending the HTTP request headers, not the data.
  177|       |         Remember that so we don't re-translate them into garbage. */
  178|       |      sending_http_headers = TRUE;
  179|       |  }
  180|       |#endif
  181|       |
  182|    215|#ifndef CURL_DISABLE_HTTP
  183|    215|  if(data->state.trailers_state == TRAILERS_INITIALIZED) {
  184|      0|    struct curl_slist *trailers = NULL;
  185|      0|    CURLcode result;
  186|      0|    int trailers_ret_code;
  187|       |
  188|       |    /* at this point we already verified that the callback exists
  189|       |       so we compile and store the trailers buffer, then proceed */
  190|      0|    infof(data,
  191|      0|          "Moving trailers state machine from initialized to sending.");
  192|      0|    data->state.trailers_state = TRAILERS_SENDING;
  193|      0|    Curl_dyn_init(&data->state.trailers_buf, DYN_TRAILERS);
  194|       |
  195|      0|    data->state.trailers_bytes_sent = 0;
  196|      0|    Curl_set_in_callback(data, true);
  197|      0|    trailers_ret_code = data->set.trailer_callback(&trailers,
  198|      0|                                                   data->set.trailer_data);
  199|      0|    Curl_set_in_callback(data, false);
  200|      0|    if(trailers_ret_code == CURL_TRAILERFUNC_OK) {
  201|      0|      result = Curl_http_compile_trailers(trailers, &data->state.trailers_buf,
  202|      0|                                          data);
  203|      0|    }
  204|      0|    else {
  205|      0|      failf(data, "operation aborted by trailing headers callback");
  206|      0|      *nreadp = 0;
  207|      0|      result = CURLE_ABORTED_BY_CALLBACK;
  208|      0|    }
  209|      0|    if(result) {
  210|      0|      Curl_dyn_free(&data->state.trailers_buf);
  211|      0|      curl_slist_free_all(trailers);
  212|      0|      return result;
  213|      0|    }
  214|      0|    infof(data, "Successfully compiled trailers.");
  215|      0|    curl_slist_free_all(trailers);
  216|      0|  }
  217|    215|#endif
  218|       |
  219|       |  /* if we are transmitting trailing data, we don't need to write
  220|       |     a chunk size so we skip this */
  221|    215|  if(data->req.upload_chunky &&
  222|    215|     data->state.trailers_state == TRAILERS_NONE) {
  223|       |    /* if chunked Transfer-Encoding */
  224|      6|    buffersize -= (8 + 2 + 2);   /* 32bit hex + CRLF + CRLF */
  225|      6|    data->req.upload_fromhere += (8 + 2); /* 32bit hex + CRLF */
  226|      6|  }
  227|       |
  228|    215|#ifndef CURL_DISABLE_HTTP
  229|    215|  if(data->state.trailers_state == TRAILERS_SENDING) {
  230|       |    /* if we're here then that means that we already sent the last empty chunk
  231|       |       but we didn't send a final CR LF, so we sent 0 CR LF. We then start
  232|       |       pulling trailing data until we have no more at which point we
  233|       |       simply return to the previous point in the state machine as if
  234|       |       nothing happened.
  235|       |       */
  236|      0|    readfunc = trailers_read;
  237|      0|    extra_data = (void *)data;
  238|      0|  }
  239|    215|  else
  240|    215|#endif
  241|    215|  {
  242|    215|    readfunc = data->state.fread_func;
  243|    215|    extra_data = data->state.in;
  244|    215|  }
  245|       |
  246|    215|  Curl_set_in_callback(data, true);
  247|    215|  nread = readfunc(data->req.upload_fromhere, 1,
  248|    215|                   buffersize, extra_data);
  249|    215|  Curl_set_in_callback(data, false);
  250|       |
  251|    215|  if(nread == CURL_READFUNC_ABORT) {
  252|      3|    failf(data, "operation aborted by callback");
  253|      3|    *nreadp = 0;
  254|      3|    return CURLE_ABORTED_BY_CALLBACK;
  255|      3|  }
  256|    212|  if(nread == CURL_READFUNC_PAUSE) {
  257|      0|    struct SingleRequest *k = &data->req;
  258|       |
  259|      0|    if(data->conn->handler->flags & PROTOPT_NONETWORK) {
  260|       |      /* protocols that work without network cannot be paused. This is
  261|       |         actually only FILE:// just now, and it can't pause since the transfer
  262|       |         isn't done using the "normal" procedure. */
  263|      0|      failf(data, "Read callback asked for PAUSE when not supported!");
  264|      0|      return CURLE_READ_ERROR;
  265|      0|    }
  266|       |
  267|       |    /* CURL_READFUNC_PAUSE pauses read callbacks that feed socket writes */
  268|      0|    k->keepon |= KEEP_SEND_PAUSE; /* mark socket send as paused */
  269|      0|    if(data->req.upload_chunky) {
  270|       |        /* Back out the preallocation done above */
  271|      0|      data->req.upload_fromhere -= (8 + 2);
  272|      0|    }
  273|      0|    *nreadp = 0;
  274|       |
  275|      0|    return CURLE_OK; /* nothing was read */
  276|      0|  }
  277|    212|  else if(nread > buffersize) {
  278|       |    /* the read function returned a too large value */
  279|      0|    *nreadp = 0;
  280|      0|    failf(data, "read function returned funny value");
  281|      0|    return CURLE_READ_ERROR;
  282|      0|  }
  283|       |
  284|    212|  if(!data->req.forbidchunk && data->req.upload_chunky) {
  285|       |    /* if chunked Transfer-Encoding
  286|       |     *    build chunk:
  287|       |     *
  288|       |     *        <HEX SIZE> CRLF
  289|       |     *        <DATA> CRLF
  290|       |     */
  291|       |    /* On non-ASCII platforms the <DATA> may or may not be
  292|       |       translated based on state.prefer_ascii while the protocol
  293|       |       portion must always be translated to the network encoding.
  294|       |       To further complicate matters, line end conversion might be
  295|       |       done later on, so we need to prevent CRLFs from becoming
  296|       |       CRCRLFs if that's the case.  To do this we use bare LFs
  297|       |       here, knowing they'll become CRLFs later on.
  298|       |     */
  299|       |
  300|      6|    bool added_crlf = FALSE;
  301|      6|    int hexlen = 0;
  302|      6|    const char *endofline_native;
  303|      6|    const char *endofline_network;
  304|       |
  305|      6|    if(
  306|      6|#ifdef CURL_DO_LINEEND_CONV
  307|      6|       (data->state.prefer_ascii) ||
  308|      6|#endif
  309|      6|       (data->set.crlf)) {
  310|       |      /* \n will become \r\n later on */
  311|      0|      endofline_native  = "\n";
  312|      0|      endofline_network = "\x0a";
  313|      0|    }
  314|      6|    else {
  315|      6|      endofline_native  = "\r\n";
  316|      6|      endofline_network = "\x0d\x0a";
  317|      6|    }
  318|       |
  319|       |    /* if we're not handling trailing data, proceed as usual */
  320|      6|    if(data->state.trailers_state != TRAILERS_SENDING) {
  321|      6|      char hexbuffer[11] = "";
  322|      6|      hexlen = msnprintf(hexbuffer, sizeof(hexbuffer),
  323|      6|                         "%zx%s", nread, endofline_native);
  324|       |
  325|       |      /* move buffer pointer */
  326|      6|      data->req.upload_fromhere -= hexlen;
  327|      6|      nread += hexlen;
  328|       |
  329|       |      /* copy the prefix to the buffer, leaving out the NUL */
  330|      6|      memcpy(data->req.upload_fromhere, hexbuffer, hexlen);
  331|       |
  332|       |      /* always append ASCII CRLF to the data unless
  333|       |         we have a valid trailer callback */
  334|      6|#ifndef CURL_DISABLE_HTTP
  335|      6|      if((nread-hexlen) == 0 &&
  336|      6|          data->set.trailer_callback != NULL &&
  337|      6|          data->state.trailers_state == TRAILERS_NONE) {
  338|      0|        data->state.trailers_state = TRAILERS_INITIALIZED;
  339|      0|      }
  340|      6|      else
  341|      6|#endif
  342|      6|      {
  343|      6|        memcpy(data->req.upload_fromhere + nread,
  344|      6|               endofline_network,
  345|      6|               strlen(endofline_network));
  346|      6|        added_crlf = TRUE;
  347|      6|      }
  348|      6|    }
  349|       |
  350|       |#ifdef CURL_DOES_CONVERSIONS
  351|       |    {
  352|       |      CURLcode result;
  353|       |      size_t length;
  354|       |      if(data->state.prefer_ascii)
  355|       |        /* translate the protocol and data */
  356|       |        length = nread;
  357|       |      else
  358|       |        /* just translate the protocol portion */
  359|       |        length = hexlen;
  360|       |      if(length) {
  361|       |        result = Curl_convert_to_network(data, data->req.upload_fromhere,
  362|       |                                         length);
  363|       |        /* Curl_convert_to_network calls failf if unsuccessful */
  364|       |        if(result)
  365|       |          return result;
  366|       |      }
  367|       |    }
  368|       |#endif /* CURL_DOES_CONVERSIONS */
  369|       |
  370|      6|#ifndef CURL_DISABLE_HTTP
  371|      6|    if(data->state.trailers_state == TRAILERS_SENDING &&
  372|      6|       !trailers_left(data)) {
  373|      0|      Curl_dyn_free(&data->state.trailers_buf);
  374|      0|      data->state.trailers_state = TRAILERS_DONE;
  375|      0|      data->set.trailer_data = NULL;
  376|      0|      data->set.trailer_callback = NULL;
  377|       |      /* mark the transfer as done */
  378|      0|      data->req.upload_done = TRUE;
  379|      0|      infof(data, "Signaling end of chunked upload after trailers.");
  380|      0|    }
  381|      6|    else
  382|      6|#endif
  383|      6|      if((nread - hexlen) == 0 &&
  384|      6|         data->state.trailers_state != TRAILERS_INITIALIZED) {
  385|       |        /* mark this as done once this chunk is transferred */
  386|      3|        data->req.upload_done = TRUE;
  387|      3|        infof(data,
  388|      3|              "Signaling end of chunked upload via terminating chunk.");
  389|      3|      }
  390|       |
  391|      6|    if(added_crlf)
  392|      6|      nread += strlen(endofline_network); /* for the added end of line */
  393|      6|  }
  394|       |#ifdef CURL_DOES_CONVERSIONS
  395|       |  else if((data->state.prefer_ascii) && (!sending_http_headers)) {
  396|       |    CURLcode result;
  397|       |    result = Curl_convert_to_network(data, data->req.upload_fromhere, nread);
  398|       |    /* Curl_convert_to_network calls failf if unsuccessful */
  399|       |    if(result)
  400|       |      return result;
  401|       |  }
  402|       |#endif /* CURL_DOES_CONVERSIONS */
  403|       |
  404|    212|  *nreadp = nread;
  405|       |
  406|    212|  return CURLE_OK;
  407|    212|}
Curl_readrewind:
  416|      8|{
  417|      8|  struct connectdata *conn = data->conn;
  418|      8|  curl_mimepart *mimepart = &data->set.mimepost;
  419|       |
  420|      8|  conn->bits.rewindaftersend = FALSE; /* we rewind now */
  421|       |
  422|       |  /* explicitly switch off sending data on this connection now since we are
  423|       |     about to restart a new transfer and thus we want to avoid inadvertently
  424|       |     sending more data on the existing connection until the next transfer
  425|       |     starts */
  426|      8|  data->req.keepon &= ~KEEP_SEND;
  427|       |
  428|       |  /* We have sent away data. If not using CURLOPT_POSTFIELDS or
  429|       |     CURLOPT_HTTPPOST, call app to rewind
  430|       |  */
  431|      8|  if(conn->handler->protocol & PROTO_FAMILY_HTTP) {
  432|      8|    struct HTTP *http = data->req.p.http;
  433|       |
  434|      8|    if(http->sendit)
  435|      5|      mimepart = http->sendit;
  436|      8|  }
  437|      8|  if(data->set.postfields)
  438|      3|    ; /* do nothing */
  439|      5|  else if(data->state.httpreq == HTTPREQ_POST_MIME ||
  440|      5|          data->state.httpreq == HTTPREQ_POST_FORM) {
  441|      5|    CURLcode result = Curl_mime_rewind(mimepart);
  442|      5|    if(result) {
  443|      2|      failf(data, "Cannot rewind mime/post data");
  444|      2|      return result;
  445|      2|    }
  446|      5|  }
  447|      0|  else {
  448|      0|    if(data->set.seek_func) {
  449|      0|      int err;
  450|       |
  451|      0|      Curl_set_in_callback(data, true);
  452|      0|      err = (data->set.seek_func)(data->set.seek_client, 0, SEEK_SET);
  453|      0|      Curl_set_in_callback(data, false);
  454|      0|      if(err) {
  455|      0|        failf(data, "seek callback returned error %d", (int)err);
  456|      0|        return CURLE_SEND_FAIL_REWIND;
  457|      0|      }
  458|      0|    }
  459|      0|    else if(data->set.ioctl_func) {
  460|      0|      curlioerr err;
  461|       |
  462|      0|      Curl_set_in_callback(data, true);
  463|      0|      err = (data->set.ioctl_func)(data, CURLIOCMD_RESTARTREAD,
  464|      0|                                   data->set.ioctl_client);
  465|      0|      Curl_set_in_callback(data, false);
  466|      0|      infof(data, "the ioctl callback returned %d", (int)err);
  467|       |
  468|      0|      if(err) {
  469|      0|        failf(data, "ioctl callback returned error %d", (int)err);
  470|      0|        return CURLE_SEND_FAIL_REWIND;
  471|      0|      }
  472|      0|    }
  473|      0|    else {
  474|       |      /* If no CURLOPT_READFUNCTION is used, we know that we operate on a
  475|       |         given FILE * stream and we can actually attempt to rewind that
  476|       |         ourselves with fseek() */
  477|      0|      if(data->state.fread_func == (curl_read_callback)fread) {
  478|      0|        if(-1 != fseek(data->state.in, 0, SEEK_SET))
  479|       |          /* successful rewind */
  480|      0|          return CURLE_OK;
  481|      0|      }
  482|       |
  483|       |      /* no callback set or failure above, makes us fail at once */
  484|      0|      failf(data, "necessary data rewind wasn't possible");
  485|      0|      return CURLE_SEND_FAIL_REWIND;
  486|      0|    }
  487|      0|  }
  488|      6|  return CURLE_OK;
  489|      8|}
Curl_done_sending:
  910|    185|{
  911|    185|  struct connectdata *conn = data->conn;
  912|    185|  k->keepon &= ~KEEP_SEND; /* we're done writing */
  913|       |
  914|       |  /* These functions should be moved into the handler struct! */
  915|    185|  Curl_http2_done_sending(data, conn);
  916|    185|  Curl_quic_done_sending(data);
  917|       |
  918|    185|  if(conn->bits.rewindaftersend) {
  919|      0|    CURLcode result = Curl_readrewind(data);
  920|      0|    if(result)
  921|      0|      return result;
  922|      0|  }
  923|    185|  return CURLE_OK;
  924|    185|}
Curl_readwrite:
 1176|  5.78M|{
 1177|  5.78M|  struct SingleRequest *k = &data->req;
 1178|  5.78M|  CURLcode result;
 1179|  5.78M|  int didwhat = 0;
 1180|       |
 1181|  5.78M|  curl_socket_t fd_read;
 1182|  5.78M|  curl_socket_t fd_write;
 1183|  5.78M|  int select_res = conn->cselect_bits;
 1184|       |
 1185|  5.78M|  conn->cselect_bits = 0;
 1186|       |
 1187|       |  /* only use the proper socket if the *_HOLD bit is not set simultaneously as
 1188|       |     then we are in rate limiting state in that transfer direction */
 1189|       |
 1190|  5.78M|  if((k->keepon & KEEP_RECVBITS) == KEEP_RECV)
 1191|  5.78M|    fd_read = conn->sockfd;
 1192|    149|  else
 1193|    149|    fd_read = CURL_SOCKET_BAD;
 1194|       |
 1195|  5.78M|  if((k->keepon & KEEP_SENDBITS) == KEEP_SEND)
 1196|    242|    fd_write = conn->writesockfd;
 1197|  5.78M|  else
 1198|  5.78M|    fd_write = CURL_SOCKET_BAD;
 1199|       |
 1200|  5.78M|  if(data->state.drain) {
 1201|      0|    select_res |= CURL_CSELECT_IN;
 1202|      0|    DEBUGF(infof(data, "Curl_readwrite: forcibly told to drain data"));
 1203|      0|  }
 1204|       |
 1205|  5.78M|  if(!select_res) /* Call for select()/poll() only, if read/write/error
 1206|       |                     status is not known. */
 1207|  5.78M|    select_res = Curl_socket_check(fd_read, CURL_SOCKET_BAD, fd_write, 0);
 1208|       |
 1209|  5.78M|  if(select_res == CURL_CSELECT_ERR) {
 1210|      0|    failf(data, "select/poll returned error");
 1211|      0|    return CURLE_SEND_ERROR;
 1212|      0|  }
 1213|       |
 1214|       |#ifdef USE_HYPER
 1215|       |  if(conn->datastream) {
 1216|       |    result = conn->datastream(data, conn, &didwhat, done, select_res);
 1217|       |    if(result || *done)
 1218|       |      return result;
 1219|       |  }
 1220|       |  else {
 1221|       |#endif
 1222|       |  /* We go ahead and do a read if we have a readable socket or if
 1223|       |     the stream was rewound (in which case we have data in a
 1224|       |     buffer) */
 1225|  5.78M|  if((k->keepon & KEEP_RECV) && (select_res & CURL_CSELECT_IN)) {
 1226|  5.78M|    result = readwrite_data(data, conn, k, &didwhat, done, comeback);
 1227|  5.78M|    if(result || *done)
 1228|    204|      return result;
 1229|  5.78M|  }
 1230|       |
 1231|       |  /* If we still have writing to do, we check if we have a writable socket. */
 1232|  5.78M|  if((k->keepon & KEEP_SEND) && (select_res & CURL_CSELECT_OUT)) {
 1233|       |    /* write */
 1234|       |
 1235|    211|    result = readwrite_upload(data, conn, &didwhat);
 1236|    211|    if(result)
 1237|      1|      return result;
 1238|    211|  }
 1239|       |#ifdef USE_HYPER
 1240|       |  }
 1241|       |#endif
 1242|       |
 1243|  5.78M|  k->now = Curl_now();
 1244|  5.78M|  if(!didwhat) {
 1245|       |    /* no read no write, this is a timeout? */
 1246|    130|    if(k->exp100 == EXP100_AWAITING_CONTINUE) {
 1247|       |      /* This should allow some time for the header to arrive, but only a
 1248|       |         very short time as otherwise it'll be too much wasted time too
 1249|       |         often. */
 1250|       |
 1251|       |      /* Quoting RFC2616, section "8.2.3 Use of the 100 (Continue) Status":
 1252|       |
 1253|       |         Therefore, when a client sends this header field to an origin server
 1254|       |         (possibly via a proxy) from which it has never seen a 100 (Continue)
 1255|       |         status, the client SHOULD NOT wait for an indefinite period before
 1256|       |         sending the request body.
 1257|       |
 1258|       |      */
 1259|       |
 1260|      1|      timediff_t ms = Curl_timediff(k->now, k->start100);
 1261|      1|      if(ms >= data->set.expect_100_timeout) {
 1262|       |        /* we've waited long enough, continue anyway */
 1263|      0|        k->exp100 = EXP100_SEND_DATA;
 1264|      0|        k->keepon |= KEEP_SEND;
 1265|      0|        Curl_expire_done(data, EXPIRE_100_TIMEOUT);
 1266|      0|        infof(data, "Done waiting for 100-continue");
 1267|      0|      }
 1268|      1|    }
 1269|    130|  }
 1270|       |
 1271|  5.78M|  if(Curl_pgrsUpdate(data))
 1272|      0|    result = CURLE_ABORTED_BY_CALLBACK;
 1273|  5.78M|  else
 1274|  5.78M|    result = Curl_speedcheck(data, k->now);
 1275|  5.78M|  if(result)
 1276|      0|    return result;
 1277|       |
 1278|  5.78M|  if(k->keepon) {
 1279|  5.78M|    if(0 > Curl_timeleft(data, &k->now, FALSE)) {
 1280|     82|      if(k->size != -1) {
 1281|     17|        failf(data, "Operation timed out after %" CURL_FORMAT_TIMEDIFF_T
 1282|     17|              " milliseconds with %" CURL_FORMAT_CURL_OFF_T " out of %"
 1283|     17|              CURL_FORMAT_CURL_OFF_T " bytes received",
 1284|     17|              Curl_timediff(k->now, data->progress.t_startsingle),
 1285|     17|              k->bytecount, k->size);
 1286|     17|      }
 1287|     65|      else {
 1288|     65|        failf(data, "Operation timed out after %" CURL_FORMAT_TIMEDIFF_T
 1289|     65|              " milliseconds with %" CURL_FORMAT_CURL_OFF_T " bytes received",
 1290|     65|              Curl_timediff(k->now, data->progress.t_startsingle),
 1291|     65|              k->bytecount);
 1292|     65|      }
 1293|     82|      return CURLE_OPERATION_TIMEDOUT;
 1294|     82|    }
 1295|  5.78M|  }
 1296|  1.26k|  else {
 1297|       |    /*
 1298|       |     * The transfer has been performed. Just make some general checks before
 1299|       |     * returning.
 1300|       |     */
 1301|       |
 1302|  1.26k|    if(!(data->set.opt_no_body) && (k->size != -1) &&
 1303|  1.26k|       (k->bytecount != k->size) &&
 1304|  1.26k|#ifdef CURL_DO_LINEEND_CONV
 1305|       |       /* Most FTP servers don't adjust their file SIZE response for CRLFs,
 1306|       |          so we'll check to see if the discrepancy can be explained
 1307|       |          by the number of CRLFs we've changed to LFs.
 1308|       |       */
 1309|  1.26k|       (k->bytecount != (k->size + data->state.crlf_conversions)) &&
 1310|  1.26k|#endif /* CURL_DO_LINEEND_CONV */
 1311|  1.26k|       !k->newurl) {
 1312|     73|      failf(data, "transfer closed with %" CURL_FORMAT_CURL_OFF_T
 1313|     73|            " bytes remaining to read", k->size - k->bytecount);
 1314|     73|      return CURLE_PARTIAL_FILE;
 1315|     73|    }
 1316|  1.19k|    if(!(data->set.opt_no_body) && k->chunk &&
 1317|  1.19k|       (conn->chunk.state != CHUNK_STOP)) {
 1318|       |      /*
 1319|       |       * In chunked mode, return an error if the connection is closed prior to
 1320|       |       * the empty (terminating) chunk is read.
 1321|       |       *
 1322|       |       * The condition above used to check for
 1323|       |       * conn->proto.http->chunk.datasize != 0 which is true after reading
 1324|       |       * *any* chunk, not just the empty chunk.
 1325|       |       *
 1326|       |       */
 1327|      9|      failf(data, "transfer closed with outstanding read data remaining");
 1328|      9|      return CURLE_PARTIAL_FILE;
 1329|      9|    }
 1330|  1.18k|    if(Curl_pgrsUpdate(data))
 1331|      0|      return CURLE_ABORTED_BY_CALLBACK;
 1332|  1.18k|  }
 1333|       |
 1334|       |  /* Now update the "done" boolean we return */
 1335|  5.78M|  *done = (0 == (k->keepon&(KEEP_RECV|KEEP_SEND|
 1336|  5.78M|                            KEEP_RECV_PAUSE|KEEP_SEND_PAUSE))) ? TRUE : FALSE;
 1337|       |
 1338|  5.78M|  return CURLE_OK;
 1339|  5.78M|}
Curl_single_getsock:
 1351|  5.78M|{
 1352|  5.78M|  int bitmap = GETSOCK_BLANK;
 1353|  5.78M|  unsigned sockindex = 0;
 1354|       |
 1355|  5.78M|  if(conn->handler->perform_getsock)
 1356|      0|    return conn->handler->perform_getsock(data, conn, sock);
 1357|       |
 1358|       |  /* don't include HOLD and PAUSE connections */
 1359|  5.78M|  if((data->req.keepon & KEEP_RECVBITS) == KEEP_RECV) {
 1360|       |
 1361|  5.78M|    DEBUGASSERT(conn->sockfd != CURL_SOCKET_BAD);
 1362|       |
 1363|  5.78M|    bitmap |= GETSOCK_READSOCK(sockindex);
 1364|  5.78M|    sock[sockindex] = conn->sockfd;
 1365|  5.78M|  }
 1366|       |
 1367|       |  /* don't include HOLD and PAUSE connections */
 1368|  5.78M|  if((data->req.keepon & KEEP_SENDBITS) == KEEP_SEND) {
 1369|       |
 1370|     30|    if((conn->sockfd != conn->writesockfd) ||
 1371|     30|       bitmap == GETSOCK_BLANK) {
 1372|       |      /* only if they are not the same socket and we have a readable
 1373|       |         one, we increase index */
 1374|     27|      if(bitmap != GETSOCK_BLANK)
 1375|      0|        sockindex++; /* increase index if we need two entries */
 1376|       |
 1377|     27|      DEBUGASSERT(conn->writesockfd != CURL_SOCKET_BAD);
 1378|       |
 1379|     27|      sock[sockindex] = conn->writesockfd;
 1380|     27|    }
 1381|       |
 1382|     30|    bitmap |= GETSOCK_WRITESOCK(sockindex);
 1383|     30|  }
 1384|       |
 1385|  5.78M|  return bitmap;
 1386|  5.78M|}
Curl_init_CONNECT:
 1391|  3.05k|{
 1392|  3.05k|  data->state.fread_func = data->set.fread_func_set;
 1393|  3.05k|  data->state.in = data->set.in_set;
 1394|  3.05k|}
Curl_pretransfer:
 1402|  3.09k|{
 1403|  3.09k|  CURLcode result;
 1404|       |
 1405|  3.09k|  if(!data->state.url && !data->set.uh) {
 1406|       |    /* we can't do anything without URL */
 1407|    157|    failf(data, "No URL set!");
 1408|    157|    return CURLE_URL_MALFORMAT;
 1409|    157|  }
 1410|       |
 1411|       |  /* since the URL may have been redirected in a previous use of this handle */
 1412|  2.94k|  if(data->state.url_alloc) {
 1413|       |    /* the already set URL is allocated, free it first! */
 1414|      4|    Curl_safefree(data->state.url);
 1415|      4|    data->state.url_alloc = FALSE;
 1416|      4|  }
 1417|       |
 1418|  2.94k|  if(!data->state.url && data->set.uh) {
 1419|      0|    CURLUcode uc;
 1420|      0|    free(data->set.str[STRING_SET_URL]);
 1421|      0|    uc = curl_url_get(data->set.uh,
 1422|      0|                      CURLUPART_URL, &data->set.str[STRING_SET_URL], 0);
 1423|      0|    if(uc) {
 1424|      0|      failf(data, "No URL set!");
 1425|      0|      return CURLE_URL_MALFORMAT;
 1426|      0|    }
 1427|      0|  }
 1428|       |
 1429|  2.94k|  data->state.prefer_ascii = data->set.prefer_ascii;
 1430|  2.94k|  data->state.list_only = data->set.list_only;
 1431|  2.94k|  data->state.httpreq = data->set.method;
 1432|  2.94k|  data->state.url = data->set.str[STRING_SET_URL];
 1433|       |
 1434|       |  /* Init the SSL session ID cache here. We do it here since we want to do it
 1435|       |     after the *_setopt() calls (that could specify the size of the cache) but
 1436|       |     before any transfer takes place. */
 1437|  2.94k|  result = Curl_ssl_initsessions(data, data->set.general_ssl.max_ssl_sessions);
 1438|  2.94k|  if(result)
 1439|      0|    return result;
 1440|       |
 1441|  2.94k|  data->state.wildcardmatch = data->set.wildcard_enabled;
 1442|  2.94k|  data->state.followlocation = 0; /* reset the location-follow counter */
 1443|  2.94k|  data->state.this_is_a_follow = FALSE; /* reset this */
 1444|  2.94k|  data->state.errorbuf = FALSE; /* no error has occurred */
 1445|  2.94k|  data->state.httpwant = data->set.httpwant;
 1446|  2.94k|  data->state.httpversion = 0;
 1447|  2.94k|  data->state.authproblem = FALSE;
 1448|  2.94k|  data->state.authhost.want = data->set.httpauth;
 1449|  2.94k|  data->state.authproxy.want = data->set.proxyauth;
 1450|  2.94k|  Curl_safefree(data->info.wouldredirect);
 1451|       |
 1452|  2.94k|  if(data->state.httpreq == HTTPREQ_PUT)
 1453|     54|    data->state.infilesize = data->set.filesize;
 1454|  2.88k|  else if((data->state.httpreq != HTTPREQ_GET) &&
 1455|  2.88k|          (data->state.httpreq != HTTPREQ_HEAD)) {
 1456|    255|    data->state.infilesize = data->set.postfieldsize;
 1457|    255|    if(data->set.postfields && (data->state.infilesize == -1))
 1458|     23|      data->state.infilesize = (curl_off_t)strlen(data->set.postfields);
 1459|    255|  }
 1460|  2.63k|  else
 1461|  2.63k|    data->state.infilesize = 0;
 1462|       |
 1463|       |  /* If there is a list of cookie files to read, do it now! */
 1464|  2.94k|  if(data->state.cookielist)
 1465|      0|    Curl_cookie_loadfiles(data);
 1466|       |
 1467|       |  /* If there is a list of host pairs to deal with */
 1468|  2.94k|  if(data->state.resolve)
 1469|      0|    result = Curl_loadhostpairs(data);
 1470|       |
 1471|  2.94k|  if(!result) {
 1472|       |    /* Allow data->set.use_port to set which port to use. This needs to be
 1473|       |     * disabled for example when we follow Location: headers to URLs using
 1474|       |     * different ports! */
 1475|  2.94k|    data->state.allow_port = TRUE;
 1476|       |
 1477|       |#if defined(HAVE_SIGNAL) && defined(SIGPIPE) && !defined(HAVE_MSG_NOSIGNAL)
 1478|       |    /*************************************************************
 1479|       |     * Tell signal handler to ignore SIGPIPE
 1480|       |     *************************************************************/
 1481|       |    if(!data->set.no_signal)
 1482|       |      data->state.prev_signal = signal(SIGPIPE, SIG_IGN);
 1483|       |#endif
 1484|       |
 1485|  2.94k|    Curl_initinfo(data); /* reset session-specific information "variables" */
 1486|  2.94k|    Curl_pgrsResetTransferSizes(data);
 1487|  2.94k|    Curl_pgrsStartNow(data);
 1488|       |
 1489|       |    /* In case the handle is re-used and an authentication method was picked
 1490|       |       in the session we need to make sure we only use the one(s) we now
 1491|       |       consider to be fine */
 1492|  2.94k|    data->state.authhost.picked &= data->state.authhost.want;
 1493|  2.94k|    data->state.authproxy.picked &= data->state.authproxy.want;
 1494|       |
 1495|  2.94k|#ifndef CURL_DISABLE_FTP
 1496|  2.94k|    if(data->state.wildcardmatch) {
 1497|     38|      struct WildcardData *wc = &data->wildcard;
 1498|     38|      if(wc->state < CURLWC_INIT) {
 1499|     34|        result = Curl_wildcard_init(wc); /* init wildcard structures */
 1500|     34|        if(result)
 1501|      0|          return CURLE_OUT_OF_MEMORY;
 1502|     34|      }
 1503|     38|    }
 1504|  2.94k|#endif
 1505|  2.94k|    Curl_http2_init_state(&data->state);
 1506|  2.94k|    result = Curl_hsts_loadcb(data, data->hsts);
 1507|  2.94k|  }
 1508|       |
 1509|       |  /*
 1510|       |   * Set user-agent. Used for HTTP, but since we can attempt to tunnel
 1511|       |   * basically anything through a http proxy we can't limit this based on
 1512|       |   * protocol.
 1513|       |   */
 1514|  2.94k|  if(data->set.str[STRING_USERAGENT]) {
 1515|      0|    Curl_safefree(data->state.aptr.uagent);
 1516|      0|    data->state.aptr.uagent =
 1517|      0|      aprintf("User-Agent: %s\r\n", data->set.str[STRING_USERAGENT]);
 1518|      0|    if(!data->state.aptr.uagent)
 1519|      0|      return CURLE_OUT_OF_MEMORY;
 1520|      0|  }
 1521|       |
 1522|  2.94k|  if(!result)
 1523|  2.94k|    result = Curl_setstropt(&data->state.aptr.user,
 1524|  2.94k|                            data->set.str[STRING_USERNAME]);
 1525|  2.94k|  if(!result)
 1526|  2.94k|    result = Curl_setstropt(&data->state.aptr.passwd,
 1527|  2.94k|                            data->set.str[STRING_PASSWORD]);
 1528|  2.94k|  if(!result)
 1529|  2.94k|    result = Curl_setstropt(&data->state.aptr.proxyuser,
 1530|  2.94k|                            data->set.str[STRING_PROXYUSERNAME]);
 1531|  2.94k|  if(!result)
 1532|  2.94k|    result = Curl_setstropt(&data->state.aptr.proxypasswd,
 1533|  2.94k|                            data->set.str[STRING_PROXYPASSWORD]);
 1534|       |
 1535|  2.94k|  data->req.headerbytecount = 0;
 1536|  2.94k|  return result;
 1537|  2.94k|}
Curl_posttransfer:
 1543|  2.93k|{
 1544|       |#if defined(HAVE_SIGNAL) && defined(SIGPIPE) && !defined(HAVE_MSG_NOSIGNAL)
 1545|       |  /* restore the signal handler for SIGPIPE before we get back */
 1546|       |  if(!data->set.no_signal)
 1547|       |    signal(SIGPIPE, data->state.prev_signal);
 1548|       |#else
 1549|  2.93k|  (void)data; /* unused parameter */
 1550|  2.93k|#endif
 1551|       |
 1552|  2.93k|  return CURLE_OK;
 1553|  2.93k|}
Curl_follow:
 1564|    190|{
 1565|       |#ifdef CURL_DISABLE_HTTP
 1566|       |  (void)data;
 1567|       |  (void)newurl;
 1568|       |  (void)type;
 1569|       |  /* Location: following will not happen when HTTP is disabled */
 1570|       |  return CURLE_TOO_MANY_REDIRECTS;
 1571|       |#else
 1572|       |
 1573|       |  /* Location: redirect */
 1574|    190|  bool disallowport = FALSE;
 1575|    190|  bool reachedmax = FALSE;
 1576|    190|  CURLUcode uc;
 1577|       |
 1578|    190|  DEBUGASSERT(type != FOLLOW_NONE);
 1579|       |
 1580|    190|  if(type == FOLLOW_REDIR) {
 1581|    120|    if((data->set.maxredirs != -1) &&
 1582|    120|       (data->state.followlocation >= data->set.maxredirs)) {
 1583|      0|      reachedmax = TRUE;
 1584|      0|      type = FOLLOW_FAKE; /* switch to fake to store the would-be-redirected
 1585|       |                             to URL */
 1586|      0|    }
 1587|    120|    else {
 1588|       |      /* mark the next request as a followed location: */
 1589|    120|      data->state.this_is_a_follow = TRUE;
 1590|       |
 1591|    120|      data->state.followlocation++; /* count location-followers */
 1592|       |
 1593|    120|      if(data->set.http_auto_referer) {
 1594|      0|        CURLU *u;
 1595|      0|        char *referer = NULL;
 1596|       |
 1597|       |        /* We are asked to automatically set the previous URL as the referer
 1598|       |           when we get the next URL. We pick the ->url field, which may or may
 1599|       |           not be 100% correct */
 1600|       |
 1601|      0|        if(data->state.referer_alloc) {
 1602|      0|          Curl_safefree(data->state.referer);
 1603|      0|          data->state.referer_alloc = FALSE;
 1604|      0|        }
 1605|       |
 1606|       |        /* Make a copy of the URL without crenditals and fragment */
 1607|      0|        u = curl_url();
 1608|      0|        if(!u)
 1609|      0|          return CURLE_OUT_OF_MEMORY;
 1610|       |
 1611|      0|        uc = curl_url_set(u, CURLUPART_URL, data->state.url, 0);
 1612|      0|        if(!uc)
 1613|      0|          uc = curl_url_set(u, CURLUPART_FRAGMENT, NULL, 0);
 1614|      0|        if(!uc)
 1615|      0|          uc = curl_url_set(u, CURLUPART_USER, NULL, 0);
 1616|      0|        if(!uc)
 1617|      0|          uc = curl_url_set(u, CURLUPART_PASSWORD, NULL, 0);
 1618|      0|        if(!uc)
 1619|      0|          uc = curl_url_get(u, CURLUPART_URL, &referer, 0);
 1620|       |
 1621|      0|        curl_url_cleanup(u);
 1622|       |
 1623|      0|        if(uc || !referer)
 1624|      0|          return CURLE_OUT_OF_MEMORY;
 1625|       |
 1626|      0|        data->state.referer = referer;
 1627|      0|        data->state.referer_alloc = TRUE; /* yes, free this later */
 1628|      0|      }
 1629|    120|    }
 1630|    120|  }
 1631|       |
 1632|    190|  if((type != FOLLOW_RETRY) &&
 1633|    190|     (data->req.httpcode != 401) && (data->req.httpcode != 407) &&
 1634|    190|     Curl_is_absolute_url(newurl, NULL, MAX_SCHEME_LEN))
 1635|       |    /* If this is not redirect due to a 401 or 407 response and an absolute
 1636|       |       URL: don't allow a custom port number */
 1637|     12|    disallowport = TRUE;
 1638|       |
 1639|    190|  DEBUGASSERT(data->state.uh);
 1640|    190|  uc = curl_url_set(data->state.uh, CURLUPART_URL, newurl,
 1641|    190|                    (type == FOLLOW_FAKE) ? CURLU_NON_SUPPORT_SCHEME :
 1642|    190|                    ((type == FOLLOW_REDIR) ? CURLU_URLENCODE : 0) |
 1643|    120|                    CURLU_ALLOW_SPACE);
 1644|    190|  if(uc) {
 1645|     24|    if(type != FOLLOW_FAKE)
 1646|      7|      return Curl_uc_to_curlcode(uc);
 1647|       |
 1648|       |    /* the URL could not be parsed for some reason, but since this is FAKE
 1649|       |       mode, just duplicate the field as-is */
 1650|     17|    newurl = strdup(newurl);
 1651|     17|    if(!newurl)
 1652|      0|      return CURLE_OUT_OF_MEMORY;
 1653|     17|  }
 1654|    166|  else {
 1655|       |
 1656|    166|    uc = curl_url_get(data->state.uh, CURLUPART_URL, &newurl, 0);
 1657|    166|    if(uc)
 1658|      0|      return Curl_uc_to_curlcode(uc);
 1659|    166|  }
 1660|       |
 1661|    183|  if(type == FOLLOW_FAKE) {
 1662|       |    /* we're only figuring out the new url if we would've followed locations
 1663|       |       but now we're done so we can get out! */
 1664|     70|    data->info.wouldredirect = newurl;
 1665|       |
 1666|     70|    if(reachedmax) {
 1667|      0|      failf(data, "Maximum (%ld) redirects followed", data->set.maxredirs);
 1668|      0|      return CURLE_TOO_MANY_REDIRECTS;
 1669|      0|    }
 1670|     70|    return CURLE_OK;
 1671|     70|  }
 1672|       |
 1673|    113|  if(disallowport)
 1674|      8|    data->state.allow_port = FALSE;
 1675|       |
 1676|    113|  if(data->state.url_alloc)
 1677|    113|    Curl_safefree(data->state.url);
 1678|       |
 1679|    113|  data->state.url = newurl;
 1680|    113|  data->state.url_alloc = TRUE;
 1681|       |
 1682|    113|  infof(data, "Issue another request to this URL: '%s'", data->state.url);
 1683|       |
 1684|       |  /*
 1685|       |   * We get here when the HTTP code is 300-399 (and 401). We need to perform
 1686|       |   * differently based on exactly what return code there was.
 1687|       |   *
 1688|       |   * News from 7.10.6: we can also get here on a 401 or 407, in case we act on
 1689|       |   * a HTTP (proxy-) authentication scheme other than Basic.
 1690|       |   */
 1691|    113|  switch(data->info.httpcode) {
 1692|       |    /* 401 - Act on a WWW-Authenticate, we keep on moving and do the
 1693|       |       Authorization: XXXX header in the HTTP request code snippet */
 1694|       |    /* 407 - Act on a Proxy-Authenticate, we keep on moving and do the
 1695|       |       Proxy-Authorization: XXXX header in the HTTP request code snippet */
 1696|       |    /* 300 - Multiple Choices */
 1697|       |    /* 306 - Not used */
 1698|       |    /* 307 - Temporary Redirect */
 1699|     70|  default:  /* for all above (and the unknown ones) */
 1700|       |    /* Some codes are explicitly mentioned since I've checked RFC2616 and they
 1701|       |     * seem to be OK to POST to.
 1702|       |     */
 1703|     70|    break;
 1704|     70|  case 301: /* Moved Permanently */
 1705|       |    /* (quote from RFC7231, section 6.4.2)
 1706|       |     *
 1707|       |     * Note: For historical reasons, a user agent MAY change the request
 1708|       |     * method from POST to GET for the subsequent request.  If this
 1709|       |     * behavior is undesired, the 307 (Temporary Redirect) status code
 1710|       |     * can be used instead.
 1711|       |     *
 1712|       |     * ----
 1713|       |     *
 1714|       |     * Many webservers expect this, so these servers often answers to a POST
 1715|       |     * request with an error page. To be sure that libcurl gets the page that
 1716|       |     * most user agents would get, libcurl has to force GET.
 1717|       |     *
 1718|       |     * This behavior is forbidden by RFC1945 and the obsolete RFC2616, and
 1719|       |     * can be overridden with CURLOPT_POSTREDIR.
 1720|       |     */
 1721|     37|    if((data->state.httpreq == HTTPREQ_POST
 1722|     37|        || data->state.httpreq == HTTPREQ_POST_FORM
 1723|     37|        || data->state.httpreq == HTTPREQ_POST_MIME)
 1724|     37|       && !(data->set.keep_post & CURL_REDIR_POST_301)) {
 1725|      1|      infof(data, "Switch from POST to GET");
 1726|      1|      data->state.httpreq = HTTPREQ_GET;
 1727|      1|    }
 1728|     37|    break;
 1729|      2|  case 302: /* Found */
 1730|       |    /* (quote from RFC7231, section 6.4.3)
 1731|       |     *
 1732|       |     * Note: For historical reasons, a user agent MAY change the request
 1733|       |     * method from POST to GET for the subsequent request.  If this
 1734|       |     * behavior is undesired, the 307 (Temporary Redirect) status code
 1735|       |     * can be used instead.
 1736|       |     *
 1737|       |     * ----
 1738|       |     *
 1739|       |     * Many webservers expect this, so these servers often answers to a POST
 1740|       |     * request with an error page. To be sure that libcurl gets the page that
 1741|       |     * most user agents would get, libcurl has to force GET.
 1742|       |     *
 1743|       |     * This behavior is forbidden by RFC1945 and the obsolete RFC2616, and
 1744|       |     * can be overridden with CURLOPT_POSTREDIR.
 1745|       |     */
 1746|      2|    if((data->state.httpreq == HTTPREQ_POST
 1747|      2|        || data->state.httpreq == HTTPREQ_POST_FORM
 1748|      2|        || data->state.httpreq == HTTPREQ_POST_MIME)
 1749|      2|       && !(data->set.keep_post & CURL_REDIR_POST_302)) {
 1750|      0|      infof(data, "Switch from POST to GET");
 1751|      0|      data->state.httpreq = HTTPREQ_GET;
 1752|      0|    }
 1753|      2|    break;
 1754|       |
 1755|      4|  case 303: /* See Other */
 1756|       |    /* 'See Other' location is not the resource but a substitute for the
 1757|       |     * resource. In this case we switch the method to GET/HEAD, unless the
 1758|       |     * method is POST and the user specified to keep it as POST.
 1759|       |     * https://github.com/curl/curl/issues/5237#issuecomment-614641049
 1760|       |     */
 1761|      4|    if(data->state.httpreq != HTTPREQ_GET &&
 1762|      4|       ((data->state.httpreq != HTTPREQ_POST &&
 1763|      3|         data->state.httpreq != HTTPREQ_POST_FORM &&
 1764|      3|         data->state.httpreq != HTTPREQ_POST_MIME) ||
 1765|      3|        !(data->set.keep_post & CURL_REDIR_POST_303))) {
 1766|      3|      data->state.httpreq = HTTPREQ_GET;
 1767|      3|      data->set.upload = false;
 1768|      3|      infof(data, "Switch to %s",
 1769|      3|            data->set.opt_no_body?"HEAD":"GET");
 1770|      3|    }
 1771|      4|    break;
 1772|      0|  case 304: /* Not Modified */
 1773|       |    /* 304 means we did a conditional request and it was "Not modified".
 1774|       |     * We shouldn't get any Location: header in this response!
 1775|       |     */
 1776|      0|    break;
 1777|      0|  case 305: /* Use Proxy */
 1778|       |    /* (quote from RFC2616, section 10.3.6):
 1779|       |     * "The requested resource MUST be accessed through the proxy given
 1780|       |     * by the Location field. The Location field gives the URI of the
 1781|       |     * proxy.  The recipient is expected to repeat this single request
 1782|       |     * via the proxy. 305 responses MUST only be generated by origin
 1783|       |     * servers."
 1784|       |     */
 1785|      0|    break;
 1786|    113|  }
 1787|    113|  Curl_pgrsTime(data, TIMER_REDIRECT);
 1788|    113|  Curl_pgrsResetTransferSizes(data);
 1789|       |
 1790|    113|  return CURLE_OK;
 1791|    113|#endif /* CURL_DISABLE_HTTP */
 1792|    113|}
Curl_retry_request:
 1798|  1.22k|{
 1799|  1.22k|  struct connectdata *conn = data->conn;
 1800|  1.22k|  bool retry = FALSE;
 1801|  1.22k|  *url = NULL;
 1802|       |
 1803|       |  /* if we're talking upload, we can't do the checks below, unless the protocol
 1804|       |     is HTTP as when uploading over HTTP we will still get a response */
 1805|  1.22k|  if(data->set.upload &&
 1806|  1.22k|     !(conn->handler->protocol&(PROTO_FAMILY_HTTP|CURLPROTO_RTSP)))
 1807|     50|    return CURLE_OK;
 1808|       |
 1809|  1.17k|  if((data->req.bytecount + data->req.headerbytecount == 0) &&
 1810|  1.17k|      conn->bits.reuse &&
 1811|  1.17k|      (!data->set.opt_no_body
 1812|      0|        || (conn->handler->protocol & PROTO_FAMILY_HTTP)) &&
 1813|  1.17k|      (data->set.rtspreq != RTSPREQ_RECEIVE))
 1814|       |    /* We got no data, we attempted to re-use a connection. For HTTP this
 1815|       |       can be a retry so we try again regardless if we expected a body.
 1816|       |       For other protocols we only try again only if we expected a body.
 1817|       |
 1818|       |       This might happen if the connection was left alive when we were
 1819|       |       done using it before, but that was closed when we wanted to read from
 1820|       |       it again. Bad luck. Retry the same request on a fresh connect! */
 1821|      0|    retry = TRUE;
 1822|  1.17k|  else if(data->state.refused_stream &&
 1823|  1.17k|          (data->req.bytecount + data->req.headerbytecount == 0) ) {
 1824|       |    /* This was sent on a refused stream, safe to rerun. A refused stream
 1825|       |       error can typically only happen on HTTP/2 level if the stream is safe
 1826|       |       to issue again, but the nghttp2 API can deliver the message to other
 1827|       |       streams as well, which is why this adds the check the data counters
 1828|       |       too. */
 1829|      0|    infof(data, "REFUSED_STREAM, retrying a fresh connect");
 1830|      0|    data->state.refused_stream = FALSE; /* clear again */
 1831|      0|    retry = TRUE;
 1832|      0|  }
 1833|  1.17k|  if(retry) {
 1834|      0|#define CONN_MAX_RETRIES 5
 1835|      0|    if(data->state.retrycount++ >= CONN_MAX_RETRIES) {
 1836|      0|      failf(data, "Connection died, tried %d times before giving up",
 1837|      0|            CONN_MAX_RETRIES);
 1838|      0|      data->state.retrycount = 0;
 1839|      0|      return CURLE_SEND_ERROR;
 1840|      0|    }
 1841|      0|    infof(data, "Connection died, retrying a fresh connect (retry count: %d)",
 1842|      0|          data->state.retrycount);
 1843|      0|    *url = strdup(data->state.url);
 1844|      0|    if(!*url)
 1845|      0|      return CURLE_OUT_OF_MEMORY;
 1846|       |
 1847|      0|    connclose(conn, "retry"); /* close this connection */
 1848|      0|    conn->bits.retry = TRUE; /* mark this as a connection we're about
 1849|       |                                to retry. Marking it this way should
 1850|       |                                prevent i.e HTTP transfers to return
 1851|       |                                error just because nothing has been
 1852|       |                                transferred! */
 1853|       |
 1854|       |
 1855|      0|    if(conn->handler->protocol&PROTO_FAMILY_HTTP) {
 1856|      0|      if(data->req.writebytecount) {
 1857|      0|        CURLcode result = Curl_readrewind(data);
 1858|      0|        if(result) {
 1859|      0|          Curl_safefree(*url);
 1860|      0|          return result;
 1861|      0|        }
 1862|      0|      }
 1863|      0|    }
 1864|      0|  }
 1865|  1.17k|  return CURLE_OK;
 1866|  1.17k|}
Curl_setup_transfer:
 1881|  1.61k|{
 1882|  1.61k|  struct SingleRequest *k = &data->req;
 1883|  1.61k|  struct connectdata *conn = data->conn;
 1884|  1.61k|  struct HTTP *http = data->req.p.http;
 1885|  1.61k|  bool httpsending = ((conn->handler->protocol&PROTO_FAMILY_HTTP) &&
 1886|  1.61k|                      (http->sending == HTTPSEND_REQUEST));
 1887|  1.61k|  DEBUGASSERT(conn != NULL);
 1888|  1.61k|  DEBUGASSERT((sockindex <= 1) && (sockindex >= -1));
 1889|       |
 1890|  1.61k|  if(conn->bits.multiplex || conn->httpversion == 20 || httpsending) {
 1891|       |    /* when multiplexing, the read/write sockets need to be the same! */
 1892|      0|    conn->sockfd = sockindex == -1 ?
 1893|      0|      ((writesockindex == -1 ? CURL_SOCKET_BAD : conn->sock[writesockindex])) :
 1894|      0|      conn->sock[sockindex];
 1895|      0|    conn->writesockfd = conn->sockfd;
 1896|      0|    if(httpsending)
 1897|       |      /* special and very HTTP-specific */
 1898|      0|      writesockindex = FIRSTSOCKET;
 1899|      0|  }
 1900|  1.61k|  else {
 1901|  1.61k|    conn->sockfd = sockindex == -1 ?
 1902|  1.48k|      CURL_SOCKET_BAD : conn->sock[sockindex];
 1903|  1.61k|    conn->writesockfd = writesockindex == -1 ?
 1904|  1.38k|      CURL_SOCKET_BAD:conn->sock[writesockindex];
 1905|  1.61k|  }
 1906|  1.61k|  k->getheader = getheader;
 1907|       |
 1908|  1.61k|  k->size = size;
 1909|       |
 1910|       |  /* The code sequence below is placed in this function just because all
 1911|       |     necessary input is not always known in do_complete() as this function may
 1912|       |     be called after that */
 1913|       |
 1914|  1.61k|  if(!k->getheader) {
 1915|    234|    k->header = FALSE;
 1916|    234|    if(size > 0)
 1917|      1|      Curl_pgrsSetDownloadSize(data, size);
 1918|    234|  }
 1919|       |  /* we want header and/or body, if neither then don't do this! */
 1920|  1.61k|  if(k->getheader || !data->set.opt_no_body) {
 1921|       |
 1922|  1.60k|    if(sockindex != -1)
 1923|  1.48k|      k->keepon |= KEEP_RECV;
 1924|       |
 1925|  1.60k|    if(writesockindex != -1) {
 1926|       |      /* HTTP 1.1 magic:
 1927|       |
 1928|       |         Even if we require a 100-return code before uploading data, we might
 1929|       |         need to write data before that since the REQUEST may not have been
 1930|       |         finished sent off just yet.
 1931|       |
 1932|       |         Thus, we must check if the request has been sent before we set the
 1933|       |         state info where we wait for the 100-return code
 1934|       |      */
 1935|    227|      if((data->state.expect100header) &&
 1936|    227|         (conn->handler->protocol&PROTO_FAMILY_HTTP) &&
 1937|    227|         (http->sending == HTTPSEND_BODY)) {
 1938|       |        /* wait with write until we either got 100-continue or a timeout */
 1939|     15|        k->exp100 = EXP100_AWAITING_CONTINUE;
 1940|     15|        k->start100 = Curl_now();
 1941|       |
 1942|       |        /* Set a timeout for the multi interface. Add the inaccuracy margin so
 1943|       |           that we don't fire slightly too early and get denied to run. */
 1944|     15|        Curl_expire(data, data->set.expect_100_timeout, EXPIRE_100_TIMEOUT);
 1945|     15|      }
 1946|    212|      else {
 1947|    212|        if(data->state.expect100header)
 1948|       |          /* when we've sent off the rest of the headers, we must await a
 1949|       |             100-continue but first finish sending the request */
 1950|      0|          k->exp100 = EXP100_SENDING_REQUEST;
 1951|       |
 1952|       |        /* enable the write bit when we're not waiting for continue */
 1953|    212|        k->keepon |= KEEP_SEND;
 1954|    212|      }
 1955|    227|    } /* if(writesockindex != -1) */
 1956|  1.60k|  } /* if(k->getheader || !data->set.opt_no_body) */
 1957|       |
 1958|  1.61k|}
transfer.c:readwrite_data:
  564|  5.78M|{
  565|  5.78M|  CURLcode result = CURLE_OK;
  566|  5.78M|  ssize_t nread; /* number of bytes read */
  567|  5.78M|  size_t excess = 0; /* excess bytes read */
  568|  5.78M|  bool readmore = FALSE; /* used by RTP to signal for more data */
  569|  5.78M|  int maxloops = 100;
  570|  5.78M|  char *buf = data->state.buffer;
  571|  5.78M|  DEBUGASSERT(buf);
  572|       |
  573|  5.78M|  *done = FALSE;
  574|  5.78M|  *comeback = FALSE;
  575|       |
  576|       |  /* This is where we loop until we have read everything there is to
  577|       |     read or we get a CURLE_AGAIN */
  578|  5.78M|  do {
  579|  5.78M|    bool is_empty_data = FALSE;
  580|  5.78M|    size_t buffersize = data->set.buffer_size;
  581|  5.78M|    size_t bytestoread = buffersize;
  582|  5.78M|#ifdef USE_NGHTTP2
  583|  5.78M|    bool is_http2 = ((conn->handler->protocol & PROTO_FAMILY_HTTP) &&
  584|  5.78M|                     (conn->httpversion == 20));
  585|  5.78M|#endif
  586|       |
  587|  5.78M|    if(
  588|  5.78M|#ifdef USE_NGHTTP2
  589|       |       /* For HTTP/2, read data without caring about the content
  590|       |          length. This is safe because body in HTTP/2 is always
  591|       |          segmented thanks to its framing layer. Meanwhile, we have to
  592|       |          call Curl_read to ensure that http2_handle_stream_close is
  593|       |          called when we read all incoming bytes for a particular
  594|       |          stream. */
  595|  5.78M|       !is_http2 &&
  596|  5.78M|#endif
  597|  5.78M|       k->size != -1 && !k->header) {
  598|       |      /* make sure we don't read too much */
  599|     69|      curl_off_t totalleft = k->size - k->bytecount;
  600|     69|      if(totalleft < (curl_off_t)bytestoread)
  601|     67|        bytestoread = (size_t)totalleft;
  602|     69|    }
  603|       |
  604|  5.78M|    if(bytestoread) {
  605|       |      /* receive data from the network! */
  606|  5.78M|      result = Curl_read(data, conn->sockfd, buf, bytestoread, &nread);
  607|       |
  608|       |      /* read would've blocked */
  609|  5.78M|      if(CURLE_AGAIN == result)
  610|      1|        break; /* get out of loop */
  611|       |
  612|  5.78M|      if(result>0)
  613|      0|        return result;
  614|  5.78M|    }
  615|      5|    else {
  616|       |      /* read nothing but since we wanted nothing we consider this an OK
  617|       |         situation to proceed from */
  618|      5|      DEBUGF(infof(data, "readwrite_data: we're done!"));
  619|      5|      nread = 0;
  620|      5|    }
  621|       |
  622|  5.78M|    if(!k->bytecount) {
  623|  5.78M|      Curl_pgrsTime(data, TIMER_STARTTRANSFER);
  624|  5.78M|      if(k->exp100 > EXP100_SEND_DATA)
  625|       |        /* set time stamp to compare with when waiting for the 100 */
  626|    117|        k->start100 = Curl_now();
  627|  5.78M|    }
  628|       |
  629|  5.78M|    *didwhat |= KEEP_RECV;
  630|       |    /* indicates data of zero size, i.e. empty file */
  631|  5.78M|    is_empty_data = ((nread == 0) && (k->bodywrites == 0)) ? TRUE : FALSE;
  632|       |
  633|  5.78M|    if(0 < nread || is_empty_data) {
  634|  5.78M|      buf[nread] = 0;
  635|  5.78M|    }
  636|    196|    else {
  637|       |      /* if we receive 0 or less here, either the http2 stream is closed or the
  638|       |         server closed the connection and we bail out from this! */
  639|    196|#ifdef USE_NGHTTP2
  640|    196|      if(is_http2 && !nread)
  641|     12|        DEBUGF(infof(data, "nread == 0, stream closed, bailing"));
  642|    184|      else
  643|    184|#endif
  644|    184|        DEBUGF(infof(data, "nread <= 0, server closed connection, bailing"));
  645|    196|      k->keepon &= ~KEEP_RECV;
  646|    196|      break;
  647|    196|    }
  648|       |
  649|       |    /* Default buffer to use when we write the buffer, it may be changed
  650|       |       in the flow below before the actual storing is done. */
  651|  5.78M|    k->str = buf;
  652|       |
  653|  5.78M|    if(conn->handler->readwrite) {
  654|  5.77M|      result = conn->handler->readwrite(data, conn, &nread, &readmore);
  655|  5.77M|      if(result)
  656|      0|        return result;
  657|  5.77M|      if(readmore)
  658|  5.77M|        break;
  659|  5.77M|    }
  660|       |
  661|  4.27k|#ifndef CURL_DISABLE_HTTP
  662|       |    /* Since this is a two-state thing, we check if we are parsing
  663|       |       headers at the moment or not. */
  664|  4.27k|    if(k->header) {
  665|       |      /* we are in parse-the-header-mode */
  666|  4.13k|      bool stop_reading = FALSE;
  667|  4.13k|      result = Curl_http_readwrite_headers(data, conn, &nread, &stop_reading);
  668|  4.13k|      if(result)
  669|     85|        return result;
  670|       |
  671|  4.05k|      if(conn->handler->readwrite &&
  672|  4.05k|         (k->maxdownload <= 0 && nread > 0)) {
  673|     55|        result = conn->handler->readwrite(data, conn, &nread, &readmore);
  674|     55|        if(result)
  675|      0|          return result;
  676|     55|        if(readmore)
  677|     49|          break;
  678|     55|      }
  679|       |
  680|  4.00k|      if(stop_reading) {
  681|       |        /* We've stopped dealing with input, get out of the do-while loop */
  682|       |
  683|     50|        if(nread > 0) {
  684|     40|          infof(data,
  685|     40|                "Excess found:"
  686|     40|                " excess = %zd"
  687|     40|                " url = %s (zero-length body)",
  688|     40|                nread, data->state.up.path);
  689|     40|        }
  690|       |
  691|     50|        break;
  692|     50|      }
  693|  4.00k|    }
  694|  4.09k|#endif /* CURL_DISABLE_HTTP */
  695|       |
  696|       |
  697|       |    /* This is not an 'else if' since it may be a rest from the header
  698|       |       parsing, where the beginning of the buffer is headers and the end
  699|       |       is non-headers. */
  700|  4.09k|    if(!k->header && (nread > 0 || is_empty_data)) {
  701|       |
  702|    532|      if(data->set.opt_no_body) {
  703|       |        /* data arrives although we want none, bail out */
  704|      1|        streamclose(conn, "ignoring body");
  705|      1|        *done = TRUE;
  706|      1|        return CURLE_WEIRD_SERVER_REPLY;
  707|      1|      }
  708|       |
  709|    531|#ifndef CURL_DISABLE_HTTP
  710|    531|      if(0 == k->bodywrites && !is_empty_data) {
  711|       |        /* These checks are only made the first time we are about to
  712|       |           write a piece of the body */
  713|    395|        if(conn->handler->protocol&(PROTO_FAMILY_HTTP|CURLPROTO_RTSP)) {
  714|       |          /* HTTP-only checks */
  715|    391|          result = Curl_http_firstwrite(data, conn, done);
  716|    391|          if(result || *done)
  717|     32|            return result;
  718|    391|        }
  719|    395|      } /* this is the first time we write a body part */
  720|    499|#endif /* CURL_DISABLE_HTTP */
  721|       |
  722|    499|      k->bodywrites++;
  723|       |
  724|       |      /* pass data to the debug function before it gets "dechunked" */
  725|    499|      if(data->set.verbose) {
  726|      0|        if(k->badheader) {
  727|      0|          Curl_debug(data, CURLINFO_DATA_IN,
  728|      0|                     Curl_dyn_ptr(&data->state.headerb),
  729|      0|                     Curl_dyn_len(&data->state.headerb));
  730|      0|          if(k->badheader == HEADER_PARTHEADER)
  731|      0|            Curl_debug(data, CURLINFO_DATA_IN,
  732|      0|                       k->str, (size_t)nread);
  733|      0|        }
  734|      0|        else
  735|      0|          Curl_debug(data, CURLINFO_DATA_IN,
  736|      0|                     k->str, (size_t)nread);
  737|      0|      }
  738|       |
  739|    499|#ifndef CURL_DISABLE_HTTP
  740|    499|      if(k->chunk) {
  741|       |        /*
  742|       |         * Here comes a chunked transfer flying and we need to decode this
  743|       |         * properly.  While the name says read, this function both reads
  744|       |         * and writes away the data. The returned 'nread' holds the number
  745|       |         * of actual data it wrote to the client.
  746|       |         */
  747|     16|        CURLcode extra;
  748|     16|        CHUNKcode res =
  749|     16|          Curl_httpchunk_read(data, k->str, nread, &nread, &extra);
  750|       |
  751|     16|        if(CHUNKE_OK < res) {
  752|     10|          if(CHUNKE_PASSTHRU_ERROR == res) {
  753|      3|            failf(data, "Failed reading the chunked-encoded stream");
  754|      3|            return extra;
  755|      3|          }
  756|      7|          failf(data, "%s in chunked-encoding", Curl_chunked_strerror(res));
  757|      7|          return CURLE_RECV_ERROR;
  758|     10|        }
  759|      6|        if(CHUNKE_STOP == res) {
  760|       |          /* we're done reading chunks! */
  761|      0|          k->keepon &= ~KEEP_RECV; /* read no more */
  762|       |
  763|       |          /* N number of bytes at the end of the str buffer that weren't
  764|       |             written to the client. */
  765|      0|          if(conn->chunk.datasize) {
  766|      0|            infof(data, "Leftovers after chunking: % "
  767|      0|                  CURL_FORMAT_CURL_OFF_T "u bytes",
  768|      0|                  conn->chunk.datasize);
  769|      0|          }
  770|      0|        }
  771|       |        /* If it returned OK, we just keep going */
  772|      6|      }
  773|    489|#endif   /* CURL_DISABLE_HTTP */
  774|       |
  775|       |      /* Account for body content stored in the header buffer */
  776|    489|      if((k->badheader == HEADER_PARTHEADER) && !k->ignorebody) {
  777|      0|        size_t headlen = Curl_dyn_len(&data->state.headerb);
  778|      0|        DEBUGF(infof(data, "Increasing bytecount by %zu", headlen));
  779|      0|        k->bytecount += headlen;
  780|      0|      }
  781|       |
  782|    489|      if((-1 != k->maxdownload) &&
  783|    489|         (k->bytecount + nread >= k->maxdownload)) {
  784|       |
  785|    126|        excess = (size_t)(k->bytecount + nread - k->maxdownload);
  786|    126|        if(excess > 0 && !k->ignorebody) {
  787|     73|          infof(data,
  788|     73|                "Excess found in a read:"
  789|     73|                " excess = %zu"
  790|     73|                ", size = %" CURL_FORMAT_CURL_OFF_T
  791|     73|                ", maxdownload = %" CURL_FORMAT_CURL_OFF_T
  792|     73|                ", bytecount = %" CURL_FORMAT_CURL_OFF_T,
  793|     73|                excess, k->size, k->maxdownload, k->bytecount);
  794|     73|          connclose(conn, "excess found in a read");
  795|     73|        }
  796|       |
  797|    126|        nread = (ssize_t) (k->maxdownload - k->bytecount);
  798|    126|        if(nread < 0) /* this should be unusual */
  799|      0|          nread = 0;
  800|       |
  801|    126|        k->keepon &= ~KEEP_RECV; /* we're done reading */
  802|    126|      }
  803|       |
  804|    489|      k->bytecount += nread;
  805|       |
  806|    489|      Curl_pgrsSetDownloadCounter(data, k->bytecount);
  807|       |
  808|    489|      if(!k->chunk && (nread || k->badheader || is_empty_data)) {
  809|       |        /* If this is chunky transfer, it was already written */
  810|       |
  811|    482|        if(k->badheader && !k->ignorebody) {
  812|       |          /* we parsed a piece of data wrongly assuming it was a header
  813|       |             and now we output it as body instead */
  814|      0|          size_t headlen = Curl_dyn_len(&data->state.headerb);
  815|       |
  816|       |          /* Don't let excess data pollute body writes */
  817|      0|          if(k->maxdownload == -1 || (curl_off_t)headlen <= k->maxdownload)
  818|      0|            result = Curl_client_write(data, CLIENTWRITE_BODY,
  819|      0|                                       Curl_dyn_ptr(&data->state.headerb),
  820|      0|                                       headlen);
  821|      0|          else
  822|      0|            result = Curl_client_write(data, CLIENTWRITE_BODY,
  823|      0|                                       Curl_dyn_ptr(&data->state.headerb),
  824|      0|                                       (size_t)k->maxdownload);
  825|       |
  826|      0|          if(result)
  827|      0|            return result;
  828|      0|        }
  829|    482|        if(k->badheader < HEADER_ALLBAD) {
  830|       |          /* This switch handles various content encodings. If there's an
  831|       |             error here, be sure to check over the almost identical code
  832|       |             in http_chunks.c.
  833|       |             Make sure that ALL_CONTENT_ENCODINGS contains all the
  834|       |             encodings handled here. */
  835|    482|          if(data->set.http_ce_skip || !k->writer_stack) {
  836|    360|            if(!k->ignorebody && nread) {
  837|    201|#ifndef CURL_DISABLE_POP3
  838|    201|              if(conn->handler->protocol & PROTO_FAMILY_POP3)
  839|      3|                result = Curl_pop3_write(data, k->str, nread);
  840|    198|              else
  841|    198|#endif /* CURL_DISABLE_POP3 */
  842|    198|                result = Curl_client_write(data, CLIENTWRITE_BODY, k->str,
  843|    198|                                           nread);
  844|    201|            }
  845|    360|          }
  846|    122|          else if(!k->ignorebody && nread)
  847|    120|            result = Curl_unencode_write(data, k->writer_stack, k->str, nread);
  848|    482|        }
  849|    482|        k->badheader = HEADER_NORMAL; /* taken care of now */
  850|       |
  851|    482|        if(result)
  852|     76|          return result;
  853|    482|      }
  854|       |
  855|    489|    } /* if(!header and data to read) */
  856|       |
  857|  3.97k|    if(conn->handler->readwrite && excess) {
  858|       |      /* Parse the excess data */
  859|      0|      k->str += nread;
  860|       |
  861|      0|      if(&k->str[excess] > &buf[data->set.buffer_size]) {
  862|       |        /* the excess amount was too excessive(!), make sure
  863|       |           it doesn't read out of buffer */
  864|      0|        excess = &buf[data->set.buffer_size] - k->str;
  865|      0|      }
  866|      0|      nread = (ssize_t)excess;
  867|       |
  868|      0|      result = conn->handler->readwrite(data, conn, &nread, &readmore);
  869|      0|      if(result)
  870|      0|        return result;
  871|       |
  872|      0|      if(readmore)
  873|      0|        k->keepon |= KEEP_RECV; /* we're not done reading */
  874|      0|      break;
  875|      0|    }
  876|       |
  877|  3.97k|    if(is_empty_data) {
  878|       |      /* if we received nothing, the server closed the connection and we
  879|       |         are done */
  880|  3.29k|      k->keepon &= ~KEEP_RECV;
  881|  3.29k|    }
  882|       |
  883|  3.97k|    if(k->keepon & KEEP_RECV_PAUSE) {
  884|       |      /* this is a paused transfer */
  885|      0|      break;
  886|      0|    }
  887|       |
  888|  3.97k|  } while(data_pending(data) && maxloops--);
  889|       |
  890|  5.78M|  if(maxloops <= 0) {
  891|       |    /* we mark it as read-again-please */
  892|     25|    conn->cselect_bits = CURL_CSELECT_IN;
  893|     25|    *comeback = TRUE;
  894|     25|  }
  895|       |
  896|  5.78M|  if(((k->keepon & (KEEP_RECV|KEEP_SEND)) == KEEP_SEND) &&
  897|  5.78M|     conn->bits.close) {
  898|       |    /* When we've read the entire thing and the close bit is set, the server
  899|       |       may now close the connection. If there's now any kind of sending going
  900|       |       on from our side, we need to stop that immediately. */
  901|      1|    infof(data, "we are done reading and this is set to close, stop send");
  902|      1|    k->keepon &= ~KEEP_SEND; /* no writing anymore either */
  903|      1|  }
  904|       |
  905|  5.78M|  return CURLE_OK;
  906|  5.78M|}
transfer.c:data_pending:
  492|  3.97k|{
  493|  3.97k|  struct connectdata *conn = data->conn;
  494|       |
  495|       |#ifdef ENABLE_QUIC
  496|       |  if(conn->transport == TRNSPRT_QUIC)
  497|       |    return Curl_quic_data_pending(data);
  498|       |#endif
  499|       |
  500|  3.97k|  if(conn->handler->protocol&PROTO_FAMILY_FTP)
  501|      0|    return Curl_ssl_data_pending(conn, SECONDARYSOCKET);
  502|       |
  503|       |  /* in the case of libssh2, we can never be really sure that we have emptied
  504|       |     its internal buffers so we MUST always try until we get EAGAIN back */
  505|  3.97k|  return conn->handler->protocol&(CURLPROTO_SCP|CURLPROTO_SFTP) ||
  506|  3.97k|#if defined(USE_NGHTTP2)
  507|       |    /* For HTTP/2, we may read up everything including response body
  508|       |       with header fields in Curl_http_readwrite_headers. If no
  509|       |       content-length is provided, curl waits for the connection
  510|       |       close, which we emulate it using conn->proto.httpc.closed =
  511|       |       TRUE. The thing is if we read everything, then http2_recv won't
  512|       |       be called and we cannot signal the HTTP/2 stream has closed. As
  513|       |       a workaround, we return nonzero here to call http2_recv. */
  514|  3.97k|    ((conn->handler->protocol&PROTO_FAMILY_HTTP) && conn->httpversion >= 20) ||
  515|  3.97k|#endif
  516|  3.97k|    Curl_ssl_data_pending(conn, FIRSTSOCKET);
  517|  3.97k|}
transfer.c:readwrite_upload:
  953|    211|{
  954|    211|  ssize_t i, si;
  955|    211|  ssize_t bytes_written;
  956|    211|  CURLcode result;
  957|    211|  ssize_t nread; /* number of bytes read */
  958|    211|  bool sending_http_headers = FALSE;
  959|    211|  struct SingleRequest *k = &data->req;
  960|       |
  961|    211|  if((k->bytecount == 0) && (k->writebytecount == 0))
  962|    176|    Curl_pgrsTime(data, TIMER_STARTTRANSFER);
  963|       |
  964|    211|  *didwhat |= KEEP_SEND;
  965|       |
  966|    211|  do {
  967|    211|    curl_off_t nbody;
  968|       |
  969|       |    /* only read more data if there's no upload data already
  970|       |       present in the upload buffer */
  971|    211|    if(0 == k->upload_present) {
  972|    211|      result = Curl_get_upload_buffer(data);
  973|    211|      if(result)
  974|      0|        return result;
  975|       |      /* init the "upload from here" pointer */
  976|    211|      k->upload_fromhere = data->state.ulbuf;
  977|       |
  978|    211|      if(!k->upload_done) {
  979|       |        /* HTTP pollution, this should be written nicer to become more
  980|       |           protocol agnostic. */
  981|    211|        size_t fillcount;
  982|    211|        struct HTTP *http = k->p.http;
  983|       |
  984|    211|        if((k->exp100 == EXP100_SENDING_REQUEST) &&
  985|    211|           (http->sending == HTTPSEND_BODY)) {
  986|       |          /* If this call is to send body data, we must take some action:
  987|       |             We have sent off the full HTTP 1.1 request, and we shall now
  988|       |             go into the Expect: 100 state and await such a header */
  989|      0|          k->exp100 = EXP100_AWAITING_CONTINUE; /* wait for the header */
  990|      0|          k->keepon &= ~KEEP_SEND;         /* disable writing */
  991|      0|          k->start100 = Curl_now();       /* timeout count starts now */
  992|      0|          *didwhat &= ~KEEP_SEND;  /* we didn't write anything actually */
  993|       |          /* set a timeout for the multi interface */
  994|      0|          Curl_expire(data, data->set.expect_100_timeout, EXPIRE_100_TIMEOUT);
  995|      0|          break;
  996|      0|        }
  997|       |
  998|    211|        if(conn->handler->protocol&(PROTO_FAMILY_HTTP|CURLPROTO_RTSP)) {
  999|    106|          if(http->sending == HTTPSEND_REQUEST)
 1000|       |            /* We're sending the HTTP request headers, not the data.
 1001|       |               Remember that so we don't change the line endings. */
 1002|      0|            sending_http_headers = TRUE;
 1003|    106|          else
 1004|    106|            sending_http_headers = FALSE;
 1005|    106|        }
 1006|       |
 1007|    211|        result = Curl_fillreadbuffer(data, data->set.upload_buffer_size,
 1008|    211|                                     &fillcount);
 1009|    211|        if(result)
 1010|      1|          return result;
 1011|       |
 1012|    210|        nread = fillcount;
 1013|    210|      }
 1014|      0|      else
 1015|      0|        nread = 0; /* we're done uploading/reading */
 1016|       |
 1017|    210|      if(!nread && (k->keepon & KEEP_SEND_PAUSE)) {
 1018|       |        /* this is a paused transfer */
 1019|      0|        break;
 1020|      0|      }
 1021|    210|      if(nread <= 0) {
 1022|     22|        result = Curl_done_sending(data, k);
 1023|     22|        if(result)
 1024|      0|          return result;
 1025|     22|        break;
 1026|     22|      }
 1027|       |
 1028|       |      /* store number of bytes available for upload */
 1029|    188|      k->upload_present = nread;
 1030|       |
 1031|       |      /* convert LF to CRLF if so asked */
 1032|    188|      if((!sending_http_headers) && (
 1033|    188|#ifdef CURL_DO_LINEEND_CONV
 1034|       |         /* always convert if we're FTPing in ASCII mode */
 1035|    188|         (data->state.prefer_ascii) ||
 1036|    188|#endif
 1037|    188|         (data->set.crlf))) {
 1038|       |        /* Do we need to allocate a scratch buffer? */
 1039|      0|        if(!data->state.scratch) {
 1040|      0|          data->state.scratch = malloc(2 * data->set.upload_buffer_size);
 1041|      0|          if(!data->state.scratch) {
 1042|      0|            failf(data, "Failed to alloc scratch buffer!");
 1043|       |
 1044|      0|            return CURLE_OUT_OF_MEMORY;
 1045|      0|          }
 1046|      0|        }
 1047|       |
 1048|       |        /*
 1049|       |         * ASCII/EBCDIC Note: This is presumably a text (not binary)
 1050|       |         * transfer so the data should already be in ASCII.
 1051|       |         * That means the hex values for ASCII CR (0x0d) & LF (0x0a)
 1052|       |         * must be used instead of the escape sequences \r & \n.
 1053|       |         */
 1054|      0|        for(i = 0, si = 0; i < nread; i++, si++) {
 1055|      0|          if(k->upload_fromhere[i] == 0x0a) {
 1056|      0|            data->state.scratch[si++] = 0x0d;
 1057|      0|            data->state.scratch[si] = 0x0a;
 1058|      0|            if(!data->set.crlf) {
 1059|       |              /* we're here only because FTP is in ASCII mode...
 1060|       |                 bump infilesize for the LF we just added */
 1061|      0|              if(data->state.infilesize != -1)
 1062|      0|                data->state.infilesize++;
 1063|      0|            }
 1064|      0|          }
 1065|      0|          else
 1066|      0|            data->state.scratch[si] = k->upload_fromhere[i];
 1067|      0|        }
 1068|       |
 1069|      0|        if(si != nread) {
 1070|       |          /* only perform the special operation if we really did replace
 1071|       |             anything */
 1072|      0|          nread = si;
 1073|       |
 1074|       |          /* upload from the new (replaced) buffer instead */
 1075|      0|          k->upload_fromhere = data->state.scratch;
 1076|       |
 1077|       |          /* set the new amount too */
 1078|      0|          k->upload_present = nread;
 1079|      0|        }
 1080|      0|      }
 1081|       |
 1082|    188|#ifndef CURL_DISABLE_SMTP
 1083|    188|      if(conn->handler->protocol & PROTO_FAMILY_SMTP) {
 1084|     51|        result = Curl_smtp_escape_eob(data, nread);
 1085|     51|        if(result)
 1086|      0|          return result;
 1087|     51|      }
 1088|    188|#endif /* CURL_DISABLE_SMTP */
 1089|    188|    } /* if 0 == k->upload_present */
 1090|      0|    else {
 1091|       |      /* We have a partial buffer left from a previous "round". Use
 1092|       |         that instead of reading more data */
 1093|      0|    }
 1094|       |
 1095|       |    /* write to socket (send away data) */
 1096|    188|    result = Curl_write(data,
 1097|    188|                        conn->writesockfd,  /* socket to send to */
 1098|    188|                        k->upload_fromhere, /* buffer pointer */
 1099|    188|                        k->upload_present,  /* buffer size */
 1100|    188|                        &bytes_written);    /* actually sent */
 1101|    188|    if(result)
 1102|      0|      return result;
 1103|       |
 1104|    188|    win_update_buffer_size(conn->writesockfd);
 1105|       |
 1106|    188|    if(k->pendingheader) {
 1107|       |      /* parts of what was sent was header */
 1108|      0|      curl_off_t n = CURLMIN(k->pendingheader, bytes_written);
 1109|       |      /* show the data before we change the pointer upload_fromhere */
 1110|      0|      Curl_debug(data, CURLINFO_HEADER_OUT, k->upload_fromhere, (size_t)n);
 1111|      0|      k->pendingheader -= n;
 1112|      0|      nbody = bytes_written - n; /* size of the written body part */
 1113|      0|    }
 1114|    188|    else
 1115|    188|      nbody = bytes_written;
 1116|       |
 1117|    188|    if(nbody) {
 1118|       |      /* show the data before we change the pointer upload_fromhere */
 1119|    188|      Curl_debug(data, CURLINFO_DATA_OUT,
 1120|    188|                 &k->upload_fromhere[bytes_written - nbody],
 1121|    188|                 (size_t)nbody);
 1122|       |
 1123|    188|      k->writebytecount += nbody;
 1124|    188|      Curl_pgrsSetUploadCounter(data, k->writebytecount);
 1125|    188|    }
 1126|       |
 1127|    188|    if((!k->upload_chunky || k->forbidchunk) &&
 1128|    188|       (k->writebytecount == data->state.infilesize)) {
 1129|       |      /* we have sent all data we were supposed to */
 1130|    158|      k->upload_done = TRUE;
 1131|    158|      infof(data, "We are completely uploaded and fine");
 1132|    158|    }
 1133|       |
 1134|    188|    if(k->upload_present != bytes_written) {
 1135|       |      /* we only wrote a part of the buffer (if anything), deal with it! */
 1136|       |
 1137|       |      /* store the amount of bytes left in the buffer to write */
 1138|      0|      k->upload_present -= bytes_written;
 1139|       |
 1140|       |      /* advance the pointer where to find the buffer when the next send
 1141|       |         is to happen */
 1142|      0|      k->upload_fromhere += bytes_written;
 1143|      0|    }
 1144|    188|    else {
 1145|       |      /* we've uploaded that buffer now */
 1146|    188|      result = Curl_get_upload_buffer(data);
 1147|    188|      if(result)
 1148|      0|        return result;
 1149|    188|      k->upload_fromhere = data->state.ulbuf;
 1150|    188|      k->upload_present = 0; /* no more bytes left */
 1151|       |
 1152|    188|      if(k->upload_done) {
 1153|    161|        result = Curl_done_sending(data, k);
 1154|    161|        if(result)
 1155|      0|          return result;
 1156|    161|      }
 1157|    188|    }
 1158|       |
 1159|       |
 1160|    188|  } while(0); /* just to break out from! */
 1161|       |
 1162|    210|  return CURLE_OK;
 1163|    211|}

Curl_freeset:
  310|  6.25k|{
  311|       |  /* Free all dynamic strings stored in the data->set substructure. */
  312|  6.25k|  enum dupstring i;
  313|  6.25k|  enum dupblob j;
  314|       |
  315|   512k|  for(i = (enum dupstring)0; i < STRING_LAST; i++) {
  316|   506k|    Curl_safefree(data->set.str[i]);
  317|   506k|  }
  318|       |
  319|  56.2k|  for(j = (enum dupblob)0; j < BLOB_LAST; j++) {
  320|  50.0k|    Curl_safefree(data->set.blobs[j]);
  321|  50.0k|  }
  322|       |
  323|  6.25k|  if(data->state.referer_alloc) {
  324|      0|    Curl_safefree(data->state.referer);
  325|      0|    data->state.referer_alloc = FALSE;
  326|      0|  }
  327|  6.25k|  data->state.referer = NULL;
  328|  6.25k|  if(data->state.url_alloc) {
  329|  2.87k|    Curl_safefree(data->state.url);
  330|  2.87k|    data->state.url_alloc = FALSE;
  331|  2.87k|  }
  332|  6.25k|  data->state.url = NULL;
  333|       |
  334|  6.25k|  Curl_mime_cleanpart(&data->set.mimepost);
  335|  6.25k|}
Curl_close:
  363|  6.25k|{
  364|  6.25k|  struct Curl_multi *m;
  365|  6.25k|  struct Curl_easy *data;
  366|       |
  367|  6.25k|  if(!datap || !*datap)
  368|      0|    return CURLE_OK;
  369|       |
  370|  6.25k|  data = *datap;
  371|  6.25k|  *datap = NULL;
  372|       |
  373|  6.25k|  Curl_expire_clear(data); /* shut off timers */
  374|       |
  375|       |  /* Detach connection if any is left. This should not be normal, but can be
  376|       |     the case for example with CONNECT_ONLY + recv/send (test 556) */
  377|  6.25k|  Curl_detach_connnection(data);
  378|  6.25k|  m = data->multi;
  379|  6.25k|  if(m)
  380|       |    /* This handle is still part of a multi handle, take care of this first
  381|       |       and detach this handle from there. */
  382|      0|    curl_multi_remove_handle(data->multi, data);
  383|       |
  384|  6.25k|  if(data->multi_easy) {
  385|       |    /* when curl_easy_perform() is used, it creates its own multi handle to
  386|       |       use and this is the one */
  387|      0|    curl_multi_cleanup(data->multi_easy);
  388|      0|    data->multi_easy = NULL;
  389|      0|  }
  390|       |
  391|       |  /* Destroy the timeout list that is held in the easy handle. It is
  392|       |     /normally/ done by curl_multi_remove_handle() but this is "just in
  393|       |     case" */
  394|  6.25k|  Curl_llist_destroy(&data->state.timeoutlist, NULL);
  395|       |
  396|  6.25k|  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
  397|       |                      the multi handle, since that function uses the magic
  398|       |                      field! */
  399|       |
  400|  6.25k|  if(data->state.rangestringalloc)
  401|     50|    free(data->state.range);
  402|       |
  403|       |  /* freed here just in case DONE wasn't called */
  404|  6.25k|  Curl_free_request_state(data);
  405|       |
  406|       |  /* Close down all open SSL info and sessions */
  407|  6.25k|  Curl_ssl_close_all(data);
  408|  6.25k|  Curl_safefree(data->state.first_host);
  409|  6.25k|  Curl_safefree(data->state.scratch);
  410|  6.25k|  Curl_ssl_free_certinfo(data);
  411|       |
  412|       |  /* Cleanup possible redirect junk */
  413|  6.25k|  free(data->req.newurl);
  414|  6.25k|  data->req.newurl = NULL;
  415|       |
  416|  6.25k|  if(data->state.referer_alloc) {
  417|      0|    Curl_safefree(data->state.referer);
  418|      0|    data->state.referer_alloc = FALSE;
  419|      0|  }
  420|  6.25k|  data->state.referer = NULL;
  421|       |
  422|  6.25k|  up_free(data);
  423|  6.25k|  Curl_safefree(data->state.buffer);
  424|  6.25k|  Curl_dyn_free(&data->state.headerb);
  425|  6.25k|  Curl_safefree(data->state.ulbuf);
  426|  6.25k|  Curl_flush_cookies(data, TRUE);
  427|  6.25k|  Curl_altsvc_save(data, data->asi, data->set.str[STRING_ALTSVC]);
  428|  6.25k|  Curl_altsvc_cleanup(&data->asi);
  429|  6.25k|  Curl_hsts_save(data, data->hsts, data->set.str[STRING_HSTS]);
  430|  6.25k|  Curl_hsts_cleanup(&data->hsts);
  431|  6.25k|#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_CRYPTO_AUTH)
  432|  6.25k|  Curl_http_auth_cleanup_digest(data);
  433|  6.25k|#endif
  434|  6.25k|  Curl_safefree(data->info.contenttype);
  435|  6.25k|  Curl_safefree(data->info.wouldredirect);
  436|       |
  437|       |  /* this destroys the channel and we cannot use it anymore after this */
  438|  6.25k|  Curl_resolver_cleanup(data->state.async.resolver);
  439|       |
  440|  6.25k|  Curl_http2_cleanup_dependencies(data);
  441|  6.25k|  Curl_convert_close(data);
  442|       |
  443|       |  /* No longer a dirty share, if it exists */
  444|  6.25k|  if(data->share) {
  445|      0|    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
  446|      0|    data->share->dirty--;
  447|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  448|      0|  }
  449|       |
  450|  6.25k|  Curl_safefree(data->state.aptr.proxyuserpwd);
  451|  6.25k|  Curl_safefree(data->state.aptr.uagent);
  452|  6.25k|  Curl_safefree(data->state.aptr.userpwd);
  453|  6.25k|  Curl_safefree(data->state.aptr.accept_encoding);
  454|  6.25k|  Curl_safefree(data->state.aptr.te);
  455|  6.25k|  Curl_safefree(data->state.aptr.rangeline);
  456|  6.25k|  Curl_safefree(data->state.aptr.ref);
  457|  6.25k|  Curl_safefree(data->state.aptr.host);
  458|  6.25k|  Curl_safefree(data->state.aptr.cookiehost);
  459|  6.25k|  Curl_safefree(data->state.aptr.rtsp_transport);
  460|  6.25k|  Curl_safefree(data->state.aptr.user);
  461|  6.25k|  Curl_safefree(data->state.aptr.passwd);
  462|  6.25k|  Curl_safefree(data->state.aptr.proxyuser);
  463|  6.25k|  Curl_safefree(data->state.aptr.proxypasswd);
  464|       |
  465|  6.25k|#ifndef CURL_DISABLE_DOH
  466|  6.25k|  if(data->req.doh) {
  467|      0|    Curl_dyn_free(&data->req.doh->probe[0].serverdoh);
  468|      0|    Curl_dyn_free(&data->req.doh->probe[1].serverdoh);
  469|      0|    curl_slist_free_all(data->req.doh->headers);
  470|      0|    Curl_safefree(data->req.doh);
  471|      0|  }
  472|  6.25k|#endif
  473|       |
  474|       |  /* destruct wildcard structures if it is needed */
  475|  6.25k|  Curl_wildcard_dtor(&data->wildcard);
  476|  6.25k|  Curl_freeset(data);
  477|  6.25k|  free(data);
  478|  6.25k|  return CURLE_OK;
  479|  6.25k|}
Curl_init_userdefined:
  486|  6.25k|{
  487|  6.25k|  struct UserDefined *set = &data->set;
  488|  6.25k|  CURLcode result = CURLE_OK;
  489|       |
  490|  6.25k|  set->out = stdout; /* default output to stdout */
  491|  6.25k|  set->in_set = stdin;  /* default input from stdin */
  492|  6.25k|  set->err  = stderr;  /* default stderr to stderr */
  493|       |
  494|       |  /* use fwrite as default function to store output */
  495|  6.25k|  set->fwrite_func = (curl_write_callback)fwrite;
  496|       |
  497|       |  /* use fread as default function to read input */
  498|  6.25k|  set->fread_func_set = (curl_read_callback)fread;
  499|  6.25k|  set->is_fread_set = 0;
  500|  6.25k|  set->is_fwrite_set = 0;
  501|       |
  502|  6.25k|  set->seek_func = ZERO_NULL;
  503|  6.25k|  set->seek_client = ZERO_NULL;
  504|       |
  505|       |  /* conversion callbacks for non-ASCII hosts */
  506|  6.25k|  set->convfromnetwork = ZERO_NULL;
  507|  6.25k|  set->convtonetwork   = ZERO_NULL;
  508|  6.25k|  set->convfromutf8    = ZERO_NULL;
  509|       |
  510|  6.25k|  set->filesize = -1;        /* we don't know the size */
  511|  6.25k|  set->postfieldsize = -1;   /* unknown size */
  512|  6.25k|  set->maxredirs = -1;       /* allow any amount by default */
  513|       |
  514|  6.25k|  set->method = HTTPREQ_GET; /* Default HTTP request */
  515|  6.25k|  set->rtspreq = RTSPREQ_OPTIONS; /* Default RTSP request */
  516|  6.25k|#ifndef CURL_DISABLE_FTP
  517|  6.25k|  set->ftp_use_epsv = TRUE;   /* FTP defaults to EPSV operations */
  518|  6.25k|  set->ftp_use_eprt = TRUE;   /* FTP defaults to EPRT operations */
  519|  6.25k|  set->ftp_use_pret = FALSE;  /* mainly useful for drftpd servers */
  520|  6.25k|  set->ftp_filemethod = FTPFILE_MULTICWD;
  521|  6.25k|  set->ftp_skip_ip = TRUE;    /* skip PASV IP by default */
  522|  6.25k|#endif
  523|  6.25k|  set->dns_cache_timeout = 60; /* Timeout every 60 seconds by default */
  524|       |
  525|       |  /* Set the default size of the SSL session ID cache */
  526|  6.25k|  set->general_ssl.max_ssl_sessions = 5;
  527|       |
  528|  6.25k|  set->proxyport = 0;
  529|  6.25k|  set->proxytype = CURLPROXY_HTTP; /* defaults to HTTP proxy */
  530|  6.25k|  set->httpauth = CURLAUTH_BASIC;  /* defaults to basic */
  531|  6.25k|  set->proxyauth = CURLAUTH_BASIC; /* defaults to basic */
  532|       |
  533|       |  /* SOCKS5 proxy auth defaults to username/password + GSS-API */
  534|  6.25k|  set->socks5auth = CURLAUTH_BASIC | CURLAUTH_GSSAPI;
  535|       |
  536|       |  /* make libcurl quiet by default: */
  537|  6.25k|  set->hide_progress = TRUE;  /* CURLOPT_NOPROGRESS changes these */
  538|       |
  539|  6.25k|  Curl_mime_initpart(&set->mimepost, data);
  540|       |
  541|       |  /*
  542|       |   * libcurl 7.10 introduced SSL verification *by default*! This needs to be
  543|       |   * switched off unless wanted.
  544|       |   */
  545|  6.25k|  set->doh_verifyhost = TRUE;
  546|  6.25k|  set->doh_verifypeer = TRUE;
  547|  6.25k|  set->ssl.primary.verifypeer = TRUE;
  548|  6.25k|  set->ssl.primary.verifyhost = TRUE;
  549|  6.25k|#ifdef USE_TLS_SRP
  550|  6.25k|  set->ssl.authtype = CURL_TLSAUTH_NONE;
  551|  6.25k|#endif
  552|  6.25k|  set->ssh_auth_types = CURLSSH_AUTH_DEFAULT; /* defaults to any auth
  553|       |                                                      type */
  554|  6.25k|  set->ssl.primary.sessionid = TRUE; /* session ID caching enabled by
  555|       |                                        default */
  556|  6.25k|#ifndef CURL_DISABLE_PROXY
  557|  6.25k|  set->proxy_ssl = set->ssl;
  558|  6.25k|#endif
  559|       |
  560|  6.25k|  set->new_file_perms = 0644;    /* Default permissions */
  561|  6.25k|  set->new_directory_perms = 0755; /* Default permissions */
  562|       |
  563|       |  /* for the *protocols fields we don't use the CURLPROTO_ALL convenience
  564|       |     define since we internally only use the lower 16 bits for the passed
  565|       |     in bitmask to not conflict with the private bits */
  566|  6.25k|  set->allowed_protocols = CURLPROTO_ALL;
  567|  6.25k|  set->redir_protocols = CURLPROTO_HTTP | CURLPROTO_HTTPS | CURLPROTO_FTP |
  568|  6.25k|                         CURLPROTO_FTPS;
  569|       |
  570|       |#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
  571|       |  /*
  572|       |   * disallow unprotected protection negotiation NEC reference implementation
  573|       |   * seem not to follow rfc1961 section 4.3/4.4
  574|       |   */
  575|       |  set->socks5_gssapi_nec = FALSE;
  576|       |#endif
  577|       |
  578|       |  /* Set the default CA cert bundle/path detected/specified at build time.
  579|       |   *
  580|       |   * If Schannel is the selected SSL backend then these locations are
  581|       |   * ignored. We allow setting CA location for schannel only when explicitly
  582|       |   * specified by the user via CURLOPT_CAINFO / --cacert.
  583|       |   */
  584|  6.25k|  if(Curl_ssl_backend() != CURLSSLBACKEND_SCHANNEL) {
  585|  6.25k|#if defined(CURL_CA_BUNDLE)
  586|  6.25k|    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE], CURL_CA_BUNDLE);
  587|  6.25k|    if(result)
  588|      0|      return result;
  589|       |
  590|  6.25k|    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE_PROXY],
  591|  6.25k|                            CURL_CA_BUNDLE);
  592|  6.25k|    if(result)
  593|      0|      return result;
  594|  6.25k|#endif
  595|       |#if defined(CURL_CA_PATH)
  596|       |    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH], CURL_CA_PATH);
  597|       |    if(result)
  598|       |      return result;
  599|       |
  600|       |    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH_PROXY], CURL_CA_PATH);
  601|       |    if(result)
  602|       |      return result;
  603|       |#endif
  604|  6.25k|  }
  605|       |
  606|  6.25k|  set->wildcard_enabled = FALSE;
  607|  6.25k|  set->chunk_bgn      = ZERO_NULL;
  608|  6.25k|  set->chunk_end      = ZERO_NULL;
  609|  6.25k|  set->tcp_keepalive = FALSE;
  610|  6.25k|  set->tcp_keepintvl = 60;
  611|  6.25k|  set->tcp_keepidle = 60;
  612|  6.25k|  set->tcp_fastopen = FALSE;
  613|  6.25k|  set->tcp_nodelay = TRUE;
  614|  6.25k|  set->ssl_enable_npn = TRUE;
  615|  6.25k|  set->ssl_enable_alpn = TRUE;
  616|  6.25k|  set->expect_100_timeout = 1000L; /* Wait for a second by default. */
  617|  6.25k|  set->sep_headers = TRUE; /* separated header lists by default */
  618|  6.25k|  set->buffer_size = READBUFFER_SIZE;
  619|  6.25k|  set->upload_buffer_size = UPLOADBUFFER_DEFAULT;
  620|  6.25k|  set->happy_eyeballs_timeout = CURL_HET_DEFAULT;
  621|  6.25k|  set->fnmatch = ZERO_NULL;
  622|  6.25k|  set->upkeep_interval_ms = CURL_UPKEEP_INTERVAL_DEFAULT;
  623|  6.25k|  set->maxconnects = DEFAULT_CONNCACHE_SIZE; /* for easy handles */
  624|  6.25k|  set->maxage_conn = 118;
  625|  6.25k|  set->maxlifetime_conn = 0;
  626|  6.25k|  set->http09_allowed = FALSE;
  627|  6.25k|  set->httpwant =
  628|  6.25k|#ifdef USE_NGHTTP2
  629|  6.25k|    CURL_HTTP_VERSION_2TLS
  630|       |#else
  631|       |    CURL_HTTP_VERSION_1_1
  632|       |#endif
  633|  6.25k|    ;
  634|  6.25k|  Curl_http2_init_userset(set);
  635|  6.25k|  return result;
  636|  6.25k|}
Curl_open:
  647|  6.25k|{
  648|  6.25k|  CURLcode result;
  649|  6.25k|  struct Curl_easy *data;
  650|       |
  651|       |  /* Very simple start-up: alloc the struct, init it with zeroes and return */
  652|  6.25k|  data = calloc(1, sizeof(struct Curl_easy));
  653|  6.25k|  if(!data) {
  654|       |    /* this is a very serious error */
  655|      0|    DEBUGF(fprintf(stderr, "Error: calloc of Curl_easy failed\n"));
  656|      0|    return CURLE_OUT_OF_MEMORY;
  657|      0|  }
  658|       |
  659|  6.25k|  data->magic = CURLEASY_MAGIC_NUMBER;
  660|       |
  661|  6.25k|  result = Curl_resolver_init(data, &data->state.async.resolver);
  662|  6.25k|  if(result) {
  663|      0|    DEBUGF(fprintf(stderr, "Error: resolver_init failed\n"));
  664|      0|    free(data);
  665|      0|    return result;
  666|      0|  }
  667|       |
  668|  6.25k|  result = Curl_init_userdefined(data);
  669|  6.25k|  if(!result) {
  670|  6.25k|    Curl_dyn_init(&data->state.headerb, CURL_MAX_HTTP_HEADER);
  671|  6.25k|    Curl_convert_init(data);
  672|  6.25k|    Curl_initinfo(data);
  673|       |
  674|       |    /* most recent connection is not yet defined */
  675|  6.25k|    data->state.lastconnect_id = -1;
  676|       |
  677|  6.25k|    data->progress.flags |= PGRS_HIDE;
  678|  6.25k|    data->state.current_speed = -1; /* init to negative == impossible */
  679|  6.25k|  }
  680|       |
  681|  6.25k|  if(result) {
  682|      0|    Curl_resolver_cleanup(data->state.async.resolver);
  683|      0|    Curl_dyn_free(&data->state.headerb);
  684|      0|    Curl_freeset(data);
  685|      0|    free(data);
  686|      0|    data = NULL;
  687|      0|  }
  688|  6.25k|  else
  689|  6.25k|    *curl = data;
  690|       |
  691|  6.25k|  return result;
  692|  6.25k|}
Curl_disconnect:
  826|  3.05k|{
  827|       |  /* there must be a connection to close */
  828|  3.05k|  DEBUGASSERT(conn);
  829|       |
  830|       |  /* it must be removed from the connection cache */
  831|  3.05k|  DEBUGASSERT(!conn->bundle);
  832|       |
  833|       |  /* there must be an associated transfer */
  834|  3.05k|  DEBUGASSERT(data);
  835|       |
  836|       |  /* the transfer must be detached from the connection */
  837|  3.05k|  DEBUGASSERT(!data->conn);
  838|       |
  839|       |  /*
  840|       |   * If this connection isn't marked to force-close, leave it open if there
  841|       |   * are other users of it
  842|       |   */
  843|  3.05k|  if(CONN_INUSE(conn) && !dead_connection) {
  844|      0|    DEBUGF(infof(data, "Curl_disconnect when inuse: %zu", CONN_INUSE(conn)));
  845|      0|    return CURLE_OK;
  846|      0|  }
  847|       |
  848|  3.05k|  if(conn->dns_entry != NULL) {
  849|      9|    Curl_resolv_unlock(data, conn->dns_entry);
  850|      9|    conn->dns_entry = NULL;
  851|      9|  }
  852|       |
  853|       |  /* Cleanup NTLM connection-related data */
  854|  3.05k|  Curl_http_auth_cleanup_ntlm(conn);
  855|       |
  856|       |  /* Cleanup NEGOTIATE connection-related data */
  857|  3.05k|  Curl_http_auth_cleanup_negotiate(conn);
  858|       |
  859|  3.05k|  if(conn->bits.connect_only)
  860|       |    /* treat the connection as dead in CONNECT_ONLY situations */
  861|      0|    dead_connection = TRUE;
  862|       |
  863|       |  /* temporarily attach the connection to this transfer handle for the
  864|       |     disconnect and shutdown */
  865|  3.05k|  Curl_attach_connnection(data, conn);
  866|       |
  867|  3.05k|  if(conn->handler->disconnect)
  868|       |    /* This is set if protocol-specific cleanups should be made */
  869|  1.69k|    conn->handler->disconnect(data, conn, dead_connection);
  870|       |
  871|  3.05k|  conn_shutdown(data, conn);
  872|       |
  873|       |  /* detach it again */
  874|  3.05k|  Curl_detach_connnection(data);
  875|       |
  876|  3.05k|  conn_free(conn);
  877|  3.05k|  return CURLE_OK;
  878|  3.05k|}
Curl_verboseconnect:
 1538|  2.92k|{
 1539|  2.92k|  if(data->set.verbose)
 1540|      0|    infof(data, "Connected to %s (%s) port %u (#%ld)",
 1541|      0|#ifndef CURL_DISABLE_PROXY
 1542|      0|          conn->bits.socksproxy ? conn->socks_proxy.host.dispname :
 1543|      0|          conn->bits.httpproxy ? conn->http_proxy.host.dispname :
 1544|      0|#endif
 1545|      0|          conn->bits.conn_to_host ? conn->conn_to_host.dispname :
 1546|      0|          conn->host.dispname,
 1547|      0|          conn->primary_ip, conn->port, conn->connection_id);
 1548|  2.92k|}
Curl_is_ASCII_name:
 1555|  6.07k|{
 1556|       |  /* get an UNSIGNED local version of the pointer */
 1557|  6.07k|  const unsigned char *ch = (const unsigned char *)hostname;
 1558|       |
 1559|  6.07k|  if(!hostname) /* bad input, consider it ASCII! */
 1560|      1|    return TRUE;
 1561|       |
 1562|  63.1k|  while(*ch) {
 1563|  57.2k|    if(*ch++ & 0x80)
 1564|    193|      return FALSE;
 1565|  57.2k|  }
 1566|  5.87k|  return TRUE;
 1567|  6.07k|}
Curl_idnconvert_hostname:
 1588|  6.05k|{
 1589|  6.05k|#ifndef USE_LIBIDN2
 1590|  6.05k|  (void)data;
 1591|  6.05k|  (void)data;
 1592|       |#elif defined(CURL_DISABLE_VERBOSE_STRINGS)
 1593|       |  (void)data;
 1594|       |#endif
 1595|       |
 1596|       |  /* set the name we use to display the host name */
 1597|  6.05k|  host->dispname = host->name;
 1598|       |
 1599|       |  /* Check name for non-ASCII and convert hostname to ACE form if we can */
 1600|  6.05k|  if(!Curl_is_ASCII_name(host->name)) {
 1601|       |#ifdef USE_LIBIDN2
 1602|       |    if(idn2_check_version(IDN2_VERSION)) {
 1603|       |      char *ace_hostname = NULL;
 1604|       |#if IDN2_VERSION_NUMBER >= 0x00140000
 1605|       |      /* IDN2_NFC_INPUT: Normalize input string using normalization form C.
 1606|       |         IDN2_NONTRANSITIONAL: Perform Unicode TR46 non-transitional
 1607|       |         processing. */
 1608|       |      int flags = IDN2_NFC_INPUT | IDN2_NONTRANSITIONAL;
 1609|       |#else
 1610|       |      int flags = IDN2_NFC_INPUT;
 1611|       |#endif
 1612|       |      int rc = IDN2_LOOKUP(host->name, &ace_hostname, flags);
 1613|       |      if(rc != IDN2_OK)
 1614|       |        /* fallback to TR46 Transitional mode for better IDNA2003
 1615|       |           compatibility */
 1616|       |        rc = IDN2_LOOKUP(host->name, &ace_hostname,
 1617|       |                         IDN2_TRANSITIONAL);
 1618|       |      if(rc == IDN2_OK) {
 1619|       |        host->encalloc = (char *)ace_hostname;
 1620|       |        /* change the name pointer to point to the encoded hostname */
 1621|       |        host->name = host->encalloc;
 1622|       |      }
 1623|       |      else {
 1624|       |        failf(data, "Failed to convert %s to ACE; %s", host->name,
 1625|       |              idn2_strerror(rc));
 1626|       |        return CURLE_URL_MALFORMAT;
 1627|       |      }
 1628|       |    }
 1629|       |#elif defined(USE_WIN32_IDN)
 1630|       |    char *ace_hostname = NULL;
 1631|       |
 1632|       |    if(curl_win32_idn_to_ascii(host->name, &ace_hostname)) {
 1633|       |      host->encalloc = ace_hostname;
 1634|       |      /* change the name pointer to point to the encoded hostname */
 1635|       |      host->name = host->encalloc;
 1636|       |    }
 1637|       |    else {
 1638|       |      char buffer[STRERROR_LEN];
 1639|       |      failf(data, "Failed to convert %s to ACE; %s", host->name,
 1640|       |            Curl_winapi_strerror(GetLastError(), buffer, sizeof(buffer)));
 1641|       |      return CURLE_URL_MALFORMAT;
 1642|       |    }
 1643|       |#else
 1644|    186|    infof(data, "IDN support not present, can't parse Unicode domains");
 1645|    186|#endif
 1646|    186|  }
 1647|  6.05k|  return CURLE_OK;
 1648|  6.05k|}
Curl_free_idnconverted_hostname:
 1654|  12.6k|{
 1655|       |#if defined(USE_LIBIDN2)
 1656|       |  if(host->encalloc) {
 1657|       |    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
 1658|       |                                 allocated by libidn */
 1659|       |    host->encalloc = NULL;
 1660|       |  }
 1661|       |#elif defined(USE_WIN32_IDN)
 1662|       |  free(host->encalloc); /* must be freed with free() since this was
 1663|       |                           allocated by curl_win32_idn_to_ascii */
 1664|       |  host->encalloc = NULL;
 1665|       |#else
 1666|  12.6k|  (void)host;
 1667|  12.6k|#endif
 1668|  12.6k|}
Curl_builtin_scheme:
 1816|  12.3k|{
 1817|  12.3k|  const struct Curl_handler * const *pp;
 1818|  12.3k|  const struct Curl_handler *p;
 1819|       |  /* Scan protocol handler table and match against 'scheme'. The handler may
 1820|       |     be changed later when the protocol specific setup function is called. */
 1821|  74.1k|  for(pp = protocols; (p = *pp) != NULL; pp++)
 1822|  74.1k|    if(strcasecompare(p->scheme, scheme))
 1823|       |      /* Protocol found in table. Check if allowed */
 1824|  12.2k|      return p;
 1825|     34|  return NULL; /* not found */
 1826|  12.3k|}
Curl_uc_to_curlcode:
 1864|     72|{
 1865|     72|  switch(uc) {
 1866|     71|  default:
 1867|     71|    return CURLE_URL_MALFORMAT;
 1868|      1|  case CURLUE_UNSUPPORTED_SCHEME:
 1869|      1|    return CURLE_UNSUPPORTED_PROTOCOL;
 1870|      0|  case CURLUE_OUT_OF_MEMORY:
 1871|      0|    return CURLE_OUT_OF_MEMORY;
 1872|      0|  case CURLUE_USER_NOT_ALLOWED:
 1873|      0|    return CURLE_LOGIN_DENIED;
 1874|     72|  }
 1875|     72|}
Curl_free_request_state:
 2204|  12.2k|{
 2205|  12.2k|  Curl_safefree(data->req.p.http);
 2206|  12.2k|  Curl_safefree(data->req.newurl);
 2207|       |
 2208|  12.2k|#ifndef CURL_DISABLE_DOH
 2209|  12.2k|  if(data->req.doh) {
 2210|      0|    Curl_close(&data->req.doh->probe[0].easy);
 2211|      0|    Curl_close(&data->req.doh->probe[1].easy);
 2212|      0|  }
 2213|  12.2k|#endif
 2214|  12.2k|}
Curl_parse_login_details:
 2777|    343|{
 2778|    343|  CURLcode result = CURLE_OK;
 2779|    343|  char *ubuf = NULL;
 2780|    343|  char *pbuf = NULL;
 2781|    343|  char *obuf = NULL;
 2782|    343|  const char *psep = NULL;
 2783|    343|  const char *osep = NULL;
 2784|    343|  size_t ulen;
 2785|    343|  size_t plen;
 2786|    343|  size_t olen;
 2787|       |
 2788|       |  /* the input length check is because this is called directly from setopt
 2789|       |     and isn't going through the regular string length check */
 2790|    343|  size_t llen = strlen(login);
 2791|    343|  if(llen > CURL_MAX_INPUT_LENGTH)
 2792|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 2793|       |
 2794|       |  /* Attempt to find the password separator */
 2795|    343|  if(passwdp) {
 2796|    343|    psep = strchr(login, ':');
 2797|       |
 2798|       |    /* Within the constraint of the login string */
 2799|    343|    if(psep >= login + len)
 2800|     25|      psep = NULL;
 2801|    343|  }
 2802|       |
 2803|       |  /* Attempt to find the options separator */
 2804|    343|  if(optionsp) {
 2805|    185|    osep = strchr(login, ';');
 2806|       |
 2807|       |    /* Within the constraint of the login string */
 2808|    185|    if(osep >= login + len)
 2809|      5|      osep = NULL;
 2810|    185|  }
 2811|       |
 2812|       |  /* Calculate the portion lengths */
 2813|    343|  ulen = (psep ?
 2814|    176|          (size_t)(osep && psep > osep ? osep - login : psep - login) :
 2815|    343|          (osep ? (size_t)(osep - login) : len));
 2816|    343|  plen = (psep ?
 2817|    176|          (osep && osep > psep ? (size_t)(osep - psep) :
 2818|    176|                                 (size_t)(login + len - psep)) - 1 : 0);
 2819|    343|  olen = (osep ?
 2820|     69|          (psep && psep > osep ? (size_t)(psep - osep) :
 2821|    274|                                 (size_t)(login + len - osep)) - 1 : 0);
 2822|       |
 2823|       |  /* Allocate the user portion buffer */
 2824|    343|  if(userp && ulen) {
 2825|    280|    ubuf = malloc(ulen + 1);
 2826|    280|    if(!ubuf)
 2827|      0|      result = CURLE_OUT_OF_MEMORY;
 2828|    280|  }
 2829|       |
 2830|       |  /* Allocate the password portion buffer */
 2831|    343|  if(!result && passwdp && plen) {
 2832|    143|    pbuf = malloc(plen + 1);
 2833|    143|    if(!pbuf) {
 2834|      0|      free(ubuf);
 2835|      0|      result = CURLE_OUT_OF_MEMORY;
 2836|      0|    }
 2837|    143|  }
 2838|       |
 2839|       |  /* Allocate the options portion buffer */
 2840|    343|  if(!result && optionsp && olen) {
 2841|     62|    obuf = malloc(olen + 1);
 2842|     62|    if(!obuf) {
 2843|      0|      free(pbuf);
 2844|      0|      free(ubuf);
 2845|      0|      result = CURLE_OUT_OF_MEMORY;
 2846|      0|    }
 2847|     62|  }
 2848|       |
 2849|    343|  if(!result) {
 2850|       |    /* Store the user portion if necessary */
 2851|    343|    if(ubuf) {
 2852|    280|      memcpy(ubuf, login, ulen);
 2853|    280|      ubuf[ulen] = '\0';
 2854|    280|      Curl_safefree(*userp);
 2855|    280|      *userp = ubuf;
 2856|    280|    }
 2857|       |
 2858|       |    /* Store the password portion if necessary */
 2859|    343|    if(pbuf) {
 2860|    143|      memcpy(pbuf, psep + 1, plen);
 2861|    143|      pbuf[plen] = '\0';
 2862|    143|      Curl_safefree(*passwdp);
 2863|    143|      *passwdp = pbuf;
 2864|    143|    }
 2865|       |
 2866|       |    /* Store the options portion if necessary */
 2867|    343|    if(obuf) {
 2868|     62|      memcpy(obuf, osep + 1, olen);
 2869|     62|      obuf[olen] = '\0';
 2870|     62|      Curl_safefree(*optionsp);
 2871|     62|      *optionsp = obuf;
 2872|     62|    }
 2873|    343|  }
 2874|       |
 2875|    343|  return result;
 2876|    343|}
Curl_setup_conn:
 4055|  2.96k|{
 4056|  2.96k|  CURLcode result = CURLE_OK;
 4057|  2.96k|  struct connectdata *conn = data->conn;
 4058|       |
 4059|  2.96k|  Curl_pgrsTime(data, TIMER_NAMELOOKUP);
 4060|       |
 4061|  2.96k|  if(conn->handler->flags & PROTOPT_NONETWORK) {
 4062|       |    /* nothing to setup when not using a network */
 4063|     36|    *protocol_done = TRUE;
 4064|     36|    return result;
 4065|     36|  }
 4066|  2.93k|  *protocol_done = FALSE; /* default to not done */
 4067|       |
 4068|  2.93k|#ifndef CURL_DISABLE_PROXY
 4069|       |  /* set proxy_connect_closed to false unconditionally already here since it
 4070|       |     is used strictly to provide extra information to a parent function in the
 4071|       |     case of proxy CONNECT failures and we must make sure we don't have it
 4072|       |     lingering set from a previous invoke */
 4073|  2.93k|  conn->bits.proxy_connect_closed = FALSE;
 4074|  2.93k|#endif
 4075|       |
 4076|  2.93k|#ifdef CURL_DO_LINEEND_CONV
 4077|  2.93k|  data->state.crlf_conversions = 0; /* reset CRLF conversion counter */
 4078|  2.93k|#endif /* CURL_DO_LINEEND_CONV */
 4079|       |
 4080|       |  /* set start time here for timeout purposes in the connect procedure, it
 4081|       |     is later set again for the progress meter purpose */
 4082|  2.93k|  conn->now = Curl_now();
 4083|       |
 4084|  2.93k|  if(CURL_SOCKET_BAD == conn->sock[FIRSTSOCKET]) {
 4085|  2.93k|    conn->bits.tcpconnect[FIRSTSOCKET] = FALSE;
 4086|  2.93k|    result = Curl_connecthost(data, conn, conn->dns_entry);
 4087|  2.93k|    if(result)
 4088|      9|      return result;
 4089|  2.93k|  }
 4090|      0|  else {
 4091|      0|    Curl_pgrsTime(data, TIMER_CONNECT);    /* we're connected already */
 4092|      0|    if(conn->ssl[FIRSTSOCKET].use ||
 4093|      0|       (conn->handler->protocol & PROTO_FAMILY_SSH))
 4094|      0|      Curl_pgrsTime(data, TIMER_APPCONNECT); /* we're connected already */
 4095|      0|    conn->bits.tcpconnect[FIRSTSOCKET] = TRUE;
 4096|      0|    *protocol_done = TRUE;
 4097|      0|    Curl_updateconninfo(data, conn, conn->sock[FIRSTSOCKET]);
 4098|      0|    Curl_verboseconnect(data, conn);
 4099|      0|  }
 4100|       |
 4101|  2.92k|  conn->now = Curl_now(); /* time this *after* the connect is done, we set
 4102|       |                             this here perhaps a second time */
 4103|  2.92k|  return result;
 4104|  2.93k|}
Curl_connect:
 4109|  3.05k|{
 4110|  3.05k|  CURLcode result;
 4111|  3.05k|  struct connectdata *conn;
 4112|       |
 4113|  3.05k|  *asyncp = FALSE; /* assume synchronous resolves by default */
 4114|       |
 4115|       |  /* init the single-transfer specific data */
 4116|  3.05k|  Curl_free_request_state(data);
 4117|  3.05k|  memset(&data->req, 0, sizeof(struct SingleRequest));
 4118|  3.05k|  data->req.size = data->req.maxdownload = -1;
 4119|       |
 4120|       |  /* call the stuff that needs to be called */
 4121|  3.05k|  result = create_conn(data, &conn, asyncp);
 4122|       |
 4123|  3.05k|  if(!result) {
 4124|  2.96k|    if(CONN_INUSE(conn) > 1)
 4125|       |      /* multiplexed */
 4126|      0|      *protocol_done = TRUE;
 4127|  2.96k|    else if(!*asyncp) {
 4128|       |      /* DNS resolution is done: that's either because this is a reused
 4129|       |         connection, in which case DNS was unnecessary, or because DNS
 4130|       |         really did finish already (synch resolver/fast async resolve) */
 4131|  2.96k|      result = Curl_setup_conn(data, protocol_done);
 4132|  2.96k|    }
 4133|  2.96k|  }
 4134|       |
 4135|  3.05k|  if(result == CURLE_NO_CONNECTION_AVAILABLE) {
 4136|      0|    return result;
 4137|      0|  }
 4138|  3.05k|  else if(result && conn) {
 4139|       |    /* We're not allowed to return failure with memory left allocated in the
 4140|       |       connectdata struct, free those here */
 4141|     94|    Curl_detach_connnection(data);
 4142|     94|    Curl_conncache_remove_conn(data, conn, TRUE);
 4143|     94|    Curl_disconnect(data, conn, TRUE);
 4144|     94|  }
 4145|       |
 4146|  3.05k|  return result;
 4147|  3.05k|}
Curl_init_do:
 4160|  2.97k|{
 4161|  2.97k|  struct SingleRequest *k = &data->req;
 4162|       |
 4163|       |  /* if this is a pushed stream, we need this: */
 4164|  2.97k|  CURLcode result = Curl_preconnect(data);
 4165|  2.97k|  if(result)
 4166|      0|    return result;
 4167|       |
 4168|  2.97k|  if(conn) {
 4169|  2.97k|    conn->bits.do_more = FALSE; /* by default there's no curl_do_more() to
 4170|       |                                   use */
 4171|       |    /* if the protocol used doesn't support wildcards, switch it off */
 4172|  2.97k|    if(data->state.wildcardmatch &&
 4173|  2.97k|       !(conn->handler->flags & PROTOPT_WILDCARD))
 4174|     25|      data->state.wildcardmatch = FALSE;
 4175|  2.97k|  }
 4176|       |
 4177|  2.97k|  data->state.done = FALSE; /* *_done() is not called yet */
 4178|  2.97k|  data->state.expect100header = FALSE;
 4179|       |
 4180|  2.97k|  if(data->set.opt_no_body)
 4181|       |    /* in HTTP lingo, no body means using the HEAD request... */
 4182|     36|    data->state.httpreq = HTTPREQ_HEAD;
 4183|       |
 4184|  2.97k|  k->start = Curl_now(); /* start time */
 4185|  2.97k|  k->now = k->start;   /* current time is now */
 4186|  2.97k|  k->header = TRUE; /* assume header */
 4187|  2.97k|  k->bytecount = 0;
 4188|  2.97k|  k->ignorebody = FALSE;
 4189|       |
 4190|  2.97k|  Curl_speedinit(data);
 4191|  2.97k|  Curl_pgrsSetUploadCounter(data, 0);
 4192|  2.97k|  Curl_pgrsSetDownloadCounter(data, 0);
 4193|       |
 4194|  2.97k|  return CURLE_OK;
 4195|  2.97k|}
url.c:up_free:
  339|  9.30k|{
  340|  9.30k|  struct urlpieces *up = &data->state.up;
  341|  9.30k|  Curl_safefree(up->scheme);
  342|  9.30k|  Curl_safefree(up->hostname);
  343|  9.30k|  Curl_safefree(up->port);
  344|  9.30k|  Curl_safefree(up->user);
  345|  9.30k|  Curl_safefree(up->password);
  346|  9.30k|  Curl_safefree(up->options);
  347|  9.30k|  Curl_safefree(up->path);
  348|  9.30k|  Curl_safefree(up->query);
  349|  9.30k|  curl_url_cleanup(data->state.uh);
  350|  9.30k|  data->state.uh = NULL;
  351|  9.30k|}
url.c:conn_shutdown:
  734|  3.05k|{
  735|  3.05k|  DEBUGASSERT(conn);
  736|  3.05k|  DEBUGASSERT(data);
  737|  3.05k|  infof(data, "Closing connection %ld", conn->connection_id);
  738|       |
  739|  3.05k|#ifndef USE_HYPER
  740|  3.05k|  if(conn->connect_state && conn->connect_state->prot_save) {
  741|       |    /* If this was closed with a CONNECT in progress, cleanup this temporary
  742|       |       struct arrangement */
  743|      0|    data->req.p.http = NULL;
  744|      0|    Curl_safefree(conn->connect_state->prot_save);
  745|      0|  }
  746|  3.05k|#endif
  747|       |
  748|       |  /* possible left-overs from the async name resolvers */
  749|  3.05k|  Curl_resolver_cancel(data);
  750|       |
  751|       |  /* close the SSL stuff before we close any sockets since they will/may
  752|       |     write to the sockets */
  753|  3.05k|  Curl_ssl_close(data, conn, FIRSTSOCKET);
  754|  3.05k|  Curl_ssl_close(data, conn, SECONDARYSOCKET);
  755|       |
  756|       |  /* close possibly still open sockets */
  757|  3.05k|  if(CURL_SOCKET_BAD != conn->sock[SECONDARYSOCKET])
  758|      0|    Curl_closesocket(data, conn, conn->sock[SECONDARYSOCKET]);
  759|  3.05k|  if(CURL_SOCKET_BAD != conn->sock[FIRSTSOCKET])
  760|  2.92k|    Curl_closesocket(data, conn, conn->sock[FIRSTSOCKET]);
  761|  3.05k|  if(CURL_SOCKET_BAD != conn->tempsock[0])
  762|      0|    Curl_closesocket(data, conn, conn->tempsock[0]);
  763|  3.05k|  if(CURL_SOCKET_BAD != conn->tempsock[1])
  764|      0|    Curl_closesocket(data, conn, conn->tempsock[1]);
  765|  3.05k|}
url.c:conn_free:
  768|  3.05k|{
  769|  3.05k|  DEBUGASSERT(conn);
  770|       |
  771|  3.05k|  Curl_free_idnconverted_hostname(&conn->host);
  772|  3.05k|  Curl_free_idnconverted_hostname(&conn->conn_to_host);
  773|  3.05k|#ifndef CURL_DISABLE_PROXY
  774|  3.05k|  Curl_free_idnconverted_hostname(&conn->http_proxy.host);
  775|  3.05k|  Curl_free_idnconverted_hostname(&conn->socks_proxy.host);
  776|  3.05k|  Curl_safefree(conn->http_proxy.user);
  777|  3.05k|  Curl_safefree(conn->socks_proxy.user);
  778|  3.05k|  Curl_safefree(conn->http_proxy.passwd);
  779|  3.05k|  Curl_safefree(conn->socks_proxy.passwd);
  780|  3.05k|  Curl_safefree(conn->http_proxy.host.rawalloc); /* http proxy name buffer */
  781|  3.05k|  Curl_safefree(conn->socks_proxy.host.rawalloc); /* socks proxy name buffer */
  782|  3.05k|  Curl_free_primary_ssl_config(&conn->proxy_ssl_config);
  783|  3.05k|#endif
  784|  3.05k|  Curl_safefree(conn->user);
  785|  3.05k|  Curl_safefree(conn->passwd);
  786|  3.05k|  Curl_safefree(conn->sasl_authzid);
  787|  3.05k|  Curl_safefree(conn->options);
  788|  3.05k|  Curl_dyn_free(&conn->trailer);
  789|  3.05k|  Curl_safefree(conn->host.rawalloc); /* host name buffer */
  790|  3.05k|  Curl_safefree(conn->conn_to_host.rawalloc); /* host name buffer */
  791|  3.05k|  Curl_safefree(conn->hostname_resolve);
  792|  3.05k|  Curl_safefree(conn->secondaryhostname);
  793|  3.05k|  Curl_safefree(conn->connect_state);
  794|       |
  795|  3.05k|  conn_reset_all_postponed_data(conn);
  796|  3.05k|  Curl_llist_destroy(&conn->easyq, NULL);
  797|  3.05k|  Curl_safefree(conn->localdev);
  798|  3.05k|  Curl_free_primary_ssl_config(&conn->ssl_config);
  799|       |
  800|  3.05k|#ifdef USE_UNIX_SOCKETS
  801|  3.05k|  Curl_safefree(conn->unix_domain_socket);
  802|  3.05k|#endif
  803|       |
  804|  3.05k|#ifdef USE_SSL
  805|  3.05k|  Curl_safefree(conn->ssl_extra);
  806|  3.05k|#endif
  807|  3.05k|  free(conn); /* free all the connection oriented data */
  808|  3.05k|}
url.c:create_conn:
 3571|  3.05k|{
 3572|  3.05k|  CURLcode result = CURLE_OK;
 3573|  3.05k|  struct connectdata *conn;
 3574|  3.05k|  struct connectdata *conn_temp = NULL;
 3575|  3.05k|  bool reuse;
 3576|  3.05k|  bool connections_available = TRUE;
 3577|  3.05k|  bool force_reuse = FALSE;
 3578|  3.05k|  bool waitpipe = FALSE;
 3579|  3.05k|  size_t max_host_connections = Curl_multi_max_host_connections(data->multi);
 3580|  3.05k|  size_t max_total_connections = Curl_multi_max_total_connections(data->multi);
 3581|       |
 3582|  3.05k|  *async = FALSE;
 3583|  3.05k|  *in_connect = NULL;
 3584|       |
 3585|       |  /*************************************************************
 3586|       |   * Check input data
 3587|       |   *************************************************************/
 3588|  3.05k|  if(!data->state.url) {
 3589|      0|    result = CURLE_URL_MALFORMAT;
 3590|      0|    goto out;
 3591|      0|  }
 3592|       |
 3593|       |  /* First, split up the current URL in parts so that we can use the
 3594|       |     parts for checking against the already present connections. In order
 3595|       |     to not have to modify everything at once, we allocate a temporary
 3596|       |     connection data struct and fill in for comparison purposes. */
 3597|  3.05k|  conn = allocate_conn(data);
 3598|       |
 3599|  3.05k|  if(!conn) {
 3600|      0|    result = CURLE_OUT_OF_MEMORY;
 3601|      0|    goto out;
 3602|      0|  }
 3603|       |
 3604|       |  /* We must set the return variable as soon as possible, so that our
 3605|       |     parent can cleanup any possible allocs we may have done before
 3606|       |     any failure */
 3607|  3.05k|  *in_connect = conn;
 3608|       |
 3609|  3.05k|  result = parseurlandfillconn(data, conn);
 3610|  3.05k|  if(result)
 3611|     78|    goto out;
 3612|       |
 3613|  2.97k|  if(data->set.str[STRING_SASL_AUTHZID]) {
 3614|      0|    conn->sasl_authzid = strdup(data->set.str[STRING_SASL_AUTHZID]);
 3615|      0|    if(!conn->sasl_authzid) {
 3616|      0|      result = CURLE_OUT_OF_MEMORY;
 3617|      0|      goto out;
 3618|      0|    }
 3619|      0|  }
 3620|       |
 3621|  2.97k|#ifdef USE_UNIX_SOCKETS
 3622|  2.97k|  if(data->set.str[STRING_UNIX_SOCKET_PATH]) {
 3623|      0|    conn->unix_domain_socket = strdup(data->set.str[STRING_UNIX_SOCKET_PATH]);
 3624|      0|    if(!conn->unix_domain_socket) {
 3625|      0|      result = CURLE_OUT_OF_MEMORY;
 3626|      0|      goto out;
 3627|      0|    }
 3628|      0|    conn->bits.abstract_unix_socket = data->set.abstract_unix_socket;
 3629|      0|  }
 3630|  2.97k|#endif
 3631|       |
 3632|       |  /* After the unix socket init but before the proxy vars are used, parse and
 3633|       |     initialize the proxy vars */
 3634|  2.97k|#ifndef CURL_DISABLE_PROXY
 3635|  2.97k|  result = create_conn_helper_init_proxy(data, conn);
 3636|  2.97k|  if(result)
 3637|      0|    goto out;
 3638|       |
 3639|       |  /*************************************************************
 3640|       |   * If the protocol is using SSL and HTTP proxy is used, we set
 3641|       |   * the tunnel_proxy bit.
 3642|       |   *************************************************************/
 3643|  2.97k|  if((conn->given->flags&PROTOPT_SSL) && conn->bits.httpproxy)
 3644|      0|    conn->bits.tunnel_proxy = TRUE;
 3645|  2.97k|#endif
 3646|       |
 3647|       |  /*************************************************************
 3648|       |   * Figure out the remote port number and fix it in the URL
 3649|       |   *************************************************************/
 3650|  2.97k|  result = parse_remote_port(data, conn);
 3651|  2.97k|  if(result)
 3652|      0|    goto out;
 3653|       |
 3654|       |  /* Check for overridden login details and set them accordingly so that
 3655|       |     they are known when protocol->setup_connection is called! */
 3656|  2.97k|  result = override_login(data, conn);
 3657|  2.97k|  if(result)
 3658|      0|    goto out;
 3659|       |
 3660|  2.97k|  result = set_login(conn); /* default credentials */
 3661|  2.97k|  if(result)
 3662|      0|    goto out;
 3663|       |
 3664|       |  /*************************************************************
 3665|       |   * Process the "connect to" linked list of hostname/port mappings.
 3666|       |   * Do this after the remote port number has been fixed in the URL.
 3667|       |   *************************************************************/
 3668|  2.97k|  result = parse_connect_to_slist(data, conn, data->set.connect_to);
 3669|  2.97k|  if(result)
 3670|      0|    goto out;
 3671|       |
 3672|       |  /*************************************************************
 3673|       |   * IDN-convert the hostnames
 3674|       |   *************************************************************/
 3675|  2.97k|  result = Curl_idnconvert_hostname(data, &conn->host);
 3676|  2.97k|  if(result)
 3677|      0|    goto out;
 3678|  2.97k|  if(conn->bits.conn_to_host) {
 3679|  2.97k|    result = Curl_idnconvert_hostname(data, &conn->conn_to_host);
 3680|  2.97k|    if(result)
 3681|      0|      goto out;
 3682|  2.97k|  }
 3683|  2.97k|#ifndef CURL_DISABLE_PROXY
 3684|  2.97k|  if(conn->bits.httpproxy) {
 3685|      0|    result = Curl_idnconvert_hostname(data, &conn->http_proxy.host);
 3686|      0|    if(result)
 3687|      0|      goto out;
 3688|      0|  }
 3689|  2.97k|  if(conn->bits.socksproxy) {
 3690|      0|    result = Curl_idnconvert_hostname(data, &conn->socks_proxy.host);
 3691|      0|    if(result)
 3692|      0|      goto out;
 3693|      0|  }
 3694|  2.97k|#endif
 3695|       |
 3696|       |  /*************************************************************
 3697|       |   * Check whether the host and the "connect to host" are equal.
 3698|       |   * Do this after the hostnames have been IDN-converted.
 3699|       |   *************************************************************/
 3700|  2.97k|  if(conn->bits.conn_to_host &&
 3701|  2.97k|     strcasecompare(conn->conn_to_host.name, conn->host.name)) {
 3702|      1|    conn->bits.conn_to_host = FALSE;
 3703|      1|  }
 3704|       |
 3705|       |  /*************************************************************
 3706|       |   * Check whether the port and the "connect to port" are equal.
 3707|       |   * Do this after the remote port number has been fixed in the URL.
 3708|       |   *************************************************************/
 3709|  2.97k|  if(conn->bits.conn_to_port && conn->conn_to_port == conn->remote_port) {
 3710|      0|    conn->bits.conn_to_port = FALSE;
 3711|      0|  }
 3712|       |
 3713|  2.97k|#ifndef CURL_DISABLE_PROXY
 3714|       |  /*************************************************************
 3715|       |   * If the "connect to" feature is used with an HTTP proxy,
 3716|       |   * we set the tunnel_proxy bit.
 3717|       |   *************************************************************/
 3718|  2.97k|  if((conn->bits.conn_to_host || conn->bits.conn_to_port) &&
 3719|  2.97k|      conn->bits.httpproxy)
 3720|      0|    conn->bits.tunnel_proxy = TRUE;
 3721|  2.97k|#endif
 3722|       |
 3723|       |  /*************************************************************
 3724|       |   * Setup internals depending on protocol. Needs to be done after
 3725|       |   * we figured out what/if proxy to use.
 3726|       |   *************************************************************/
 3727|  2.97k|  result = setup_connection_internals(data, conn);
 3728|  2.97k|  if(result)
 3729|      0|    goto out;
 3730|       |
 3731|  2.97k|  conn->recv[FIRSTSOCKET] = Curl_recv_plain;
 3732|  2.97k|  conn->send[FIRSTSOCKET] = Curl_send_plain;
 3733|  2.97k|  conn->recv[SECONDARYSOCKET] = Curl_recv_plain;
 3734|  2.97k|  conn->send[SECONDARYSOCKET] = Curl_send_plain;
 3735|       |
 3736|  2.97k|  conn->bits.tcp_fastopen = data->set.tcp_fastopen;
 3737|       |
 3738|       |  /***********************************************************************
 3739|       |   * file: is a special case in that it doesn't need a network connection
 3740|       |   ***********************************************************************/
 3741|  2.97k|#ifndef CURL_DISABLE_FILE
 3742|  2.97k|  if(conn->handler->flags & PROTOPT_NONETWORK) {
 3743|     43|    bool done;
 3744|       |    /* this is supposed to be the connect function so we better at least check
 3745|       |       that the file is present here! */
 3746|     43|    DEBUGASSERT(conn->handler->connect_it);
 3747|     43|    Curl_persistconninfo(data, conn, NULL, -1);
 3748|     43|    result = conn->handler->connect_it(data, &done);
 3749|       |
 3750|       |    /* Setup a "faked" transfer that'll do nothing */
 3751|     43|    if(!result) {
 3752|     36|      conn->bits.tcpconnect[FIRSTSOCKET] = TRUE; /* we are "connected */
 3753|       |
 3754|     36|      Curl_attach_connnection(data, conn);
 3755|     36|      result = Curl_conncache_add_conn(data);
 3756|     36|      if(result)
 3757|      0|        goto out;
 3758|       |
 3759|       |      /*
 3760|       |       * Setup whatever necessary for a resumed transfer
 3761|       |       */
 3762|     36|      result = setup_range(data);
 3763|     36|      if(result) {
 3764|      0|        DEBUGASSERT(conn->handler->done);
 3765|       |        /* we ignore the return code for the protocol-specific DONE */
 3766|      0|        (void)conn->handler->done(data, result, FALSE);
 3767|      0|        goto out;
 3768|      0|      }
 3769|     36|      Curl_setup_transfer(data, -1, -1, FALSE, -1);
 3770|     36|    }
 3771|       |
 3772|       |    /* since we skip do_init() */
 3773|     43|    Curl_init_do(data, conn);
 3774|       |
 3775|     43|    goto out;
 3776|     43|  }
 3777|  2.93k|#endif
 3778|       |
 3779|       |  /* Get a cloned copy of the SSL config situation stored in the
 3780|       |     connection struct. But to get this going nicely, we must first make
 3781|       |     sure that the strings in the master copy are pointing to the correct
 3782|       |     strings in the session handle strings array!
 3783|       |
 3784|       |     Keep in mind that the pointers in the master copy are pointing to strings
 3785|       |     that will be freed as part of the Curl_easy struct, but all cloned
 3786|       |     copies will be separately allocated.
 3787|       |  */
 3788|  2.93k|  data->set.ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH];
 3789|  2.93k|  data->set.ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE];
 3790|  2.93k|  data->set.ssl.primary.issuercert = data->set.str[STRING_SSL_ISSUERCERT];
 3791|  2.93k|  data->set.ssl.primary.issuercert_blob = data->set.blobs[BLOB_SSL_ISSUERCERT];
 3792|  2.93k|  data->set.ssl.primary.random_file = data->set.str[STRING_SSL_RANDOM_FILE];
 3793|  2.93k|  data->set.ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];
 3794|  2.93k|  data->set.ssl.primary.cipher_list =
 3795|  2.93k|    data->set.str[STRING_SSL_CIPHER_LIST];
 3796|  2.93k|  data->set.ssl.primary.cipher_list13 =
 3797|  2.93k|    data->set.str[STRING_SSL_CIPHER13_LIST];
 3798|  2.93k|  data->set.ssl.primary.pinned_key =
 3799|  2.93k|    data->set.str[STRING_SSL_PINNEDPUBLICKEY];
 3800|  2.93k|  data->set.ssl.primary.cert_blob = data->set.blobs[BLOB_CERT];
 3801|  2.93k|  data->set.ssl.primary.ca_info_blob = data->set.blobs[BLOB_CAINFO];
 3802|  2.93k|  data->set.ssl.primary.curves = data->set.str[STRING_SSL_EC_CURVES];
 3803|       |
 3804|  2.93k|#ifndef CURL_DISABLE_PROXY
 3805|  2.93k|  data->set.proxy_ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH_PROXY];
 3806|  2.93k|  data->set.proxy_ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE_PROXY];
 3807|  2.93k|  data->set.proxy_ssl.primary.random_file =
 3808|  2.93k|    data->set.str[STRING_SSL_RANDOM_FILE];
 3809|  2.93k|  data->set.proxy_ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];
 3810|  2.93k|  data->set.proxy_ssl.primary.cipher_list =
 3811|  2.93k|    data->set.str[STRING_SSL_CIPHER_LIST_PROXY];
 3812|  2.93k|  data->set.proxy_ssl.primary.cipher_list13 =
 3813|  2.93k|    data->set.str[STRING_SSL_CIPHER13_LIST_PROXY];
 3814|  2.93k|  data->set.proxy_ssl.primary.pinned_key =
 3815|  2.93k|    data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY];
 3816|  2.93k|  data->set.proxy_ssl.primary.cert_blob = data->set.blobs[BLOB_CERT_PROXY];
 3817|  2.93k|  data->set.proxy_ssl.primary.ca_info_blob =
 3818|  2.93k|    data->set.blobs[BLOB_CAINFO_PROXY];
 3819|  2.93k|  data->set.proxy_ssl.primary.issuercert =
 3820|  2.93k|    data->set.str[STRING_SSL_ISSUERCERT_PROXY];
 3821|  2.93k|  data->set.proxy_ssl.primary.issuercert_blob =
 3822|  2.93k|    data->set.blobs[BLOB_SSL_ISSUERCERT_PROXY];
 3823|  2.93k|  data->set.proxy_ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE_PROXY];
 3824|  2.93k|  data->set.proxy_ssl.cert_type = data->set.str[STRING_CERT_TYPE_PROXY];
 3825|  2.93k|  data->set.proxy_ssl.key = data->set.str[STRING_KEY_PROXY];
 3826|  2.93k|  data->set.proxy_ssl.key_type = data->set.str[STRING_KEY_TYPE_PROXY];
 3827|  2.93k|  data->set.proxy_ssl.key_passwd = data->set.str[STRING_KEY_PASSWD_PROXY];
 3828|  2.93k|  data->set.proxy_ssl.primary.clientcert = data->set.str[STRING_CERT_PROXY];
 3829|  2.93k|  data->set.proxy_ssl.key_blob = data->set.blobs[BLOB_KEY_PROXY];
 3830|  2.93k|#endif
 3831|  2.93k|  data->set.ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE];
 3832|  2.93k|  data->set.ssl.cert_type = data->set.str[STRING_CERT_TYPE];
 3833|  2.93k|  data->set.ssl.key = data->set.str[STRING_KEY];
 3834|  2.93k|  data->set.ssl.key_type = data->set.str[STRING_KEY_TYPE];
 3835|  2.93k|  data->set.ssl.key_passwd = data->set.str[STRING_KEY_PASSWD];
 3836|  2.93k|  data->set.ssl.primary.clientcert = data->set.str[STRING_CERT];
 3837|  2.93k|#ifdef USE_TLS_SRP
 3838|  2.93k|  data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME];
 3839|  2.93k|  data->set.ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD];
 3840|  2.93k|#ifndef CURL_DISABLE_PROXY
 3841|  2.93k|  data->set.proxy_ssl.username = data->set.str[STRING_TLSAUTH_USERNAME_PROXY];
 3842|  2.93k|  data->set.proxy_ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD_PROXY];
 3843|  2.93k|#endif
 3844|  2.93k|#endif
 3845|  2.93k|  data->set.ssl.key_blob = data->set.blobs[BLOB_KEY];
 3846|       |
 3847|  2.93k|  if(!Curl_clone_primary_ssl_config(&data->set.ssl.primary,
 3848|  2.93k|                                    &conn->ssl_config)) {
 3849|      0|    result = CURLE_OUT_OF_MEMORY;
 3850|      0|    goto out;
 3851|      0|  }
 3852|       |
 3853|  2.93k|#ifndef CURL_DISABLE_PROXY
 3854|  2.93k|  if(!Curl_clone_primary_ssl_config(&data->set.proxy_ssl.primary,
 3855|  2.93k|                                    &conn->proxy_ssl_config)) {
 3856|      0|    result = CURLE_OUT_OF_MEMORY;
 3857|      0|    goto out;
 3858|      0|  }
 3859|  2.93k|#endif
 3860|       |
 3861|  2.93k|  prune_dead_connections(data);
 3862|       |
 3863|       |  /*************************************************************
 3864|       |   * Check the current list of connections to see if we can
 3865|       |   * re-use an already existing one or if we have to create a
 3866|       |   * new one.
 3867|       |   *************************************************************/
 3868|       |
 3869|  2.93k|  DEBUGASSERT(conn->user);
 3870|  2.93k|  DEBUGASSERT(conn->passwd);
 3871|       |
 3872|       |  /* reuse_fresh is TRUE if we are told to use a new connection by force, but
 3873|       |     we only acknowledge this option if this is not a re-used connection
 3874|       |     already (which happens due to follow-location or during a HTTP
 3875|       |     authentication phase). CONNECT_ONLY transfers also refuse reuse. */
 3876|  2.93k|  if((data->set.reuse_fresh && !data->state.this_is_a_follow) ||
 3877|  2.93k|     data->set.connect_only)
 3878|      0|    reuse = FALSE;
 3879|  2.93k|  else
 3880|  2.93k|    reuse = ConnectionExists(data, conn, &conn_temp, &force_reuse, &waitpipe);
 3881|       |
 3882|  2.93k|  if(reuse) {
 3883|       |    /*
 3884|       |     * We already have a connection for this, we got the former connection in
 3885|       |     * the conn_temp variable and thus we need to cleanup the one we just
 3886|       |     * allocated before we can move along and use the previously existing one.
 3887|       |     */
 3888|      0|    reuse_conn(data, conn, conn_temp);
 3889|      0|#ifdef USE_SSL
 3890|      0|    free(conn->ssl_extra);
 3891|      0|#endif
 3892|      0|    free(conn);          /* we don't need this anymore */
 3893|      0|    conn = conn_temp;
 3894|      0|    *in_connect = conn;
 3895|       |
 3896|      0|#ifndef CURL_DISABLE_PROXY
 3897|      0|    infof(data, "Re-using existing connection! (#%ld) with %s %s",
 3898|      0|          conn->connection_id,
 3899|      0|          conn->bits.proxy?"proxy":"host",
 3900|      0|          conn->socks_proxy.host.name ? conn->socks_proxy.host.dispname :
 3901|      0|          conn->http_proxy.host.name ? conn->http_proxy.host.dispname :
 3902|      0|          conn->host.dispname);
 3903|       |#else
 3904|       |    infof(data, "Re-using existing connection! (#%ld) with host %s",
 3905|       |          conn->connection_id, conn->host.dispname);
 3906|       |#endif
 3907|      0|  }
 3908|  2.93k|  else {
 3909|       |    /* We have decided that we want a new connection. However, we may not
 3910|       |       be able to do that if we have reached the limit of how many
 3911|       |       connections we are allowed to open. */
 3912|       |
 3913|  2.93k|    if(conn->handler->flags & PROTOPT_ALPN_NPN) {
 3914|       |      /* The protocol wants it, so set the bits if enabled in the easy handle
 3915|       |         (default) */
 3916|      0|      if(data->set.ssl_enable_alpn)
 3917|      0|        conn->bits.tls_enable_alpn = TRUE;
 3918|      0|      if(data->set.ssl_enable_npn)
 3919|      0|        conn->bits.tls_enable_npn = TRUE;
 3920|      0|    }
 3921|       |
 3922|  2.93k|    if(waitpipe)
 3923|       |      /* There is a connection that *might* become usable for multiplexing
 3924|       |         "soon", and we wait for that */
 3925|      0|      connections_available = FALSE;
 3926|  2.93k|    else {
 3927|       |      /* this gets a lock on the conncache */
 3928|  2.93k|      const char *bundlehost;
 3929|  2.93k|      struct connectbundle *bundle =
 3930|  2.93k|        Curl_conncache_find_bundle(data, conn, data->state.conn_cache,
 3931|  2.93k|                                   &bundlehost);
 3932|       |
 3933|  2.93k|      if(max_host_connections > 0 && bundle &&
 3934|  2.93k|         (bundle->num_connections >= max_host_connections)) {
 3935|      0|        struct connectdata *conn_candidate;
 3936|       |
 3937|       |        /* The bundle is full. Extract the oldest connection. */
 3938|      0|        conn_candidate = Curl_conncache_extract_bundle(data, bundle);
 3939|      0|        CONNCACHE_UNLOCK(data);
 3940|       |
 3941|      0|        if(conn_candidate)
 3942|      0|          (void)Curl_disconnect(data, conn_candidate, FALSE);
 3943|      0|        else {
 3944|      0|          infof(data, "No more connections allowed to host %s: %zu",
 3945|      0|                bundlehost, max_host_connections);
 3946|      0|          connections_available = FALSE;
 3947|      0|        }
 3948|      0|      }
 3949|  2.93k|      else
 3950|  2.93k|        CONNCACHE_UNLOCK(data);
 3951|       |
 3952|  2.93k|    }
 3953|       |
 3954|  2.93k|    if(connections_available &&
 3955|  2.93k|       (max_total_connections > 0) &&
 3956|  2.93k|       (Curl_conncache_size(data) >= max_total_connections)) {
 3957|      0|      struct connectdata *conn_candidate;
 3958|       |
 3959|       |      /* The cache is full. Let's see if we can kill a connection. */
 3960|      0|      conn_candidate = Curl_conncache_extract_oldest(data);
 3961|      0|      if(conn_candidate)
 3962|      0|        (void)Curl_disconnect(data, conn_candidate, FALSE);
 3963|      0|      else {
 3964|      0|        infof(data, "No connections available in cache");
 3965|      0|        connections_available = FALSE;
 3966|      0|      }
 3967|      0|    }
 3968|       |
 3969|  2.93k|    if(!connections_available) {
 3970|      0|      infof(data, "No connections available.");
 3971|       |
 3972|      0|      conn_free(conn);
 3973|      0|      *in_connect = NULL;
 3974|       |
 3975|      0|      result = CURLE_NO_CONNECTION_AVAILABLE;
 3976|      0|      goto out;
 3977|      0|    }
 3978|  2.93k|    else {
 3979|       |      /*
 3980|       |       * This is a brand new connection, so let's store it in the connection
 3981|       |       * cache of ours!
 3982|       |       */
 3983|  2.93k|      Curl_attach_connnection(data, conn);
 3984|  2.93k|      result = Curl_conncache_add_conn(data);
 3985|  2.93k|      if(result)
 3986|      0|        goto out;
 3987|  2.93k|    }
 3988|       |
 3989|  2.93k|#if defined(USE_NTLM)
 3990|       |    /* If NTLM is requested in a part of this connection, make sure we don't
 3991|       |       assume the state is fine as this is a fresh connection and NTLM is
 3992|       |       connection based. */
 3993|  2.93k|    if((data->state.authhost.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
 3994|  2.93k|       data->state.authhost.done) {
 3995|      0|      infof(data, "NTLM picked AND auth done set, clear picked!");
 3996|      0|      data->state.authhost.picked = CURLAUTH_NONE;
 3997|      0|      data->state.authhost.done = FALSE;
 3998|      0|    }
 3999|       |
 4000|  2.93k|    if((data->state.authproxy.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
 4001|  2.93k|       data->state.authproxy.done) {
 4002|      0|      infof(data, "NTLM-proxy picked AND auth done set, clear picked!");
 4003|      0|      data->state.authproxy.picked = CURLAUTH_NONE;
 4004|      0|      data->state.authproxy.done = FALSE;
 4005|      0|    }
 4006|  2.93k|#endif
 4007|  2.93k|  }
 4008|       |
 4009|       |  /* Setup and init stuff before DO starts, in preparing for the transfer. */
 4010|  2.93k|  Curl_init_do(data, conn);
 4011|       |
 4012|       |  /*
 4013|       |   * Setup whatever necessary for a resumed transfer
 4014|       |   */
 4015|  2.93k|  result = setup_range(data);
 4016|  2.93k|  if(result)
 4017|      0|    goto out;
 4018|       |
 4019|       |  /* Continue connectdata initialization here. */
 4020|       |
 4021|       |  /*
 4022|       |   * Inherit the proper values from the urldata struct AFTER we have arranged
 4023|       |   * the persistent connection stuff
 4024|       |   */
 4025|  2.93k|  conn->seek_func = data->set.seek_func;
 4026|  2.93k|  conn->seek_client = data->set.seek_client;
 4027|       |
 4028|       |  /*************************************************************
 4029|       |   * Resolve the address of the server or proxy
 4030|       |   *************************************************************/
 4031|  2.93k|  result = resolve_server(data, conn, async);
 4032|       |
 4033|       |  /* Strip trailing dots. resolve_server copied the name. */
 4034|  2.93k|  strip_trailing_dot(&conn->host);
 4035|  2.93k|#ifndef CURL_DISABLE_PROXY
 4036|  2.93k|  if(conn->bits.httpproxy)
 4037|      0|    strip_trailing_dot(&conn->http_proxy.host);
 4038|  2.93k|  if(conn->bits.socksproxy)
 4039|      0|    strip_trailing_dot(&conn->socks_proxy.host);
 4040|  2.93k|#endif
 4041|  2.93k|  if(conn->bits.conn_to_host)
 4042|  2.93k|    strip_trailing_dot(&conn->conn_to_host);
 4043|       |
 4044|  3.05k|out:
 4045|  3.05k|  return result;
 4046|  2.93k|}
url.c:allocate_conn:
 1674|  3.05k|{
 1675|  3.05k|  struct connectdata *conn = calloc(1, sizeof(struct connectdata));
 1676|  3.05k|  if(!conn)
 1677|      0|    return NULL;
 1678|       |
 1679|  3.05k|#ifdef USE_SSL
 1680|       |  /* The SSL backend-specific data (ssl_backend_data) objects are allocated as
 1681|       |     a separate array to ensure suitable alignment.
 1682|       |     Note that these backend pointers can be swapped by vtls (eg ssl backend
 1683|       |     data becomes proxy backend data). */
 1684|  3.05k|  {
 1685|  3.05k|    size_t sslsize = Curl_ssl->sizeof_ssl_backend_data;
 1686|  3.05k|    char *ssl = calloc(4, sslsize);
 1687|  3.05k|    if(!ssl) {
 1688|      0|      free(conn);
 1689|      0|      return NULL;
 1690|      0|    }
 1691|  3.05k|    conn->ssl_extra = ssl;
 1692|  3.05k|    conn->ssl[0].backend = (void *)ssl;
 1693|  3.05k|    conn->ssl[1].backend = (void *)(ssl + sslsize);
 1694|  3.05k|#ifndef CURL_DISABLE_PROXY
 1695|  3.05k|    conn->proxy_ssl[0].backend = (void *)(ssl + 2 * sslsize);
 1696|  3.05k|    conn->proxy_ssl[1].backend = (void *)(ssl + 3 * sslsize);
 1697|  3.05k|#endif
 1698|  3.05k|  }
 1699|      0|#endif
 1700|       |
 1701|      0|  conn->handler = &Curl_handler_dummy;  /* Be sure we have a handler defined
 1702|       |                                           already from start to avoid NULL
 1703|       |                                           situations and checks */
 1704|       |
 1705|       |  /* and we setup a few fields in case we end up actually using this struct */
 1706|       |
 1707|  3.05k|  conn->sock[FIRSTSOCKET] = CURL_SOCKET_BAD;     /* no file descriptor */
 1708|  3.05k|  conn->sock[SECONDARYSOCKET] = CURL_SOCKET_BAD; /* no file descriptor */
 1709|  3.05k|  conn->tempsock[0] = CURL_SOCKET_BAD; /* no file descriptor */
 1710|  3.05k|  conn->tempsock[1] = CURL_SOCKET_BAD; /* no file descriptor */
 1711|  3.05k|  conn->connection_id = -1;    /* no ID */
 1712|  3.05k|  conn->port = -1; /* unknown at this point */
 1713|  3.05k|  conn->remote_port = -1; /* unknown at this point */
 1714|       |#if defined(USE_RECV_BEFORE_SEND_WORKAROUND) && defined(DEBUGBUILD)
 1715|       |  conn->postponed[0].bindsock = CURL_SOCKET_BAD; /* no file descriptor */
 1716|       |  conn->postponed[1].bindsock = CURL_SOCKET_BAD; /* no file descriptor */
 1717|       |#endif /* USE_RECV_BEFORE_SEND_WORKAROUND && DEBUGBUILD */
 1718|       |
 1719|       |  /* Default protocol-independent behavior doesn't support persistent
 1720|       |     connections, so we set this to force-close. Protocols that support
 1721|       |     this need to set this to FALSE in their "curl_do" functions. */
 1722|  3.05k|  connclose(conn, "Default to force-close");
 1723|       |
 1724|       |  /* Store creation time to help future close decision making */
 1725|  3.05k|  conn->created = Curl_now();
 1726|       |
 1727|       |  /* Store current time to give a baseline to keepalive connection times. */
 1728|  3.05k|  conn->keepalive = Curl_now();
 1729|       |
 1730|  3.05k|#ifndef CURL_DISABLE_PROXY
 1731|  3.05k|  conn->http_proxy.proxytype = data->set.proxytype;
 1732|  3.05k|  conn->socks_proxy.proxytype = CURLPROXY_SOCKS4;
 1733|       |
 1734|       |  /* note that these two proxy bits are now just on what looks to be
 1735|       |     requested, they may be altered down the road */
 1736|  3.05k|  conn->bits.proxy = (data->set.str[STRING_PROXY] &&
 1737|  3.05k|                      *data->set.str[STRING_PROXY]) ? TRUE : FALSE;
 1738|  3.05k|  conn->bits.httpproxy = (conn->bits.proxy &&
 1739|  3.05k|                          (conn->http_proxy.proxytype == CURLPROXY_HTTP ||
 1740|      0|                           conn->http_proxy.proxytype == CURLPROXY_HTTP_1_0 ||
 1741|      0|                           conn->http_proxy.proxytype == CURLPROXY_HTTPS)) ?
 1742|  3.05k|                           TRUE : FALSE;
 1743|  3.05k|  conn->bits.socksproxy = (conn->bits.proxy &&
 1744|  3.05k|                           !conn->bits.httpproxy) ? TRUE : FALSE;
 1745|       |
 1746|  3.05k|  if(data->set.str[STRING_PRE_PROXY] && *data->set.str[STRING_PRE_PROXY]) {
 1747|      0|    conn->bits.proxy = TRUE;
 1748|      0|    conn->bits.socksproxy = TRUE;
 1749|      0|  }
 1750|       |
 1751|  3.05k|  conn->bits.proxy_user_passwd =
 1752|  3.05k|    (data->state.aptr.proxyuser) ? TRUE : FALSE;
 1753|  3.05k|  conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;
 1754|  3.05k|#endif /* CURL_DISABLE_PROXY */
 1755|       |
 1756|  3.05k|  conn->bits.user_passwd = (data->state.aptr.user) ? TRUE : FALSE;
 1757|  3.05k|#ifndef CURL_DISABLE_FTP
 1758|  3.05k|  conn->bits.ftp_use_epsv = data->set.ftp_use_epsv;
 1759|  3.05k|  conn->bits.ftp_use_eprt = data->set.ftp_use_eprt;
 1760|  3.05k|#endif
 1761|  3.05k|  conn->ssl_config.verifystatus = data->set.ssl.primary.verifystatus;
 1762|  3.05k|  conn->ssl_config.verifypeer = data->set.ssl.primary.verifypeer;
 1763|  3.05k|  conn->ssl_config.verifyhost = data->set.ssl.primary.verifyhost;
 1764|  3.05k|#ifndef CURL_DISABLE_PROXY
 1765|  3.05k|  conn->proxy_ssl_config.verifystatus =
 1766|  3.05k|    data->set.proxy_ssl.primary.verifystatus;
 1767|  3.05k|  conn->proxy_ssl_config.verifypeer = data->set.proxy_ssl.primary.verifypeer;
 1768|  3.05k|  conn->proxy_ssl_config.verifyhost = data->set.proxy_ssl.primary.verifyhost;
 1769|  3.05k|#endif
 1770|  3.05k|  conn->ip_version = data->set.ipver;
 1771|  3.05k|  conn->bits.connect_only = data->set.connect_only;
 1772|  3.05k|  conn->transport = TRNSPRT_TCP; /* most of them are TCP streams */
 1773|       |
 1774|  3.05k|#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \
 1775|  3.05k|    defined(NTLM_WB_ENABLED)
 1776|  3.05k|  conn->ntlm.ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;
 1777|  3.05k|  conn->proxyntlm.ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;
 1778|  3.05k|#endif
 1779|       |
 1780|       |  /* Initialize the easy handle list */
 1781|  3.05k|  Curl_llist_init(&conn->easyq, NULL);
 1782|       |
 1783|       |#ifdef HAVE_GSSAPI
 1784|       |  conn->data_prot = PROT_CLEAR;
 1785|       |#endif
 1786|       |
 1787|       |  /* Store the local bind parameters that will be used for this connection */
 1788|  3.05k|  if(data->set.str[STRING_DEVICE]) {
 1789|      0|    conn->localdev = strdup(data->set.str[STRING_DEVICE]);
 1790|      0|    if(!conn->localdev)
 1791|      0|      goto error;
 1792|      0|  }
 1793|  3.05k|  conn->localportrange = data->set.localportrange;
 1794|  3.05k|  conn->localport = data->set.localport;
 1795|       |
 1796|       |  /* the close socket stuff needs to be copied to the connection struct as
 1797|       |     it may live on without (this specific) Curl_easy */
 1798|  3.05k|  conn->fclosesocket = data->set.fclosesocket;
 1799|  3.05k|  conn->closesocket_client = data->set.closesocket_client;
 1800|  3.05k|  conn->lastused = Curl_now(); /* used now */
 1801|       |
 1802|  3.05k|  return conn;
 1803|      0|  error:
 1804|       |
 1805|      0|  Curl_llist_destroy(&conn->easyq, NULL);
 1806|      0|  free(conn->localdev);
 1807|      0|#ifdef USE_SSL
 1808|      0|  free(conn->ssl_extra);
 1809|      0|#endif
 1810|      0|  free(conn);
 1811|      0|  return NULL;
 1812|  3.05k|}
url.c:parseurlandfillconn:
 1932|  3.05k|{
 1933|  3.05k|  CURLcode result;
 1934|  3.05k|  CURLU *uh;
 1935|  3.05k|  CURLUcode uc;
 1936|  3.05k|  char *hostname;
 1937|  3.05k|  bool use_set_uh = (data->set.uh && !data->state.this_is_a_follow);
 1938|       |
 1939|  3.05k|  up_free(data); /* cleanup previous leftovers first */
 1940|       |
 1941|       |  /* parse the URL */
 1942|  3.05k|  if(use_set_uh) {
 1943|      0|    uh = data->state.uh = curl_url_dup(data->set.uh);
 1944|      0|  }
 1945|  3.05k|  else {
 1946|  3.05k|    uh = data->state.uh = curl_url();
 1947|  3.05k|  }
 1948|       |
 1949|  3.05k|  if(!uh)
 1950|      0|    return CURLE_OUT_OF_MEMORY;
 1951|       |
 1952|  3.05k|  if(data->set.str[STRING_DEFAULT_PROTOCOL] &&
 1953|  3.05k|     !Curl_is_absolute_url(data->state.url, NULL, MAX_SCHEME_LEN)) {
 1954|      0|    char *url = aprintf("%s://%s", data->set.str[STRING_DEFAULT_PROTOCOL],
 1955|      0|                        data->state.url);
 1956|      0|    if(!url)
 1957|      0|      return CURLE_OUT_OF_MEMORY;
 1958|      0|    if(data->state.url_alloc)
 1959|      0|      free(data->state.url);
 1960|      0|    data->state.url = url;
 1961|      0|    data->state.url_alloc = TRUE;
 1962|      0|  }
 1963|       |
 1964|  3.05k|  if(!use_set_uh) {
 1965|  3.05k|    char *newurl;
 1966|  3.05k|    uc = curl_url_set(uh, CURLUPART_URL, data->state.url,
 1967|  3.05k|                    CURLU_GUESS_SCHEME |
 1968|  3.05k|                    CURLU_NON_SUPPORT_SCHEME |
 1969|  3.05k|                    (data->set.disallow_username_in_url ?
 1970|  3.05k|                     CURLU_DISALLOW_USER : 0) |
 1971|  3.05k|                    (data->set.path_as_is ? CURLU_PATH_AS_IS : 0));
 1972|  3.05k|    if(uc) {
 1973|     64|      DEBUGF(infof(data, "curl_url_set rejected %s: %s", data->state.url,
 1974|     64|                   curl_url_strerror(uc)));
 1975|     64|      return Curl_uc_to_curlcode(uc);
 1976|     64|    }
 1977|       |
 1978|       |    /* after it was parsed, get the generated normalized version */
 1979|  2.98k|    uc = curl_url_get(uh, CURLUPART_URL, &newurl, 0);
 1980|  2.98k|    if(uc)
 1981|      0|      return Curl_uc_to_curlcode(uc);
 1982|  2.98k|    if(data->state.url_alloc)
 1983|    109|      free(data->state.url);
 1984|  2.98k|    data->state.url = newurl;
 1985|  2.98k|    data->state.url_alloc = TRUE;
 1986|  2.98k|  }
 1987|       |
 1988|  2.98k|  uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);
 1989|  2.98k|  if(uc)
 1990|      0|    return Curl_uc_to_curlcode(uc);
 1991|       |
 1992|  2.98k|  uc = curl_url_get(uh, CURLUPART_HOST, &data->state.up.hostname, 0);
 1993|  2.98k|  if(uc) {
 1994|     43|    if(!strcasecompare("file", data->state.up.scheme))
 1995|      0|      return CURLE_OUT_OF_MEMORY;
 1996|     43|  }
 1997|       |
 1998|  2.98k|#ifndef CURL_DISABLE_HSTS
 1999|  2.98k|  if(data->hsts && strcasecompare("http", data->state.up.scheme)) {
 2000|      0|    if(Curl_hsts(data->hsts, data->state.up.hostname, TRUE)) {
 2001|      0|      char *url;
 2002|      0|      Curl_safefree(data->state.up.scheme);
 2003|      0|      uc = curl_url_set(uh, CURLUPART_SCHEME, "https", 0);
 2004|      0|      if(uc)
 2005|      0|        return Curl_uc_to_curlcode(uc);
 2006|      0|      if(data->state.url_alloc)
 2007|      0|        Curl_safefree(data->state.url);
 2008|       |      /* after update, get the updated version */
 2009|      0|      uc = curl_url_get(uh, CURLUPART_URL, &url, 0);
 2010|      0|      if(uc)
 2011|      0|        return Curl_uc_to_curlcode(uc);
 2012|      0|      uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);
 2013|      0|      if(uc) {
 2014|      0|        free(url);
 2015|      0|        return Curl_uc_to_curlcode(uc);
 2016|      0|      }
 2017|      0|      data->state.url = url;
 2018|      0|      data->state.url_alloc = TRUE;
 2019|      0|      infof(data, "Switched from HTTP to HTTPS due to HSTS => %s",
 2020|      0|            data->state.url);
 2021|      0|    }
 2022|      0|  }
 2023|  2.98k|#endif
 2024|       |
 2025|  2.98k|  result = findprotocol(data, conn, data->state.up.scheme);
 2026|  2.98k|  if(result)
 2027|     11|    return result;
 2028|       |
 2029|       |  /*
 2030|       |   * User name and password set with their own options override the
 2031|       |   * credentials possibly set in the URL.
 2032|       |   */
 2033|  2.97k|  if(!data->state.aptr.user) {
 2034|       |    /* we don't use the URL API's URL decoder option here since it rejects
 2035|       |       control codes and we want to allow them for some schemes in the user
 2036|       |       and password fields */
 2037|  2.72k|    uc = curl_url_get(uh, CURLUPART_USER, &data->state.up.user, 0);
 2038|  2.72k|    if(!uc) {
 2039|    240|      char *decoded;
 2040|    240|      result = Curl_urldecode(NULL, data->state.up.user, 0, &decoded, NULL,
 2041|    240|                              conn->handler->flags&PROTOPT_USERPWDCTRL ?
 2042|    132|                              REJECT_ZERO : REJECT_CTRL);
 2043|    240|      if(result)
 2044|      1|        return result;
 2045|    239|      conn->user = decoded;
 2046|    239|      conn->bits.user_passwd = TRUE;
 2047|    239|      result = Curl_setstropt(&data->state.aptr.user, decoded);
 2048|    239|      if(result)
 2049|      0|        return result;
 2050|    239|    }
 2051|  2.48k|    else if(uc != CURLUE_NO_USER)
 2052|      0|      return Curl_uc_to_curlcode(uc);
 2053|  2.72k|  }
 2054|       |
 2055|  2.97k|  if(!data->state.aptr.passwd) {
 2056|  2.92k|    uc = curl_url_get(uh, CURLUPART_PASSWORD, &data->state.up.password, 0);
 2057|  2.92k|    if(!uc) {
 2058|    114|      char *decoded;
 2059|    114|      result = Curl_urldecode(NULL, data->state.up.password, 0, &decoded, NULL,
 2060|    114|                              conn->handler->flags&PROTOPT_USERPWDCTRL ?
 2061|     62|                              REJECT_ZERO : REJECT_CTRL);
 2062|    114|      if(result)
 2063|      1|        return result;
 2064|    113|      conn->passwd = decoded;
 2065|    113|      conn->bits.user_passwd = TRUE;
 2066|    113|      result = Curl_setstropt(&data->state.aptr.passwd, decoded);
 2067|    113|      if(result)
 2068|      0|        return result;
 2069|    113|    }
 2070|  2.80k|    else if(uc != CURLUE_NO_PASSWORD)
 2071|      0|      return Curl_uc_to_curlcode(uc);
 2072|  2.92k|  }
 2073|       |
 2074|  2.97k|  uc = curl_url_get(uh, CURLUPART_OPTIONS, &data->state.up.options,
 2075|  2.97k|                    CURLU_URLDECODE);
 2076|  2.97k|  if(!uc) {
 2077|     61|    conn->options = strdup(data->state.up.options);
 2078|     61|    if(!conn->options)
 2079|      0|      return CURLE_OUT_OF_MEMORY;
 2080|     61|  }
 2081|  2.91k|  else if(uc != CURLUE_NO_OPTIONS)
 2082|      1|    return Curl_uc_to_curlcode(uc);
 2083|       |
 2084|  2.97k|  uc = curl_url_get(uh, CURLUPART_PATH, &data->state.up.path, 0);
 2085|  2.97k|  if(uc)
 2086|      0|    return Curl_uc_to_curlcode(uc);
 2087|       |
 2088|  2.97k|  uc = curl_url_get(uh, CURLUPART_PORT, &data->state.up.port,
 2089|  2.97k|                    CURLU_DEFAULT_PORT);
 2090|  2.97k|  if(uc) {
 2091|      0|    if(!strcasecompare("file", data->state.up.scheme))
 2092|      0|      return CURLE_OUT_OF_MEMORY;
 2093|      0|  }
 2094|  2.97k|  else {
 2095|  2.97k|    unsigned long port = strtoul(data->state.up.port, NULL, 10);
 2096|  2.97k|    conn->port = conn->remote_port =
 2097|  2.97k|      (data->set.use_port && data->state.allow_port) ?
 2098|  2.97k|      (int)data->set.use_port : curlx_ultous(port);
 2099|  2.97k|  }
 2100|       |
 2101|  2.97k|  (void)curl_url_get(uh, CURLUPART_QUERY, &data->state.up.query, 0);
 2102|       |
 2103|  2.97k|  hostname = data->state.up.hostname;
 2104|  2.97k|  if(hostname && hostname[0] == '[') {
 2105|       |    /* This looks like an IPv6 address literal. See if there is an address
 2106|       |       scope. */
 2107|     10|    size_t hlen;
 2108|     10|    conn->bits.ipv6_ip = TRUE;
 2109|       |    /* cut off the brackets! */
 2110|     10|    hostname++;
 2111|     10|    hlen = strlen(hostname);
 2112|     10|    hostname[hlen - 1] = 0;
 2113|       |
 2114|     10|    zonefrom_url(uh, data, conn);
 2115|     10|  }
 2116|       |
 2117|       |  /* make sure the connect struct gets its own copy of the host name */
 2118|  2.97k|  conn->host.rawalloc = strdup(hostname ? hostname : "");
 2119|  2.97k|  if(!conn->host.rawalloc)
 2120|      0|    return CURLE_OUT_OF_MEMORY;
 2121|  2.97k|  conn->host.name = conn->host.rawalloc;
 2122|       |
 2123|  2.97k|  if(data->set.scope_id)
 2124|       |    /* Override any scope that was set above.  */
 2125|      0|    conn->scope_id = data->set.scope_id;
 2126|       |
 2127|  2.97k|  return CURLE_OK;
 2128|  2.97k|}
url.c:findprotocol:
 1832|  2.98k|{
 1833|  2.98k|  const struct Curl_handler *p = Curl_builtin_scheme(protostr);
 1834|       |
 1835|  2.98k|  if(p && /* Protocol found in table. Check if allowed */
 1836|  2.98k|     (data->set.allowed_protocols & p->protocol)) {
 1837|       |
 1838|       |    /* it is allowed for "normal" request, now do an extra check if this is
 1839|       |       the result of a redirect */
 1840|  2.97k|    if(data->state.this_is_a_follow &&
 1841|  2.97k|       !(data->set.redir_protocols & p->protocol))
 1842|       |      /* nope, get out */
 1843|      0|      ;
 1844|  2.97k|    else {
 1845|       |      /* Perform setup complement if some. */
 1846|  2.97k|      conn->handler = conn->given = p;
 1847|       |
 1848|       |      /* 'port' and 'remote_port' are set in setup_connection_internals() */
 1849|  2.97k|      return CURLE_OK;
 1850|  2.97k|    }
 1851|  2.97k|  }
 1852|       |
 1853|       |  /* The protocol was not found in the table, but we don't have to assign it
 1854|       |     to anything since it is already assigned to a dummy-struct in the
 1855|       |     create_conn() function when the connectdata struct is allocated. */
 1856|     11|  failf(data, "Protocol \"%s\" not supported or disabled in " LIBCURL_NAME,
 1857|     11|        protostr);
 1858|       |
 1859|     11|  return CURLE_UNSUPPORTED_PROTOCOL;
 1860|  2.98k|}
url.c:zonefrom_url:
 1884|     10|{
 1885|     10|  char *zoneid;
 1886|     10|  CURLUcode uc = curl_url_get(uh, CURLUPART_ZONEID, &zoneid, 0);
 1887|       |#ifdef CURL_DISABLE_VERBOSE_STRINGS
 1888|       |  (void)data;
 1889|       |#endif
 1890|       |
 1891|     10|  if(!uc && zoneid) {
 1892|      0|    char *endp;
 1893|      0|    unsigned long scope = strtoul(zoneid, &endp, 10);
 1894|      0|    if(!*endp && (scope < UINT_MAX))
 1895|       |      /* A plain number, use it directly as a scope id. */
 1896|      0|      conn->scope_id = (unsigned int)scope;
 1897|      0|#if defined(HAVE_IF_NAMETOINDEX)
 1898|      0|    else {
 1899|       |#elif defined(WIN32)
 1900|       |    else if(Curl_if_nametoindex) {
 1901|       |#endif
 1902|       |
 1903|      0|#if defined(HAVE_IF_NAMETOINDEX) || defined(WIN32)
 1904|       |      /* Zone identifier is not numeric */
 1905|      0|      unsigned int scopeidx = 0;
 1906|       |#if defined(WIN32)
 1907|       |      scopeidx = Curl_if_nametoindex(zoneid);
 1908|       |#else
 1909|      0|      scopeidx = if_nametoindex(zoneid);
 1910|      0|#endif
 1911|      0|      if(!scopeidx) {
 1912|      0|#ifndef CURL_DISABLE_VERBOSE_STRINGS
 1913|      0|        char buffer[STRERROR_LEN];
 1914|      0|        infof(data, "Invalid zoneid: %s; %s", zoneid,
 1915|      0|              Curl_strerror(errno, buffer, sizeof(buffer)));
 1916|      0|#endif
 1917|      0|      }
 1918|      0|      else
 1919|      0|        conn->scope_id = scopeidx;
 1920|      0|    }
 1921|      0|#endif /* HAVE_IF_NAMETOINDEX || WIN32 */
 1922|       |
 1923|      0|    free(zoneid);
 1924|      0|  }
 1925|     10|}
url.c:create_conn_helper_init_proxy:
 2575|  2.97k|{
 2576|  2.97k|  char *proxy = NULL;
 2577|  2.97k|  char *socksproxy = NULL;
 2578|  2.97k|  char *no_proxy = NULL;
 2579|  2.97k|  CURLcode result = CURLE_OK;
 2580|       |
 2581|       |  /*************************************************************
 2582|       |   * Extract the user and password from the authentication string
 2583|       |   *************************************************************/
 2584|  2.97k|  if(conn->bits.proxy_user_passwd) {
 2585|      0|    result = parse_proxy_auth(data, conn);
 2586|      0|    if(result)
 2587|      0|      goto out;
 2588|      0|  }
 2589|       |
 2590|       |  /*************************************************************
 2591|       |   * Detect what (if any) proxy to use
 2592|       |   *************************************************************/
 2593|  2.97k|  if(data->set.str[STRING_PROXY]) {
 2594|      0|    proxy = strdup(data->set.str[STRING_PROXY]);
 2595|       |    /* if global proxy is set, this is it */
 2596|      0|    if(NULL == proxy) {
 2597|      0|      failf(data, "memory shortage");
 2598|      0|      result = CURLE_OUT_OF_MEMORY;
 2599|      0|      goto out;
 2600|      0|    }
 2601|      0|  }
 2602|       |
 2603|  2.97k|  if(data->set.str[STRING_PRE_PROXY]) {
 2604|      0|    socksproxy = strdup(data->set.str[STRING_PRE_PROXY]);
 2605|       |    /* if global socks proxy is set, this is it */
 2606|      0|    if(NULL == socksproxy) {
 2607|      0|      failf(data, "memory shortage");
 2608|      0|      result = CURLE_OUT_OF_MEMORY;
 2609|      0|      goto out;
 2610|      0|    }
 2611|      0|  }
 2612|       |
 2613|  2.97k|  if(!data->set.str[STRING_NOPROXY]) {
 2614|  2.97k|    const char *p = "no_proxy";
 2615|  2.97k|    no_proxy = curl_getenv(p);
 2616|  2.97k|    if(!no_proxy) {
 2617|  2.97k|      p = "NO_PROXY";
 2618|  2.97k|      no_proxy = curl_getenv(p);
 2619|  2.97k|    }
 2620|  2.97k|    if(no_proxy) {
 2621|      0|      infof(data, "Uses proxy env variable %s == '%s'", p, no_proxy);
 2622|      0|    }
 2623|  2.97k|  }
 2624|       |
 2625|  2.97k|  if(check_noproxy(conn->host.name, data->set.str[STRING_NOPROXY] ?
 2626|  2.97k|      data->set.str[STRING_NOPROXY] : no_proxy)) {
 2627|      0|    Curl_safefree(proxy);
 2628|      0|    Curl_safefree(socksproxy);
 2629|      0|  }
 2630|  2.97k|#ifndef CURL_DISABLE_HTTP
 2631|  2.97k|  else if(!proxy && !socksproxy)
 2632|       |    /* if the host is not in the noproxy list, detect proxy. */
 2633|  2.97k|    proxy = detect_proxy(data, conn);
 2634|  2.97k|#endif /* CURL_DISABLE_HTTP */
 2635|       |
 2636|  2.97k|  Curl_safefree(no_proxy);
 2637|       |
 2638|  2.97k|#ifdef USE_UNIX_SOCKETS
 2639|       |  /* For the time being do not mix proxy and unix domain sockets. See #1274 */
 2640|  2.97k|  if(proxy && conn->unix_domain_socket) {
 2641|      0|    free(proxy);
 2642|      0|    proxy = NULL;
 2643|      0|  }
 2644|  2.97k|#endif
 2645|       |
 2646|  2.97k|  if(proxy && (!*proxy || (conn->handler->flags & PROTOPT_NONETWORK))) {
 2647|      0|    free(proxy);  /* Don't bother with an empty proxy string or if the
 2648|       |                     protocol doesn't work with network */
 2649|      0|    proxy = NULL;
 2650|      0|  }
 2651|  2.97k|  if(socksproxy && (!*socksproxy ||
 2652|      0|                    (conn->handler->flags & PROTOPT_NONETWORK))) {
 2653|      0|    free(socksproxy);  /* Don't bother with an empty socks proxy string or if
 2654|       |                          the protocol doesn't work with network */
 2655|      0|    socksproxy = NULL;
 2656|      0|  }
 2657|       |
 2658|       |  /***********************************************************************
 2659|       |   * If this is supposed to use a proxy, we need to figure out the proxy host
 2660|       |   * name, proxy type and port number, so that we can re-use an existing
 2661|       |   * connection that may exist registered to the same proxy host.
 2662|       |   ***********************************************************************/
 2663|  2.97k|  if(proxy || socksproxy) {
 2664|      0|    if(proxy) {
 2665|      0|      result = parse_proxy(data, conn, proxy, conn->http_proxy.proxytype);
 2666|      0|      Curl_safefree(proxy); /* parse_proxy copies the proxy string */
 2667|      0|      if(result)
 2668|      0|        goto out;
 2669|      0|    }
 2670|       |
 2671|      0|    if(socksproxy) {
 2672|      0|      result = parse_proxy(data, conn, socksproxy,
 2673|      0|                           conn->socks_proxy.proxytype);
 2674|       |      /* parse_proxy copies the socks proxy string */
 2675|      0|      Curl_safefree(socksproxy);
 2676|      0|      if(result)
 2677|      0|        goto out;
 2678|      0|    }
 2679|       |
 2680|      0|    if(conn->http_proxy.host.rawalloc) {
 2681|       |#ifdef CURL_DISABLE_HTTP
 2682|       |      /* asking for a HTTP proxy is a bit funny when HTTP is disabled... */
 2683|       |      result = CURLE_UNSUPPORTED_PROTOCOL;
 2684|       |      goto out;
 2685|       |#else
 2686|       |      /* force this connection's protocol to become HTTP if compatible */
 2687|      0|      if(!(conn->handler->protocol & PROTO_FAMILY_HTTP)) {
 2688|      0|        if((conn->handler->flags & PROTOPT_PROXY_AS_HTTP) &&
 2689|      0|           !conn->bits.tunnel_proxy)
 2690|      0|          conn->handler = &Curl_handler_http;
 2691|      0|        else
 2692|       |          /* if not converting to HTTP over the proxy, enforce tunneling */
 2693|      0|          conn->bits.tunnel_proxy = TRUE;
 2694|      0|      }
 2695|      0|      conn->bits.httpproxy = TRUE;
 2696|      0|#endif
 2697|      0|    }
 2698|      0|    else {
 2699|      0|      conn->bits.httpproxy = FALSE; /* not a HTTP proxy */
 2700|      0|      conn->bits.tunnel_proxy = FALSE; /* no tunneling if not HTTP */
 2701|      0|    }
 2702|       |
 2703|      0|    if(conn->socks_proxy.host.rawalloc) {
 2704|      0|      if(!conn->http_proxy.host.rawalloc) {
 2705|       |        /* once a socks proxy */
 2706|      0|        if(!conn->socks_proxy.user) {
 2707|      0|          conn->socks_proxy.user = conn->http_proxy.user;
 2708|      0|          conn->http_proxy.user = NULL;
 2709|      0|          Curl_safefree(conn->socks_proxy.passwd);
 2710|      0|          conn->socks_proxy.passwd = conn->http_proxy.passwd;
 2711|      0|          conn->http_proxy.passwd = NULL;
 2712|      0|        }
 2713|      0|      }
 2714|      0|      conn->bits.socksproxy = TRUE;
 2715|      0|    }
 2716|      0|    else
 2717|      0|      conn->bits.socksproxy = FALSE; /* not a socks proxy */
 2718|      0|  }
 2719|  2.97k|  else {
 2720|  2.97k|    conn->bits.socksproxy = FALSE;
 2721|  2.97k|    conn->bits.httpproxy = FALSE;
 2722|  2.97k|  }
 2723|  2.97k|  conn->bits.proxy = conn->bits.httpproxy || conn->bits.socksproxy;
 2724|       |
 2725|  2.97k|  if(!conn->bits.proxy) {
 2726|       |    /* we aren't using the proxy after all... */
 2727|  2.97k|    conn->bits.proxy = FALSE;
 2728|  2.97k|    conn->bits.httpproxy = FALSE;
 2729|  2.97k|    conn->bits.socksproxy = FALSE;
 2730|  2.97k|    conn->bits.proxy_user_passwd = FALSE;
 2731|  2.97k|    conn->bits.tunnel_proxy = FALSE;
 2732|       |    /* CURLPROXY_HTTPS does not have its own flag in conn->bits, yet we need
 2733|       |       to signal that CURLPROXY_HTTPS is not used for this connection */
 2734|  2.97k|    conn->http_proxy.proxytype = CURLPROXY_HTTP;
 2735|  2.97k|  }
 2736|       |
 2737|  2.97k|out:
 2738|       |
 2739|  2.97k|  free(socksproxy);
 2740|  2.97k|  free(proxy);
 2741|  2.97k|  return result;
 2742|  2.97k|}
url.c:check_noproxy:
 2223|  2.97k|{
 2224|       |  /* no_proxy=domain1.dom,host.domain2.dom
 2225|       |   *   (a comma-separated list of hosts which should
 2226|       |   *   not be proxied, or an asterisk to override
 2227|       |   *   all proxy variables)
 2228|       |   */
 2229|  2.97k|  if(no_proxy && no_proxy[0]) {
 2230|      0|    size_t tok_start;
 2231|      0|    size_t tok_end;
 2232|      0|    const char *separator = ", ";
 2233|      0|    size_t no_proxy_len;
 2234|      0|    size_t namelen;
 2235|      0|    char *endptr;
 2236|      0|    if(strcasecompare("*", no_proxy)) {
 2237|      0|      return TRUE;
 2238|      0|    }
 2239|       |
 2240|       |    /* NO_PROXY was specified and it wasn't just an asterisk */
 2241|       |
 2242|      0|    no_proxy_len = strlen(no_proxy);
 2243|      0|    if(name[0] == '[') {
 2244|       |      /* IPv6 numerical address */
 2245|      0|      endptr = strchr(name, ']');
 2246|      0|      if(!endptr)
 2247|      0|        return FALSE;
 2248|      0|      name++;
 2249|      0|      namelen = endptr - name;
 2250|      0|    }
 2251|      0|    else
 2252|      0|      namelen = strlen(name);
 2253|       |
 2254|      0|    for(tok_start = 0; tok_start < no_proxy_len; tok_start = tok_end + 1) {
 2255|      0|      while(tok_start < no_proxy_len &&
 2256|      0|            strchr(separator, no_proxy[tok_start]) != NULL) {
 2257|       |        /* Look for the beginning of the token. */
 2258|      0|        ++tok_start;
 2259|      0|      }
 2260|       |
 2261|      0|      if(tok_start == no_proxy_len)
 2262|      0|        break; /* It was all trailing separator chars, no more tokens. */
 2263|       |
 2264|      0|      for(tok_end = tok_start; tok_end < no_proxy_len &&
 2265|      0|            strchr(separator, no_proxy[tok_end]) == NULL; ++tok_end)
 2266|       |        /* Look for the end of the token. */
 2267|      0|        ;
 2268|       |
 2269|       |      /* To match previous behavior, where it was necessary to specify
 2270|       |       * ".local.com" to prevent matching "notlocal.com", we will leave
 2271|       |       * the '.' off.
 2272|       |       */
 2273|      0|      if(no_proxy[tok_start] == '.')
 2274|      0|        ++tok_start;
 2275|       |
 2276|      0|      if((tok_end - tok_start) <= namelen) {
 2277|       |        /* Match the last part of the name to the domain we are checking. */
 2278|      0|        const char *checkn = name + namelen - (tok_end - tok_start);
 2279|      0|        if(strncasecompare(no_proxy + tok_start, checkn,
 2280|      0|                           tok_end - tok_start)) {
 2281|      0|          if((tok_end - tok_start) == namelen || *(checkn - 1) == '.') {
 2282|       |            /* We either have an exact match, or the previous character is a .
 2283|       |             * so it is within the same domain, so no proxy for this host.
 2284|       |             */
 2285|      0|            return TRUE;
 2286|      0|          }
 2287|      0|        }
 2288|      0|      } /* if((tok_end - tok_start) <= namelen) */
 2289|      0|    } /* for(tok_start = 0; tok_start < no_proxy_len;
 2290|       |         tok_start = tok_end + 1) */
 2291|      0|  } /* NO_PROXY was specified and it wasn't just an asterisk */
 2292|       |
 2293|  2.97k|  return FALSE;
 2294|  2.97k|}
url.c:detect_proxy:
 2304|  2.97k|{
 2305|  2.97k|  char *proxy = NULL;
 2306|       |
 2307|       |  /* If proxy was not specified, we check for default proxy environment
 2308|       |   * variables, to enable i.e Lynx compliance:
 2309|       |   *
 2310|       |   * http_proxy=http://some.server.dom:port/
 2311|       |   * https_proxy=http://some.server.dom:port/
 2312|       |   * ftp_proxy=http://some.server.dom:port/
 2313|       |   * no_proxy=domain1.dom,host.domain2.dom
 2314|       |   *   (a comma-separated list of hosts which should
 2315|       |   *   not be proxied, or an asterisk to override
 2316|       |   *   all proxy variables)
 2317|       |   * all_proxy=http://some.server.dom:port/
 2318|       |   *   (seems to exist for the CERN www lib. Probably
 2319|       |   *   the first to check for.)
 2320|       |   *
 2321|       |   * For compatibility, the all-uppercase versions of these variables are
 2322|       |   * checked if the lowercase versions don't exist.
 2323|       |   */
 2324|  2.97k|  char proxy_env[128];
 2325|  2.97k|  const char *protop = conn->handler->scheme;
 2326|  2.97k|  char *envp = proxy_env;
 2327|  2.97k|  char *prox;
 2328|       |#ifdef CURL_DISABLE_VERBOSE_STRINGS
 2329|       |  (void)data;
 2330|       |#endif
 2331|       |
 2332|       |  /* Now, build <protocol>_proxy and check for such a one to use */
 2333|  14.7k|  while(*protop)
 2334|  11.7k|    *envp++ = (char)tolower((int)*protop++);
 2335|       |
 2336|       |  /* append _proxy */
 2337|  2.97k|  strcpy(envp, "_proxy");
 2338|       |
 2339|       |  /* read the protocol proxy: */
 2340|  2.97k|  prox = curl_getenv(proxy_env);
 2341|       |
 2342|       |  /*
 2343|       |   * We don't try the uppercase version of HTTP_PROXY because of
 2344|       |   * security reasons:
 2345|       |   *
 2346|       |   * When curl is used in a webserver application
 2347|       |   * environment (cgi or php), this environment variable can
 2348|       |   * be controlled by the web server user by setting the
 2349|       |   * http header 'Proxy:' to some value.
 2350|       |   *
 2351|       |   * This can cause 'internal' http/ftp requests to be
 2352|       |   * arbitrarily redirected by any external attacker.
 2353|       |   */
 2354|  2.97k|  if(!prox && !strcasecompare("http_proxy", proxy_env)) {
 2355|       |    /* There was no lowercase variable, try the uppercase version: */
 2356|  1.74k|    Curl_strntoupper(proxy_env, proxy_env, sizeof(proxy_env));
 2357|  1.74k|    prox = curl_getenv(proxy_env);
 2358|  1.74k|  }
 2359|       |
 2360|  2.97k|  envp = proxy_env;
 2361|  2.97k|  if(prox) {
 2362|      0|    proxy = prox; /* use this */
 2363|      0|  }
 2364|  2.97k|  else {
 2365|  2.97k|    envp = (char *)"all_proxy";
 2366|  2.97k|    proxy = curl_getenv(envp); /* default proxy to use */
 2367|  2.97k|    if(!proxy) {
 2368|  2.97k|      envp = (char *)"ALL_PROXY";
 2369|  2.97k|      proxy = curl_getenv(envp);
 2370|  2.97k|    }
 2371|  2.97k|  }
 2372|  2.97k|  if(proxy)
 2373|      0|    infof(data, "Uses proxy env variable %s == '%s'", envp, proxy);
 2374|       |
 2375|  2.97k|  return proxy;
 2376|  2.97k|}
url.c:parse_remote_port:
 2888|  2.97k|{
 2889|       |
 2890|  2.97k|  if(data->set.use_port && data->state.allow_port) {
 2891|       |    /* if set, we use this instead of the port possibly given in the URL */
 2892|      0|    char portbuf[16];
 2893|      0|    CURLUcode uc;
 2894|      0|    conn->remote_port = (unsigned short)data->set.use_port;
 2895|      0|    msnprintf(portbuf, sizeof(portbuf), "%d", conn->remote_port);
 2896|      0|    uc = curl_url_set(data->state.uh, CURLUPART_PORT, portbuf, 0);
 2897|      0|    if(uc)
 2898|      0|      return CURLE_OUT_OF_MEMORY;
 2899|      0|  }
 2900|       |
 2901|  2.97k|  return CURLE_OK;
 2902|  2.97k|}
url.c:override_login:
 2910|  2.97k|{
 2911|  2.97k|  CURLUcode uc;
 2912|  2.97k|  char **userp = &conn->user;
 2913|  2.97k|  char **passwdp = &conn->passwd;
 2914|  2.97k|  char **optionsp = &conn->options;
 2915|       |
 2916|  2.97k|#ifndef CURL_DISABLE_NETRC
 2917|  2.97k|  if(data->set.use_netrc == CURL_NETRC_REQUIRED && conn->bits.user_passwd) {
 2918|      0|    Curl_safefree(*userp);
 2919|      0|    Curl_safefree(*passwdp);
 2920|      0|    conn->bits.user_passwd = FALSE; /* disable user+password */
 2921|      0|  }
 2922|  2.97k|#endif
 2923|       |
 2924|  2.97k|  if(data->set.str[STRING_OPTIONS]) {
 2925|      0|    free(*optionsp);
 2926|      0|    *optionsp = strdup(data->set.str[STRING_OPTIONS]);
 2927|      0|    if(!*optionsp)
 2928|      0|      return CURLE_OUT_OF_MEMORY;
 2929|      0|  }
 2930|       |
 2931|  2.97k|#ifndef CURL_DISABLE_NETRC
 2932|  2.97k|  conn->bits.netrc = FALSE;
 2933|  2.97k|  if(data->set.use_netrc && !data->set.str[STRING_USERNAME]) {
 2934|      0|    bool netrc_user_changed = FALSE;
 2935|      0|    bool netrc_passwd_changed = FALSE;
 2936|      0|    int ret;
 2937|       |
 2938|      0|    ret = Curl_parsenetrc(conn->host.name,
 2939|      0|                          userp, passwdp,
 2940|      0|                          &netrc_user_changed, &netrc_passwd_changed,
 2941|      0|                          data->set.str[STRING_NETRC_FILE]);
 2942|      0|    if(ret > 0) {
 2943|      0|      infof(data, "Couldn't find host %s in the %s file; using defaults",
 2944|      0|            conn->host.name, data->set.str[STRING_NETRC_FILE]);
 2945|      0|    }
 2946|      0|    else if(ret < 0) {
 2947|      0|      return CURLE_OUT_OF_MEMORY;
 2948|      0|    }
 2949|      0|    else {
 2950|       |      /* set bits.netrc TRUE to remember that we got the name from a .netrc
 2951|       |         file, so that it is safe to use even if we followed a Location: to a
 2952|       |         different host or similar. */
 2953|      0|      conn->bits.netrc = TRUE;
 2954|      0|      conn->bits.user_passwd = TRUE; /* enable user+password */
 2955|      0|    }
 2956|      0|  }
 2957|  2.97k|#endif
 2958|       |
 2959|       |  /* for updated strings, we update them in the URL */
 2960|  2.97k|  if(*userp) {
 2961|    238|    CURLcode result = Curl_setstropt(&data->state.aptr.user, *userp);
 2962|    238|    if(result)
 2963|      0|      return result;
 2964|    238|  }
 2965|  2.97k|  if(data->state.aptr.user) {
 2966|    494|    uc = curl_url_set(data->state.uh, CURLUPART_USER, data->state.aptr.user,
 2967|    494|                      CURLU_URLENCODE);
 2968|    494|    if(uc)
 2969|      0|      return Curl_uc_to_curlcode(uc);
 2970|    494|    if(!*userp) {
 2971|    256|      *userp = strdup(data->state.aptr.user);
 2972|    256|      if(!*userp)
 2973|      0|        return CURLE_OUT_OF_MEMORY;
 2974|    256|    }
 2975|    494|  }
 2976|       |
 2977|  2.97k|  if(*passwdp) {
 2978|    113|    CURLcode result = Curl_setstropt(&data->state.aptr.passwd, *passwdp);
 2979|    113|    if(result)
 2980|      0|      return result;
 2981|    113|  }
 2982|  2.97k|  if(data->state.aptr.passwd) {
 2983|    169|    uc = curl_url_set(data->state.uh, CURLUPART_PASSWORD,
 2984|    169|                      data->state.aptr.passwd, CURLU_URLENCODE);
 2985|    169|    if(uc)
 2986|      0|      return Curl_uc_to_curlcode(uc);
 2987|    169|    if(!*passwdp) {
 2988|     56|      *passwdp = strdup(data->state.aptr.passwd);
 2989|     56|      if(!*passwdp)
 2990|      0|        return CURLE_OUT_OF_MEMORY;
 2991|     56|    }
 2992|    169|  }
 2993|       |
 2994|  2.97k|  return CURLE_OK;
 2995|  2.97k|}
url.c:set_login:
 3001|  2.97k|{
 3002|  2.97k|  CURLcode result = CURLE_OK;
 3003|  2.97k|  const char *setuser = CURL_DEFAULT_USER;
 3004|  2.97k|  const char *setpasswd = CURL_DEFAULT_PASSWORD;
 3005|       |
 3006|       |  /* If our protocol needs a password and we have none, use the defaults */
 3007|  2.97k|  if((conn->handler->flags & PROTOPT_NEEDSPWD) && !conn->bits.user_passwd)
 3008|    161|    ;
 3009|  2.81k|  else {
 3010|  2.81k|    setuser = "";
 3011|  2.81k|    setpasswd = "";
 3012|  2.81k|  }
 3013|       |  /* Store the default user */
 3014|  2.97k|  if(!conn->user) {
 3015|  2.48k|    conn->user = strdup(setuser);
 3016|  2.48k|    if(!conn->user)
 3017|      0|      return CURLE_OUT_OF_MEMORY;
 3018|  2.48k|  }
 3019|       |
 3020|       |  /* Store the default password */
 3021|  2.97k|  if(!conn->passwd) {
 3022|  2.80k|    conn->passwd = strdup(setpasswd);
 3023|  2.80k|    if(!conn->passwd)
 3024|      0|      result = CURLE_OUT_OF_MEMORY;
 3025|  2.80k|  }
 3026|       |
 3027|  2.97k|  return result;
 3028|  2.97k|}
url.c:parse_connect_to_slist:
 3211|  2.97k|{
 3212|  2.97k|  CURLcode result = CURLE_OK;
 3213|  2.97k|  char *host = NULL;
 3214|  2.97k|  int port = -1;
 3215|       |
 3216|  5.95k|  while(conn_to_host && !host && port == -1) {
 3217|  2.97k|    result = parse_connect_to_string(data, conn, conn_to_host->data,
 3218|  2.97k|                                     &host, &port);
 3219|  2.97k|    if(result)
 3220|      0|      return result;
 3221|       |
 3222|  2.97k|    if(host && *host) {
 3223|  2.97k|      conn->conn_to_host.rawalloc = host;
 3224|  2.97k|      conn->conn_to_host.name = host;
 3225|  2.97k|      conn->bits.conn_to_host = TRUE;
 3226|       |
 3227|  2.97k|      infof(data, "Connecting to hostname: %s", host);
 3228|  2.97k|    }
 3229|      0|    else {
 3230|       |      /* no "connect to host" */
 3231|      0|      conn->bits.conn_to_host = FALSE;
 3232|      0|      Curl_safefree(host);
 3233|      0|    }
 3234|       |
 3235|  2.97k|    if(port >= 0) {
 3236|      0|      conn->conn_to_port = port;
 3237|      0|      conn->bits.conn_to_port = TRUE;
 3238|      0|      infof(data, "Connecting to port: %d", port);
 3239|      0|    }
 3240|  2.97k|    else {
 3241|       |      /* no "connect to port" */
 3242|  2.97k|      conn->bits.conn_to_port = FALSE;
 3243|  2.97k|      port = -1;
 3244|  2.97k|    }
 3245|       |
 3246|  2.97k|    conn_to_host = conn_to_host->next;
 3247|  2.97k|  }
 3248|       |
 3249|  2.97k|#ifndef CURL_DISABLE_ALTSVC
 3250|  2.97k|  if(data->asi && !host && (port == -1) &&
 3251|  2.97k|     ((conn->handler->protocol == CURLPROTO_HTTPS) ||
 3252|      0|#ifdef CURLDEBUG
 3253|       |      /* allow debug builds to circumvent the HTTPS restriction */
 3254|      0|      getenv("CURL_ALTSVC_HTTP")
 3255|       |#else
 3256|       |      0
 3257|       |#endif
 3258|      0|       )) {
 3259|       |    /* no connect_to match, try alt-svc! */
 3260|      0|    enum alpnid srcalpnid;
 3261|      0|    bool hit;
 3262|      0|    struct altsvc *as;
 3263|      0|    const int allowed_versions = ( ALPN_h1
 3264|      0|#ifdef USE_NGHTTP2
 3265|      0|      | ALPN_h2
 3266|      0|#endif
 3267|       |#ifdef ENABLE_QUIC
 3268|       |      | ALPN_h3
 3269|       |#endif
 3270|      0|      ) & data->asi->flags;
 3271|       |
 3272|      0|    host = conn->host.rawalloc;
 3273|      0|#ifdef USE_NGHTTP2
 3274|       |    /* with h2 support, check that first */
 3275|      0|    srcalpnid = ALPN_h2;
 3276|      0|    hit = Curl_altsvc_lookup(data->asi,
 3277|      0|                             srcalpnid, host, conn->remote_port, /* from */
 3278|      0|                             &as /* to */,
 3279|      0|                             allowed_versions);
 3280|      0|    if(!hit)
 3281|      0|#endif
 3282|      0|    {
 3283|      0|      srcalpnid = ALPN_h1;
 3284|      0|      hit = Curl_altsvc_lookup(data->asi,
 3285|      0|                               srcalpnid, host, conn->remote_port, /* from */
 3286|      0|                               &as /* to */,
 3287|      0|                               allowed_versions);
 3288|      0|    }
 3289|      0|    if(hit) {
 3290|      0|      char *hostd = strdup((char *)as->dst.host);
 3291|      0|      if(!hostd)
 3292|      0|        return CURLE_OUT_OF_MEMORY;
 3293|      0|      conn->conn_to_host.rawalloc = hostd;
 3294|      0|      conn->conn_to_host.name = hostd;
 3295|      0|      conn->bits.conn_to_host = TRUE;
 3296|      0|      conn->conn_to_port = as->dst.port;
 3297|      0|      conn->bits.conn_to_port = TRUE;
 3298|      0|      conn->bits.altused = TRUE;
 3299|      0|      infof(data, "Alt-svc connecting from [%s]%s:%d to [%s]%s:%d",
 3300|      0|            Curl_alpnid2str(srcalpnid), host, conn->remote_port,
 3301|      0|            Curl_alpnid2str(as->dst.alpnid), hostd, as->dst.port);
 3302|      0|      if(srcalpnid != as->dst.alpnid) {
 3303|       |        /* protocol version switch */
 3304|      0|        switch(as->dst.alpnid) {
 3305|      0|        case ALPN_h1:
 3306|      0|          conn->httpversion = 11;
 3307|      0|          break;
 3308|      0|        case ALPN_h2:
 3309|      0|          conn->httpversion = 20;
 3310|      0|          break;
 3311|      0|        case ALPN_h3:
 3312|      0|          conn->transport = TRNSPRT_QUIC;
 3313|      0|          conn->httpversion = 30;
 3314|      0|          break;
 3315|      0|        default: /* shouldn't be possible */
 3316|      0|          break;
 3317|      0|        }
 3318|      0|      }
 3319|      0|    }
 3320|      0|  }
 3321|  2.97k|#endif
 3322|       |
 3323|  2.97k|  return result;
 3324|  2.97k|}
url.c:parse_connect_to_string:
 3143|  2.97k|{
 3144|  2.97k|  CURLcode result = CURLE_OK;
 3145|  2.97k|  const char *ptr = conn_to_host;
 3146|  2.97k|  int host_match = FALSE;
 3147|  2.97k|  int port_match = FALSE;
 3148|       |
 3149|  2.97k|  *host_result = NULL;
 3150|  2.97k|  *port_result = -1;
 3151|       |
 3152|  2.97k|  if(*ptr == ':') {
 3153|       |    /* an empty hostname always matches */
 3154|  2.97k|    host_match = TRUE;
 3155|  2.97k|    ptr++;
 3156|  2.97k|  }
 3157|      0|  else {
 3158|       |    /* check whether the URL's hostname matches */
 3159|      0|    size_t hostname_to_match_len;
 3160|      0|    char *hostname_to_match = aprintf("%s%s%s",
 3161|      0|                                      conn->bits.ipv6_ip ? "[" : "",
 3162|      0|                                      conn->host.name,
 3163|      0|                                      conn->bits.ipv6_ip ? "]" : "");
 3164|      0|    if(!hostname_to_match)
 3165|      0|      return CURLE_OUT_OF_MEMORY;
 3166|      0|    hostname_to_match_len = strlen(hostname_to_match);
 3167|      0|    host_match = strncasecompare(ptr, hostname_to_match,
 3168|      0|                                 hostname_to_match_len);
 3169|      0|    free(hostname_to_match);
 3170|      0|    ptr += hostname_to_match_len;
 3171|       |
 3172|      0|    host_match = host_match && *ptr == ':';
 3173|      0|    ptr++;
 3174|      0|  }
 3175|       |
 3176|  2.97k|  if(host_match) {
 3177|  2.97k|    if(*ptr == ':') {
 3178|       |      /* an empty port always matches */
 3179|  2.97k|      port_match = TRUE;
 3180|  2.97k|      ptr++;
 3181|  2.97k|    }
 3182|      0|    else {
 3183|       |      /* check whether the URL's port matches */
 3184|      0|      char *ptr_next = strchr(ptr, ':');
 3185|      0|      if(ptr_next) {
 3186|      0|        char *endp = NULL;
 3187|      0|        long port_to_match = strtol(ptr, &endp, 10);
 3188|      0|        if((endp == ptr_next) && (port_to_match == conn->remote_port)) {
 3189|      0|          port_match = TRUE;
 3190|      0|          ptr = ptr_next + 1;
 3191|      0|        }
 3192|      0|      }
 3193|      0|    }
 3194|  2.97k|  }
 3195|       |
 3196|  2.97k|  if(host_match && port_match) {
 3197|       |    /* parse the hostname and port to connect to */
 3198|  2.97k|    result = parse_connect_to_host_port(data, ptr, host_result, port_result);
 3199|  2.97k|  }
 3200|       |
 3201|  2.97k|  return result;
 3202|  2.97k|}
url.c:parse_connect_to_host_port:
 3039|  2.97k|{
 3040|  2.97k|  char *host_dup;
 3041|  2.97k|  char *hostptr;
 3042|  2.97k|  char *host_portno;
 3043|  2.97k|  char *portptr;
 3044|  2.97k|  int port = -1;
 3045|  2.97k|  CURLcode result = CURLE_OK;
 3046|       |
 3047|       |#if defined(CURL_DISABLE_VERBOSE_STRINGS)
 3048|       |  (void) data;
 3049|       |#endif
 3050|       |
 3051|  2.97k|  *hostname_result = NULL;
 3052|  2.97k|  *port_result = -1;
 3053|       |
 3054|  2.97k|  if(!host || !*host)
 3055|      0|    return CURLE_OK;
 3056|       |
 3057|  2.97k|  host_dup = strdup(host);
 3058|  2.97k|  if(!host_dup)
 3059|      0|    return CURLE_OUT_OF_MEMORY;
 3060|       |
 3061|  2.97k|  hostptr = host_dup;
 3062|       |
 3063|       |  /* start scanning for port number at this point */
 3064|  2.97k|  portptr = hostptr;
 3065|       |
 3066|       |  /* detect and extract RFC6874-style IPv6-addresses */
 3067|  2.97k|  if(*hostptr == '[') {
 3068|      0|#ifdef ENABLE_IPV6
 3069|      0|    char *ptr = ++hostptr; /* advance beyond the initial bracket */
 3070|      0|    while(*ptr && (ISXDIGIT(*ptr) || (*ptr == ':') || (*ptr == '.')))
 3071|      0|      ptr++;
 3072|      0|    if(*ptr == '%') {
 3073|       |      /* There might be a zone identifier */
 3074|      0|      if(strncmp("%25", ptr, 3))
 3075|      0|        infof(data, "Please URL encode %% as %%25, see RFC 6874.");
 3076|      0|      ptr++;
 3077|       |      /* Allow unreserved characters as defined in RFC 3986 */
 3078|      0|      while(*ptr && (ISALPHA(*ptr) || ISXDIGIT(*ptr) || (*ptr == '-') ||
 3079|      0|                     (*ptr == '.') || (*ptr == '_') || (*ptr == '~')))
 3080|      0|        ptr++;
 3081|      0|    }
 3082|      0|    if(*ptr == ']')
 3083|       |      /* yeps, it ended nicely with a bracket as well */
 3084|      0|      *ptr++ = '\0';
 3085|      0|    else
 3086|      0|      infof(data, "Invalid IPv6 address format");
 3087|      0|    portptr = ptr;
 3088|       |    /* Note that if this didn't end with a bracket, we still advanced the
 3089|       |     * hostptr first, but I can't see anything wrong with that as no host
 3090|       |     * name nor a numeric can legally start with a bracket.
 3091|       |     */
 3092|       |#else
 3093|       |    failf(data, "Use of IPv6 in *_CONNECT_TO without IPv6 support built-in!");
 3094|       |    result = CURLE_NOT_BUILT_IN;
 3095|       |    goto error;
 3096|       |#endif
 3097|      0|  }
 3098|       |
 3099|       |  /* Get port number off server.com:1080 */
 3100|  2.97k|  host_portno = strchr(portptr, ':');
 3101|  2.97k|  if(host_portno) {
 3102|  2.97k|    char *endp = NULL;
 3103|  2.97k|    *host_portno = '\0'; /* cut off number from host name */
 3104|  2.97k|    host_portno++;
 3105|  2.97k|    if(*host_portno) {
 3106|      0|      long portparse = strtol(host_portno, &endp, 10);
 3107|      0|      if((endp && *endp) || (portparse < 0) || (portparse > 65535)) {
 3108|      0|        failf(data, "No valid port number in connect to host string (%s)",
 3109|      0|              host_portno);
 3110|      0|        result = CURLE_SETOPT_OPTION_SYNTAX;
 3111|      0|        goto error;
 3112|      0|      }
 3113|      0|      else
 3114|      0|        port = (int)portparse; /* we know it will fit */
 3115|      0|    }
 3116|  2.97k|  }
 3117|       |
 3118|       |  /* now, clone the cleaned host name */
 3119|  2.97k|  if(hostptr) {
 3120|  2.97k|    *hostname_result = strdup(hostptr);
 3121|  2.97k|    if(!*hostname_result) {
 3122|      0|      result = CURLE_OUT_OF_MEMORY;
 3123|      0|      goto error;
 3124|      0|    }
 3125|  2.97k|  }
 3126|       |
 3127|  2.97k|  *port_result = port;
 3128|       |
 3129|  2.97k|  error:
 3130|  2.97k|  free(host_dup);
 3131|  2.97k|  return result;
 3132|  2.97k|}
url.c:setup_connection_internals:
 2174|  2.97k|{
 2175|  2.97k|  const struct Curl_handler *p;
 2176|  2.97k|  CURLcode result;
 2177|       |
 2178|       |  /* Perform setup complement if some. */
 2179|  2.97k|  p = conn->handler;
 2180|       |
 2181|  2.97k|  if(p->setup_connection) {
 2182|  2.93k|    result = (*p->setup_connection)(data, conn);
 2183|       |
 2184|  2.93k|    if(result)
 2185|      0|      return result;
 2186|       |
 2187|  2.93k|    p = conn->handler;              /* May have changed. */
 2188|  2.93k|  }
 2189|       |
 2190|  2.97k|  if(conn->port < 0)
 2191|       |    /* we check for -1 here since if proxy was detected already, this
 2192|       |       was very likely already set to the proxy port */
 2193|      0|    conn->port = p->defport;
 2194|       |
 2195|  2.97k|  return CURLE_OK;
 2196|  2.97k|}
url.c:setup_range:
 2136|  2.96k|{
 2137|  2.96k|  struct UrlState *s = &data->state;
 2138|  2.96k|  s->resume_from = data->set.set_resume_from;
 2139|  2.96k|  if(s->resume_from || data->set.str[STRING_SET_RANGE]) {
 2140|     52|    if(s->rangestringalloc)
 2141|      2|      free(s->range);
 2142|       |
 2143|     52|    if(s->resume_from)
 2144|      0|      s->range = aprintf("%" CURL_FORMAT_CURL_OFF_T "-", s->resume_from);
 2145|     52|    else
 2146|     52|      s->range = strdup(data->set.str[STRING_SET_RANGE]);
 2147|       |
 2148|     52|    s->rangestringalloc = (s->range) ? TRUE : FALSE;
 2149|       |
 2150|     52|    if(!s->range)
 2151|      0|      return CURLE_OUT_OF_MEMORY;
 2152|       |
 2153|       |    /* tell ourselves to fetch this range */
 2154|     52|    s->use_range = TRUE;        /* enable range download */
 2155|     52|  }
 2156|  2.91k|  else
 2157|  2.91k|    s->use_range = FALSE; /* disable range download */
 2158|       |
 2159|  2.96k|  return CURLE_OK;
 2160|  2.96k|}
url.c:prune_dead_connections:
 1077|  2.93k|{
 1078|  2.93k|  struct curltime now = Curl_now();
 1079|  2.93k|  timediff_t elapsed;
 1080|       |
 1081|  2.93k|  DEBUGASSERT(!data->conn); /* no connection */
 1082|  2.93k|  CONNCACHE_LOCK(data);
 1083|  2.93k|  elapsed =
 1084|  2.93k|    Curl_timediff(now, data->state.conn_cache->last_cleanup);
 1085|  2.93k|  CONNCACHE_UNLOCK(data);
 1086|       |
 1087|  2.93k|  if(elapsed >= 1000L) {
 1088|  2.81k|    struct prunedead prune;
 1089|  2.81k|    prune.data = data;
 1090|  2.81k|    prune.extracted = NULL;
 1091|  2.81k|    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
 1092|  2.81k|                                 call_extract_if_dead)) {
 1093|       |      /* unlocked */
 1094|       |
 1095|       |      /* remove connection from cache */
 1096|      0|      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
 1097|       |
 1098|       |      /* disconnect it */
 1099|      0|      (void)Curl_disconnect(data, prune.extracted, TRUE);
 1100|      0|    }
 1101|  2.81k|    CONNCACHE_LOCK(data);
 1102|  2.81k|    data->state.conn_cache->last_cleanup = now;
 1103|  2.81k|    CONNCACHE_UNLOCK(data);
 1104|  2.81k|  }
 1105|  2.93k|}
url.c:extract_if_dead:
 1010|     65|{
 1011|     65|  if(!CONN_INUSE(conn)) {
 1012|       |    /* The check for a dead socket makes sense only if the connection isn't in
 1013|       |       use */
 1014|     65|    bool dead;
 1015|     65|    struct curltime now = Curl_now();
 1016|     65|    if(conn_maxage(data, conn, now)) {
 1017|       |      /* avoid check if already too old */
 1018|      0|      dead = TRUE;
 1019|      0|    }
 1020|     65|    else if(conn->handler->connection_check) {
 1021|       |      /* The protocol has a special method for checking the state of the
 1022|       |         connection. Use it to check if the connection is dead. */
 1023|      0|      unsigned int state;
 1024|       |
 1025|       |      /* briefly attach the connection to this transfer for the purpose of
 1026|       |         checking it */
 1027|      0|      Curl_attach_connnection(data, conn);
 1028|       |
 1029|      0|      state = conn->handler->connection_check(data, conn, CONNCHECK_ISDEAD);
 1030|      0|      dead = (state & CONNRESULT_DEAD);
 1031|       |      /* detach the connection again */
 1032|      0|      Curl_detach_connnection(data);
 1033|       |
 1034|      0|    }
 1035|     65|    else {
 1036|       |      /* Use the general method for determining the death of a connection */
 1037|     65|      dead = SocketIsDead(conn->sock[FIRSTSOCKET]);
 1038|     65|    }
 1039|       |
 1040|     65|    if(dead) {
 1041|     55|      infof(data, "Connection %ld seems to be dead!", conn->connection_id);
 1042|     55|      Curl_conncache_remove_conn(data, conn, FALSE);
 1043|     55|      return TRUE;
 1044|     55|    }
 1045|     65|  }
 1046|     10|  return FALSE;
 1047|     65|}
url.c:conn_maxage:
  973|     65|{
  974|     65|  timediff_t idletime, lifetime;
  975|       |
  976|     65|  idletime = Curl_timediff(now, conn->lastused);
  977|     65|  idletime /= 1000; /* integer seconds is fine */
  978|       |
  979|     65|  if(idletime > data->set.maxage_conn) {
  980|      0|    infof(data, "Too old connection (%ld seconds idle), disconnect it",
  981|      0|          idletime);
  982|      0|    return TRUE;
  983|      0|  }
  984|       |
  985|     65|  lifetime = Curl_timediff(now, conn->created);
  986|     65|  lifetime /= 1000; /* integer seconds is fine */
  987|       |
  988|     65|  if(data->set.maxlifetime_conn && lifetime > data->set.maxlifetime_conn) {
  989|      0|    infof(data,
  990|      0|          "Too old connection (%ld seconds since creation), disconnect it",
  991|      0|          lifetime);
  992|      0|    return TRUE;
  993|      0|  }
  994|       |
  995|       |
  996|     65|  return FALSE;
  997|     65|}
url.c:SocketIsDead:
  886|     65|{
  887|     65|  int sval;
  888|     65|  bool ret_val = TRUE;
  889|       |
  890|     65|  sval = SOCKET_READABLE(sock, 0);
  891|     65|  if(sval == 0)
  892|       |    /* timeout */
  893|     10|    ret_val = FALSE;
  894|       |
  895|     65|  return ret_val;
  896|     65|}
url.c:ConnectionExists:
 1124|  2.93k|{
 1125|  2.93k|  struct connectdata *check;
 1126|  2.93k|  struct connectdata *chosen = 0;
 1127|  2.93k|  bool foundPendingCandidate = FALSE;
 1128|  2.93k|  bool canmultiplex = IsMultiplexingPossible(data, needle);
 1129|  2.93k|  struct connectbundle *bundle;
 1130|  2.93k|  const char *hostbundle;
 1131|       |
 1132|  2.93k|#ifdef USE_NTLM
 1133|  2.93k|  bool wantNTLMhttp = ((data->state.authhost.want &
 1134|  2.93k|                        (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
 1135|  2.93k|                       (needle->handler->protocol & PROTO_FAMILY_HTTP));
 1136|  2.93k|#ifndef CURL_DISABLE_PROXY
 1137|  2.93k|  bool wantProxyNTLMhttp = (needle->bits.proxy_user_passwd &&
 1138|  2.93k|                            ((data->state.authproxy.want &
 1139|      0|                              (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
 1140|      0|                             (needle->handler->protocol & PROTO_FAMILY_HTTP)));
 1141|       |#else
 1142|       |  bool wantProxyNTLMhttp = FALSE;
 1143|       |#endif
 1144|  2.93k|#endif
 1145|       |
 1146|  2.93k|  *force_reuse = FALSE;
 1147|  2.93k|  *waitpipe = FALSE;
 1148|       |
 1149|       |  /* Look up the bundle with all the connections to this particular host.
 1150|       |     Locks the connection cache, beware of early returns! */
 1151|  2.93k|  bundle = Curl_conncache_find_bundle(data, needle, data->state.conn_cache,
 1152|  2.93k|                                      &hostbundle);
 1153|  2.93k|  if(bundle) {
 1154|       |    /* Max pipe length is zero (unlimited) for multiplexed connections */
 1155|     65|    struct Curl_llist_element *curr;
 1156|       |
 1157|     65|    infof(data, "Found bundle for host %s: %p [%s]",
 1158|     65|          hostbundle, (void *)bundle, (bundle->multiuse == BUNDLE_MULTIPLEX ?
 1159|     55|                                       "can multiplex" : "serially"));
 1160|       |
 1161|       |    /* We can't multiplex if we don't know anything about the server */
 1162|     65|    if(canmultiplex) {
 1163|     61|      if(bundle->multiuse == BUNDLE_UNKNOWN) {
 1164|      0|        if(data->set.pipewait) {
 1165|      0|          infof(data, "Server doesn't support multiplex yet, wait");
 1166|      0|          *waitpipe = TRUE;
 1167|      0|          CONNCACHE_UNLOCK(data);
 1168|      0|          return FALSE; /* no re-use */
 1169|      0|        }
 1170|       |
 1171|      0|        infof(data, "Server doesn't support multiplex (yet)");
 1172|      0|        canmultiplex = FALSE;
 1173|      0|      }
 1174|     61|      if((bundle->multiuse == BUNDLE_MULTIPLEX) &&
 1175|     61|         !Curl_multiplex_wanted(data->multi)) {
 1176|      0|        infof(data, "Could multiplex, but not asked to!");
 1177|      0|        canmultiplex = FALSE;
 1178|      0|      }
 1179|     61|      if(bundle->multiuse == BUNDLE_NO_MULTIUSE) {
 1180|     51|        infof(data, "Can not multiplex, even if we wanted to!");
 1181|     51|        canmultiplex = FALSE;
 1182|     51|      }
 1183|     61|    }
 1184|       |
 1185|     65|    curr = bundle->conn_list.head;
 1186|    130|    while(curr) {
 1187|     65|      bool match = FALSE;
 1188|     65|      size_t multiplexed = 0;
 1189|       |
 1190|       |      /*
 1191|       |       * Note that if we use a HTTP proxy in normal mode (no tunneling), we
 1192|       |       * check connections to that proxy and not to the actual remote server.
 1193|       |       */
 1194|     65|      check = curr->ptr;
 1195|     65|      curr = curr->next;
 1196|       |
 1197|     65|      if(check->bits.connect_only || check->bits.close)
 1198|       |        /* connect-only or to-be-closed connections will not be reused */
 1199|      0|        continue;
 1200|       |
 1201|     65|      if(extract_if_dead(check, data)) {
 1202|       |        /* disconnect it */
 1203|     55|        (void)Curl_disconnect(data, check, TRUE);
 1204|     55|        continue;
 1205|     55|      }
 1206|       |
 1207|     10|      if(data->set.ipver != CURL_IPRESOLVE_WHATEVER
 1208|     10|          && data->set.ipver != check->ip_version) {
 1209|       |        /* skip because the connection is not via the requested IP version */
 1210|      0|        continue;
 1211|      0|      }
 1212|       |
 1213|     10|      if(bundle->multiuse == BUNDLE_MULTIPLEX)
 1214|      0|        multiplexed = CONN_INUSE(check);
 1215|       |
 1216|     10|      if(!canmultiplex) {
 1217|     10|        if(multiplexed) {
 1218|       |          /* can only happen within multi handles, and means that another easy
 1219|       |             handle is using this connection */
 1220|      0|          continue;
 1221|      0|        }
 1222|       |
 1223|     10|        if(Curl_resolver_asynch()) {
 1224|       |          /* primary_ip[0] is NUL only if the resolving of the name hasn't
 1225|       |             completed yet and until then we don't re-use this connection */
 1226|     10|          if(!check->primary_ip[0]) {
 1227|     10|            infof(data,
 1228|     10|                  "Connection #%ld is still name resolving, can't reuse",
 1229|     10|                  check->connection_id);
 1230|     10|            continue;
 1231|     10|          }
 1232|     10|        }
 1233|       |
 1234|      0|        if(check->sock[FIRSTSOCKET] == CURL_SOCKET_BAD) {
 1235|      0|          foundPendingCandidate = TRUE;
 1236|       |          /* Don't pick a connection that hasn't connected yet */
 1237|      0|          infof(data, "Connection #%ld isn't open enough, can't reuse",
 1238|      0|                check->connection_id);
 1239|      0|          continue;
 1240|      0|        }
 1241|      0|      }
 1242|       |
 1243|      0|#ifdef USE_UNIX_SOCKETS
 1244|      0|      if(needle->unix_domain_socket) {
 1245|      0|        if(!check->unix_domain_socket)
 1246|      0|          continue;
 1247|      0|        if(strcmp(needle->unix_domain_socket, check->unix_domain_socket))
 1248|      0|          continue;
 1249|      0|        if(needle->bits.abstract_unix_socket !=
 1250|      0|           check->bits.abstract_unix_socket)
 1251|      0|          continue;
 1252|      0|      }
 1253|      0|      else if(check->unix_domain_socket)
 1254|      0|        continue;
 1255|      0|#endif
 1256|       |
 1257|      0|      if((needle->handler->flags&PROTOPT_SSL) !=
 1258|      0|         (check->handler->flags&PROTOPT_SSL))
 1259|       |        /* don't do mixed SSL and non-SSL connections */
 1260|      0|        if(get_protocol_family(check->handler) !=
 1261|      0|           needle->handler->protocol || !check->bits.tls_upgraded)
 1262|       |          /* except protocols that have been upgraded via TLS */
 1263|      0|          continue;
 1264|       |
 1265|      0|#ifndef CURL_DISABLE_PROXY
 1266|      0|      if(needle->bits.httpproxy != check->bits.httpproxy ||
 1267|      0|         needle->bits.socksproxy != check->bits.socksproxy)
 1268|      0|        continue;
 1269|       |
 1270|      0|      if(needle->bits.socksproxy &&
 1271|      0|        !socks_proxy_info_matches(&needle->socks_proxy,
 1272|      0|                                  &check->socks_proxy))
 1273|      0|        continue;
 1274|      0|#endif
 1275|      0|      if(needle->bits.conn_to_host != check->bits.conn_to_host)
 1276|       |        /* don't mix connections that use the "connect to host" feature and
 1277|       |         * connections that don't use this feature */
 1278|      0|        continue;
 1279|       |
 1280|      0|      if(needle->bits.conn_to_port != check->bits.conn_to_port)
 1281|       |        /* don't mix connections that use the "connect to port" feature and
 1282|       |         * connections that don't use this feature */
 1283|      0|        continue;
 1284|       |
 1285|      0|#ifndef CURL_DISABLE_PROXY
 1286|      0|      if(needle->bits.httpproxy) {
 1287|      0|        if(!proxy_info_matches(&needle->http_proxy, &check->http_proxy))
 1288|      0|          continue;
 1289|       |
 1290|      0|        if(needle->bits.tunnel_proxy != check->bits.tunnel_proxy)
 1291|      0|          continue;
 1292|       |
 1293|      0|        if(needle->http_proxy.proxytype == CURLPROXY_HTTPS) {
 1294|       |          /* use https proxy */
 1295|      0|          if(needle->handler->flags&PROTOPT_SSL) {
 1296|       |            /* use double layer ssl */
 1297|      0|            if(!Curl_ssl_config_matches(&needle->proxy_ssl_config,
 1298|      0|                                        &check->proxy_ssl_config))
 1299|      0|              continue;
 1300|      0|            if(check->proxy_ssl[FIRSTSOCKET].state != ssl_connection_complete)
 1301|      0|              continue;
 1302|      0|          }
 1303|      0|          else {
 1304|      0|            if(!Curl_ssl_config_matches(&needle->ssl_config,
 1305|      0|                                        &check->ssl_config))
 1306|      0|              continue;
 1307|      0|            if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete)
 1308|      0|              continue;
 1309|      0|          }
 1310|      0|        }
 1311|      0|      }
 1312|      0|#endif
 1313|       |
 1314|      0|      if(!canmultiplex && CONN_INUSE(check))
 1315|       |        /* this request can't be multiplexed but the checked connection is
 1316|       |           already in use so we skip it */
 1317|      0|        continue;
 1318|       |
 1319|      0|      if(CONN_INUSE(check)) {
 1320|       |        /* Subject for multiplex use if 'checks' belongs to the same multi
 1321|       |           handle as 'data' is. */
 1322|      0|        struct Curl_llist_element *e = check->easyq.head;
 1323|      0|        struct Curl_easy *entry = e->ptr;
 1324|      0|        if(entry->multi != data->multi)
 1325|      0|          continue;
 1326|      0|      }
 1327|       |
 1328|      0|      if(needle->localdev || needle->localport) {
 1329|       |        /* If we are bound to a specific local end (IP+port), we must not
 1330|       |           re-use a random other one, although if we didn't ask for a
 1331|       |           particular one we can reuse one that was bound.
 1332|       |
 1333|       |           This comparison is a bit rough and too strict. Since the input
 1334|       |           parameters can be specified in numerous ways and still end up the
 1335|       |           same it would take a lot of processing to make it really accurate.
 1336|       |           Instead, this matching will assume that re-uses of bound connections
 1337|       |           will most likely also re-use the exact same binding parameters and
 1338|       |           missing out a few edge cases shouldn't hurt anyone very much.
 1339|       |        */
 1340|      0|        if((check->localport != needle->localport) ||
 1341|      0|           (check->localportrange != needle->localportrange) ||
 1342|      0|           (needle->localdev &&
 1343|      0|            (!check->localdev || strcmp(check->localdev, needle->localdev))))
 1344|      0|          continue;
 1345|      0|      }
 1346|       |
 1347|      0|      if(!(needle->handler->flags & PROTOPT_CREDSPERREQUEST)) {
 1348|       |        /* This protocol requires credentials per connection,
 1349|       |           so verify that we're using the same name and password as well */
 1350|      0|        if(strcmp(needle->user, check->user) ||
 1351|      0|           strcmp(needle->passwd, check->passwd)) {
 1352|       |          /* one of them was different */
 1353|      0|          continue;
 1354|      0|        }
 1355|      0|      }
 1356|       |
 1357|       |      /* If multiplexing isn't enabled on the h2 connection and h1 is
 1358|       |         explicitly requested, handle it: */
 1359|      0|      if((needle->handler->protocol & PROTO_FAMILY_HTTP) &&
 1360|      0|         (check->httpversion >= 20) &&
 1361|      0|         (data->state.httpwant < CURL_HTTP_VERSION_2_0))
 1362|      0|        continue;
 1363|       |
 1364|      0|      if((needle->handler->flags&PROTOPT_SSL)
 1365|      0|#ifndef CURL_DISABLE_PROXY
 1366|      0|         || !needle->bits.httpproxy || needle->bits.tunnel_proxy
 1367|      0|#endif
 1368|      0|        ) {
 1369|       |        /* The requested connection does not use a HTTP proxy or it uses SSL or
 1370|       |           it is a non-SSL protocol tunneled or it is a non-SSL protocol which
 1371|       |           is allowed to be upgraded via TLS */
 1372|       |
 1373|      0|        if((strcasecompare(needle->handler->scheme, check->handler->scheme) ||
 1374|      0|            (get_protocol_family(check->handler) ==
 1375|      0|             needle->handler->protocol && check->bits.tls_upgraded)) &&
 1376|      0|           (!needle->bits.conn_to_host || strcasecompare(
 1377|      0|            needle->conn_to_host.name, check->conn_to_host.name)) &&
 1378|      0|           (!needle->bits.conn_to_port ||
 1379|      0|             needle->conn_to_port == check->conn_to_port) &&
 1380|      0|           strcasecompare(needle->host.name, check->host.name) &&
 1381|      0|           needle->remote_port == check->remote_port) {
 1382|       |          /* The schemes match or the protocol family is the same and the
 1383|       |             previous connection was TLS upgraded, and the hostname and host
 1384|       |             port match */
 1385|      0|          if(needle->handler->flags & PROTOPT_SSL) {
 1386|       |            /* This is a SSL connection so verify that we're using the same
 1387|       |               SSL options as well */
 1388|      0|            if(!Curl_ssl_config_matches(&needle->ssl_config,
 1389|      0|                                        &check->ssl_config)) {
 1390|      0|              DEBUGF(infof(data,
 1391|      0|                           "Connection #%ld has different SSL parameters, "
 1392|      0|                           "can't reuse",
 1393|      0|                           check->connection_id));
 1394|      0|              continue;
 1395|      0|            }
 1396|      0|            if(check->ssl[FIRSTSOCKET].state != ssl_connection_complete) {
 1397|      0|              foundPendingCandidate = TRUE;
 1398|      0|              DEBUGF(infof(data,
 1399|      0|                           "Connection #%ld has not started SSL connect, "
 1400|      0|                           "can't reuse",
 1401|      0|                           check->connection_id));
 1402|      0|              continue;
 1403|      0|            }
 1404|      0|          }
 1405|      0|          match = TRUE;
 1406|      0|        }
 1407|      0|      }
 1408|      0|      else {
 1409|       |        /* The requested connection is using the same HTTP proxy in normal
 1410|       |           mode (no tunneling) */
 1411|      0|        match = TRUE;
 1412|      0|      }
 1413|       |
 1414|      0|      if(match) {
 1415|      0|#if defined(USE_NTLM)
 1416|       |        /* If we are looking for an HTTP+NTLM connection, check if this is
 1417|       |           already authenticating with the right credentials. If not, keep
 1418|       |           looking so that we can reuse NTLM connections if
 1419|       |           possible. (Especially we must not reuse the same connection if
 1420|       |           partway through a handshake!) */
 1421|      0|        if(wantNTLMhttp) {
 1422|      0|          if(strcmp(needle->user, check->user) ||
 1423|      0|             strcmp(needle->passwd, check->passwd)) {
 1424|       |
 1425|       |            /* we prefer a credential match, but this is at least a connection
 1426|       |               that can be reused and "upgraded" to NTLM */
 1427|      0|            if(check->http_ntlm_state == NTLMSTATE_NONE)
 1428|      0|              chosen = check;
 1429|      0|            continue;
 1430|      0|          }
 1431|      0|        }
 1432|      0|        else if(check->http_ntlm_state != NTLMSTATE_NONE) {
 1433|       |          /* Connection is using NTLM auth but we don't want NTLM */
 1434|      0|          continue;
 1435|      0|        }
 1436|       |
 1437|      0|#ifndef CURL_DISABLE_PROXY
 1438|       |        /* Same for Proxy NTLM authentication */
 1439|      0|        if(wantProxyNTLMhttp) {
 1440|       |          /* Both check->http_proxy.user and check->http_proxy.passwd can be
 1441|       |           * NULL */
 1442|      0|          if(!check->http_proxy.user || !check->http_proxy.passwd)
 1443|      0|            continue;
 1444|       |
 1445|      0|          if(strcmp(needle->http_proxy.user, check->http_proxy.user) ||
 1446|      0|             strcmp(needle->http_proxy.passwd, check->http_proxy.passwd))
 1447|      0|            continue;
 1448|      0|        }
 1449|      0|        else if(check->proxy_ntlm_state != NTLMSTATE_NONE) {
 1450|       |          /* Proxy connection is using NTLM auth but we don't want NTLM */
 1451|      0|          continue;
 1452|      0|        }
 1453|      0|#endif
 1454|      0|        if(wantNTLMhttp || wantProxyNTLMhttp) {
 1455|       |          /* Credentials are already checked, we can use this connection */
 1456|      0|          chosen = check;
 1457|       |
 1458|      0|          if((wantNTLMhttp &&
 1459|      0|             (check->http_ntlm_state != NTLMSTATE_NONE)) ||
 1460|      0|              (wantProxyNTLMhttp &&
 1461|      0|               (check->proxy_ntlm_state != NTLMSTATE_NONE))) {
 1462|       |            /* We must use this connection, no other */
 1463|      0|            *force_reuse = TRUE;
 1464|      0|            break;
 1465|      0|          }
 1466|       |
 1467|       |          /* Continue look up for a better connection */
 1468|      0|          continue;
 1469|      0|        }
 1470|      0|#endif
 1471|      0|        if(canmultiplex) {
 1472|       |          /* We can multiplex if we want to. Let's continue looking for
 1473|       |             the optimal connection to use. */
 1474|       |
 1475|      0|          if(!multiplexed) {
 1476|       |            /* We have the optimal connection. Let's stop looking. */
 1477|      0|            chosen = check;
 1478|      0|            break;
 1479|      0|          }
 1480|       |
 1481|      0|#ifdef USE_NGHTTP2
 1482|       |          /* If multiplexed, make sure we don't go over concurrency limit */
 1483|      0|          if(check->bits.multiplex) {
 1484|       |            /* Multiplexed connections can only be HTTP/2 for now */
 1485|      0|            struct http_conn *httpc = &check->proto.httpc;
 1486|      0|            if(multiplexed >= httpc->settings.max_concurrent_streams) {
 1487|      0|              infof(data, "MAX_CONCURRENT_STREAMS reached, skip (%zu)",
 1488|      0|                    multiplexed);
 1489|      0|              continue;
 1490|      0|            }
 1491|      0|            else if(multiplexed >=
 1492|      0|                    Curl_multi_max_concurrent_streams(data->multi)) {
 1493|      0|              infof(data, "client side MAX_CONCURRENT_STREAMS reached"
 1494|      0|                    ", skip (%zu)",
 1495|      0|                    multiplexed);
 1496|      0|              continue;
 1497|      0|            }
 1498|      0|          }
 1499|      0|#endif
 1500|       |          /* When not multiplexed, we have a match here! */
 1501|      0|          chosen = check;
 1502|      0|          infof(data, "Multiplexed connection found!");
 1503|      0|          break;
 1504|      0|        }
 1505|      0|        else {
 1506|       |          /* We have found a connection. Let's stop searching. */
 1507|      0|          chosen = check;
 1508|      0|          break;
 1509|      0|        }
 1510|      0|      }
 1511|      0|    }
 1512|     65|  }
 1513|       |
 1514|  2.93k|  if(chosen) {
 1515|       |    /* mark it as used before releasing the lock */
 1516|      0|    Curl_attach_connnection(data, chosen);
 1517|      0|    CONNCACHE_UNLOCK(data);
 1518|      0|    *usethis = chosen;
 1519|      0|    return TRUE; /* yes, we found one to use! */
 1520|      0|  }
 1521|  2.93k|  CONNCACHE_UNLOCK(data);
 1522|       |
 1523|  2.93k|  if(foundPendingCandidate && data->set.pipewait) {
 1524|      0|    infof(data,
 1525|      0|          "Found pending candidate for reuse and CURLOPT_PIPEWAIT is set");
 1526|      0|    *waitpipe = TRUE;
 1527|      0|  }
 1528|       |
 1529|  2.93k|  return FALSE; /* no matching connecting exists */
 1530|  2.93k|}
url.c:IsMultiplexingPossible:
  906|  2.93k|{
  907|  2.93k|  int avail = 0;
  908|       |
  909|       |  /* If a HTTP protocol and multiplexing is enabled */
  910|  2.93k|  if((conn->handler->protocol & PROTO_FAMILY_HTTP) &&
  911|  2.93k|     (!conn->bits.protoconnstart || !conn->bits.close)) {
  912|       |
  913|  1.23k|    if(Curl_multiplex_wanted(handle->multi) &&
  914|  1.23k|       (handle->state.httpwant >= CURL_HTTP_VERSION_2))
  915|       |      /* allows HTTP/2 */
  916|  1.23k|      avail |= CURLPIPE_MULTIPLEX;
  917|  1.23k|  }
  918|  2.93k|  return avail;
  919|  2.93k|}
url.c:resolve_server:
 3332|  2.93k|{
 3333|  2.93k|  CURLcode result = CURLE_OK;
 3334|  2.93k|  timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
 3335|       |
 3336|  2.93k|  DEBUGASSERT(conn);
 3337|  2.93k|  DEBUGASSERT(data);
 3338|       |  /*************************************************************
 3339|       |   * Resolve the name of the server or proxy
 3340|       |   *************************************************************/
 3341|  2.93k|  if(conn->bits.reuse)
 3342|       |    /* We're reusing the connection - no need to resolve anything, and
 3343|       |       idnconvert_hostname() was called already in create_conn() for the re-use
 3344|       |       case. */
 3345|      0|    *async = FALSE;
 3346|       |
 3347|  2.93k|  else {
 3348|       |    /* this is a fresh connect */
 3349|  2.93k|    int rc;
 3350|  2.93k|    struct Curl_dns_entry *hostaddr = NULL;
 3351|       |
 3352|  2.93k|#ifdef USE_UNIX_SOCKETS
 3353|  2.93k|    if(conn->unix_domain_socket) {
 3354|       |      /* Unix domain sockets are local. The host gets ignored, just use the
 3355|       |       * specified domain socket address. Do not cache "DNS entries". There is
 3356|       |       * no DNS involved and we already have the filesystem path available */
 3357|      0|      const char *path = conn->unix_domain_socket;
 3358|       |
 3359|      0|      hostaddr = calloc(1, sizeof(struct Curl_dns_entry));
 3360|      0|      if(!hostaddr)
 3361|      0|        result = CURLE_OUT_OF_MEMORY;
 3362|      0|      else {
 3363|      0|        bool longpath = FALSE;
 3364|      0|        hostaddr->addr = Curl_unix2addr(path, &longpath,
 3365|      0|                                        conn->bits.abstract_unix_socket);
 3366|      0|        if(hostaddr->addr)
 3367|      0|          hostaddr->inuse++;
 3368|      0|        else {
 3369|       |          /* Long paths are not supported for now */
 3370|      0|          if(longpath) {
 3371|      0|            failf(data, "Unix socket path too long: '%s'", path);
 3372|      0|            result = CURLE_COULDNT_RESOLVE_HOST;
 3373|      0|          }
 3374|      0|          else
 3375|      0|            result = CURLE_OUT_OF_MEMORY;
 3376|      0|          free(hostaddr);
 3377|      0|          hostaddr = NULL;
 3378|      0|        }
 3379|      0|      }
 3380|      0|    }
 3381|  2.93k|    else
 3382|  2.93k|#endif
 3383|       |
 3384|  2.93k|    if(!conn->bits.proxy) {
 3385|  2.93k|      struct hostname *connhost;
 3386|  2.93k|      if(conn->bits.conn_to_host)
 3387|  2.93k|        connhost = &conn->conn_to_host;
 3388|      1|      else
 3389|      1|        connhost = &conn->host;
 3390|       |
 3391|       |      /* If not connecting via a proxy, extract the port from the URL, if it is
 3392|       |       * there, thus overriding any defaults that might have been set above. */
 3393|  2.93k|      if(conn->bits.conn_to_port)
 3394|      0|        conn->port = conn->conn_to_port;
 3395|  2.93k|      else
 3396|  2.93k|        conn->port = conn->remote_port;
 3397|       |
 3398|       |      /* Resolve target host right on */
 3399|  2.93k|      conn->hostname_resolve = strdup(connhost->name);
 3400|  2.93k|      if(!conn->hostname_resolve)
 3401|      0|        return CURLE_OUT_OF_MEMORY;
 3402|  2.93k|      rc = Curl_resolv_timeout(data, conn->hostname_resolve, (int)conn->port,
 3403|  2.93k|                               &hostaddr, timeout_ms);
 3404|  2.93k|      if(rc == CURLRESOLV_PENDING)
 3405|      0|        *async = TRUE;
 3406|       |
 3407|  2.93k|      else if(rc == CURLRESOLV_TIMEDOUT) {
 3408|      0|        failf(data, "Failed to resolve host '%s' with timeout after %ld ms",
 3409|      0|              connhost->dispname,
 3410|      0|              Curl_timediff(Curl_now(), data->progress.t_startsingle));
 3411|      0|        result = CURLE_OPERATION_TIMEDOUT;
 3412|      0|      }
 3413|  2.93k|      else if(!hostaddr) {
 3414|      0|        failf(data, "Could not resolve host: %s", connhost->dispname);
 3415|      0|        result = CURLE_COULDNT_RESOLVE_HOST;
 3416|       |        /* don't return yet, we need to clean up the timeout first */
 3417|      0|      }
 3418|  2.93k|    }
 3419|      0|#ifndef CURL_DISABLE_PROXY
 3420|      0|    else {
 3421|       |      /* This is a proxy that hasn't been resolved yet. */
 3422|       |
 3423|      0|      struct hostname * const host = conn->bits.socksproxy ?
 3424|      0|        &conn->socks_proxy.host : &conn->http_proxy.host;
 3425|       |
 3426|       |      /* resolve proxy */
 3427|      0|      conn->hostname_resolve = strdup(host->name);
 3428|      0|      if(!conn->hostname_resolve)
 3429|      0|        return CURLE_OUT_OF_MEMORY;
 3430|      0|      rc = Curl_resolv_timeout(data, conn->hostname_resolve, (int)conn->port,
 3431|      0|                               &hostaddr, timeout_ms);
 3432|       |
 3433|      0|      if(rc == CURLRESOLV_PENDING)
 3434|      0|        *async = TRUE;
 3435|       |
 3436|      0|      else if(rc == CURLRESOLV_TIMEDOUT)
 3437|      0|        result = CURLE_OPERATION_TIMEDOUT;
 3438|       |
 3439|      0|      else if(!hostaddr) {
 3440|      0|        failf(data, "Couldn't resolve proxy '%s'", host->dispname);
 3441|      0|        result = CURLE_COULDNT_RESOLVE_PROXY;
 3442|       |        /* don't return yet, we need to clean up the timeout first */
 3443|      0|      }
 3444|      0|    }
 3445|  2.93k|#endif
 3446|  2.93k|    DEBUGASSERT(conn->dns_entry == NULL);
 3447|  2.93k|    conn->dns_entry = hostaddr;
 3448|  2.93k|  }
 3449|       |
 3450|  2.93k|  return result;
 3451|  2.93k|}
url.c:strip_trailing_dot:
 1574|  5.86k|{
 1575|  5.86k|  size_t len;
 1576|  5.86k|  if(!host || !host->name)
 1577|      0|    return;
 1578|  5.86k|  len = strlen(host->name);
 1579|  5.86k|  if(len && (host->name[len-1] == '.'))
 1580|    126|    host->name[len-1] = 0;
 1581|  5.86k|}

Curl_is_absolute_url:
  236|  6.63k|{
  237|  6.63k|  size_t i;
  238|       |#ifdef WIN32
  239|       |  if(STARTS_WITH_DRIVE_PREFIX(url))
  240|       |    return FALSE;
  241|       |#endif
  242|  32.9k|  for(i = 0; i < buflen && url[i]; ++i) {
  243|  32.9k|    char s = url[i];
  244|  32.9k|    if((s == ':') && (url[i + 1] == '/')) {
  245|  5.70k|      if(buf)
  246|  2.91k|        buf[i] = 0;
  247|  5.70k|      return TRUE;
  248|  5.70k|    }
  249|       |    /* RFC 3986 3.1 explains:
  250|       |      scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  251|       |    */
  252|  27.2k|    else if(ISALNUM(s) || (s == '+') || (s == '-') || (s == '.') ) {
  253|  26.3k|      if(buf)
  254|  12.8k|        buf[i] = (char)TOLOWER(s);
  255|  26.3k|    }
  256|    853|    else
  257|    853|      break;
  258|  32.9k|  }
  259|    922|  return FALSE;
  260|  6.63k|}
Curl_parse_port:
  500|  3.14k|{
  501|  3.14k|  char *portptr = NULL;
  502|  3.14k|  char endbracket;
  503|  3.14k|  int len;
  504|       |
  505|       |  /*
  506|       |   * Find the end of an IPv6 address, either on the ']' ending bracket or
  507|       |   * a percent-encoded zone index.
  508|       |   */
  509|  3.14k|  if(1 == sscanf(hostname, "[%*45[0123456789abcdefABCDEF:.]%c%n",
  510|  3.14k|                 &endbracket, &len)) {
  511|     18|    if(']' == endbracket)
  512|     14|      portptr = &hostname[len];
  513|      4|    else if('%' == endbracket) {
  514|      2|      int zonelen = len;
  515|      2|      if(1 == sscanf(hostname + zonelen, "%*[^]]%c%n", &endbracket, &len)) {
  516|      1|        if(']' != endbracket)
  517|      0|          return CURLUE_MALFORMED_INPUT;
  518|      1|        portptr = &hostname[--zonelen + len + 1];
  519|      1|      }
  520|      1|      else
  521|      1|        return CURLUE_MALFORMED_INPUT;
  522|      2|    }
  523|      2|    else
  524|      2|      return CURLUE_MALFORMED_INPUT;
  525|       |
  526|       |    /* this is a RFC2732-style specified IP-address */
  527|     15|    if(portptr && *portptr) {
  528|      2|      if(*portptr != ':')
  529|      1|        return CURLUE_MALFORMED_INPUT;
  530|      2|    }
  531|     13|    else
  532|     13|      portptr = NULL;
  533|     15|  }
  534|  3.13k|  else
  535|  3.13k|    portptr = strchr(hostname, ':');
  536|       |
  537|  3.14k|  if(portptr) {
  538|  1.30k|    char *rest;
  539|  1.30k|    long port;
  540|  1.30k|    char portbuf[7];
  541|       |
  542|       |    /* Browser behavior adaptation. If there's a colon with no digits after,
  543|       |       just cut off the name there which makes us ignore the colon and just
  544|       |       use the default port. Firefox, Chrome and Safari all do that.
  545|       |
  546|       |       Don't do it if the URL has no scheme, to make something that looks like
  547|       |       a scheme not work!
  548|       |    */
  549|  1.30k|    if(!portptr[1]) {
  550|     50|      *portptr = '\0';
  551|     50|      return has_scheme ? CURLUE_OK : CURLUE_BAD_PORT_NUMBER;
  552|     50|    }
  553|       |
  554|  1.25k|    if(!ISDIGIT(portptr[1]))
  555|      8|      return CURLUE_BAD_PORT_NUMBER;
  556|       |
  557|  1.25k|    port = strtol(portptr + 1, &rest, 10);  /* Port number must be decimal */
  558|       |
  559|  1.25k|    if((port <= 0) || (port > 0xffff))
  560|       |      /* Single unix standard says port numbers are 16 bits long, but we don't
  561|       |         treat port zero as OK. */
  562|      3|      return CURLUE_BAD_PORT_NUMBER;
  563|       |
  564|  1.24k|    if(rest[0])
  565|      3|      return CURLUE_BAD_PORT_NUMBER;
  566|       |
  567|  1.24k|    *portptr++ = '\0'; /* cut off the name there */
  568|  1.24k|    *rest = 0;
  569|       |    /* generate a new port number string to get rid of leading zeroes etc */
  570|  1.24k|    msnprintf(portbuf, sizeof(portbuf), "%ld", port);
  571|  1.24k|    u->portnum = port;
  572|  1.24k|    u->port = strdup(portbuf);
  573|  1.24k|    if(!u->port)
  574|      0|      return CURLUE_OUT_OF_MEMORY;
  575|  1.24k|  }
  576|       |
  577|  3.08k|  return CURLUE_OK;
  578|  3.14k|}
curl_url:
 1117|  6.29k|{
 1118|  6.29k|  return calloc(sizeof(struct Curl_URL), 1);
 1119|  6.29k|}
curl_url_cleanup:
 1122|  9.39k|{
 1123|  9.39k|  if(u) {
 1124|  3.14k|    free_urlhandle(u);
 1125|  3.14k|    free(u);
 1126|  3.14k|  }
 1127|  9.39k|}
curl_url_get:
 1161|  27.6k|{
 1162|  27.6k|  char *ptr;
 1163|  27.6k|  CURLUcode ifmissing = CURLUE_UNKNOWN_PART;
 1164|  27.6k|  char portbuf[7];
 1165|  27.6k|  bool urldecode = (flags & CURLU_URLDECODE)?1:0;
 1166|  27.6k|  bool urlencode = (flags & CURLU_URLENCODE)?1:0;
 1167|  27.6k|  bool plusdecode = FALSE;
 1168|  27.6k|  (void)flags;
 1169|  27.6k|  if(!u)
 1170|      0|    return CURLUE_BAD_HANDLE;
 1171|  27.6k|  if(!part)
 1172|      0|    return CURLUE_BAD_PARTPOINTER;
 1173|  27.6k|  *part = NULL;
 1174|       |
 1175|  27.6k|  switch(what) {
 1176|  2.98k|  case CURLUPART_SCHEME:
 1177|  2.98k|    ptr = u->scheme;
 1178|  2.98k|    ifmissing = CURLUE_NO_SCHEME;
 1179|  2.98k|    urldecode = FALSE; /* never for schemes */
 1180|  2.98k|    break;
 1181|  2.72k|  case CURLUPART_USER:
 1182|  2.72k|    ptr = u->user;
 1183|  2.72k|    ifmissing = CURLUE_NO_USER;
 1184|  2.72k|    break;
 1185|  2.92k|  case CURLUPART_PASSWORD:
 1186|  2.92k|    ptr = u->password;
 1187|  2.92k|    ifmissing = CURLUE_NO_PASSWORD;
 1188|  2.92k|    break;
 1189|  2.97k|  case CURLUPART_OPTIONS:
 1190|  2.97k|    ptr = u->options;
 1191|  2.97k|    ifmissing = CURLUE_NO_OPTIONS;
 1192|  2.97k|    break;
 1193|  2.98k|  case CURLUPART_HOST:
 1194|  2.98k|    ptr = u->host;
 1195|  2.98k|    ifmissing = CURLUE_NO_HOST;
 1196|  2.98k|    break;
 1197|     10|  case CURLUPART_ZONEID:
 1198|     10|    ptr = u->zoneid;
 1199|     10|    break;
 1200|  2.97k|  case CURLUPART_PORT:
 1201|  2.97k|    ptr = u->port;
 1202|  2.97k|    ifmissing = CURLUE_NO_PORT;
 1203|  2.97k|    urldecode = FALSE; /* never for port */
 1204|  2.97k|    if(!ptr && (flags & CURLU_DEFAULT_PORT) && u->scheme) {
 1205|       |      /* there's no stored port number, but asked to deliver
 1206|       |         a default one for the scheme */
 1207|  1.78k|      const struct Curl_handler *h =
 1208|  1.78k|        Curl_builtin_scheme(u->scheme);
 1209|  1.78k|      if(h) {
 1210|  1.78k|        msnprintf(portbuf, sizeof(portbuf), "%u", h->defport);
 1211|  1.78k|        ptr = portbuf;
 1212|  1.78k|      }
 1213|  1.78k|    }
 1214|  1.18k|    else if(ptr && u->scheme) {
 1215|       |      /* there is a stored port number, but ask to inhibit if
 1216|       |         it matches the default one for the scheme */
 1217|  1.18k|      const struct Curl_handler *h =
 1218|  1.18k|        Curl_builtin_scheme(u->scheme);
 1219|  1.18k|      if(h && (h->defport == u->portnum) &&
 1220|  1.18k|         (flags & CURLU_NO_DEFAULT_PORT))
 1221|      0|        ptr = NULL;
 1222|  1.18k|    }
 1223|  2.97k|    break;
 1224|  2.97k|  case CURLUPART_PATH:
 1225|  2.97k|    ptr = u->path;
 1226|  2.97k|    if(!ptr) {
 1227|    606|      ptr = u->path = strdup("/");
 1228|    606|      if(!u->path)
 1229|      0|        return CURLUE_OUT_OF_MEMORY;
 1230|    606|    }
 1231|  2.97k|    break;
 1232|  3.43k|  case CURLUPART_QUERY:
 1233|  3.43k|    ptr = u->query;
 1234|  3.43k|    ifmissing = CURLUE_NO_QUERY;
 1235|  3.43k|    plusdecode = urldecode;
 1236|  3.43k|    break;
 1237|      0|  case CURLUPART_FRAGMENT:
 1238|      0|    ptr = u->fragment;
 1239|      0|    ifmissing = CURLUE_NO_FRAGMENT;
 1240|      0|    break;
 1241|  3.61k|  case CURLUPART_URL: {
 1242|  3.61k|    char *url;
 1243|  3.61k|    char *scheme;
 1244|  3.61k|    char *options = u->options;
 1245|  3.61k|    char *port = u->port;
 1246|  3.61k|    char *allochost = NULL;
 1247|  3.61k|    if(u->scheme && strcasecompare("file", u->scheme)) {
 1248|     43|      url = aprintf("file://%s%s%s",
 1249|     43|                    u->path,
 1250|     43|                    u->fragment? "#": "",
 1251|     43|                    u->fragment? u->fragment : "");
 1252|     43|    }
 1253|  3.57k|    else if(!u->host)
 1254|    328|      return CURLUE_NO_HOST;
 1255|  3.24k|    else {
 1256|  3.24k|      const struct Curl_handler *h = NULL;
 1257|  3.24k|      if(u->scheme)
 1258|  3.24k|        scheme = u->scheme;
 1259|      0|      else if(flags & CURLU_DEFAULT_SCHEME)
 1260|      0|        scheme = (char *) DEFAULT_SCHEME;
 1261|      0|      else
 1262|      0|        return CURLUE_NO_SCHEME;
 1263|       |
 1264|  3.24k|      h = Curl_builtin_scheme(scheme);
 1265|  3.24k|      if(!port && (flags & CURLU_DEFAULT_PORT)) {
 1266|       |        /* there's no stored port number, but asked to deliver
 1267|       |           a default one for the scheme */
 1268|      0|        if(h) {
 1269|      0|          msnprintf(portbuf, sizeof(portbuf), "%u", h->defport);
 1270|      0|          port = portbuf;
 1271|      0|        }
 1272|      0|      }
 1273|  3.24k|      else if(port) {
 1274|       |        /* there is a stored port number, but asked to inhibit if it matches
 1275|       |           the default one for the scheme */
 1276|  1.27k|        if(h && (h->defport == u->portnum) &&
 1277|  1.27k|           (flags & CURLU_NO_DEFAULT_PORT))
 1278|      0|          port = NULL;
 1279|  1.27k|      }
 1280|       |
 1281|  3.24k|      if(h && !(h->flags & PROTOPT_URLOPTIONS))
 1282|  1.91k|        options = NULL;
 1283|       |
 1284|  3.24k|      if(u->host[0] == '[') {
 1285|     15|        if(u->zoneid) {
 1286|       |          /* make it '[ host %25 zoneid ]' */
 1287|      0|          size_t hostlen = strlen(u->host);
 1288|      0|          size_t alen = hostlen + 3 + strlen(u->zoneid) + 1;
 1289|      0|          allochost = malloc(alen);
 1290|      0|          if(!allochost)
 1291|      0|            return CURLUE_OUT_OF_MEMORY;
 1292|      0|          memcpy(allochost, u->host, hostlen - 1);
 1293|      0|          msnprintf(&allochost[hostlen - 1], alen - hostlen + 1,
 1294|      0|                    "%%25%s]", u->zoneid);
 1295|      0|        }
 1296|     15|      }
 1297|  3.23k|      else if(urlencode) {
 1298|     64|        allochost = curl_easy_escape(NULL, u->host, 0);
 1299|     64|        if(!allochost)
 1300|      0|          return CURLUE_OUT_OF_MEMORY;
 1301|     64|      }
 1302|  3.16k|      else {
 1303|       |        /* only encode '%' in output host name */
 1304|  3.16k|        char *host = u->host;
 1305|  3.16k|        size_t pcount = 0;
 1306|       |        /* first, count number of percents present in the name */
 1307|  30.0k|        while(*host) {
 1308|  26.8k|          if(*host == '%')
 1309|    381|            pcount++;
 1310|  26.8k|          host++;
 1311|  26.8k|        }
 1312|       |        /* if there were percents, encode the host name */
 1313|  3.16k|        if(pcount) {
 1314|     29|          size_t hostlen = strlen(u->host);
 1315|     29|          size_t alen = hostlen + 2 * pcount + 1;
 1316|     29|          char *o = allochost = malloc(alen);
 1317|     29|          if(!allochost)
 1318|      0|            return CURLUE_OUT_OF_MEMORY;
 1319|       |
 1320|     29|          host = u->host;
 1321|    866|          while(*host) {
 1322|    837|            if(*host == '%') {
 1323|    381|              memcpy(o, "%25", 3);
 1324|    381|              o += 3;
 1325|    381|              host++;
 1326|    381|              continue;
 1327|    381|            }
 1328|    456|            *o++ = *host++;
 1329|    456|          }
 1330|     29|          *o = '\0';
 1331|     29|        }
 1332|  3.16k|      }
 1333|       |
 1334|  3.24k|      url = aprintf("%s://%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
 1335|  3.24k|                    scheme,
 1336|  3.24k|                    u->user ? u->user : "",
 1337|  3.24k|                    u->password ? ":": "",
 1338|  3.24k|                    u->password ? u->password : "",
 1339|  3.24k|                    options ? ";" : "",
 1340|  3.24k|                    options ? options : "",
 1341|  3.24k|                    (u->user || u->password || options) ? "@": "",
 1342|  3.24k|                    allochost ? allochost : u->host,
 1343|  3.24k|                    port ? ":": "",
 1344|  3.24k|                    port ? port : "",
 1345|  3.24k|                    (u->path && (u->path[0] != '/')) ? "/": "",
 1346|  3.24k|                    u->path ? u->path : "/",
 1347|  3.24k|                    (u->query && u->query[0]) ? "?": "",
 1348|  3.24k|                    (u->query && u->query[0]) ? u->query : "",
 1349|  3.24k|                    u->fragment? "#": "",
 1350|  3.24k|                    u->fragment? u->fragment : "");
 1351|  3.24k|      free(allochost);
 1352|  3.24k|    }
 1353|  3.28k|    if(!url)
 1354|      0|      return CURLUE_OUT_OF_MEMORY;
 1355|  3.28k|    *part = url;
 1356|  3.28k|    return CURLUE_OK;
 1357|  3.28k|  }
 1358|      0|  default:
 1359|      0|    ptr = NULL;
 1360|      0|    break;
 1361|  27.6k|  }
 1362|  23.9k|  if(ptr) {
 1363|  12.5k|    *part = strdup(ptr);
 1364|  12.5k|    if(!*part)
 1365|      0|      return CURLUE_OUT_OF_MEMORY;
 1366|  12.5k|    if(plusdecode) {
 1367|       |      /* convert + to space */
 1368|     57|      char *plus;
 1369|    872|      for(plus = *part; *plus; ++plus) {
 1370|    815|        if(*plus == '+')
 1371|      3|          *plus = ' ';
 1372|    815|      }
 1373|     57|    }
 1374|  12.5k|    if(urldecode) {
 1375|    119|      char *decoded;
 1376|    119|      size_t dlen;
 1377|       |      /* this unconditional rejection of control bytes is documented
 1378|       |         API behavior */
 1379|    119|      CURLcode res = Curl_urldecode(NULL, *part, 0, &decoded, &dlen,
 1380|    119|                                    REJECT_CTRL);
 1381|    119|      free(*part);
 1382|    119|      if(res) {
 1383|      1|        *part = NULL;
 1384|      1|        return CURLUE_URLDECODE;
 1385|      1|      }
 1386|    118|      *part = decoded;
 1387|    118|    }
 1388|  12.5k|    return CURLUE_OK;
 1389|  12.5k|  }
 1390|  11.4k|  else
 1391|  11.4k|    return ifmissing;
 1392|  23.9k|}
curl_url_set:
 1396|  3.90k|{
 1397|  3.90k|  char **storep = NULL;
 1398|  3.90k|  long port = 0;
 1399|  3.90k|  bool urlencode = (flags & CURLU_URLENCODE)? 1 : 0;
 1400|  3.90k|  bool plusencode = FALSE;
 1401|  3.90k|  bool urlskipslash = FALSE;
 1402|  3.90k|  bool appendquery = FALSE;
 1403|  3.90k|  bool equalsencode = FALSE;
 1404|       |
 1405|  3.90k|  if(!u)
 1406|      0|    return CURLUE_BAD_HANDLE;
 1407|  3.90k|  if(!part) {
 1408|       |    /* setting a part to NULL clears it */
 1409|      0|    switch(what) {
 1410|      0|    case CURLUPART_URL:
 1411|      0|      break;
 1412|      0|    case CURLUPART_SCHEME:
 1413|      0|      storep = &u->scheme;
 1414|      0|      break;
 1415|      0|    case CURLUPART_USER:
 1416|      0|      storep = &u->user;
 1417|      0|      break;
 1418|      0|    case CURLUPART_PASSWORD:
 1419|      0|      storep = &u->password;
 1420|      0|      break;
 1421|      0|    case CURLUPART_OPTIONS:
 1422|      0|      storep = &u->options;
 1423|      0|      break;
 1424|      0|    case CURLUPART_HOST:
 1425|      0|      storep = &u->host;
 1426|      0|      break;
 1427|      0|    case CURLUPART_ZONEID:
 1428|      0|      storep = &u->zoneid;
 1429|      0|      break;
 1430|      0|    case CURLUPART_PORT:
 1431|      0|      u->portnum = 0;
 1432|      0|      storep = &u->port;
 1433|      0|      break;
 1434|      0|    case CURLUPART_PATH:
 1435|      0|      storep = &u->path;
 1436|      0|      break;
 1437|      0|    case CURLUPART_QUERY:
 1438|      0|      storep = &u->query;
 1439|      0|      break;
 1440|      0|    case CURLUPART_FRAGMENT:
 1441|      0|      storep = &u->fragment;
 1442|      0|      break;
 1443|      0|    default:
 1444|      0|      return CURLUE_UNKNOWN_PART;
 1445|      0|    }
 1446|      0|    if(storep && *storep) {
 1447|      0|      Curl_safefree(*storep);
 1448|      0|    }
 1449|      0|    return CURLUE_OK;
 1450|      0|  }
 1451|       |
 1452|  3.90k|  switch(what) {
 1453|      0|  case CURLUPART_SCHEME:
 1454|      0|    if(strlen(part) > MAX_SCHEME_LEN)
 1455|       |      /* too long */
 1456|      0|      return CURLUE_MALFORMED_INPUT;
 1457|      0|    if(!(flags & CURLU_NON_SUPPORT_SCHEME) &&
 1458|       |       /* verify that it is a fine scheme */
 1459|      0|       !Curl_builtin_scheme(part))
 1460|      0|      return CURLUE_UNSUPPORTED_SCHEME;
 1461|      0|    storep = &u->scheme;
 1462|      0|    urlencode = FALSE; /* never */
 1463|      0|    break;
 1464|    494|  case CURLUPART_USER:
 1465|    494|    storep = &u->user;
 1466|    494|    break;
 1467|    169|  case CURLUPART_PASSWORD:
 1468|    169|    storep = &u->password;
 1469|    169|    break;
 1470|      0|  case CURLUPART_OPTIONS:
 1471|      0|    storep = &u->options;
 1472|      0|    break;
 1473|      0|  case CURLUPART_HOST: {
 1474|      0|    size_t len = strcspn(part, " \r\n");
 1475|      0|    if(strlen(part) != len)
 1476|       |      /* hostname with bad content */
 1477|      0|      return CURLUE_MALFORMED_INPUT;
 1478|      0|    storep = &u->host;
 1479|      0|    Curl_safefree(u->zoneid);
 1480|      0|    break;
 1481|      0|  }
 1482|      0|  case CURLUPART_ZONEID:
 1483|      0|    storep = &u->zoneid;
 1484|      0|    break;
 1485|      0|  case CURLUPART_PORT:
 1486|      0|  {
 1487|      0|    char *endp;
 1488|      0|    urlencode = FALSE; /* never */
 1489|      0|    port = strtol(part, &endp, 10);  /* Port number must be decimal */
 1490|      0|    if((port <= 0) || (port > 0xffff))
 1491|      0|      return CURLUE_BAD_PORT_NUMBER;
 1492|      0|    if(*endp)
 1493|       |      /* weirdly provided number, not good! */
 1494|      0|      return CURLUE_MALFORMED_INPUT;
 1495|      0|    storep = &u->port;
 1496|      0|  }
 1497|      0|  break;
 1498|      0|  case CURLUPART_PATH:
 1499|      0|    urlskipslash = TRUE;
 1500|      0|    storep = &u->path;
 1501|      0|    break;
 1502|      0|  case CURLUPART_QUERY:
 1503|      0|    plusencode = urlencode;
 1504|      0|    appendquery = (flags & CURLU_APPENDQUERY)?1:0;
 1505|      0|    equalsencode = appendquery;
 1506|      0|    storep = &u->query;
 1507|      0|    break;
 1508|      0|  case CURLUPART_FRAGMENT:
 1509|      0|    storep = &u->fragment;
 1510|      0|    break;
 1511|  3.24k|  case CURLUPART_URL: {
 1512|       |    /*
 1513|       |     * Allow a new URL to replace the existing (if any) contents.
 1514|       |     *
 1515|       |     * If the existing contents is enough for a URL, allow a relative URL to
 1516|       |     * replace it.
 1517|       |     */
 1518|  3.24k|    CURLUcode result;
 1519|  3.24k|    char *oldurl;
 1520|  3.24k|    char *redired_url;
 1521|  3.24k|    CURLU *handle2;
 1522|       |
 1523|  3.24k|    if(Curl_is_absolute_url(part, NULL, MAX_SCHEME_LEN + 1)) {
 1524|  2.78k|      handle2 = curl_url();
 1525|  2.78k|      if(!handle2)
 1526|      0|        return CURLUE_OUT_OF_MEMORY;
 1527|  2.78k|      result = parseurl(part, handle2, flags);
 1528|  2.78k|      if(!result)
 1529|  2.74k|        mv_urlhandle(handle2, u);
 1530|     34|      else
 1531|     34|        curl_url_cleanup(handle2);
 1532|  2.78k|      return result;
 1533|  2.78k|    }
 1534|       |    /* extract the full "old" URL to do the redirect on */
 1535|    461|    result = curl_url_get(u, CURLUPART_URL, &oldurl, flags);
 1536|    461|    if(result) {
 1537|       |      /* couldn't get the old URL, just use the new! */
 1538|    328|      handle2 = curl_url();
 1539|    328|      if(!handle2)
 1540|      0|        return CURLUE_OUT_OF_MEMORY;
 1541|    328|      result = parseurl(part, handle2, flags);
 1542|    328|      if(!result)
 1543|    295|        mv_urlhandle(handle2, u);
 1544|     33|      else
 1545|     33|        curl_url_cleanup(handle2);
 1546|    328|      return result;
 1547|    328|    }
 1548|       |
 1549|       |    /* apply the relative part to create a new URL */
 1550|    133|    redired_url = concat_url(oldurl, part);
 1551|    133|    free(oldurl);
 1552|    133|    if(!redired_url)
 1553|      0|      return CURLUE_OUT_OF_MEMORY;
 1554|       |
 1555|       |    /* now parse the new URL */
 1556|    133|    handle2 = curl_url();
 1557|    133|    if(!handle2) {
 1558|      0|      free(redired_url);
 1559|      0|      return CURLUE_OUT_OF_MEMORY;
 1560|      0|    }
 1561|    133|    result = parseurl(redired_url, handle2, flags);
 1562|    133|    free(redired_url);
 1563|    133|    if(!result)
 1564|    112|      mv_urlhandle(handle2, u);
 1565|     21|    else
 1566|     21|      curl_url_cleanup(handle2);
 1567|    133|    return result;
 1568|    133|  }
 1569|      0|  default:
 1570|      0|    return CURLUE_UNKNOWN_PART;
 1571|  3.90k|  }
 1572|    663|  DEBUGASSERT(storep);
 1573|    663|  {
 1574|    663|    const char *newp = part;
 1575|    663|    size_t nalloc = strlen(part);
 1576|       |
 1577|    663|    if(nalloc > CURL_MAX_INPUT_LENGTH)
 1578|       |      /* excessive input length */
 1579|      0|      return CURLUE_MALFORMED_INPUT;
 1580|       |
 1581|    663|    if(urlencode) {
 1582|    663|      const unsigned char *i;
 1583|    663|      char *o;
 1584|    663|      char *enc = malloc(nalloc * 3 + 1); /* for worst case! */
 1585|    663|      if(!enc)
 1586|      0|        return CURLUE_OUT_OF_MEMORY;
 1587|  64.3k|      for(i = (const unsigned char *)part, o = enc; *i; i++) {
 1588|  63.7k|        if((*i == ' ') && plusencode) {
 1589|      0|          *o = '+';
 1590|      0|          o++;
 1591|      0|        }
 1592|  63.7k|        else if(Curl_isunreserved(*i) ||
 1593|  63.7k|                ((*i == '/') && urlskipslash) ||
 1594|  63.7k|                ((*i == '=') && equalsencode)) {
 1595|  48.9k|          if((*i == '=') && equalsencode)
 1596|       |            /* only skip the first equals sign */
 1597|      0|            equalsencode = FALSE;
 1598|  48.9k|          *o = *i;
 1599|  48.9k|          o++;
 1600|  48.9k|        }
 1601|  14.7k|        else {
 1602|  14.7k|          msnprintf(o, 4, "%%%02x", *i);
 1603|  14.7k|          o += 3;
 1604|  14.7k|        }
 1605|  63.7k|      }
 1606|    663|      *o = 0; /* null-terminate */
 1607|    663|      newp = enc;
 1608|    663|    }
 1609|      0|    else {
 1610|      0|      char *p;
 1611|      0|      newp = strdup(part);
 1612|      0|      if(!newp)
 1613|      0|        return CURLUE_OUT_OF_MEMORY;
 1614|      0|      p = (char *)newp;
 1615|      0|      while(*p) {
 1616|       |        /* make sure percent encoded are lower case */
 1617|      0|        if((*p == '%') && ISXDIGIT(p[1]) && ISXDIGIT(p[2]) &&
 1618|      0|           (ISUPPER(p[1]) || ISUPPER(p[2]))) {
 1619|      0|          p[1] = (char)TOLOWER(p[1]);
 1620|      0|          p[2] = (char)TOLOWER(p[2]);
 1621|      0|          p += 3;
 1622|      0|        }
 1623|      0|        else
 1624|      0|          p++;
 1625|      0|      }
 1626|      0|    }
 1627|       |
 1628|    663|    if(appendquery) {
 1629|       |      /* Append the string onto the old query. Add a '&' separator if none is
 1630|       |         present at the end of the exsting query already */
 1631|      0|      size_t querylen = u->query ? strlen(u->query) : 0;
 1632|      0|      bool addamperand = querylen && (u->query[querylen -1] != '&');
 1633|      0|      if(querylen) {
 1634|      0|        size_t newplen = strlen(newp);
 1635|      0|        char *p = malloc(querylen + addamperand + newplen + 1);
 1636|      0|        if(!p) {
 1637|      0|          free((char *)newp);
 1638|      0|          return CURLUE_OUT_OF_MEMORY;
 1639|      0|        }
 1640|      0|        strcpy(p, u->query); /* original query */
 1641|      0|        if(addamperand)
 1642|      0|          p[querylen] = '&'; /* ampersand */
 1643|      0|        strcpy(&p[querylen + addamperand], newp); /* new suffix */
 1644|      0|        free((char *)newp);
 1645|      0|        free(*storep);
 1646|      0|        *storep = p;
 1647|      0|        return CURLUE_OK;
 1648|      0|      }
 1649|      0|    }
 1650|       |
 1651|    663|    if(what == CURLUPART_HOST) {
 1652|      0|      if(0 == strlen(newp) && (flags & CURLU_NO_AUTHORITY)) {
 1653|       |        /* Skip hostname check, it's allowed to be empty. */
 1654|      0|      }
 1655|      0|      else {
 1656|      0|        if(hostname_check(u, (char *)newp)) {
 1657|      0|          free((char *)newp);
 1658|      0|          return CURLUE_MALFORMED_INPUT;
 1659|      0|        }
 1660|      0|      }
 1661|      0|    }
 1662|       |
 1663|    663|    free(*storep);
 1664|    663|    *storep = (char *)newp;
 1665|    663|  }
 1666|       |  /* set after the string, to make it not assigned if the allocation above
 1667|       |     fails */
 1668|    663|  if(port)
 1669|      0|    u->portnum = port;
 1670|    663|  return CURLUE_OK;
 1671|    663|}
urlapi.c:free_urlhandle:
   74|  6.38k|{
   75|  6.38k|  free(u->scheme);
   76|  6.38k|  free(u->user);
   77|  6.38k|  free(u->password);
   78|  6.38k|  free(u->options);
   79|  6.38k|  free(u->host);
   80|  6.38k|  free(u->zoneid);
   81|  6.38k|  free(u->port);
   82|  6.38k|  free(u->path);
   83|  6.38k|  free(u->query);
   84|  6.38k|  free(u->fragment);
   85|  6.38k|  free(u->scratch);
   86|  6.38k|  free(u->temppath);
   87|  6.38k|}
urlapi.c:parseurl:
 1105|  3.24k|{
 1106|  3.24k|  CURLUcode result = seturl(url, u, flags);
 1107|  3.24k|  if(result) {
 1108|     88|    free_urlhandle(u);
 1109|     88|    memset(u, 0, sizeof(struct Curl_URL));
 1110|     88|  }
 1111|  3.24k|  return result;
 1112|  3.24k|}
urlapi.c:seturl:
  782|  3.24k|{
  783|  3.24k|  char *path;
  784|  3.24k|  bool path_alloced = FALSE;
  785|  3.24k|  bool uncpath = FALSE;
  786|  3.24k|  char *hostname;
  787|  3.24k|  char *query = NULL;
  788|  3.24k|  char *fragment = NULL;
  789|  3.24k|  CURLUcode result;
  790|  3.24k|  bool url_has_scheme = FALSE;
  791|  3.24k|  char schemebuf[MAX_SCHEME_LEN + 1];
  792|  3.24k|  const char *schemep = NULL;
  793|  3.24k|  size_t schemelen = 0;
  794|  3.24k|  size_t urllen;
  795|       |
  796|  3.24k|  DEBUGASSERT(url);
  797|       |
  798|       |  /*************************************************************
  799|       |   * Parse the URL.
  800|       |   ************************************************************/
  801|       |  /* allocate scratch area */
  802|  3.24k|  urllen = strlen(url);
  803|  3.24k|  if(urllen > CURL_MAX_INPUT_LENGTH)
  804|       |    /* excessive input length */
  805|      0|    return CURLUE_MALFORMED_INPUT;
  806|       |
  807|  3.24k|  path = u->scratch = malloc(urllen * 2 + 2);
  808|  3.24k|  if(!path)
  809|      0|    return CURLUE_OUT_OF_MEMORY;
  810|       |
  811|  3.24k|  hostname = &path[urllen + 1];
  812|  3.24k|  hostname[0] = 0;
  813|       |
  814|  3.24k|  if(Curl_is_absolute_url(url, schemebuf, sizeof(schemebuf))) {
  815|  2.91k|    url_has_scheme = TRUE;
  816|  2.91k|    schemelen = strlen(schemebuf);
  817|  2.91k|  }
  818|       |
  819|       |  /* handle the file: scheme */
  820|  3.24k|  if(url_has_scheme && strcasecompare(schemebuf, "file")) {
  821|       |    /* path has been allocated large enough to hold this */
  822|     51|    strcpy(path, &url[5]);
  823|       |
  824|     51|    u->scheme = strdup("file");
  825|     51|    if(!u->scheme)
  826|      0|      return CURLUE_OUT_OF_MEMORY;
  827|       |
  828|       |    /* Extra handling URLs with an authority component (i.e. that start with
  829|       |     * "file://")
  830|       |     *
  831|       |     * We allow omitted hostname (e.g. file:/<path>) -- valid according to
  832|       |     * RFC 8089, but not the (current) WHAT-WG URL spec.
  833|       |     */
  834|     51|    if(path[0] == '/' && path[1] == '/') {
  835|       |      /* swallow the two slashes */
  836|      7|      char *ptr = &path[2];
  837|       |
  838|       |      /*
  839|       |       * According to RFC 8089, a file: URL can be reliably dereferenced if:
  840|       |       *
  841|       |       *  o it has no/blank hostname, or
  842|       |       *
  843|       |       *  o the hostname matches "localhost" (case-insensitively), or
  844|       |       *
  845|       |       *  o the hostname is a FQDN that resolves to this machine, or
  846|       |       *
  847|       |       *  o it is an UNC String transformed to an URI (Windows only, RFC 8089
  848|       |       *    Appendix E.3).
  849|       |       *
  850|       |       * For brevity, we only consider URLs with empty, "localhost", or
  851|       |       * "127.0.0.1" hostnames as local, otherwise as an UNC String.
  852|       |       *
  853|       |       * Additionally, there is an exception for URLs with a Windows drive
  854|       |       * letter in the authority (which was accidentally omitted from RFC 8089
  855|       |       * Appendix E, but believe me, it was meant to be there. --MK)
  856|       |       */
  857|      7|      if(ptr[0] != '/' && !STARTS_WITH_URL_DRIVE_PREFIX(ptr)) {
  858|       |        /* the URL includes a host name, it must match "localhost" or
  859|       |           "127.0.0.1" to be valid */
  860|      4|        if(checkprefix("localhost/", ptr) ||
  861|      4|           checkprefix("127.0.0.1/", ptr)) {
  862|      0|          ptr += 9; /* now points to the slash after the host */
  863|      0|        }
  864|      4|        else {
  865|       |#if defined(WIN32)
  866|       |          size_t len;
  867|       |
  868|       |          /* the host name, NetBIOS computer name, can not contain disallowed
  869|       |             chars, and the delimiting slash character must be appended to the
  870|       |             host name */
  871|       |          path = strpbrk(ptr, "/\\:*?\"<>|");
  872|       |          if(!path || *path != '/')
  873|       |            return CURLUE_MALFORMED_INPUT;
  874|       |
  875|       |          len = path - ptr;
  876|       |          if(len) {
  877|       |            memcpy(hostname, ptr, len);
  878|       |            hostname[len] = 0;
  879|       |            uncpath = TRUE;
  880|       |          }
  881|       |
  882|       |          ptr -= 2; /* now points to the // before the host in UNC */
  883|       |#else
  884|       |          /* Invalid file://hostname/, expected localhost or 127.0.0.1 or
  885|       |             none */
  886|      4|          return CURLUE_MALFORMED_INPUT;
  887|      4|#endif
  888|      4|        }
  889|      4|      }
  890|       |
  891|      3|      path = ptr;
  892|      3|    }
  893|       |
  894|     47|    if(!uncpath)
  895|     47|        hostname = NULL; /* no host for file: URLs by default */
  896|       |
  897|     47|#if !defined(MSDOS) && !defined(WIN32) && !defined(__CYGWIN__)
  898|       |    /* Don't allow Windows drive letters when not in Windows.
  899|       |     * This catches both "file:/c:" and "file:c:" */
  900|     47|    if(('/' == path[0] && STARTS_WITH_URL_DRIVE_PREFIX(&path[1])) ||
  901|     47|       STARTS_WITH_URL_DRIVE_PREFIX(path)) {
  902|       |      /* File drive letters are only accepted in MSDOS/Windows */
  903|      4|      return CURLUE_MALFORMED_INPUT;
  904|      4|    }
  905|       |#else
  906|       |    /* If the path starts with a slash and a drive letter, ditch the slash */
  907|       |    if('/' == path[0] && STARTS_WITH_URL_DRIVE_PREFIX(&path[1])) {
  908|       |      /* This cannot be done with strcpy, as the memory chunks overlap! */
  909|       |      memmove(path, &path[1], strlen(&path[1]) + 1);
  910|       |    }
  911|       |#endif
  912|       |
  913|     47|  }
  914|  3.19k|  else {
  915|       |    /* clear path */
  916|  3.19k|    const char *p;
  917|  3.19k|    const char *hostp;
  918|  3.19k|    size_t len;
  919|  3.19k|    path[0] = 0;
  920|       |
  921|  3.19k|    if(url_has_scheme) {
  922|  2.86k|      int i = 0;
  923|  2.86k|      p = &url[schemelen + 1];
  924|  8.18k|      while(p && (*p == '/') && (i < 4)) {
  925|  5.31k|        p++;
  926|  5.31k|        i++;
  927|  5.31k|      }
  928|  2.86k|      if((i < 1) || (i>3))
  929|       |        /* less than one or more than three slashes */
  930|      1|        return CURLUE_MALFORMED_INPUT;
  931|       |
  932|  2.86k|      schemep = schemebuf;
  933|  2.86k|      if(!Curl_builtin_scheme(schemep) &&
  934|  2.86k|         !(flags & CURLU_NON_SUPPORT_SCHEME))
  935|      1|        return CURLUE_UNSUPPORTED_SCHEME;
  936|       |
  937|  2.86k|      if(junkscan(schemep, flags))
  938|      0|        return CURLUE_MALFORMED_INPUT;
  939|  2.86k|    }
  940|    328|    else {
  941|       |      /* no scheme! */
  942|       |
  943|    328|      if(!(flags & (CURLU_DEFAULT_SCHEME|CURLU_GUESS_SCHEME)))
  944|      0|        return CURLUE_MALFORMED_INPUT;
  945|    328|      if(flags & CURLU_DEFAULT_SCHEME)
  946|      0|        schemep = DEFAULT_SCHEME;
  947|       |
  948|       |      /*
  949|       |       * The URL was badly formatted, let's try without scheme specified.
  950|       |       */
  951|    328|      p = url;
  952|    328|    }
  953|  3.19k|    hostp = p; /* host name starts here */
  954|       |
  955|  44.6k|    while(*p && !HOSTNAME_END(*p)) /* find end of host name */
  956|  41.5k|      p++;
  957|       |
  958|  3.19k|    len = p - hostp;
  959|  3.19k|    if(len) {
  960|  3.18k|      memcpy(hostname, hostp, len);
  961|  3.18k|      hostname[len] = 0;
  962|  3.18k|    }
  963|      6|    else {
  964|      6|      if(!(flags & CURLU_NO_AUTHORITY))
  965|      6|        return CURLUE_MALFORMED_INPUT;
  966|      6|    }
  967|       |
  968|  3.18k|    len = strlen(p);
  969|  3.18k|    memcpy(path, p, len);
  970|  3.18k|    path[len] = 0;
  971|       |
  972|  3.18k|    if(schemep) {
  973|  2.85k|      u->scheme = strdup(schemep);
  974|  2.85k|      if(!u->scheme)
  975|      0|        return CURLUE_OUT_OF_MEMORY;
  976|  2.85k|    }
  977|  3.18k|  }
  978|       |
  979|  3.22k|  if(junkscan(path, flags))
  980|     21|    return CURLUE_MALFORMED_INPUT;
  981|       |
  982|  3.20k|  if((flags & CURLU_URLENCODE) && path[0]) {
  983|       |    /* worst case output length is 3x the original! */
  984|    110|    char *newp = malloc(strlen(path) * 3);
  985|    110|    if(!newp)
  986|      0|      return CURLUE_OUT_OF_MEMORY;
  987|    110|    path_alloced = TRUE;
  988|    110|    strcpy_url(newp, path, TRUE); /* consider it relative */
  989|    110|    u->temppath = path = newp;
  990|    110|  }
  991|       |
  992|  3.20k|  fragment = strchr(path, '#');
  993|  3.20k|  if(fragment) {
  994|     40|    *fragment++ = 0;
  995|     40|    if(fragment[0]) {
  996|     38|      u->fragment = strdup(fragment);
  997|     38|      if(!u->fragment)
  998|      0|        return CURLUE_OUT_OF_MEMORY;
  999|     38|    }
 1000|     40|  }
 1001|       |
 1002|  3.20k|  query = strchr(path, '?');
 1003|  3.20k|  if(query) {
 1004|    166|    *query++ = 0;
 1005|       |    /* done even if the query part is a blank string */
 1006|    166|    u->query = strdup(query);
 1007|    166|    if(!u->query)
 1008|      0|      return CURLUE_OUT_OF_MEMORY;
 1009|    166|  }
 1010|       |
 1011|  3.20k|  if(!path[0])
 1012|       |    /* if there's no path left set, unset */
 1013|    657|    path = NULL;
 1014|  2.54k|  else {
 1015|  2.54k|    if(!(flags & CURLU_PATH_AS_IS)) {
 1016|       |      /* remove ../ and ./ sequences according to RFC3986 */
 1017|  2.54k|      char *newp = Curl_dedotdotify(path);
 1018|  2.54k|      if(!newp)
 1019|      0|        return CURLUE_OUT_OF_MEMORY;
 1020|       |
 1021|  2.54k|      if(strcmp(newp, path)) {
 1022|       |        /* if we got a new version */
 1023|     99|        if(path_alloced)
 1024|      1|          Curl_safefree(u->temppath);
 1025|     99|        u->temppath = path = newp;
 1026|     99|        path_alloced = TRUE;
 1027|     99|      }
 1028|  2.45k|      else
 1029|  2.45k|        free(newp);
 1030|  2.54k|    }
 1031|       |
 1032|  2.54k|    u->path = path_alloced?path:strdup(path);
 1033|  2.54k|    if(!u->path)
 1034|      0|      return CURLUE_OUT_OF_MEMORY;
 1035|  2.54k|    u->temppath = NULL; /* used now */
 1036|  2.54k|  }
 1037|       |
 1038|  3.20k|  if(hostname) {
 1039|  3.16k|    char normalized_ipv4[sizeof("255.255.255.255") + 1];
 1040|       |    /*
 1041|       |     * Parse the login details and strip them out of the host name.
 1042|       |     */
 1043|  3.16k|    if(junkscan(hostname, flags))
 1044|     15|      return CURLUE_MALFORMED_INPUT;
 1045|       |
 1046|  3.14k|    result = parse_hostname_login(u, &hostname, flags);
 1047|  3.14k|    if(result)
 1048|      0|      return result;
 1049|       |
 1050|  3.14k|    result = Curl_parse_port(u, hostname, url_has_scheme);
 1051|  3.14k|    if(result)
 1052|     19|      return result;
 1053|       |
 1054|  3.12k|    if(0 == strlen(hostname) && (flags & CURLU_NO_AUTHORITY)) {
 1055|       |      /* Skip hostname check, it's allowed to be empty. */
 1056|      0|      u->host = strdup("");
 1057|      0|    }
 1058|  3.12k|    else {
 1059|  3.12k|      if(ipv4_normalize(hostname, normalized_ipv4, sizeof(normalized_ipv4)))
 1060|  2.13k|        u->host = strdup(normalized_ipv4);
 1061|    992|      else {
 1062|    992|        result = decode_host(hostname, &u->host);
 1063|    992|        if(result)
 1064|      1|          return result;
 1065|    991|        result = hostname_check(u, u->host);
 1066|    991|        if(result)
 1067|     16|          return result;
 1068|    991|      }
 1069|  3.12k|    }
 1070|  3.11k|    if(!u->host)
 1071|      0|      return CURLUE_OUT_OF_MEMORY;
 1072|  3.11k|    if((flags & CURLU_GUESS_SCHEME) && !schemep) {
 1073|       |      /* legacy curl-style guess based on host name */
 1074|    295|      if(checkprefix("ftp.", hostname))
 1075|      3|        schemep = "ftp";
 1076|    292|      else if(checkprefix("dict.", hostname))
 1077|      2|        schemep = "dict";
 1078|    290|      else if(checkprefix("ldap.", hostname))
 1079|      1|        schemep = "ldap";
 1080|    289|      else if(checkprefix("imap.", hostname))
 1081|      1|        schemep = "imap";
 1082|    288|      else if(checkprefix("smtp.", hostname))
 1083|      1|        schemep = "smtp";
 1084|    287|      else if(checkprefix("pop3.", hostname))
 1085|      1|        schemep = "pop3";
 1086|    286|      else
 1087|    286|        schemep = "http";
 1088|       |
 1089|    295|      u->scheme = strdup(schemep);
 1090|    295|      if(!u->scheme)
 1091|      0|        return CURLUE_OUT_OF_MEMORY;
 1092|    295|    }
 1093|  3.11k|  }
 1094|       |
 1095|  3.15k|  Curl_safefree(u->scratch);
 1096|  3.15k|  Curl_safefree(u->temppath);
 1097|       |
 1098|  3.15k|  return CURLUE_OK;
 1099|  3.20k|}
urlapi.c:junkscan:
  582|  9.25k|{
  583|  9.25k|  if(part) {
  584|  9.25k|    static const char badbytes[]={
  585|  9.25k|      /* */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  586|  9.25k|      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  587|  9.25k|      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  588|  9.25k|      0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  589|  9.25k|      0x7f, 0x00 /* null-terminate */
  590|  9.25k|    };
  591|  9.25k|    size_t n = strlen(part);
  592|  9.25k|    size_t nfine = strcspn(part, badbytes);
  593|  9.25k|    if(nfine != n)
  594|       |      /* since we don't know which part is scanned, return a generic error
  595|       |         code */
  596|     30|      return TRUE;
  597|  9.22k|    if(!(flags & CURLU_ALLOW_SPACE) && strchr(part, ' '))
  598|      6|      return TRUE;
  599|  9.22k|  }
  600|  9.21k|  return FALSE;
  601|  9.25k|}
urlapi.c:strcpy_url:
  186|    243|{
  187|       |  /* we must add this with whitespace-replacing */
  188|    243|  bool left = TRUE;
  189|    243|  const unsigned char *iptr;
  190|    243|  char *optr = output;
  191|    243|  const unsigned char *host_sep = (const unsigned char *) url;
  192|       |
  193|    243|  if(!relative)
  194|      9|    host_sep = (const unsigned char *) find_host_sep(url);
  195|       |
  196|    243|  for(iptr = (unsigned char *)url;    /* read from here */
  197|  6.76k|      *iptr;         /* until zero byte */
  198|  6.52k|      iptr++) {
  199|       |
  200|  6.52k|    if(iptr < host_sep) {
  201|    191|      *optr++ = *iptr;
  202|    191|      continue;
  203|    191|    }
  204|       |
  205|  6.33k|    if(*iptr == ' ') {
  206|    378|      if(left) {
  207|    269|        *optr++='%'; /* add a '%' */
  208|    269|        *optr++='2'; /* add a '2' */
  209|    269|        *optr++='0'; /* add a '0' */
  210|    269|      }
  211|    109|      else
  212|    109|        *optr++='+'; /* add a '+' here */
  213|    378|      continue;
  214|    378|    }
  215|       |
  216|  5.95k|    if(*iptr == '?')
  217|    165|      left = FALSE;
  218|       |
  219|  5.95k|    if(urlchar_needs_escaping(*iptr)) {
  220|    602|      msnprintf(optr, 4, "%%%02x", *iptr);
  221|    602|      optr += 3;
  222|    602|    }
  223|  5.35k|    else
  224|  5.35k|      *optr++ = *iptr;
  225|  5.95k|  }
  226|    243|  *optr = 0; /* null-terminate output buffer */
  227|       |
  228|    243|}
urlapi.c:find_host_sep:
  104|     18|{
  105|     18|  const char *sep;
  106|     18|  const char *query;
  107|       |
  108|       |  /* Find the start of the hostname */
  109|     18|  sep = strstr(url, "//");
  110|     18|  if(!sep)
  111|     14|    sep = url;
  112|      4|  else
  113|      4|    sep += 2;
  114|       |
  115|     18|  query = strchr(sep, '?');
  116|     18|  sep = strchr(sep, '/');
  117|       |
  118|     18|  if(!sep)
  119|      6|    sep = url + strlen(url);
  120|       |
  121|     18|  if(!query)
  122|     16|    query = url + strlen(url);
  123|       |
  124|     18|  return sep < query ? sep : query;
  125|     18|}
urlapi.c:urlchar_needs_escaping:
  133|  9.98k|{
  134|  9.98k|  return !(ISCNTRL(c) || ISSPACE(c) || ISGRAPH(c));
  135|  9.98k|}
urlapi.c:parse_hostname_login:
  431|  3.14k|{
  432|  3.14k|  CURLUcode result = CURLUE_OK;
  433|  3.14k|  CURLcode ccode;
  434|  3.14k|  char *userp = NULL;
  435|  3.14k|  char *passwdp = NULL;
  436|  3.14k|  char *optionsp = NULL;
  437|  3.14k|  const struct Curl_handler *h = NULL;
  438|       |
  439|       |  /* At this point, we're hoping all the other special cases have
  440|       |   * been taken care of, so conn->host.name is at most
  441|       |   *    [user[:password][;options]]@]hostname
  442|       |   *
  443|       |   * We need somewhere to put the embedded details, so do that first.
  444|       |   */
  445|       |
  446|  3.14k|  char *ptr = strchr(*hostname, '@');
  447|  3.14k|  char *login = *hostname;
  448|       |
  449|  3.14k|  if(!ptr)
  450|  2.80k|    goto out;
  451|       |
  452|       |  /* We will now try to extract the
  453|       |   * possible login information in a string like:
  454|       |   * ftp://user:password@ftp.my.site:8021/README */
  455|    343|  *hostname = ++ptr;
  456|       |
  457|       |  /* if this is a known scheme, get some details */
  458|    343|  if(u->scheme)
  459|    251|    h = Curl_builtin_scheme(u->scheme);
  460|       |
  461|       |  /* We could use the login information in the URL so extract it. Only parse
  462|       |     options if the handler says we should. Note that 'h' might be NULL! */
  463|    343|  ccode = Curl_parse_login_details(login, ptr - login - 1,
  464|    343|                                   &userp, &passwdp,
  465|    343|                                   (h && (h->flags & PROTOPT_URLOPTIONS)) ?
  466|    185|                                   &optionsp:NULL);
  467|    343|  if(ccode) {
  468|      0|    result = CURLUE_MALFORMED_INPUT;
  469|      0|    goto out;
  470|      0|  }
  471|       |
  472|    343|  if(userp) {
  473|    280|    if(flags & CURLU_DISALLOW_USER) {
  474|       |      /* Option DISALLOW_USER is set and url contains username. */
  475|      0|      result = CURLUE_USER_NOT_ALLOWED;
  476|      0|      goto out;
  477|      0|    }
  478|       |
  479|    280|    u->user = userp;
  480|    280|  }
  481|       |
  482|    343|  if(passwdp)
  483|    143|    u->password = passwdp;
  484|       |
  485|    343|  if(optionsp)
  486|     62|    u->options = optionsp;
  487|       |
  488|    343|  return CURLUE_OK;
  489|  2.80k|  out:
  490|       |
  491|  2.80k|  free(userp);
  492|  2.80k|  free(passwdp);
  493|  2.80k|  free(optionsp);
  494|       |
  495|  2.80k|  return result;
  496|    343|}
urlapi.c:ipv4_normalize:
  680|  3.12k|{
  681|  3.12k|  bool done = FALSE;
  682|  3.12k|  int n = 0;
  683|  3.12k|  const char *c = hostname;
  684|  3.12k|  unsigned long parts[4] = {0, 0, 0, 0};
  685|       |
  686|  10.3k|  while(!done) {
  687|  8.16k|    char *endp;
  688|  8.16k|    unsigned long l;
  689|  8.16k|    if((*c < '0') || (*c > '9'))
  690|       |      /* most importantly this doesn't allow a leading plus or minus */
  691|    818|      return FALSE;
  692|  7.34k|    l = strtoul(c, &endp, 0);
  693|       |
  694|       |    /* overflow or nothing parsed at all */
  695|  7.34k|    if(((l == ULONG_MAX) && (errno == ERANGE)) ||  (endp == c))
  696|      1|      return FALSE;
  697|       |
  698|  7.34k|#if SIZEOF_LONG > 4
  699|       |    /* a value larger than 32 bits */
  700|  7.34k|    if(l > UINT_MAX)
  701|      1|      return FALSE;
  702|  7.34k|#endif
  703|       |
  704|  7.34k|    parts[n] = l;
  705|  7.34k|    c = endp;
  706|       |
  707|  7.34k|    switch (*c) {
  708|  5.05k|    case '.' :
  709|  5.05k|      if(n == 3)
  710|     14|        return FALSE;
  711|  5.03k|      n++;
  712|  5.03k|      c++;
  713|  5.03k|      break;
  714|       |
  715|  2.19k|    case '\0':
  716|  2.19k|      done = TRUE;
  717|  2.19k|      break;
  718|       |
  719|    103|    default:
  720|    103|      return FALSE;
  721|  7.34k|    }
  722|  7.34k|  }
  723|       |
  724|       |  /* this is deemed a valid IPv4 numerical address */
  725|       |
  726|  2.19k|  switch(n) {
  727|    533|  case 0: /* a -- 32 bits */
  728|    533|    msnprintf(outp, olen, "%u.%u.%u.%u",
  729|    533|              parts[0] >> 24, (parts[0] >> 16) & 0xff,
  730|    533|              (parts[0] >> 8) & 0xff, parts[0] & 0xff);
  731|    533|    break;
  732|    141|  case 1: /* a.b -- 8.24 bits */
  733|    141|    if((parts[0] > 0xff) || (parts[1] > 0xffffff))
  734|      7|      return FALSE;
  735|    134|    msnprintf(outp, olen, "%u.%u.%u.%u",
  736|    134|              parts[0], (parts[1] >> 16) & 0xff,
  737|    134|              (parts[1] >> 8) & 0xff, parts[1] & 0xff);
  738|    134|    break;
  739|     55|  case 2: /* a.b.c -- 8.8.16 bits */
  740|     55|    if((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xffff))
  741|     11|      return FALSE;
  742|     44|    msnprintf(outp, olen, "%u.%u.%u.%u",
  743|     44|              parts[0], parts[1], (parts[2] >> 8) & 0xff,
  744|     44|              parts[2] & 0xff);
  745|     44|    break;
  746|  1.46k|  case 3: /* a.b.c.d -- 8.8.8.8 bits */
  747|  1.46k|    if((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff) ||
  748|  1.46k|       (parts[3] > 0xff))
  749|     37|      return FALSE;
  750|  1.42k|    msnprintf(outp, olen, "%u.%u.%u.%u",
  751|  1.42k|              parts[0], parts[1], parts[2], parts[3]);
  752|  1.42k|    break;
  753|  2.19k|  }
  754|  2.13k|  return TRUE;
  755|  2.19k|}
urlapi.c:decode_host:
  759|    992|{
  760|    992|  char *per = NULL;
  761|    992|  if(hostname[0] != '[')
  762|       |    /* only decode if not an ipv6 numerical */
  763|    972|    per = strchr(hostname, '%');
  764|    992|  if(!per) {
  765|    926|    *outp = strdup(hostname);
  766|    926|    if(!*outp)
  767|      0|      return CURLUE_OUT_OF_MEMORY;
  768|    926|  }
  769|     66|  else {
  770|       |    /* might be encoded */
  771|     66|    size_t dlen;
  772|     66|    CURLcode result = Curl_urldecode(NULL, hostname, 0,
  773|     66|                                     outp, &dlen, REJECT_CTRL);
  774|     66|    if(result)
  775|      1|      return CURLUE_MALFORMED_INPUT;
  776|     66|  }
  777|       |
  778|    991|  return CURLUE_OK;
  779|    992|}
urlapi.c:mv_urlhandle:
   93|  3.15k|{
   94|  3.15k|  free_urlhandle(to);
   95|  3.15k|  *to = *from;
   96|  3.15k|  free(from);
   97|  3.15k|}
urlapi.c:concat_url:
  269|    133|{
  270|       |  /***
  271|       |   TRY to append this new path to the old URL
  272|       |   to the right of the host part. Oh crap, this is doomed to cause
  273|       |   problems in the future...
  274|       |  */
  275|    133|  char *newest;
  276|    133|  char *protsep;
  277|    133|  char *pathsep;
  278|    133|  size_t newlen;
  279|    133|  bool host_changed = FALSE;
  280|       |
  281|    133|  const char *useurl = relurl;
  282|    133|  size_t urllen;
  283|       |
  284|       |  /* we must make our own copy of the URL to play with, as it may
  285|       |     point to read-only data */
  286|    133|  char *url_clone = strdup(base);
  287|       |
  288|    133|  if(!url_clone)
  289|      0|    return NULL; /* skip out of this NOW */
  290|       |
  291|       |  /* protsep points to the start of the host name */
  292|    133|  protsep = strstr(url_clone, "//");
  293|    133|  if(!protsep)
  294|      0|    protsep = url_clone;
  295|    133|  else
  296|    133|    protsep += 2; /* pass the slashes */
  297|       |
  298|    133|  if('/' != relurl[0]) {
  299|    119|    int level = 0;
  300|       |
  301|       |    /* First we need to find out if there's a ?-letter in the URL,
  302|       |       and cut it and the right-side of that off */
  303|    119|    pathsep = strchr(protsep, '?');
  304|    119|    if(pathsep)
  305|     11|      *pathsep = 0;
  306|       |
  307|       |    /* we have a relative path to append to the last slash if there's one
  308|       |       available, or if the new URL is just a query string (starts with a
  309|       |       '?')  we append the new one at the end of the entire currently worked
  310|       |       out URL */
  311|    119|    if(useurl[0] != '?') {
  312|    118|      pathsep = strrchr(protsep, '/');
  313|    118|      if(pathsep)
  314|    118|        *pathsep = 0;
  315|    118|    }
  316|       |
  317|       |    /* Check if there's any slash after the host name, and if so, remember
  318|       |       that position instead */
  319|    119|    pathsep = strchr(protsep, '/');
  320|    119|    if(pathsep)
  321|     34|      protsep = pathsep + 1;
  322|     85|    else
  323|     85|      protsep = NULL;
  324|       |
  325|       |    /* now deal with one "./" or any amount of "../" in the newurl
  326|       |       and act accordingly */
  327|       |
  328|    119|    if((useurl[0] == '.') && (useurl[1] == '/'))
  329|      4|      useurl += 2; /* just skip the "./" */
  330|       |
  331|    127|    while((useurl[0] == '.') &&
  332|    127|          (useurl[1] == '.') &&
  333|    127|          (useurl[2] == '/')) {
  334|      8|      level++;
  335|      8|      useurl += 3; /* pass the "../" */
  336|      8|    }
  337|       |
  338|    119|    if(protsep) {
  339|     39|      while(level--) {
  340|       |        /* cut off one more level from the right of the original URL */
  341|      7|        pathsep = strrchr(protsep, '/');
  342|      7|        if(pathsep)
  343|      5|          *pathsep = 0;
  344|      2|        else {
  345|      2|          *protsep = 0;
  346|      2|          break;
  347|      2|        }
  348|      7|      }
  349|     34|    }
  350|    119|  }
  351|     14|  else {
  352|       |    /* We got a new absolute path for this server */
  353|       |
  354|     14|    if(relurl[1] == '/') {
  355|       |      /* the new URL starts with //, just keep the protocol part from the
  356|       |         original one */
  357|      9|      *protsep = 0;
  358|      9|      useurl = &relurl[2]; /* we keep the slashes from the original, so we
  359|       |                              skip the new ones */
  360|      9|      host_changed = TRUE;
  361|      9|    }
  362|      5|    else {
  363|       |      /* cut off the original URL from the first slash, or deal with URLs
  364|       |         without slash */
  365|      5|      pathsep = strchr(protsep, '/');
  366|      5|      if(pathsep) {
  367|       |        /* When people use badly formatted URLs, such as
  368|       |           "http://www.url.com?dir=/home/daniel" we must not use the first
  369|       |           slash, if there's a ?-letter before it! */
  370|      5|        char *sep = strchr(protsep, '?');
  371|      5|        if(sep && (sep < pathsep))
  372|      0|          pathsep = sep;
  373|      5|        *pathsep = 0;
  374|      5|      }
  375|      0|      else {
  376|       |        /* There was no slash. Now, since we might be operating on a badly
  377|       |           formatted URL, such as "http://www.url.com?id=2380" which doesn't
  378|       |           use a slash separator as it is supposed to, we need to check for a
  379|       |           ?-letter as well! */
  380|      0|        pathsep = strchr(protsep, '?');
  381|      0|        if(pathsep)
  382|      0|          *pathsep = 0;
  383|      0|      }
  384|      5|    }
  385|     14|  }
  386|       |
  387|       |  /* If the new part contains a space, this is a mighty stupid redirect
  388|       |     but we still make an effort to do "right". To the left of a '?'
  389|       |     letter we replace each space with %20 while it is replaced with '+'
  390|       |     on the right side of the '?' letter.
  391|       |  */
  392|    133|  newlen = strlen_url(useurl, !host_changed);
  393|       |
  394|    133|  urllen = strlen(url_clone);
  395|       |
  396|    133|  newest = malloc(urllen + 1 + /* possible slash */
  397|    133|                  newlen + 1 /* zero byte */);
  398|       |
  399|    133|  if(!newest) {
  400|      0|    free(url_clone); /* don't leak this */
  401|      0|    return NULL;
  402|      0|  }
  403|       |
  404|       |  /* copy over the root url part */
  405|    133|  memcpy(newest, url_clone, urllen);
  406|       |
  407|       |  /* check if we need to append a slash */
  408|    133|  if(('/' == useurl[0]) || (protsep && !*protsep) || ('?' == useurl[0]))
  409|     39|    ;
  410|     94|  else
  411|     94|    newest[urllen++]='/';
  412|       |
  413|       |  /* then append the new piece on the right side */
  414|    133|  strcpy_url(&newest[urllen], useurl, !host_changed);
  415|       |
  416|    133|  free(url_clone);
  417|       |
  418|    133|  return newest;
  419|    133|}
urlapi.c:strlen_url:
  144|    133|{
  145|    133|  const unsigned char *ptr;
  146|    133|  size_t newlen = 0;
  147|    133|  bool left = TRUE; /* left side of the ? */
  148|    133|  const unsigned char *host_sep = (const unsigned char *) url;
  149|       |
  150|    133|  if(!relative)
  151|      9|    host_sep = (const unsigned char *) find_host_sep(url);
  152|       |
  153|  4.73k|  for(ptr = (unsigned char *)url; *ptr; ptr++) {
  154|       |
  155|  4.60k|    if(ptr < host_sep) {
  156|    191|      ++newlen;
  157|    191|      continue;
  158|    191|    }
  159|       |
  160|  4.41k|    if(*ptr == ' ') {
  161|    378|      if(left)
  162|    269|        newlen += 3;
  163|    109|      else
  164|    109|        newlen++;
  165|    378|      continue;
  166|    378|    }
  167|       |
  168|  4.03k|    if (*ptr == '?')
  169|    131|      left = FALSE;
  170|       |
  171|  4.03k|    if(urlchar_needs_escaping(*ptr))
  172|    576|      newlen += 2;
  173|       |
  174|  4.03k|    newlen++;
  175|  4.03k|  }
  176|       |
  177|    133|  return newlen;
  178|    133|}
urlapi.c:hostname_check:
  604|    991|{
  605|    991|  size_t len;
  606|    991|  size_t hlen = strlen(hostname);
  607|       |
  608|    991|  if(hostname[0] == '[') {
  609|     20|#ifdef ENABLE_IPV6
  610|     20|    char dest[16]; /* fits a binary IPv6 address */
  611|     20|#endif
  612|     20|    const char *l = "0123456789abcdefABCDEF:.";
  613|     20|    if(hlen < 4) /* '[::]' is the shortest possible valid string */
  614|      2|      return CURLUE_MALFORMED_INPUT;
  615|     18|    hostname++;
  616|     18|    hlen -= 2;
  617|       |
  618|     18|    if(hostname[hlen] != ']')
  619|      1|      return CURLUE_MALFORMED_INPUT;
  620|       |
  621|       |    /* only valid letters are ok */
  622|     17|    len = strspn(hostname, l);
  623|     17|    if(hlen != len) {
  624|      4|      hlen = len;
  625|      4|      if(hostname[len] == '%') {
  626|       |        /* this could now be '%[zone id]' */
  627|      3|        char zoneid[16];
  628|      3|        int i = 0;
  629|      3|        char *h = &hostname[len + 1];
  630|       |        /* pass '25' if present and is a url encoded percent sign */
  631|      3|        if(!strncmp(h, "25", 2) && h[2] && (h[2] != ']'))
  632|      0|          h += 2;
  633|      8|        while(*h && (*h != ']') && (i < 15))
  634|      5|          zoneid[i++] = *h++;
  635|      3|        if(!i || (']' != *h))
  636|      0|          return CURLUE_MALFORMED_INPUT;
  637|      3|        zoneid[i] = 0;
  638|      3|        u->zoneid = strdup(zoneid);
  639|      3|        if(!u->zoneid)
  640|      0|          return CURLUE_OUT_OF_MEMORY;
  641|      3|        hostname[len] = ']'; /* insert end bracket */
  642|      3|        hostname[len + 1] = 0; /* terminate the hostname */
  643|      3|      }
  644|      1|      else
  645|      1|        return CURLUE_MALFORMED_INPUT;
  646|       |      /* hostname is fine */
  647|      4|    }
  648|     16|#ifdef ENABLE_IPV6
  649|     16|    hostname[hlen] = 0; /* end the address there */
  650|     16|    if(1 != Curl_inet_pton(AF_INET6, hostname, dest))
  651|      4|      return CURLUE_MALFORMED_INPUT;
  652|     12|    hostname[hlen] = ']'; /* restore ending bracket */
  653|     12|#endif
  654|     12|  }
  655|    971|  else {
  656|       |    /* letters from the second string is not ok */
  657|    971|    len = strcspn(hostname, " \r\n");
  658|    971|    if(hlen != len)
  659|       |      /* hostname with bad content */
  660|      1|      return CURLUE_MALFORMED_INPUT;
  661|    971|  }
  662|    982|  if(!hostname[0])
  663|      7|    return CURLUE_NO_HOST;
  664|    975|  return CURLUE_OK;
  665|    982|}

Curl_auth_create_plain_message:
   64|      1|{
   65|      1|  char *plainauth;
   66|      1|  size_t plainlen;
   67|      1|  size_t zlen;
   68|      1|  size_t clen;
   69|      1|  size_t plen;
   70|       |
   71|      1|  zlen = (authzid == NULL ? 0 : strlen(authzid));
   72|      1|  clen = strlen(authcid);
   73|      1|  plen = strlen(passwd);
   74|       |
   75|       |  /* Compute binary message length. Check for overflows. */
   76|      1|  if((zlen > SIZE_T_MAX/4) || (clen > SIZE_T_MAX/4) ||
   77|      1|     (plen > (SIZE_T_MAX/2 - 2)))
   78|      0|    return CURLE_OUT_OF_MEMORY;
   79|      1|  plainlen = zlen + clen + plen + 2;
   80|       |
   81|      1|  plainauth = malloc(plainlen + 1);
   82|      1|  if(!plainauth)
   83|      0|    return CURLE_OUT_OF_MEMORY;
   84|       |
   85|       |  /* Calculate the reply */
   86|      1|  if(zlen)
   87|      0|    memcpy(plainauth, authzid, zlen);
   88|      1|  plainauth[zlen] = '\0';
   89|      1|  memcpy(plainauth + zlen + 1, authcid, clen);
   90|      1|  plainauth[zlen + clen + 1] = '\0';
   91|      1|  memcpy(plainauth + zlen + clen + 2, passwd, plen);
   92|      1|  plainauth[plainlen] = '\0';
   93|      1|  Curl_bufref_set(out, plainauth, plainlen, curl_free);
   94|      1|  return CURLE_OK;
   95|      1|}
Curl_auth_create_login_message:
  111|     16|{
  112|     16|  Curl_bufref_set(out, valuep, strlen(valuep), NULL);
  113|     16|  return CURLE_OK;
  114|     16|}

Curl_auth_create_cram_md5_message:
   62|     29|{
   63|     29|  struct HMAC_context *ctxt;
   64|     29|  unsigned char digest[MD5_DIGEST_LEN];
   65|     29|  char *response;
   66|       |
   67|       |  /* Compute the digest using the password as the key */
   68|     29|  ctxt = Curl_HMAC_init(Curl_HMAC_MD5,
   69|     29|                        (const unsigned char *) passwdp,
   70|     29|                        curlx_uztoui(strlen(passwdp)));
   71|     29|  if(!ctxt)
   72|      0|    return CURLE_OUT_OF_MEMORY;
   73|       |
   74|       |  /* Update the digest with the given challenge */
   75|     29|  if(Curl_bufref_len(chlg))
   76|     15|    Curl_HMAC_update(ctxt, Curl_bufref_ptr(chlg),
   77|     15|                     curlx_uztoui(Curl_bufref_len(chlg)));
   78|       |
   79|       |  /* Finalise the digest */
   80|     29|  Curl_HMAC_final(ctxt, digest);
   81|       |
   82|       |  /* Generate the response */
   83|     29|  response = aprintf(
   84|     29|    "%s %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
   85|     29|    userp, digest[0], digest[1], digest[2], digest[3], digest[4],
   86|     29|    digest[5], digest[6], digest[7], digest[8], digest[9], digest[10],
   87|     29|    digest[11], digest[12], digest[13], digest[14], digest[15]);
   88|     29|  if(!response)
   89|      0|    return CURLE_OUT_OF_MEMORY;
   90|       |
   91|     29|  Curl_bufref_set(out, response, strlen(response), curl_free);
   92|     29|  return CURLE_OK;
   93|     29|}

Curl_auth_digest_get_pair:
   76|    575|{
   77|    575|  int c;
   78|    575|  bool starts_with_quote = FALSE;
   79|    575|  bool escape = FALSE;
   80|       |
   81|  4.67k|  for(c = DIGEST_MAX_VALUE_LENGTH - 1; (*str && (*str != '=') && c--);)
   82|  4.09k|    *value++ = *str++;
   83|    575|  *value = 0;
   84|       |
   85|    575|  if('=' != *str++)
   86|       |    /* eek, no match */
   87|    126|    return FALSE;
   88|       |
   89|    449|  if('\"' == *str) {
   90|       |    /* This starts with a quote so it must end with one as well! */
   91|    317|    str++;
   92|    317|    starts_with_quote = TRUE;
   93|    317|  }
   94|       |
   95|  7.00k|  for(c = DIGEST_MAX_CONTENT_LENGTH - 1; *str && c--; str++) {
   96|  6.55k|    switch(*str) {
   97|    189|    case '\\':
   98|    189|      if(!escape) {
   99|       |        /* possibly the start of an escaped quote */
  100|    100|        escape = TRUE;
  101|    100|        *content++ = '\\'; /* Even though this is an escape character, we still
  102|       |                              store it as-is in the target buffer */
  103|    100|        continue;
  104|    100|      }
  105|     89|      break;
  106|       |
  107|    203|    case ',':
  108|    203|      if(!starts_with_quote) {
  109|       |        /* This signals the end of the content if we didn't get a starting
  110|       |           quote and then we do "sloppy" parsing */
  111|    102|        c = 0; /* the end */
  112|    102|        continue;
  113|    102|      }
  114|    101|      break;
  115|       |
  116|    101|    case '\r':
  117|      0|    case '\n':
  118|       |      /* end of string */
  119|      0|      c = 0;
  120|      0|      continue;
  121|       |
  122|    754|    case '\"':
  123|    754|      if(!escape && starts_with_quote) {
  124|       |        /* end of string */
  125|    271|        c = 0;
  126|    271|        continue;
  127|    271|      }
  128|    483|      break;
  129|  6.55k|    }
  130|       |
  131|  6.08k|    escape = FALSE;
  132|  6.08k|    *content++ = *str;
  133|  6.08k|  }
  134|       |
  135|    449|  *content = 0;
  136|    449|  *endptr = str;
  137|       |
  138|    449|  return TRUE;
  139|    449|}
Curl_auth_is_digest_supported:
  312|    144|{
  313|    144|  return TRUE;
  314|    144|}
Curl_auth_create_digest_md5_message:
  339|      6|{
  340|      6|  size_t i;
  341|      6|  struct MD5_context *ctxt;
  342|      6|  char *response = NULL;
  343|      6|  unsigned char digest[MD5_DIGEST_LEN];
  344|      6|  char HA1_hex[2 * MD5_DIGEST_LEN + 1];
  345|      6|  char HA2_hex[2 * MD5_DIGEST_LEN + 1];
  346|      6|  char resp_hash_hex[2 * MD5_DIGEST_LEN + 1];
  347|      6|  char nonce[64];
  348|      6|  char realm[128];
  349|      6|  char algorithm[64];
  350|      6|  char qop_options[64];
  351|      6|  int qop_values;
  352|      6|  char cnonce[33];
  353|      6|  char nonceCount[] = "00000001";
  354|      6|  char method[]     = "AUTHENTICATE";
  355|      6|  char qop[]        = DIGEST_QOP_VALUE_STRING_AUTH;
  356|      6|  char *spn         = NULL;
  357|       |
  358|       |  /* Decode the challenge message */
  359|      6|  CURLcode result = auth_decode_digest_md5_message(chlg,
  360|      6|                                                   nonce, sizeof(nonce),
  361|      6|                                                   realm, sizeof(realm),
  362|      6|                                                   algorithm,
  363|      6|                                                   sizeof(algorithm),
  364|      6|                                                   qop_options,
  365|      6|                                                   sizeof(qop_options));
  366|      6|  if(result)
  367|      6|    return result;
  368|       |
  369|       |  /* We only support md5 sessions */
  370|      0|  if(strcmp(algorithm, "md5-sess") != 0)
  371|      0|    return CURLE_BAD_CONTENT_ENCODING;
  372|       |
  373|       |  /* Get the qop-values from the qop-options */
  374|      0|  result = auth_digest_get_qop_values(qop_options, &qop_values);
  375|      0|  if(result)
  376|      0|    return result;
  377|       |
  378|       |  /* We only support auth quality-of-protection */
  379|      0|  if(!(qop_values & DIGEST_QOP_VALUE_AUTH))
  380|      0|    return CURLE_BAD_CONTENT_ENCODING;
  381|       |
  382|       |  /* Generate 32 random hex chars, 32 bytes + 1 zero termination */
  383|      0|  result = Curl_rand_hex(data, (unsigned char *)cnonce, sizeof(cnonce));
  384|      0|  if(result)
  385|      0|    return result;
  386|       |
  387|       |  /* So far so good, now calculate A1 and H(A1) according to RFC 2831 */
  388|      0|  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  389|      0|  if(!ctxt)
  390|      0|    return CURLE_OUT_OF_MEMORY;
  391|       |
  392|      0|  Curl_MD5_update(ctxt, (const unsigned char *) userp,
  393|      0|                  curlx_uztoui(strlen(userp)));
  394|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  395|      0|  Curl_MD5_update(ctxt, (const unsigned char *) realm,
  396|      0|                  curlx_uztoui(strlen(realm)));
  397|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  398|      0|  Curl_MD5_update(ctxt, (const unsigned char *) passwdp,
  399|      0|                  curlx_uztoui(strlen(passwdp)));
  400|      0|  Curl_MD5_final(ctxt, digest);
  401|       |
  402|      0|  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  403|      0|  if(!ctxt)
  404|      0|    return CURLE_OUT_OF_MEMORY;
  405|       |
  406|      0|  Curl_MD5_update(ctxt, (const unsigned char *) digest, MD5_DIGEST_LEN);
  407|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  408|      0|  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
  409|      0|                  curlx_uztoui(strlen(nonce)));
  410|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  411|      0|  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
  412|      0|                  curlx_uztoui(strlen(cnonce)));
  413|      0|  Curl_MD5_final(ctxt, digest);
  414|       |
  415|       |  /* Convert calculated 16 octet hex into 32 bytes string */
  416|      0|  for(i = 0; i < MD5_DIGEST_LEN; i++)
  417|      0|    msnprintf(&HA1_hex[2 * i], 3, "%02x", digest[i]);
  418|       |
  419|       |  /* Generate our SPN */
  420|      0|  spn = Curl_auth_build_spn(service, realm, NULL);
  421|      0|  if(!spn)
  422|      0|    return CURLE_OUT_OF_MEMORY;
  423|       |
  424|       |  /* Calculate H(A2) */
  425|      0|  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  426|      0|  if(!ctxt) {
  427|      0|    free(spn);
  428|       |
  429|      0|    return CURLE_OUT_OF_MEMORY;
  430|      0|  }
  431|       |
  432|      0|  Curl_MD5_update(ctxt, (const unsigned char *) method,
  433|      0|                  curlx_uztoui(strlen(method)));
  434|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  435|      0|  Curl_MD5_update(ctxt, (const unsigned char *) spn,
  436|      0|                  curlx_uztoui(strlen(spn)));
  437|      0|  Curl_MD5_final(ctxt, digest);
  438|       |
  439|      0|  for(i = 0; i < MD5_DIGEST_LEN; i++)
  440|      0|    msnprintf(&HA2_hex[2 * i], 3, "%02x", digest[i]);
  441|       |
  442|       |  /* Now calculate the response hash */
  443|      0|  ctxt = Curl_MD5_init(Curl_DIGEST_MD5);
  444|      0|  if(!ctxt) {
  445|      0|    free(spn);
  446|       |
  447|      0|    return CURLE_OUT_OF_MEMORY;
  448|      0|  }
  449|       |
  450|      0|  Curl_MD5_update(ctxt, (const unsigned char *) HA1_hex, 2 * MD5_DIGEST_LEN);
  451|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  452|      0|  Curl_MD5_update(ctxt, (const unsigned char *) nonce,
  453|      0|                  curlx_uztoui(strlen(nonce)));
  454|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  455|       |
  456|      0|  Curl_MD5_update(ctxt, (const unsigned char *) nonceCount,
  457|      0|                  curlx_uztoui(strlen(nonceCount)));
  458|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  459|      0|  Curl_MD5_update(ctxt, (const unsigned char *) cnonce,
  460|      0|                  curlx_uztoui(strlen(cnonce)));
  461|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  462|      0|  Curl_MD5_update(ctxt, (const unsigned char *) qop,
  463|      0|                  curlx_uztoui(strlen(qop)));
  464|      0|  Curl_MD5_update(ctxt, (const unsigned char *) ":", 1);
  465|       |
  466|      0|  Curl_MD5_update(ctxt, (const unsigned char *) HA2_hex, 2 * MD5_DIGEST_LEN);
  467|      0|  Curl_MD5_final(ctxt, digest);
  468|       |
  469|      0|  for(i = 0; i < MD5_DIGEST_LEN; i++)
  470|      0|    msnprintf(&resp_hash_hex[2 * i], 3, "%02x", digest[i]);
  471|       |
  472|       |  /* Generate the response */
  473|      0|  response = aprintf("username=\"%s\",realm=\"%s\",nonce=\"%s\","
  474|      0|                     "cnonce=\"%s\",nc=\"%s\",digest-uri=\"%s\",response=%s,"
  475|      0|                     "qop=%s",
  476|      0|                     userp, realm, nonce,
  477|      0|                     cnonce, nonceCount, spn, resp_hash_hex, qop);
  478|      0|  free(spn);
  479|      0|  if(!response)
  480|      0|    return CURLE_OUT_OF_MEMORY;
  481|       |
  482|       |  /* Return the response. */
  483|      0|  Curl_bufref_set(out, response, strlen(response), curl_free);
  484|      0|  return result;
  485|      0|}
Curl_auth_decode_digest_http_message:
  502|    126|{
  503|    126|  bool before = FALSE; /* got a nonce before */
  504|    126|  bool foundAuth = FALSE;
  505|    126|  bool foundAuthInt = FALSE;
  506|    126|  char *token = NULL;
  507|    126|  char *tmp = NULL;
  508|       |
  509|       |  /* If we already have received a nonce, keep that in mind */
  510|    126|  if(digest->nonce)
  511|      0|    before = TRUE;
  512|       |
  513|       |  /* Clean up any former leftovers and initialise to defaults */
  514|    126|  Curl_auth_digest_cleanup(digest);
  515|       |
  516|    575|  for(;;) {
  517|    575|    char value[DIGEST_MAX_VALUE_LENGTH];
  518|    575|    char content[DIGEST_MAX_CONTENT_LENGTH];
  519|       |
  520|       |    /* Pass all additional spaces here */
  521|    804|    while(*chlg && ISSPACE(*chlg))
  522|    229|      chlg++;
  523|       |
  524|       |    /* Extract a value=content pair */
  525|    575|    if(Curl_auth_digest_get_pair(chlg, value, content, &chlg)) {
  526|    449|      if(strcasecompare(value, "nonce")) {
  527|    123|        free(digest->nonce);
  528|    123|        digest->nonce = strdup(content);
  529|    123|        if(!digest->nonce)
  530|      0|          return CURLE_OUT_OF_MEMORY;
  531|    123|      }
  532|    326|      else if(strcasecompare(value, "stale")) {
  533|      0|        if(strcasecompare(content, "true")) {
  534|      0|          digest->stale = TRUE;
  535|      0|          digest->nc = 1; /* we make a new nonce now */
  536|      0|        }
  537|      0|      }
  538|    326|      else if(strcasecompare(value, "realm")) {
  539|     83|        free(digest->realm);
  540|     83|        digest->realm = strdup(content);
  541|     83|        if(!digest->realm)
  542|      0|          return CURLE_OUT_OF_MEMORY;
  543|     83|      }
  544|    243|      else if(strcasecompare(value, "opaque")) {
  545|      0|        free(digest->opaque);
  546|      0|        digest->opaque = strdup(content);
  547|      0|        if(!digest->opaque)
  548|      0|          return CURLE_OUT_OF_MEMORY;
  549|      0|      }
  550|    243|      else if(strcasecompare(value, "qop")) {
  551|      0|        char *tok_buf = NULL;
  552|       |        /* Tokenize the list and choose auth if possible, use a temporary
  553|       |           clone of the buffer since strtok_r() ruins it */
  554|      0|        tmp = strdup(content);
  555|      0|        if(!tmp)
  556|      0|          return CURLE_OUT_OF_MEMORY;
  557|       |
  558|      0|        token = strtok_r(tmp, ",", &tok_buf);
  559|      0|        while(token != NULL) {
  560|      0|          if(strcasecompare(token, DIGEST_QOP_VALUE_STRING_AUTH)) {
  561|      0|            foundAuth = TRUE;
  562|      0|          }
  563|      0|          else if(strcasecompare(token, DIGEST_QOP_VALUE_STRING_AUTH_INT)) {
  564|      0|            foundAuthInt = TRUE;
  565|      0|          }
  566|      0|          token = strtok_r(NULL, ",", &tok_buf);
  567|      0|        }
  568|       |
  569|      0|        free(tmp);
  570|       |
  571|       |        /* Select only auth or auth-int. Otherwise, ignore */
  572|      0|        if(foundAuth) {
  573|      0|          free(digest->qop);
  574|      0|          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH);
  575|      0|          if(!digest->qop)
  576|      0|            return CURLE_OUT_OF_MEMORY;
  577|      0|        }
  578|      0|        else if(foundAuthInt) {
  579|      0|          free(digest->qop);
  580|      0|          digest->qop = strdup(DIGEST_QOP_VALUE_STRING_AUTH_INT);
  581|      0|          if(!digest->qop)
  582|      0|            return CURLE_OUT_OF_MEMORY;
  583|      0|        }
  584|      0|      }
  585|    243|      else if(strcasecompare(value, "algorithm")) {
  586|      0|        free(digest->algorithm);
  587|      0|        digest->algorithm = strdup(content);
  588|      0|        if(!digest->algorithm)
  589|      0|          return CURLE_OUT_OF_MEMORY;
  590|       |
  591|      0|        if(strcasecompare(content, "MD5-sess"))
  592|      0|          digest->algo = CURLDIGESTALGO_MD5SESS;
  593|      0|        else if(strcasecompare(content, "MD5"))
  594|      0|          digest->algo = CURLDIGESTALGO_MD5;
  595|      0|        else if(strcasecompare(content, "SHA-256"))
  596|      0|          digest->algo = CURLDIGESTALGO_SHA256;
  597|      0|        else if(strcasecompare(content, "SHA-256-SESS"))
  598|      0|          digest->algo = CURLDIGESTALGO_SHA256SESS;
  599|      0|        else if(strcasecompare(content, "SHA-512-256"))
  600|      0|          digest->algo = CURLDIGESTALGO_SHA512_256;
  601|      0|        else if(strcasecompare(content, "SHA-512-256-SESS"))
  602|      0|          digest->algo = CURLDIGESTALGO_SHA512_256SESS;
  603|      0|        else
  604|      0|          return CURLE_BAD_CONTENT_ENCODING;
  605|      0|      }
  606|    243|      else if(strcasecompare(value, "userhash")) {
  607|      0|        if(strcasecompare(content, "true")) {
  608|      0|          digest->userhash = TRUE;
  609|      0|        }
  610|      0|      }
  611|    243|      else {
  612|       |        /* Unknown specifier, ignore it! */
  613|    243|      }
  614|    449|    }
  615|    126|    else
  616|    126|      break; /* We're done here */
  617|       |
  618|       |    /* Pass all additional spaces here */
  619|    804|    while(*chlg && ISSPACE(*chlg))
  620|    355|      chlg++;
  621|       |
  622|       |    /* Allow the list to be comma-separated */
  623|    449|    if(',' == *chlg)
  624|    120|      chlg++;
  625|    449|  }
  626|       |
  627|       |  /* We had a nonce since before, and we got another one now without
  628|       |     'stale=true'. This means we provided bad credentials in the previous
  629|       |     request */
  630|    126|  if(before && !digest->stale)
  631|      0|    return CURLE_BAD_CONTENT_ENCODING;
  632|       |
  633|       |  /* We got this header without a nonce, that's a bad Digest line! */
  634|    126|  if(!digest->nonce)
  635|     46|    return CURLE_BAD_CONTENT_ENCODING;
  636|       |
  637|     80|  return CURLE_OK;
  638|    126|}
Curl_auth_create_digest_http_message:
  924|     45|{
  925|     45|  switch(digest->algo) {
  926|     45|  case CURLDIGESTALGO_MD5:
  927|     45|  case CURLDIGESTALGO_MD5SESS:
  928|     45|    return auth_create_digest_http_message(data, userp, passwdp,
  929|     45|                                           request, uripath, digest,
  930|     45|                                           outptr, outlen,
  931|     45|                                           auth_digest_md5_to_ascii,
  932|     45|                                           Curl_md5it);
  933|       |
  934|      0|  case CURLDIGESTALGO_SHA256:
  935|      0|  case CURLDIGESTALGO_SHA256SESS:
  936|      0|  case CURLDIGESTALGO_SHA512_256:
  937|      0|  case CURLDIGESTALGO_SHA512_256SESS:
  938|      0|    return auth_create_digest_http_message(data, userp, passwdp,
  939|      0|                                           request, uripath, digest,
  940|      0|                                           outptr, outlen,
  941|      0|                                           auth_digest_sha256_to_ascii,
  942|      0|                                           Curl_sha256it);
  943|       |
  944|      0|  default:
  945|      0|    return CURLE_UNSUPPORTED_PROTOCOL;
  946|     45|  }
  947|     45|}
Curl_auth_digest_cleanup:
  960|  12.6k|{
  961|  12.6k|  Curl_safefree(digest->nonce);
  962|  12.6k|  Curl_safefree(digest->cnonce);
  963|  12.6k|  Curl_safefree(digest->realm);
  964|  12.6k|  Curl_safefree(digest->opaque);
  965|  12.6k|  Curl_safefree(digest->qop);
  966|  12.6k|  Curl_safefree(digest->algorithm);
  967|       |
  968|  12.6k|  digest->nc = 0;
  969|  12.6k|  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  970|  12.6k|  digest->stale = FALSE; /* default means normal, not stale */
  971|  12.6k|  digest->userhash = FALSE;
  972|  12.6k|}
digest.c:auth_decode_digest_md5_message:
  274|      6|{
  275|      6|  const char *chlg = (const char *) Curl_bufref_ptr(chlgref);
  276|       |
  277|       |  /* Ensure we have a valid challenge message */
  278|      6|  if(!Curl_bufref_len(chlgref))
  279|      2|    return CURLE_BAD_CONTENT_ENCODING;
  280|       |
  281|       |  /* Retrieve nonce string from the challenge */
  282|      4|  if(!auth_digest_get_key_value(chlg, "nonce=\"", nonce, nlen, '\"'))
  283|      4|    return CURLE_BAD_CONTENT_ENCODING;
  284|       |
  285|       |  /* Retrieve realm string from the challenge */
  286|      0|  if(!auth_digest_get_key_value(chlg, "realm=\"", realm, rlen, '\"')) {
  287|       |    /* Challenge does not have a realm, set empty string [RFC2831] page 6 */
  288|      0|    strcpy(realm, "");
  289|      0|  }
  290|       |
  291|       |  /* Retrieve algorithm string from the challenge */
  292|      0|  if(!auth_digest_get_key_value(chlg, "algorithm=", alg, alen, ','))
  293|      0|    return CURLE_BAD_CONTENT_ENCODING;
  294|       |
  295|       |  /* Retrieve qop-options string from the challenge */
  296|      0|  if(!auth_digest_get_key_value(chlg, "qop=\"", qop, qlen, '\"'))
  297|      0|    return CURLE_BAD_CONTENT_ENCODING;
  298|       |
  299|      0|  return CURLE_OK;
  300|      0|}
digest.c:auth_digest_get_key_value:
  200|      4|{
  201|      4|  char *find_pos;
  202|      4|  size_t i;
  203|       |
  204|      4|  find_pos = strstr(chlg, key);
  205|      4|  if(!find_pos)
  206|      4|    return FALSE;
  207|       |
  208|      0|  find_pos += strlen(key);
  209|       |
  210|      0|  for(i = 0; *find_pos && *find_pos != end_char && i < max_val_len - 1; ++i)
  211|      0|    value[i] = *find_pos++;
  212|      0|  value[i] = '\0';
  213|       |
  214|      0|  return TRUE;
  215|      4|}
digest.c:auth_create_digest_http_message:
  671|     45|{
  672|     45|  CURLcode result;
  673|     45|  unsigned char hashbuf[32]; /* 32 bytes/256 bits */
  674|     45|  unsigned char request_digest[65];
  675|     45|  unsigned char ha1[65];    /* 64 digits and 1 zero byte */
  676|     45|  unsigned char ha2[65];    /* 64 digits and 1 zero byte */
  677|     45|  char userh[65];
  678|     45|  char *cnonce = NULL;
  679|     45|  size_t cnonce_sz = 0;
  680|     45|  char *userp_quoted;
  681|     45|  char *response = NULL;
  682|     45|  char *hashthis = NULL;
  683|     45|  char *tmp = NULL;
  684|       |
  685|     45|  if(!digest->nc)
  686|     45|    digest->nc = 1;
  687|       |
  688|     45|  if(!digest->cnonce) {
  689|     45|    char cnoncebuf[33];
  690|     45|    result = Curl_rand_hex(data, (unsigned char *)cnoncebuf,
  691|     45|                           sizeof(cnoncebuf));
  692|     45|    if(result)
  693|      0|      return result;
  694|       |
  695|     45|    result = Curl_base64_encode(data, cnoncebuf, strlen(cnoncebuf),
  696|     45|                                &cnonce, &cnonce_sz);
  697|     45|    if(result)
  698|      0|      return result;
  699|       |
  700|     45|    digest->cnonce = cnonce;
  701|     45|  }
  702|       |
  703|     45|  if(digest->userhash) {
  704|      0|    hashthis = aprintf("%s:%s", userp, digest->realm);
  705|      0|    if(!hashthis)
  706|      0|      return CURLE_OUT_OF_MEMORY;
  707|       |
  708|      0|    CURL_OUTPUT_DIGEST_CONV(data, hashthis);
  709|      0|    hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
  710|      0|    free(hashthis);
  711|      0|    convert_to_ascii(hashbuf, (unsigned char *)userh);
  712|      0|  }
  713|       |
  714|       |  /*
  715|       |    If the algorithm is "MD5" or unspecified (which then defaults to MD5):
  716|       |
  717|       |      A1 = unq(username-value) ":" unq(realm-value) ":" passwd
  718|       |
  719|       |    If the algorithm is "MD5-sess" then:
  720|       |
  721|       |      A1 = H(unq(username-value) ":" unq(realm-value) ":" passwd) ":"
  722|       |           unq(nonce-value) ":" unq(cnonce-value)
  723|       |  */
  724|       |
  725|     45|  hashthis = aprintf("%s:%s:%s", digest->userhash ? userh : userp,
  726|     45|                                 digest->realm, passwdp);
  727|     45|  if(!hashthis)
  728|      0|    return CURLE_OUT_OF_MEMORY;
  729|       |
  730|     45|  CURL_OUTPUT_DIGEST_CONV(data, hashthis); /* convert on non-ASCII machines */
  731|     45|  hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
  732|     45|  free(hashthis);
  733|     45|  convert_to_ascii(hashbuf, ha1);
  734|       |
  735|     45|  if(digest->algo == CURLDIGESTALGO_MD5SESS ||
  736|     45|     digest->algo == CURLDIGESTALGO_SHA256SESS ||
  737|     45|     digest->algo == CURLDIGESTALGO_SHA512_256SESS) {
  738|       |    /* nonce and cnonce are OUTSIDE the hash */
  739|      0|    tmp = aprintf("%s:%s:%s", ha1, digest->nonce, digest->cnonce);
  740|      0|    if(!tmp)
  741|      0|      return CURLE_OUT_OF_MEMORY;
  742|       |
  743|      0|    CURL_OUTPUT_DIGEST_CONV(data, tmp); /* Convert on non-ASCII machines */
  744|      0|    hash(hashbuf, (unsigned char *) tmp, strlen(tmp));
  745|      0|    free(tmp);
  746|      0|    convert_to_ascii(hashbuf, ha1);
  747|      0|  }
  748|       |
  749|       |  /*
  750|       |    If the "qop" directive's value is "auth" or is unspecified, then A2 is:
  751|       |
  752|       |      A2 = Method ":" digest-uri-value
  753|       |
  754|       |    If the "qop" value is "auth-int", then A2 is:
  755|       |
  756|       |      A2 = Method ":" digest-uri-value ":" H(entity-body)
  757|       |
  758|       |    (The "Method" value is the HTTP request method as specified in section
  759|       |    5.1.1 of RFC 2616)
  760|       |  */
  761|       |
  762|     45|  hashthis = aprintf("%s:%s", request, uripath);
  763|     45|  if(!hashthis)
  764|      0|    return CURLE_OUT_OF_MEMORY;
  765|       |
  766|     45|  if(digest->qop && strcasecompare(digest->qop, "auth-int")) {
  767|       |    /* We don't support auth-int for PUT or POST */
  768|      0|    char hashed[65];
  769|      0|    char *hashthis2;
  770|       |
  771|      0|    hash(hashbuf, (const unsigned char *)"", 0);
  772|      0|    convert_to_ascii(hashbuf, (unsigned char *)hashed);
  773|       |
  774|      0|    hashthis2 = aprintf("%s:%s", hashthis, hashed);
  775|      0|    free(hashthis);
  776|      0|    hashthis = hashthis2;
  777|      0|  }
  778|       |
  779|     45|  if(!hashthis)
  780|      0|    return CURLE_OUT_OF_MEMORY;
  781|       |
  782|     45|  CURL_OUTPUT_DIGEST_CONV(data, hashthis); /* convert on non-ASCII machines */
  783|     45|  hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
  784|     45|  free(hashthis);
  785|     45|  convert_to_ascii(hashbuf, ha2);
  786|       |
  787|     45|  if(digest->qop) {
  788|      0|    hashthis = aprintf("%s:%s:%08x:%s:%s:%s", ha1, digest->nonce, digest->nc,
  789|      0|                       digest->cnonce, digest->qop, ha2);
  790|      0|  }
  791|     45|  else {
  792|     45|    hashthis = aprintf("%s:%s:%s", ha1, digest->nonce, ha2);
  793|     45|  }
  794|       |
  795|     45|  if(!hashthis)
  796|      0|    return CURLE_OUT_OF_MEMORY;
  797|       |
  798|     45|  CURL_OUTPUT_DIGEST_CONV(data, hashthis); /* convert on non-ASCII machines */
  799|     45|  hash(hashbuf, (unsigned char *) hashthis, strlen(hashthis));
  800|     45|  free(hashthis);
  801|     45|  convert_to_ascii(hashbuf, request_digest);
  802|       |
  803|       |  /* For test case 64 (snooped from a Mozilla 1.3a request)
  804|       |
  805|       |     Authorization: Digest username="testuser", realm="testrealm", \
  806|       |     nonce="1053604145", uri="/64", response="c55f7f30d83d774a3d2dcacf725abaca"
  807|       |
  808|       |     Digest parameters are all quoted strings.  Username which is provided by
  809|       |     the user will need double quotes and backslashes within it escaped.  For
  810|       |     the other fields, this shouldn't be an issue.  realm, nonce, and opaque
  811|       |     are copied as is from the server, escapes and all.  cnonce is generated
  812|       |     with web-safe characters.  uri is already percent encoded.  nc is 8 hex
  813|       |     characters.  algorithm and qop with standard values only contain web-safe
  814|       |     characters.
  815|       |  */
  816|     45|  userp_quoted = auth_digest_string_quoted(digest->userhash ? userh : userp);
  817|     45|  if(!userp_quoted)
  818|      0|    return CURLE_OUT_OF_MEMORY;
  819|       |
  820|     45|  if(digest->qop) {
  821|      0|    response = aprintf("username=\"%s\", "
  822|      0|                       "realm=\"%s\", "
  823|      0|                       "nonce=\"%s\", "
  824|      0|                       "uri=\"%s\", "
  825|      0|                       "cnonce=\"%s\", "
  826|      0|                       "nc=%08x, "
  827|      0|                       "qop=%s, "
  828|      0|                       "response=\"%s\"",
  829|      0|                       userp_quoted,
  830|      0|                       digest->realm,
  831|      0|                       digest->nonce,
  832|      0|                       uripath,
  833|      0|                       digest->cnonce,
  834|      0|                       digest->nc,
  835|      0|                       digest->qop,
  836|      0|                       request_digest);
  837|       |
  838|      0|    if(strcasecompare(digest->qop, "auth"))
  839|      0|      digest->nc++; /* The nc (from RFC) has to be a 8 hex digit number 0
  840|       |                       padded which tells to the server how many times you are
  841|       |                       using the same nonce in the qop=auth mode */
  842|      0|  }
  843|     45|  else {
  844|     45|    response = aprintf("username=\"%s\", "
  845|     45|                       "realm=\"%s\", "
  846|     45|                       "nonce=\"%s\", "
  847|     45|                       "uri=\"%s\", "
  848|     45|                       "response=\"%s\"",
  849|     45|                       userp_quoted,
  850|     45|                       digest->realm,
  851|     45|                       digest->nonce,
  852|     45|                       uripath,
  853|     45|                       request_digest);
  854|     45|  }
  855|     45|  free(userp_quoted);
  856|     45|  if(!response)
  857|      0|    return CURLE_OUT_OF_MEMORY;
  858|       |
  859|       |  /* Add the optional fields */
  860|     45|  if(digest->opaque) {
  861|       |    /* Append the opaque */
  862|      0|    tmp = aprintf("%s, opaque=\"%s\"", response, digest->opaque);
  863|      0|    free(response);
  864|      0|    if(!tmp)
  865|      0|      return CURLE_OUT_OF_MEMORY;
  866|       |
  867|      0|    response = tmp;
  868|      0|  }
  869|       |
  870|     45|  if(digest->algorithm) {
  871|       |    /* Append the algorithm */
  872|      0|    tmp = aprintf("%s, algorithm=%s", response, digest->algorithm);
  873|      0|    free(response);
  874|      0|    if(!tmp)
  875|      0|      return CURLE_OUT_OF_MEMORY;
  876|       |
  877|      0|    response = tmp;
  878|      0|  }
  879|       |
  880|     45|  if(digest->userhash) {
  881|       |    /* Append the userhash */
  882|      0|    tmp = aprintf("%s, userhash=true", response);
  883|      0|    free(response);
  884|      0|    if(!tmp)
  885|      0|      return CURLE_OUT_OF_MEMORY;
  886|       |
  887|      0|    response = tmp;
  888|      0|  }
  889|       |
  890|       |  /* Return the output */
  891|     45|  *outptr = response;
  892|     45|  *outlen = strlen(response);
  893|       |
  894|     45|  return CURLE_OK;
  895|     45|}
digest.c:auth_digest_string_quoted:
  162|     45|{
  163|     45|  char *dest;
  164|     45|  const char *s = source;
  165|     45|  size_t n = 1; /* null terminator */
  166|       |
  167|       |  /* Calculate size needed */
  168|  2.02k|  while(*s) {
  169|  1.98k|    ++n;
  170|  1.98k|    if(*s == '"' || *s == '\\') {
  171|    345|      ++n;
  172|    345|    }
  173|  1.98k|    ++s;
  174|  1.98k|  }
  175|       |
  176|     45|  dest = malloc(n);
  177|     45|  if(dest) {
  178|     45|    char *d = dest;
  179|     45|    s = source;
  180|  2.02k|    while(*s) {
  181|  1.98k|      if(*s == '"' || *s == '\\') {
  182|    345|        *d++ = '\\';
  183|    345|      }
  184|  1.98k|      *d++ = *s++;
  185|  1.98k|    }
  186|     45|    *d = 0;
  187|     45|  }
  188|       |
  189|     45|  return dest;
  190|     45|}
digest.c:auth_digest_md5_to_ascii:
  145|    135|{
  146|    135|  int i;
  147|  2.29k|  for(i = 0; i < 16; i++)
  148|  2.16k|    msnprintf((char *) &dest[i * 2], 3, "%02x", source[i]);
  149|    135|}

Curl_auth_create_ntlm_type1_message:
  352|      1|{
  353|       |  /* NTLM type-1 message structure:
  354|       |
  355|       |       Index  Description            Content
  356|       |         0    NTLMSSP Signature      Null-terminated ASCII "NTLMSSP"
  357|       |                                     (0x4e544c4d53535000)
  358|       |         8    NTLM Message Type      long (0x01000000)
  359|       |        12    Flags                  long
  360|       |       (16)   Supplied Domain        security buffer (*)
  361|       |       (24)   Supplied Workstation   security buffer (*)
  362|       |       (32)   OS Version Structure   8 bytes (*)
  363|       |  (32) (40)   Start of data block    (*)
  364|       |                                     (*) -> Optional
  365|       |  */
  366|       |
  367|      1|  size_t size;
  368|       |
  369|      1|  char *ntlmbuf;
  370|      1|  const char *host = "";              /* empty */
  371|      1|  const char *domain = "";            /* empty */
  372|      1|  size_t hostlen = 0;
  373|      1|  size_t domlen = 0;
  374|      1|  size_t hostoff = 0;
  375|      1|  size_t domoff = hostoff + hostlen;  /* This is 0: remember that host and
  376|       |                                         domain are empty */
  377|      1|  (void)data;
  378|      1|  (void)userp;
  379|      1|  (void)passwdp;
  380|      1|  (void)service,
  381|      1|  (void)hostname,
  382|       |
  383|       |  /* Clean up any former leftovers and initialise to defaults */
  384|      1|  Curl_auth_cleanup_ntlm(ntlm);
  385|       |
  386|      1|#if defined(USE_NTRESPONSES) && \
  387|      1|    (defined(USE_NTLM2SESSION) || defined(USE_NTLM_V2))
  388|      1|#define NTLM2FLAG NTLMFLAG_NEGOTIATE_NTLM2_KEY
  389|       |#else
  390|       |#define NTLM2FLAG 0
  391|       |#endif
  392|      1|  ntlmbuf = aprintf(NTLMSSP_SIGNATURE "%c"
  393|      1|                    "\x01%c%c%c" /* 32-bit type = 1 */
  394|      1|                    "%c%c%c%c"   /* 32-bit NTLM flag field */
  395|      1|                    "%c%c"       /* domain length */
  396|      1|                    "%c%c"       /* domain allocated space */
  397|      1|                    "%c%c"       /* domain name offset */
  398|      1|                    "%c%c"       /* 2 zeroes */
  399|      1|                    "%c%c"       /* host length */
  400|      1|                    "%c%c"       /* host allocated space */
  401|      1|                    "%c%c"       /* host name offset */
  402|      1|                    "%c%c"       /* 2 zeroes */
  403|      1|                    "%s"         /* host name */
  404|      1|                    "%s",        /* domain string */
  405|      1|                    0,           /* trailing zero */
  406|      1|                    0, 0, 0,     /* part of type-1 long */
  407|       |
  408|      1|                    LONGQUARTET(NTLMFLAG_NEGOTIATE_OEM |
  409|      1|                                NTLMFLAG_REQUEST_TARGET |
  410|      1|                                NTLMFLAG_NEGOTIATE_NTLM_KEY |
  411|      1|                                NTLM2FLAG |
  412|      1|                                NTLMFLAG_NEGOTIATE_ALWAYS_SIGN),
  413|      1|                    SHORTPAIR(domlen),
  414|      1|                    SHORTPAIR(domlen),
  415|      1|                    SHORTPAIR(domoff),
  416|      1|                    0, 0,
  417|      1|                    SHORTPAIR(hostlen),
  418|      1|                    SHORTPAIR(hostlen),
  419|      1|                    SHORTPAIR(hostoff),
  420|      1|                    0, 0,
  421|      1|                    host,  /* this is empty */
  422|      1|                    domain /* this is empty */);
  423|       |
  424|      1|  if(!ntlmbuf)
  425|      0|    return CURLE_OUT_OF_MEMORY;
  426|       |
  427|       |  /* Initial packet length */
  428|      1|  size = 32 + hostlen + domlen;
  429|       |
  430|      1|  DEBUG_OUT({
  431|      1|    fprintf(stderr, "* TYPE1 header flags=0x%02.2x%02.2x%02.2x%02.2x "
  432|      1|            "0x%08.8x ",
  433|      1|            LONGQUARTET(NTLMFLAG_NEGOTIATE_OEM |
  434|      1|                        NTLMFLAG_REQUEST_TARGET |
  435|      1|                        NTLMFLAG_NEGOTIATE_NTLM_KEY |
  436|      1|                        NTLM2FLAG |
  437|      1|                        NTLMFLAG_NEGOTIATE_ALWAYS_SIGN),
  438|      1|            NTLMFLAG_NEGOTIATE_OEM |
  439|      1|            NTLMFLAG_REQUEST_TARGET |
  440|      1|            NTLMFLAG_NEGOTIATE_NTLM_KEY |
  441|      1|            NTLM2FLAG |
  442|      1|            NTLMFLAG_NEGOTIATE_ALWAYS_SIGN);
  443|      1|    ntlm_print_flags(stderr,
  444|      1|                     NTLMFLAG_NEGOTIATE_OEM |
  445|      1|                     NTLMFLAG_REQUEST_TARGET |
  446|      1|                     NTLMFLAG_NEGOTIATE_NTLM_KEY |
  447|      1|                     NTLM2FLAG |
  448|      1|                     NTLMFLAG_NEGOTIATE_ALWAYS_SIGN);
  449|      1|    fprintf(stderr, "\n****\n");
  450|      1|  });
  451|       |
  452|      1|  Curl_bufref_set(out, ntlmbuf, size, curl_free);
  453|      1|  return CURLE_OK;
  454|      1|}
Curl_auth_cleanup_ntlm:
  849|  6.10k|{
  850|       |  /* Free the target info */
  851|  6.10k|  Curl_safefree(ntlm->target_info);
  852|       |
  853|       |  /* Reset any variables */
  854|  6.10k|  ntlm->target_info_len = 0;
  855|  6.10k|}

Curl_tls_keylog_open:
   47|      1|{
   48|      1|  char *keylog_file_name;
   49|       |
   50|      1|  if(!keylog_file_fp) {
   51|      1|    keylog_file_name = curl_getenv("SSLKEYLOGFILE");
   52|      1|    if(keylog_file_name) {
   53|      0|      keylog_file_fp = fopen(keylog_file_name, FOPEN_APPENDTEXT);
   54|      0|      if(keylog_file_fp) {
   55|       |#ifdef WIN32
   56|       |        if(setvbuf(keylog_file_fp, NULL, _IONBF, 0))
   57|       |#else
   58|      0|        if(setvbuf(keylog_file_fp, NULL, _IOLBF, 4096))
   59|      0|#endif
   60|      0|        {
   61|      0|          fclose(keylog_file_fp);
   62|      0|          keylog_file_fp = NULL;
   63|      0|        }
   64|      0|      }
   65|      0|      Curl_safefree(keylog_file_name);
   66|      0|    }
   67|      1|  }
   68|      1|}
Curl_tls_keylog_enabled:
   81|     30|{
   82|     30|  return keylog_file_fp != NULL;
   83|     30|}

openssl.c:ossl_init:
 1172|      1|{
 1173|       |#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) &&  \
 1174|       |  !defined(LIBRESSL_VERSION_NUMBER)
 1175|       |  const uint64_t flags =
 1176|       |#ifdef OPENSSL_INIT_ENGINE_ALL_BUILTIN
 1177|       |    /* not present in BoringSSL */
 1178|       |    OPENSSL_INIT_ENGINE_ALL_BUILTIN |
 1179|       |#endif
 1180|       |#ifdef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG
 1181|       |    OPENSSL_INIT_NO_LOAD_CONFIG |
 1182|       |#else
 1183|       |    OPENSSL_INIT_LOAD_CONFIG |
 1184|       |#endif
 1185|       |    0;
 1186|       |  OPENSSL_init_ssl(flags, NULL);
 1187|       |#else
 1188|      1|  OPENSSL_load_builtin_modules();
 1189|       |
 1190|      1|#ifdef USE_OPENSSL_ENGINE
 1191|      1|  ENGINE_load_builtin_engines();
 1192|      1|#endif
 1193|       |
 1194|       |/* CONF_MFLAGS_DEFAULT_SECTION was introduced some time between 0.9.8b and
 1195|       |   0.9.8e */
 1196|       |#ifndef CONF_MFLAGS_DEFAULT_SECTION
 1197|       |#define CONF_MFLAGS_DEFAULT_SECTION 0x0
 1198|       |#endif
 1199|       |
 1200|      1|#ifndef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG
 1201|      1|  CONF_modules_load_file(NULL, NULL,
 1202|      1|                         CONF_MFLAGS_DEFAULT_SECTION|
 1203|      1|                         CONF_MFLAGS_IGNORE_MISSING_FILE);
 1204|      1|#endif
 1205|       |
 1206|       |  /* Let's get nice error messages */
 1207|      1|  SSL_load_error_strings();
 1208|       |
 1209|       |  /* Init the global ciphers and digests */
 1210|      1|  if(!SSLeay_add_ssl_algorithms())
 1211|      0|    return 0;
 1212|       |
 1213|      1|  OpenSSL_add_all_algorithms();
 1214|      1|#endif
 1215|       |
 1216|      1|  Curl_tls_keylog_open();
 1217|       |
 1218|       |  /* Initialize the extra data indexes */
 1219|      1|  if(ossl_get_ssl_data_index() < 0 || ossl_get_ssl_conn_index() < 0 ||
 1220|      1|     ossl_get_ssl_sockindex_index() < 0 || ossl_get_proxy_index() < 0)
 1221|      0|    return 0;
 1222|       |
 1223|      1|  return 1;
 1224|      1|}
openssl.c:ossl_get_ssl_data_index:
  373|     91|{
  374|     91|  static int ssl_ex_data_data_index = -1;
  375|     91|  if(ssl_ex_data_data_index < 0) {
  376|      1|    ssl_ex_data_data_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  377|      1|  }
  378|     91|  return ssl_ex_data_data_index;
  379|     91|}
openssl.c:ossl_get_ssl_conn_index:
  385|     91|{
  386|     91|  static int ssl_ex_data_conn_index = -1;
  387|     91|  if(ssl_ex_data_conn_index < 0) {
  388|      1|    ssl_ex_data_conn_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  389|      1|  }
  390|     91|  return ssl_ex_data_conn_index;
  391|     91|}
openssl.c:ossl_get_ssl_sockindex_index:
  397|     91|{
  398|     91|  static int sockindex_index = -1;
  399|     91|  if(sockindex_index < 0) {
  400|      1|    sockindex_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  401|      1|  }
  402|     91|  return sockindex_index;
  403|     91|}
openssl.c:ossl_get_proxy_index:
  409|     91|{
  410|     91|  static int proxy_index = -1;
  411|     91|  if(proxy_index < 0) {
  412|      1|    proxy_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  413|      1|  }
  414|     91|  return proxy_index;
  415|     91|}
openssl.c:ossl_strerror:
  351|     30|{
  352|     30|  if(size)
  353|     30|    *buf = '\0';
  354|       |
  355|       |#ifdef OPENSSL_IS_BORINGSSL
  356|       |  ERR_error_string_n((uint32_t)error, buf, size);
  357|       |#else
  358|     30|  ERR_error_string_n(error, buf, size);
  359|     30|#endif
  360|       |
  361|     30|  if(size > 1 && !*buf) {
  362|      0|    strncpy(buf, (error ? "Unknown error" : "No error"), size);
  363|      0|    buf[size - 1] = '\0';
  364|      0|  }
  365|       |
  366|     30|  return buf;
  367|     30|}
openssl.c:SSL_ERROR_to_str:
  311|     30|{
  312|     30|  switch(err) {
  313|      0|  case SSL_ERROR_NONE:
  314|      0|    return "SSL_ERROR_NONE";
  315|      0|  case SSL_ERROR_SSL:
  316|      0|    return "SSL_ERROR_SSL";
  317|      0|  case SSL_ERROR_WANT_READ:
  318|      0|    return "SSL_ERROR_WANT_READ";
  319|      0|  case SSL_ERROR_WANT_WRITE:
  320|      0|    return "SSL_ERROR_WANT_WRITE";
  321|      0|  case SSL_ERROR_WANT_X509_LOOKUP:
  322|      0|    return "SSL_ERROR_WANT_X509_LOOKUP";
  323|     30|  case SSL_ERROR_SYSCALL:
  324|     30|    return "SSL_ERROR_SYSCALL";
  325|      0|  case SSL_ERROR_ZERO_RETURN:
  326|      0|    return "SSL_ERROR_ZERO_RETURN";
  327|      0|  case SSL_ERROR_WANT_CONNECT:
  328|      0|    return "SSL_ERROR_WANT_CONNECT";
  329|      0|  case SSL_ERROR_WANT_ACCEPT:
  330|      0|    return "SSL_ERROR_WANT_ACCEPT";
  331|       |#if defined(SSL_ERROR_WANT_ASYNC)
  332|       |  case SSL_ERROR_WANT_ASYNC:
  333|       |    return "SSL_ERROR_WANT_ASYNC";
  334|       |#endif
  335|       |#if defined(SSL_ERROR_WANT_ASYNC_JOB)
  336|       |  case SSL_ERROR_WANT_ASYNC_JOB:
  337|       |    return "SSL_ERROR_WANT_ASYNC_JOB";
  338|       |#endif
  339|       |#if defined(SSL_ERROR_WANT_EARLY)
  340|       |  case SSL_ERROR_WANT_EARLY:
  341|       |    return "SSL_ERROR_WANT_EARLY";
  342|       |#endif
  343|      0|  default:
  344|      0|    return "SSL_ERROR unknown";
  345|     30|  }
  346|     30|}
openssl.c:ossl_data_pending:
 4167|  10.6k|{
 4168|  10.6k|  const struct ssl_connect_data *connssl = &conn->ssl[connindex];
 4169|  10.6k|  if(connssl->backend->handle && SSL_pending(connssl->backend->handle))
 4170|      0|    return TRUE;
 4171|  10.6k|#ifndef CURL_DISABLE_PROXY
 4172|  10.6k|  {
 4173|  10.6k|    const struct ssl_connect_data *proxyssl = &conn->proxy_ssl[connindex];
 4174|  10.6k|    if(proxyssl->backend->handle && SSL_pending(proxyssl->backend->handle))
 4175|      0|      return TRUE;
 4176|  10.6k|  }
 4177|  10.6k|#endif
 4178|  10.6k|  return FALSE;
 4179|  10.6k|}
openssl.c:ossl_random:
 4427|  3.84k|{
 4428|  3.84k|  int rc;
 4429|  3.84k|  if(data) {
 4430|  3.84k|    if(ossl_seed(data)) /* Initiate the seed if not already done */
 4431|      0|      return CURLE_FAILED_INIT; /* couldn't seed for some reason */
 4432|  3.84k|  }
 4433|      0|  else {
 4434|      0|    if(!rand_enough())
 4435|      0|      return CURLE_FAILED_INIT;
 4436|      0|  }
 4437|       |  /* RAND_bytes() returns 1 on success, 0 otherwise.  */
 4438|  3.84k|  rc = RAND_bytes(entropy, curlx_uztosi(length));
 4439|  3.84k|  return (rc == 1 ? CURLE_OK : CURLE_FAILED_INIT);
 4440|  3.84k|}
openssl.c:ossl_seed:
  441|  3.87k|{
  442|       |  /* This might get called before it has been added to a multi handle */
  443|  3.87k|  if(data->multi && data->multi->ssl_seeded)
  444|    135|    return CURLE_OK;
  445|       |
  446|  3.73k|  if(rand_enough()) {
  447|       |    /* OpenSSL 1.1.0+ should return here */
  448|  3.73k|    if(data->multi)
  449|     75|      data->multi->ssl_seeded = TRUE;
  450|  3.73k|    return CURLE_OK;
  451|  3.73k|  }
  452|       |#ifdef HAVE_RANDOM_INIT_BY_DEFAULT
  453|       |  /* with OpenSSL 1.1.0+, a failed RAND_status is a showstopper */
  454|       |  failf(data, "Insufficient randomness");
  455|       |  return CURLE_SSL_CONNECT_ERROR;
  456|       |#else
  457|       |
  458|       |#ifndef RANDOM_FILE
  459|       |  /* if RANDOM_FILE isn't defined, we only perform this if an option tells
  460|       |     us to! */
  461|       |  if(data->set.str[STRING_SSL_RANDOM_FILE])
  462|       |#define RANDOM_FILE "" /* doesn't matter won't be used */
  463|       |#endif
  464|      0|  {
  465|       |    /* let the option override the define */
  466|      0|    RAND_load_file((data->set.str[STRING_SSL_RANDOM_FILE]?
  467|      0|                    data->set.str[STRING_SSL_RANDOM_FILE]:
  468|      0|                    RANDOM_FILE),
  469|      0|                   RAND_LOAD_LENGTH);
  470|      0|    if(rand_enough())
  471|      0|      return CURLE_OK;
  472|      0|  }
  473|       |
  474|      0|#if defined(HAVE_RAND_EGD)
  475|       |  /* only available in OpenSSL 0.9.5 and later */
  476|       |  /* EGD_SOCKET is set at configure time or not at all */
  477|      0|#ifndef EGD_SOCKET
  478|       |  /* If we don't have the define set, we only do this if the egd-option
  479|       |     is set */
  480|      0|  if(data->set.str[STRING_SSL_EGDSOCKET])
  481|      0|#define EGD_SOCKET "" /* doesn't matter won't be used */
  482|      0|#endif
  483|      0|  {
  484|       |    /* If there's an option and a define, the option overrides the
  485|       |       define */
  486|      0|    int ret = RAND_egd(data->set.str[STRING_SSL_EGDSOCKET]?
  487|      0|                       data->set.str[STRING_SSL_EGDSOCKET]:EGD_SOCKET);
  488|      0|    if(-1 != ret) {
  489|      0|      if(rand_enough())
  490|      0|        return CURLE_OK;
  491|      0|    }
  492|      0|  }
  493|      0|#endif
  494|       |
  495|       |  /* fallback to a custom seeding of the PRNG using a hash based on a current
  496|       |     time */
  497|      0|  do {
  498|      0|    unsigned char randb[64];
  499|      0|    size_t len = sizeof(randb);
  500|      0|    size_t i, i_max;
  501|      0|    for(i = 0, i_max = len / sizeof(struct curltime); i < i_max; ++i) {
  502|      0|      struct curltime tv = Curl_now();
  503|      0|      Curl_wait_ms(1);
  504|      0|      tv.tv_sec *= i + 1;
  505|      0|      tv.tv_usec *= (unsigned int)i + 2;
  506|      0|      tv.tv_sec ^= ((Curl_now().tv_sec + Curl_now().tv_usec) *
  507|      0|                    (i + 3)) << 8;
  508|      0|      tv.tv_usec ^= (unsigned int) ((Curl_now().tv_sec +
  509|      0|                                     Curl_now().tv_usec) *
  510|      0|                                    (i + 4)) << 16;
  511|      0|      memcpy(&randb[i * sizeof(struct curltime)], &tv,
  512|      0|             sizeof(struct curltime));
  513|      0|    }
  514|      0|    RAND_add(randb, (int)len, (double)len/2);
  515|      0|  } while(!rand_enough());
  516|       |
  517|      0|  {
  518|       |    /* generates a default path for the random seed file */
  519|      0|    char fname[256];
  520|      0|    fname[0] = 0; /* blank it first */
  521|      0|    RAND_file_name(fname, sizeof(fname));
  522|      0|    if(fname[0]) {
  523|       |      /* we got a file name to try */
  524|      0|      RAND_load_file(fname, RAND_LOAD_LENGTH);
  525|      0|      if(rand_enough())
  526|      0|        return CURLE_OK;
  527|      0|    }
  528|      0|  }
  529|       |
  530|      0|  infof(data, "libcurl is now using a weak random seed!");
  531|      0|  return (rand_enough() ? CURLE_OK :
  532|      0|          CURLE_SSL_CONNECT_ERROR /* confusing error code */);
  533|      0|#endif
  534|      0|}
openssl.c:rand_enough:
  436|  3.73k|{
  437|  3.73k|  return (0 != RAND_status()) ? TRUE : FALSE;
  438|  3.73k|}
openssl.c:ossl_connect_common:
 4038|     30|{
 4039|     30|  CURLcode result;
 4040|     30|  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 4041|     30|  curl_socket_t sockfd = conn->sock[sockindex];
 4042|     30|  int what;
 4043|       |
 4044|       |  /* check if the connection has already been established */
 4045|     30|  if(ssl_connection_complete == connssl->state) {
 4046|      0|    *done = TRUE;
 4047|      0|    return CURLE_OK;
 4048|      0|  }
 4049|       |
 4050|     30|  if(ssl_connect_1 == connssl->connecting_state) {
 4051|       |    /* Find out how much more time we're allowed */
 4052|     30|    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
 4053|       |
 4054|     30|    if(timeout_ms < 0) {
 4055|       |      /* no need to continue if time is already up */
 4056|      0|      failf(data, "SSL connection timeout");
 4057|      0|      return CURLE_OPERATION_TIMEDOUT;
 4058|      0|    }
 4059|       |
 4060|     30|    result = ossl_connect_step1(data, conn, sockindex);
 4061|     30|    if(result)
 4062|      0|      return result;
 4063|     30|  }
 4064|       |
 4065|     30|  while(ssl_connect_2 == connssl->connecting_state ||
 4066|     30|        ssl_connect_2_reading == connssl->connecting_state ||
 4067|     30|        ssl_connect_2_writing == connssl->connecting_state) {
 4068|       |
 4069|       |    /* check allowed time left */
 4070|     30|    const timediff_t timeout_ms = Curl_timeleft(data, NULL, TRUE);
 4071|       |
 4072|     30|    if(timeout_ms < 0) {
 4073|       |      /* no need to continue if time already is up */
 4074|      0|      failf(data, "SSL connection timeout");
 4075|      0|      return CURLE_OPERATION_TIMEDOUT;
 4076|      0|    }
 4077|       |
 4078|       |    /* if ssl is expecting something, check if it's available. */
 4079|     30|    if(connssl->connecting_state == ssl_connect_2_reading ||
 4080|     30|       connssl->connecting_state == ssl_connect_2_writing) {
 4081|       |
 4082|      0|      curl_socket_t writefd = ssl_connect_2_writing ==
 4083|      0|        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
 4084|      0|      curl_socket_t readfd = ssl_connect_2_reading ==
 4085|      0|        connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
 4086|       |
 4087|      0|      what = Curl_socket_check(readfd, CURL_SOCKET_BAD, writefd,
 4088|      0|                               nonblocking?0:timeout_ms);
 4089|      0|      if(what < 0) {
 4090|       |        /* fatal error */
 4091|      0|        failf(data, "select/poll on SSL socket, errno: %d", SOCKERRNO);
 4092|      0|        return CURLE_SSL_CONNECT_ERROR;
 4093|      0|      }
 4094|      0|      if(0 == what) {
 4095|      0|        if(nonblocking) {
 4096|      0|          *done = FALSE;
 4097|      0|          return CURLE_OK;
 4098|      0|        }
 4099|       |        /* timeout */
 4100|      0|        failf(data, "SSL connection timeout");
 4101|      0|        return CURLE_OPERATION_TIMEDOUT;
 4102|      0|      }
 4103|       |      /* socket is readable or writable */
 4104|      0|    }
 4105|       |
 4106|       |    /* Run transaction, and return to the caller if it failed or if this
 4107|       |     * connection is done nonblocking and this loop would execute again. This
 4108|       |     * permits the owner of a multi handle to abort a connection attempt
 4109|       |     * before step2 has completed while ensuring that a client using select()
 4110|       |     * or epoll() will always have a valid fdset to wait on.
 4111|       |     */
 4112|     30|    result = ossl_connect_step2(data, conn, sockindex);
 4113|     30|    if(result || (nonblocking &&
 4114|      0|                  (ssl_connect_2 == connssl->connecting_state ||
 4115|      0|                   ssl_connect_2_reading == connssl->connecting_state ||
 4116|      0|                   ssl_connect_2_writing == connssl->connecting_state)))
 4117|     30|      return result;
 4118|       |
 4119|     30|  } /* repeat step2 until all transactions are done. */
 4120|       |
 4121|      0|  if(ssl_connect_3 == connssl->connecting_state) {
 4122|      0|    result = ossl_connect_step3(data, conn, sockindex);
 4123|      0|    if(result)
 4124|      0|      return result;
 4125|      0|  }
 4126|       |
 4127|      0|  if(ssl_connect_done == connssl->connecting_state) {
 4128|      0|    connssl->state = ssl_connection_complete;
 4129|      0|    conn->recv[sockindex] = ossl_recv;
 4130|      0|    conn->send[sockindex] = ossl_send;
 4131|      0|    *done = TRUE;
 4132|      0|  }
 4133|      0|  else
 4134|      0|    *done = FALSE;
 4135|       |
 4136|       |  /* Reset our connect state machine */
 4137|      0|  connssl->connecting_state = ssl_connect_1;
 4138|       |
 4139|      0|  return CURLE_OK;
 4140|      0|}
openssl.c:ossl_connect_step1:
 2604|     30|{
 2605|     30|  CURLcode result = CURLE_OK;
 2606|     30|  char *ciphers;
 2607|     30|  SSL_METHOD_QUAL SSL_METHOD *req_method = NULL;
 2608|     30|  X509_LOOKUP *lookup = NULL;
 2609|     30|  curl_socket_t sockfd = conn->sock[sockindex];
 2610|     30|  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 2611|     30|  ctx_option_t ctx_options = 0;
 2612|     30|  void *ssl_sessionid = NULL;
 2613|       |
 2614|     30|#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
 2615|     30|  bool sni;
 2616|     30|  const char * const hostname = SSL_HOST_NAME();
 2617|       |
 2618|     30|#ifdef ENABLE_IPV6
 2619|     30|  struct in6_addr addr;
 2620|       |#else
 2621|       |  struct in_addr addr;
 2622|       |#endif
 2623|     30|#endif
 2624|     30|  const long int ssl_version = SSL_CONN_CONFIG(version);
 2625|     30|#ifdef USE_OPENSSL_SRP
 2626|     30|  const enum CURL_TLSAUTH ssl_authtype = SSL_SET_OPTION(authtype);
 2627|     30|#endif
 2628|     30|  char * const ssl_cert = SSL_SET_OPTION(primary.clientcert);
 2629|     30|  const struct curl_blob *ssl_cert_blob = SSL_SET_OPTION(primary.cert_blob);
 2630|     30|  const struct curl_blob *ca_info_blob = SSL_CONN_CONFIG(ca_info_blob);
 2631|     30|  const char * const ssl_cert_type = SSL_SET_OPTION(cert_type);
 2632|     30|  const char * const ssl_cafile =
 2633|       |    /* CURLOPT_CAINFO_BLOB overrides CURLOPT_CAINFO */
 2634|     30|    (ca_info_blob ? NULL : SSL_CONN_CONFIG(CAfile));
 2635|     30|  const char * const ssl_capath = SSL_CONN_CONFIG(CApath);
 2636|     30|  const bool verifypeer = SSL_CONN_CONFIG(verifypeer);
 2637|     30|  const char * const ssl_crlfile = SSL_SET_OPTION(CRLfile);
 2638|     30|  char error_buffer[256];
 2639|     30|  struct ssl_backend_data *backend = connssl->backend;
 2640|     30|  bool imported_native_ca = false;
 2641|       |
 2642|     30|  DEBUGASSERT(ssl_connect_1 == connssl->connecting_state);
 2643|       |
 2644|       |  /* Make funny stuff to get random input */
 2645|     30|  result = ossl_seed(data);
 2646|     30|  if(result)
 2647|      0|    return result;
 2648|       |
 2649|     30|  SSL_SET_OPTION_LVALUE(certverifyresult) = !X509_V_OK;
 2650|       |
 2651|       |  /* check to see if we've been told to use an explicit SSL/TLS version */
 2652|       |
 2653|     30|  switch(ssl_version) {
 2654|     30|  case CURL_SSLVERSION_DEFAULT:
 2655|     30|  case CURL_SSLVERSION_TLSv1:
 2656|     30|  case CURL_SSLVERSION_TLSv1_0:
 2657|     30|  case CURL_SSLVERSION_TLSv1_1:
 2658|     30|  case CURL_SSLVERSION_TLSv1_2:
 2659|     30|  case CURL_SSLVERSION_TLSv1_3:
 2660|       |    /* it will be handled later with the context options */
 2661|       |#if (OPENSSL_VERSION_NUMBER >= 0x10100000L)
 2662|       |    req_method = TLS_client_method();
 2663|       |#else
 2664|     30|    req_method = SSLv23_client_method();
 2665|     30|#endif
 2666|     30|    use_sni(TRUE);
 2667|     30|    break;
 2668|      0|  case CURL_SSLVERSION_SSLv2:
 2669|      0|    failf(data, "No SSLv2 support");
 2670|      0|    return CURLE_NOT_BUILT_IN;
 2671|      0|  case CURL_SSLVERSION_SSLv3:
 2672|      0|    failf(data, "No SSLv3 support");
 2673|      0|    return CURLE_NOT_BUILT_IN;
 2674|      0|  default:
 2675|      0|    failf(data, "Unrecognized parameter passed via CURLOPT_SSLVERSION");
 2676|      0|    return CURLE_SSL_CONNECT_ERROR;
 2677|     30|  }
 2678|       |
 2679|     30|  DEBUGASSERT(!backend->ctx);
 2680|     30|  backend->ctx = SSL_CTX_new(req_method);
 2681|       |
 2682|     30|  if(!backend->ctx) {
 2683|      0|    failf(data, "SSL: couldn't create a context: %s",
 2684|      0|          ossl_strerror(ERR_peek_error(), error_buffer, sizeof(error_buffer)));
 2685|      0|    return CURLE_OUT_OF_MEMORY;
 2686|      0|  }
 2687|       |
 2688|     30|#ifdef SSL_MODE_RELEASE_BUFFERS
 2689|     30|  SSL_CTX_set_mode(backend->ctx, SSL_MODE_RELEASE_BUFFERS);
 2690|     30|#endif
 2691|       |
 2692|     30|#ifdef SSL_CTRL_SET_MSG_CALLBACK
 2693|     30|  if(data->set.fdebug && data->set.verbose) {
 2694|       |    /* the SSL trace callback is only used for verbose logging */
 2695|      0|    SSL_CTX_set_msg_callback(backend->ctx, ossl_trace);
 2696|      0|    SSL_CTX_set_msg_callback_arg(backend->ctx, conn);
 2697|      0|    set_logger(conn, data);
 2698|      0|  }
 2699|     30|#endif
 2700|       |
 2701|       |  /* OpenSSL contains code to work around lots of bugs and flaws in various
 2702|       |     SSL-implementations. SSL_CTX_set_options() is used to enabled those
 2703|       |     work-arounds. The man page for this option states that SSL_OP_ALL enables
 2704|       |     all the work-arounds and that "It is usually safe to use SSL_OP_ALL to
 2705|       |     enable the bug workaround options if compatibility with somewhat broken
 2706|       |     implementations is desired."
 2707|       |
 2708|       |     The "-no_ticket" option was introduced in OpenSSL 0.9.8j. It's a flag to
 2709|       |     disable "rfc4507bis session ticket support".  rfc4507bis was later turned
 2710|       |     into the proper RFC5077 it seems: https://tools.ietf.org/html/rfc5077
 2711|       |
 2712|       |     The enabled extension concerns the session management. I wonder how often
 2713|       |     libcurl stops a connection and then resumes a TLS session. Also, sending
 2714|       |     the session data is some overhead. I suggest that you just use your
 2715|       |     proposed patch (which explicitly disables TICKET).
 2716|       |
 2717|       |     If someone writes an application with libcurl and OpenSSL who wants to
 2718|       |     enable the feature, one can do this in the SSL callback.
 2719|       |
 2720|       |     SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG option enabling allowed proper
 2721|       |     interoperability with web server Netscape Enterprise Server 2.0.1 which
 2722|       |     was released back in 1996.
 2723|       |
 2724|       |     Due to CVE-2010-4180, option SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG has
 2725|       |     become ineffective as of OpenSSL 0.9.8q and 1.0.0c. In order to mitigate
 2726|       |     CVE-2010-4180 when using previous OpenSSL versions we no longer enable
 2727|       |     this option regardless of OpenSSL version and SSL_OP_ALL definition.
 2728|       |
 2729|       |     OpenSSL added a work-around for a SSL 3.0/TLS 1.0 CBC vulnerability
 2730|       |     (https://www.openssl.org/~bodo/tls-cbc.txt). In 0.9.6e they added a bit to
 2731|       |     SSL_OP_ALL that _disables_ that work-around despite the fact that
 2732|       |     SSL_OP_ALL is documented to do "rather harmless" workarounds. In order to
 2733|       |     keep the secure work-around, the SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS bit
 2734|       |     must not be set.
 2735|       |  */
 2736|       |
 2737|     30|  ctx_options = SSL_OP_ALL;
 2738|       |
 2739|     30|#ifdef SSL_OP_NO_TICKET
 2740|     30|  ctx_options |= SSL_OP_NO_TICKET;
 2741|     30|#endif
 2742|       |
 2743|     30|#ifdef SSL_OP_NO_COMPRESSION
 2744|     30|  ctx_options |= SSL_OP_NO_COMPRESSION;
 2745|     30|#endif
 2746|       |
 2747|     30|#ifdef SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG
 2748|       |  /* mitigate CVE-2010-4180 */
 2749|     30|  ctx_options &= ~SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;
 2750|     30|#endif
 2751|       |
 2752|     30|#ifdef SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
 2753|       |  /* unless the user explicitly asks to allow the protocol vulnerability we
 2754|       |     use the work-around */
 2755|     30|  if(!SSL_SET_OPTION(enable_beast))
 2756|     30|    ctx_options &= ~SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;
 2757|     30|#endif
 2758|       |
 2759|     30|  switch(ssl_version) {
 2760|      0|    case CURL_SSLVERSION_SSLv2:
 2761|      0|    case CURL_SSLVERSION_SSLv3:
 2762|      0|      return CURLE_NOT_BUILT_IN;
 2763|       |
 2764|       |    /* "--tlsv<x.y>" options mean TLS >= version <x.y> */
 2765|     30|    case CURL_SSLVERSION_DEFAULT:
 2766|     30|    case CURL_SSLVERSION_TLSv1: /* TLS >= version 1.0 */
 2767|     30|    case CURL_SSLVERSION_TLSv1_0: /* TLS >= version 1.0 */
 2768|     30|    case CURL_SSLVERSION_TLSv1_1: /* TLS >= version 1.1 */
 2769|     30|    case CURL_SSLVERSION_TLSv1_2: /* TLS >= version 1.2 */
 2770|     30|    case CURL_SSLVERSION_TLSv1_3: /* TLS >= version 1.3 */
 2771|       |      /* asking for any TLS version as the minimum, means no SSL versions
 2772|       |        allowed */
 2773|     30|      ctx_options |= SSL_OP_NO_SSLv2;
 2774|     30|      ctx_options |= SSL_OP_NO_SSLv3;
 2775|       |
 2776|       |#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) /* 1.1.0 */
 2777|       |      result = set_ssl_version_min_max(backend->ctx, conn);
 2778|       |#else
 2779|     30|      result = set_ssl_version_min_max_legacy(&ctx_options, data, conn,
 2780|     30|                                              sockindex);
 2781|     30|#endif
 2782|     30|      if(result != CURLE_OK)
 2783|      0|        return result;
 2784|     30|      break;
 2785|       |
 2786|     30|    default:
 2787|      0|      failf(data, "Unrecognized parameter passed via CURLOPT_SSLVERSION");
 2788|      0|      return CURLE_SSL_CONNECT_ERROR;
 2789|     30|  }
 2790|       |
 2791|     30|  SSL_CTX_set_options(backend->ctx, ctx_options);
 2792|       |
 2793|     30|#ifdef HAS_NPN
 2794|     30|  if(conn->bits.tls_enable_npn)
 2795|      0|    SSL_CTX_set_next_proto_select_cb(backend->ctx, select_next_proto_cb, data);
 2796|     30|#endif
 2797|       |
 2798|     30|#ifdef HAS_ALPN
 2799|     30|  if(conn->bits.tls_enable_alpn) {
 2800|      0|    int cur = 0;
 2801|      0|    unsigned char protocols[128];
 2802|       |
 2803|      0|#ifdef USE_HTTP2
 2804|      0|    if(data->state.httpwant >= CURL_HTTP_VERSION_2
 2805|      0|#ifndef CURL_DISABLE_PROXY
 2806|      0|       && (!SSL_IS_PROXY() || !conn->bits.tunnel_proxy)
 2807|      0|#endif
 2808|      0|      ) {
 2809|      0|      protocols[cur++] = ALPN_H2_LENGTH;
 2810|       |
 2811|      0|      memcpy(&protocols[cur], ALPN_H2, ALPN_H2_LENGTH);
 2812|      0|      cur += ALPN_H2_LENGTH;
 2813|      0|      infof(data, "ALPN, offering %s", ALPN_H2);
 2814|      0|    }
 2815|      0|#endif
 2816|       |
 2817|      0|    protocols[cur++] = ALPN_HTTP_1_1_LENGTH;
 2818|      0|    memcpy(&protocols[cur], ALPN_HTTP_1_1, ALPN_HTTP_1_1_LENGTH);
 2819|      0|    cur += ALPN_HTTP_1_1_LENGTH;
 2820|      0|    infof(data, "ALPN, offering %s", ALPN_HTTP_1_1);
 2821|       |
 2822|       |    /* expects length prefixed preference ordered list of protocols in wire
 2823|       |     * format
 2824|       |     */
 2825|      0|    if(SSL_CTX_set_alpn_protos(backend->ctx, protocols, cur)) {
 2826|      0|      failf(data, "Error setting ALPN");
 2827|      0|      return CURLE_SSL_CONNECT_ERROR;
 2828|      0|    }
 2829|      0|  }
 2830|     30|#endif
 2831|       |
 2832|     30|  if(ssl_cert || ssl_cert_blob || ssl_cert_type) {
 2833|      0|    if(!result &&
 2834|      0|       !cert_stuff(data, backend->ctx,
 2835|      0|                   ssl_cert, ssl_cert_blob, ssl_cert_type,
 2836|      0|                   SSL_SET_OPTION(key), SSL_SET_OPTION(key_blob),
 2837|      0|                   SSL_SET_OPTION(key_type), SSL_SET_OPTION(key_passwd)))
 2838|      0|      result = CURLE_SSL_CERTPROBLEM;
 2839|      0|    if(result)
 2840|       |      /* failf() is already done in cert_stuff() */
 2841|      0|      return result;
 2842|      0|  }
 2843|       |
 2844|     30|  ciphers = SSL_CONN_CONFIG(cipher_list);
 2845|     30|  if(!ciphers)
 2846|     30|    ciphers = (char *)DEFAULT_CIPHER_SELECTION;
 2847|     30|  if(ciphers) {
 2848|     30|    if(!SSL_CTX_set_cipher_list(backend->ctx, ciphers)) {
 2849|      0|      failf(data, "failed setting cipher list: %s", ciphers);
 2850|      0|      return CURLE_SSL_CIPHER;
 2851|      0|    }
 2852|     30|    infof(data, "Cipher selection: %s", ciphers);
 2853|     30|  }
 2854|       |
 2855|       |#ifdef HAVE_SSL_CTX_SET_CIPHERSUITES
 2856|       |  {
 2857|       |    char *ciphers13 = SSL_CONN_CONFIG(cipher_list13);
 2858|       |    if(ciphers13) {
 2859|       |      if(!SSL_CTX_set_ciphersuites(backend->ctx, ciphers13)) {
 2860|       |        failf(data, "failed setting TLS 1.3 cipher suite: %s", ciphers13);
 2861|       |        return CURLE_SSL_CIPHER;
 2862|       |      }
 2863|       |      infof(data, "TLS 1.3 cipher selection: %s", ciphers13);
 2864|       |    }
 2865|       |  }
 2866|       |#endif
 2867|       |
 2868|       |#ifdef HAVE_SSL_CTX_SET_POST_HANDSHAKE_AUTH
 2869|       |  /* OpenSSL 1.1.1 requires clients to opt-in for PHA */
 2870|       |  SSL_CTX_set_post_handshake_auth(backend->ctx, 1);
 2871|       |#endif
 2872|       |
 2873|       |#ifdef HAVE_SSL_CTX_SET_EC_CURVES
 2874|       |  {
 2875|       |    char *curves = SSL_CONN_CONFIG(curves);
 2876|       |    if(curves) {
 2877|       |      if(!SSL_CTX_set1_curves_list(backend->ctx, curves)) {
 2878|       |        failf(data, "failed setting curves list: '%s'", curves);
 2879|       |        return CURLE_SSL_CIPHER;
 2880|       |      }
 2881|       |    }
 2882|       |  }
 2883|       |#endif
 2884|       |
 2885|     30|#ifdef USE_OPENSSL_SRP
 2886|     30|  if(ssl_authtype == CURL_TLSAUTH_SRP) {
 2887|      0|    char * const ssl_username = SSL_SET_OPTION(username);
 2888|       |
 2889|      0|    infof(data, "Using TLS-SRP username: %s", ssl_username);
 2890|       |
 2891|      0|    if(!SSL_CTX_set_srp_username(backend->ctx, ssl_username)) {
 2892|      0|      failf(data, "Unable to set SRP user name");
 2893|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2894|      0|    }
 2895|      0|    if(!SSL_CTX_set_srp_password(backend->ctx, SSL_SET_OPTION(password))) {
 2896|      0|      failf(data, "failed setting SRP password");
 2897|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2898|      0|    }
 2899|      0|    if(!SSL_CONN_CONFIG(cipher_list)) {
 2900|      0|      infof(data, "Setting cipher list SRP");
 2901|       |
 2902|      0|      if(!SSL_CTX_set_cipher_list(backend->ctx, "SRP")) {
 2903|      0|        failf(data, "failed setting SRP cipher list");
 2904|      0|        return CURLE_SSL_CIPHER;
 2905|      0|      }
 2906|      0|    }
 2907|      0|  }
 2908|     30|#endif
 2909|       |
 2910|       |
 2911|       |#if defined(USE_WIN32_CRYPTO)
 2912|       |  /* Import certificates from the Windows root certificate store if requested.
 2913|       |     https://stackoverflow.com/questions/9507184/
 2914|       |     https://github.com/d3x0r/SACK/blob/master/src/netlib/ssl_layer.c#L1037
 2915|       |     https://tools.ietf.org/html/rfc5280 */
 2916|       |  if((SSL_CONN_CONFIG(verifypeer) || SSL_CONN_CONFIG(verifyhost)) &&
 2917|       |     (SSL_SET_OPTION(native_ca_store))) {
 2918|       |    X509_STORE *store = SSL_CTX_get_cert_store(backend->ctx);
 2919|       |    HCERTSTORE hStore = CertOpenSystemStore(0, TEXT("ROOT"));
 2920|       |
 2921|       |    if(hStore) {
 2922|       |      PCCERT_CONTEXT pContext = NULL;
 2923|       |      /* The array of enhanced key usage OIDs will vary per certificate and is
 2924|       |         declared outside of the loop so that rather than malloc/free each
 2925|       |         iteration we can grow it with realloc, when necessary. */
 2926|       |      CERT_ENHKEY_USAGE *enhkey_usage = NULL;
 2927|       |      DWORD enhkey_usage_size = 0;
 2928|       |
 2929|       |      /* This loop makes a best effort to import all valid certificates from
 2930|       |         the MS root store. If a certificate cannot be imported it is skipped.
 2931|       |         'result' is used to store only hard-fail conditions (such as out of
 2932|       |         memory) that cause an early break. */
 2933|       |      result = CURLE_OK;
 2934|       |      for(;;) {
 2935|       |        X509 *x509;
 2936|       |        FILETIME now;
 2937|       |        BYTE key_usage[2];
 2938|       |        DWORD req_size;
 2939|       |        const unsigned char *encoded_cert;
 2940|       |#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
 2941|       |        char cert_name[256];
 2942|       |#endif
 2943|       |
 2944|       |        pContext = CertEnumCertificatesInStore(hStore, pContext);
 2945|       |        if(!pContext)
 2946|       |          break;
 2947|       |
 2948|       |#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
 2949|       |        if(!CertGetNameStringA(pContext, CERT_NAME_SIMPLE_DISPLAY_TYPE, 0,
 2950|       |                               NULL, cert_name, sizeof(cert_name))) {
 2951|       |          strcpy(cert_name, "Unknown");
 2952|       |        }
 2953|       |        infof(data, "SSL: Checking cert \"%s\"", cert_name);
 2954|       |#endif
 2955|       |
 2956|       |        encoded_cert = (const unsigned char *)pContext->pbCertEncoded;
 2957|       |        if(!encoded_cert)
 2958|       |          continue;
 2959|       |
 2960|       |        GetSystemTimeAsFileTime(&now);
 2961|       |        if(CompareFileTime(&pContext->pCertInfo->NotBefore, &now) > 0 ||
 2962|       |           CompareFileTime(&now, &pContext->pCertInfo->NotAfter) > 0)
 2963|       |          continue;
 2964|       |
 2965|       |        /* If key usage exists check for signing attribute */
 2966|       |        if(CertGetIntendedKeyUsage(pContext->dwCertEncodingType,
 2967|       |                                   pContext->pCertInfo,
 2968|       |                                   key_usage, sizeof(key_usage))) {
 2969|       |          if(!(key_usage[0] & CERT_KEY_CERT_SIGN_KEY_USAGE))
 2970|       |            continue;
 2971|       |        }
 2972|       |        else if(GetLastError())
 2973|       |          continue;
 2974|       |
 2975|       |        /* If enhanced key usage exists check for server auth attribute.
 2976|       |         *
 2977|       |         * Note "In a Microsoft environment, a certificate might also have EKU
 2978|       |         * extended properties that specify valid uses for the certificate."
 2979|       |         * The call below checks both, and behavior varies depending on what is
 2980|       |         * found. For more details see CertGetEnhancedKeyUsage doc.
 2981|       |         */
 2982|       |        if(CertGetEnhancedKeyUsage(pContext, 0, NULL, &req_size)) {
 2983|       |          if(req_size && req_size > enhkey_usage_size) {
 2984|       |            void *tmp = realloc(enhkey_usage, req_size);
 2985|       |
 2986|       |            if(!tmp) {
 2987|       |              failf(data, "SSL: Out of memory allocating for OID list");
 2988|       |              result = CURLE_OUT_OF_MEMORY;
 2989|       |              break;
 2990|       |            }
 2991|       |
 2992|       |            enhkey_usage = (CERT_ENHKEY_USAGE *)tmp;
 2993|       |            enhkey_usage_size = req_size;
 2994|       |          }
 2995|       |
 2996|       |          if(CertGetEnhancedKeyUsage(pContext, 0, enhkey_usage, &req_size)) {
 2997|       |            if(!enhkey_usage->cUsageIdentifier) {
 2998|       |              /* "If GetLastError returns CRYPT_E_NOT_FOUND, the certificate is
 2999|       |                 good for all uses. If it returns zero, the certificate has no
 3000|       |                 valid uses." */
 3001|       |              if((HRESULT)GetLastError() != CRYPT_E_NOT_FOUND)
 3002|       |                continue;
 3003|       |            }
 3004|       |            else {
 3005|       |              DWORD i;
 3006|       |              bool found = false;
 3007|       |
 3008|       |              for(i = 0; i < enhkey_usage->cUsageIdentifier; ++i) {
 3009|       |                if(!strcmp("1.3.6.1.5.5.7.3.1" /* OID server auth */,
 3010|       |                           enhkey_usage->rgpszUsageIdentifier[i])) {
 3011|       |                  found = true;
 3012|       |                  break;
 3013|       |                }
 3014|       |              }
 3015|       |
 3016|       |              if(!found)
 3017|       |                continue;
 3018|       |            }
 3019|       |          }
 3020|       |          else
 3021|       |            continue;
 3022|       |        }
 3023|       |        else
 3024|       |          continue;
 3025|       |
 3026|       |        x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);
 3027|       |        if(!x509)
 3028|       |          continue;
 3029|       |
 3030|       |        /* Try to import the certificate. This may fail for legitimate reasons
 3031|       |           such as duplicate certificate, which is allowed by MS but not
 3032|       |           OpenSSL. */
 3033|       |        if(X509_STORE_add_cert(store, x509) == 1) {
 3034|       |#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
 3035|       |          infof(data, "SSL: Imported cert \"%s\"", cert_name);
 3036|       |#endif
 3037|       |          imported_native_ca = true;
 3038|       |        }
 3039|       |        X509_free(x509);
 3040|       |      }
 3041|       |
 3042|       |      free(enhkey_usage);
 3043|       |      CertFreeCertificateContext(pContext);
 3044|       |      CertCloseStore(hStore, 0);
 3045|       |
 3046|       |      if(result)
 3047|       |        return result;
 3048|       |    }
 3049|       |    if(imported_native_ca)
 3050|       |      infof(data, "successfully imported Windows CA store");
 3051|       |    else
 3052|       |      infof(data, "error importing Windows CA store, continuing anyway");
 3053|       |  }
 3054|       |#endif
 3055|       |
 3056|     30|  if(ca_info_blob) {
 3057|      0|    result = load_cacert_from_memory(backend->ctx, ca_info_blob);
 3058|      0|    if(result) {
 3059|      0|      if(result == CURLE_OUT_OF_MEMORY ||
 3060|      0|         (verifypeer && !imported_native_ca)) {
 3061|      0|        failf(data, "error importing CA certificate blob");
 3062|      0|        return result;
 3063|      0|      }
 3064|       |      /* Only warn if no certificate verification is required. */
 3065|      0|      infof(data, "error importing CA certificate blob, continuing anyway");
 3066|      0|    }
 3067|      0|  }
 3068|       |
 3069|     30|  if(verifypeer && !imported_native_ca && (ssl_cafile || ssl_capath)) {
 3070|       |#if defined(OPENSSL_VERSION_MAJOR) && (OPENSSL_VERSION_MAJOR >= 3)
 3071|       |  /* OpenSSL 3.0.0 has deprecated SSL_CTX_load_verify_locations */
 3072|       |    if(ssl_cafile &&
 3073|       |       !SSL_CTX_load_verify_file(backend->ctx, ssl_cafile)) {
 3074|       |      /* Fail if we insist on successfully verifying the server. */
 3075|       |      failf(data, "error setting certificate file: %s", ssl_cafile);
 3076|       |      return CURLE_SSL_CACERT_BADFILE;
 3077|       |    }
 3078|       |    if(ssl_capath &&
 3079|       |       !SSL_CTX_load_verify_dir(backend->ctx, ssl_capath)) {
 3080|       |      /* Fail if we insist on successfully verifying the server. */
 3081|       |      failf(data, "error setting certificate path: %s", ssl_capath);
 3082|       |      return CURLE_SSL_CACERT_BADFILE;
 3083|       |    }
 3084|       |#else
 3085|       |    /* tell OpenSSL where to find CA certificates that are used to verify the
 3086|       |       server's certificate. */
 3087|     30|    if(!SSL_CTX_load_verify_locations(backend->ctx, ssl_cafile, ssl_capath)) {
 3088|       |      /* Fail if we insist on successfully verifying the server. */
 3089|      0|      failf(data, "error setting certificate verify locations:"
 3090|      0|            "  CAfile: %s CApath: %s",
 3091|      0|            ssl_cafile ? ssl_cafile : "none",
 3092|      0|            ssl_capath ? ssl_capath : "none");
 3093|      0|      return CURLE_SSL_CACERT_BADFILE;
 3094|      0|    }
 3095|     30|#endif
 3096|     30|    infof(data, " CAfile: %s", ssl_cafile ? ssl_cafile : "none");
 3097|     30|    infof(data, " CApath: %s", ssl_capath ? ssl_capath : "none");
 3098|     30|  }
 3099|       |
 3100|       |#ifdef CURL_CA_FALLBACK
 3101|       |  if(verifypeer &&
 3102|       |     !ca_info_blob && !ssl_cafile && !ssl_capath && !imported_native_ca) {
 3103|       |    /* verifying the peer without any CA certificates won't
 3104|       |       work so use openssl's built-in default as fallback */
 3105|       |    SSL_CTX_set_default_verify_paths(backend->ctx);
 3106|       |  }
 3107|       |#endif
 3108|       |
 3109|     30|  if(ssl_crlfile) {
 3110|       |    /* tell OpenSSL where to find CRL file that is used to check certificate
 3111|       |     * revocation */
 3112|      0|    lookup = X509_STORE_add_lookup(SSL_CTX_get_cert_store(backend->ctx),
 3113|      0|                                 X509_LOOKUP_file());
 3114|      0|    if(!lookup ||
 3115|      0|       (!X509_load_crl_file(lookup, ssl_crlfile, X509_FILETYPE_PEM)) ) {
 3116|      0|      failf(data, "error loading CRL file: %s", ssl_crlfile);
 3117|      0|      return CURLE_SSL_CRL_BADFILE;
 3118|      0|    }
 3119|       |    /* Everything is fine. */
 3120|      0|    infof(data, "successfully loaded CRL file:");
 3121|      0|    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),
 3122|      0|                         X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
 3123|       |
 3124|      0|    infof(data, "  CRLfile: %s", ssl_crlfile);
 3125|      0|  }
 3126|       |
 3127|     30|  if(verifypeer) {
 3128|       |    /* Try building a chain using issuers in the trusted store first to avoid
 3129|       |       problems with server-sent legacy intermediates.  Newer versions of
 3130|       |       OpenSSL do alternate chain checking by default but we do not know how to
 3131|       |       determine that in a reliable manner.
 3132|       |       https://rt.openssl.org/Ticket/Display.html?id=3621&user=guest&pass=guest
 3133|       |    */
 3134|     30|#if defined(X509_V_FLAG_TRUSTED_FIRST)
 3135|     30|    X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),
 3136|     30|                         X509_V_FLAG_TRUSTED_FIRST);
 3137|     30|#endif
 3138|     30|#ifdef X509_V_FLAG_PARTIAL_CHAIN
 3139|     30|    if(!SSL_SET_OPTION(no_partialchain) && !ssl_crlfile) {
 3140|       |      /* Have intermediate certificates in the trust store be treated as
 3141|       |         trust-anchors, in the same way as self-signed root CA certificates
 3142|       |         are. This allows users to verify servers using the intermediate cert
 3143|       |         only, instead of needing the whole chain.
 3144|       |
 3145|       |         Due to OpenSSL bug https://github.com/openssl/openssl/issues/5081 we
 3146|       |         cannot do partial chains with a CRL check.
 3147|       |      */
 3148|     30|      X509_STORE_set_flags(SSL_CTX_get_cert_store(backend->ctx),
 3149|     30|                           X509_V_FLAG_PARTIAL_CHAIN);
 3150|     30|    }
 3151|     30|#endif
 3152|     30|  }
 3153|       |
 3154|       |  /* OpenSSL always tries to verify the peer, this only says whether it should
 3155|       |   * fail to connect if the verification fails, or if it should continue
 3156|       |   * anyway. In the latter case the result of the verification is checked with
 3157|       |   * SSL_get_verify_result() below. */
 3158|     30|  SSL_CTX_set_verify(backend->ctx,
 3159|     30|                     verifypeer ? SSL_VERIFY_PEER : SSL_VERIFY_NONE, NULL);
 3160|       |
 3161|       |  /* Enable logging of secrets to the file specified in env SSLKEYLOGFILE. */
 3162|       |#ifdef HAVE_KEYLOG_CALLBACK
 3163|       |  if(Curl_tls_keylog_enabled()) {
 3164|       |    SSL_CTX_set_keylog_callback(backend->ctx, ossl_keylog_callback);
 3165|       |  }
 3166|       |#endif
 3167|       |
 3168|       |  /* Enable the session cache because it's a prerequisite for the "new session"
 3169|       |   * callback. Use the "external storage" mode to prevent OpenSSL from creating
 3170|       |   * an internal session cache.
 3171|       |   */
 3172|     30|  SSL_CTX_set_session_cache_mode(backend->ctx,
 3173|     30|      SSL_SESS_CACHE_CLIENT | SSL_SESS_CACHE_NO_INTERNAL);
 3174|     30|  SSL_CTX_sess_set_new_cb(backend->ctx, ossl_new_session_cb);
 3175|       |
 3176|       |  /* give application a chance to interfere with SSL set up. */
 3177|     30|  if(data->set.ssl.fsslctx) {
 3178|      0|    Curl_set_in_callback(data, true);
 3179|      0|    result = (*data->set.ssl.fsslctx)(data, backend->ctx,
 3180|      0|                                      data->set.ssl.fsslctxp);
 3181|      0|    Curl_set_in_callback(data, false);
 3182|      0|    if(result) {
 3183|      0|      failf(data, "error signaled by ssl ctx callback");
 3184|      0|      return result;
 3185|      0|    }
 3186|      0|  }
 3187|       |
 3188|       |  /* Let's make an SSL structure */
 3189|     30|  if(backend->handle)
 3190|      0|    SSL_free(backend->handle);
 3191|     30|  backend->handle = SSL_new(backend->ctx);
 3192|     30|  if(!backend->handle) {
 3193|      0|    failf(data, "SSL: couldn't create a context (handle)!");
 3194|      0|    return CURLE_OUT_OF_MEMORY;
 3195|      0|  }
 3196|       |
 3197|     30|#if (OPENSSL_VERSION_NUMBER >= 0x0090808fL) && !defined(OPENSSL_NO_TLSEXT) && \
 3198|     30|    !defined(OPENSSL_NO_OCSP)
 3199|     30|  if(SSL_CONN_CONFIG(verifystatus))
 3200|      0|    SSL_set_tlsext_status_type(backend->handle, TLSEXT_STATUSTYPE_ocsp);
 3201|     30|#endif
 3202|       |
 3203|       |#if defined(OPENSSL_IS_BORINGSSL) && defined(ALLOW_RENEG)
 3204|       |  SSL_set_renegotiate_mode(backend->handle, ssl_renegotiate_freely);
 3205|       |#endif
 3206|       |
 3207|     30|  SSL_set_connect_state(backend->handle);
 3208|       |
 3209|     30|  backend->server_cert = 0x0;
 3210|     30|#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
 3211|     30|  if((0 == Curl_inet_pton(AF_INET, hostname, &addr)) &&
 3212|     30|#ifdef ENABLE_IPV6
 3213|     30|     (0 == Curl_inet_pton(AF_INET6, hostname, &addr)) &&
 3214|     30|#endif
 3215|     30|     sni) {
 3216|     28|    size_t nlen = strlen(hostname);
 3217|     28|    if((long)nlen >= data->set.buffer_size)
 3218|       |      /* this is seriously messed up */
 3219|      0|      return CURLE_SSL_CONNECT_ERROR;
 3220|       |
 3221|       |    /* RFC 6066 section 3 says the SNI field is case insensitive, but browsers
 3222|       |       send the data lowercase and subsequently there are now numerous servers
 3223|       |       out there that don't work unless the name is lowercased */
 3224|     28|    Curl_strntolower(data->state.buffer, hostname, nlen);
 3225|     28|    data->state.buffer[nlen] = 0;
 3226|     28|    if(!SSL_set_tlsext_host_name(backend->handle, data->state.buffer))
 3227|      2|      infof(data, "WARNING: failed to configure server name indication (SNI) "
 3228|      2|            "TLS extension");
 3229|     28|  }
 3230|     30|#endif
 3231|       |
 3232|     30|  ossl_associate_connection(data, conn, sockindex);
 3233|       |
 3234|     30|  Curl_ssl_sessionid_lock(data);
 3235|     30|  if(!Curl_ssl_getsessionid(data, conn, SSL_IS_PROXY() ? TRUE : FALSE,
 3236|     30|                            &ssl_sessionid, NULL, sockindex)) {
 3237|       |    /* we got a session id, use it! */
 3238|      0|    if(!SSL_set_session(backend->handle, ssl_sessionid)) {
 3239|      0|      Curl_ssl_sessionid_unlock(data);
 3240|      0|      failf(data, "SSL: SSL_set_session failed: %s",
 3241|      0|            ossl_strerror(ERR_get_error(), error_buffer,
 3242|      0|                          sizeof(error_buffer)));
 3243|      0|      return CURLE_SSL_CONNECT_ERROR;
 3244|      0|    }
 3245|       |    /* Informational message */
 3246|      0|    infof(data, "SSL re-using session ID");
 3247|      0|  }
 3248|     30|  Curl_ssl_sessionid_unlock(data);
 3249|       |
 3250|     30|#ifndef CURL_DISABLE_PROXY
 3251|     30|  if(conn->proxy_ssl[sockindex].use) {
 3252|      0|    BIO *const bio = BIO_new(BIO_f_ssl());
 3253|      0|    SSL *handle = conn->proxy_ssl[sockindex].backend->handle;
 3254|      0|    DEBUGASSERT(ssl_connection_complete == conn->proxy_ssl[sockindex].state);
 3255|      0|    DEBUGASSERT(handle != NULL);
 3256|      0|    DEBUGASSERT(bio != NULL);
 3257|      0|    BIO_set_ssl(bio, handle, FALSE);
 3258|      0|    SSL_set_bio(backend->handle, bio, bio);
 3259|      0|  }
 3260|     30|  else
 3261|     30|#endif
 3262|     30|    if(!SSL_set_fd(backend->handle, (int)sockfd)) {
 3263|       |    /* pass the raw socket into the SSL layers */
 3264|      0|    failf(data, "SSL: SSL_set_fd failed: %s",
 3265|      0|          ossl_strerror(ERR_get_error(), error_buffer, sizeof(error_buffer)));
 3266|      0|    return CURLE_SSL_CONNECT_ERROR;
 3267|      0|  }
 3268|       |
 3269|     30|  connssl->connecting_state = ssl_connect_2;
 3270|       |
 3271|     30|  return CURLE_OK;
 3272|     30|}
openssl.c:set_ssl_version_min_max_legacy:
 2404|     30|{
 2405|     30|  long ssl_version = SSL_CONN_CONFIG(version);
 2406|     30|  long ssl_version_max = SSL_CONN_CONFIG(version_max);
 2407|       |
 2408|     30|  (void) data; /* In case it's unused. */
 2409|       |
 2410|     30|  switch(ssl_version) {
 2411|      0|    case CURL_SSLVERSION_TLSv1_3:
 2412|       |#ifdef TLS1_3_VERSION
 2413|       |    {
 2414|       |      struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 2415|       |      SSL_CTX_set_max_proto_version(backend->ctx, TLS1_3_VERSION);
 2416|       |      *ctx_options |= SSL_OP_NO_TLSv1_2;
 2417|       |    }
 2418|       |#else
 2419|      0|      (void)sockindex;
 2420|      0|      (void)ctx_options;
 2421|      0|      failf(data, OSSL_PACKAGE " was built without TLS 1.3 support");
 2422|      0|      return CURLE_NOT_BUILT_IN;
 2423|      0|#endif
 2424|       |      /* FALLTHROUGH */
 2425|      0|    case CURL_SSLVERSION_TLSv1_2:
 2426|      0|#if OPENSSL_VERSION_NUMBER >= 0x1000100FL
 2427|      0|      *ctx_options |= SSL_OP_NO_TLSv1_1;
 2428|       |#else
 2429|       |      failf(data, OSSL_PACKAGE " was built without TLS 1.2 support");
 2430|       |      return CURLE_NOT_BUILT_IN;
 2431|       |#endif
 2432|       |      /* FALLTHROUGH */
 2433|      0|    case CURL_SSLVERSION_TLSv1_1:
 2434|      0|#if OPENSSL_VERSION_NUMBER >= 0x1000100FL
 2435|      0|      *ctx_options |= SSL_OP_NO_TLSv1;
 2436|       |#else
 2437|       |      failf(data, OSSL_PACKAGE " was built without TLS 1.1 support");
 2438|       |      return CURLE_NOT_BUILT_IN;
 2439|       |#endif
 2440|       |      /* FALLTHROUGH */
 2441|      0|    case CURL_SSLVERSION_TLSv1_0:
 2442|      0|    case CURL_SSLVERSION_TLSv1:
 2443|      0|      break;
 2444|     30|  }
 2445|       |
 2446|     30|  switch(ssl_version_max) {
 2447|      0|    case CURL_SSLVERSION_MAX_TLSv1_0:
 2448|      0|#if OPENSSL_VERSION_NUMBER >= 0x1000100FL
 2449|      0|      *ctx_options |= SSL_OP_NO_TLSv1_1;
 2450|      0|#endif
 2451|       |      /* FALLTHROUGH */
 2452|      0|    case CURL_SSLVERSION_MAX_TLSv1_1:
 2453|      0|#if OPENSSL_VERSION_NUMBER >= 0x1000100FL
 2454|      0|      *ctx_options |= SSL_OP_NO_TLSv1_2;
 2455|      0|#endif
 2456|       |      /* FALLTHROUGH */
 2457|      0|    case CURL_SSLVERSION_MAX_TLSv1_2:
 2458|       |#ifdef TLS1_3_VERSION
 2459|       |      *ctx_options |= SSL_OP_NO_TLSv1_3;
 2460|       |#endif
 2461|      0|      break;
 2462|      0|    case CURL_SSLVERSION_MAX_TLSv1_3:
 2463|       |#ifdef TLS1_3_VERSION
 2464|       |      break;
 2465|       |#else
 2466|      0|      failf(data, OSSL_PACKAGE " was built without TLS 1.3 support");
 2467|      0|      return CURLE_NOT_BUILT_IN;
 2468|     30|#endif
 2469|     30|  }
 2470|     30|  return CURLE_OK;
 2471|     30|}
openssl.c:ossl_connect_step2:
 3276|     30|{
 3277|     30|  int err;
 3278|     30|  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 3279|     30|  struct ssl_backend_data *backend = connssl->backend;
 3280|     30|  DEBUGASSERT(ssl_connect_2 == connssl->connecting_state
 3281|     30|              || ssl_connect_2_reading == connssl->connecting_state
 3282|     30|              || ssl_connect_2_writing == connssl->connecting_state);
 3283|       |
 3284|     30|  ERR_clear_error();
 3285|       |
 3286|     30|  err = SSL_connect(backend->handle);
 3287|     30|#ifndef HAVE_KEYLOG_CALLBACK
 3288|     30|  if(Curl_tls_keylog_enabled()) {
 3289|       |    /* If key logging is enabled, wait for the handshake to complete and then
 3290|       |     * proceed with logging secrets (for TLS 1.2 or older).
 3291|       |     */
 3292|      0|    ossl_log_tls12_secret(backend->handle, &backend->keylog_done);
 3293|      0|  }
 3294|     30|#endif
 3295|       |
 3296|       |  /* 1  is fine
 3297|       |     0  is "not successful but was shut down controlled"
 3298|       |     <0 is "handshake was not successful, because a fatal error occurred" */
 3299|     30|  if(1 != err) {
 3300|     30|    int detail = SSL_get_error(backend->handle, err);
 3301|       |
 3302|     30|    if(SSL_ERROR_WANT_READ == detail) {
 3303|      0|      connssl->connecting_state = ssl_connect_2_reading;
 3304|      0|      return CURLE_OK;
 3305|      0|    }
 3306|     30|    if(SSL_ERROR_WANT_WRITE == detail) {
 3307|      0|      connssl->connecting_state = ssl_connect_2_writing;
 3308|      0|      return CURLE_OK;
 3309|      0|    }
 3310|       |#ifdef SSL_ERROR_WANT_ASYNC
 3311|       |    if(SSL_ERROR_WANT_ASYNC == detail) {
 3312|       |      connssl->connecting_state = ssl_connect_2;
 3313|       |      return CURLE_OK;
 3314|       |    }
 3315|       |#endif
 3316|     30|    else {
 3317|       |      /* untreated error */
 3318|     30|      unsigned long errdetail;
 3319|     30|      char error_buffer[256]="";
 3320|     30|      CURLcode result;
 3321|     30|      long lerr;
 3322|     30|      int lib;
 3323|     30|      int reason;
 3324|       |
 3325|       |      /* the connection failed, we're not waiting for anything else. */
 3326|     30|      connssl->connecting_state = ssl_connect_2;
 3327|       |
 3328|       |      /* Get the earliest error code from the thread's error queue and remove
 3329|       |         the entry. */
 3330|     30|      errdetail = ERR_get_error();
 3331|       |
 3332|       |      /* Extract which lib and reason */
 3333|     30|      lib = ERR_GET_LIB(errdetail);
 3334|     30|      reason = ERR_GET_REASON(errdetail);
 3335|       |
 3336|     30|      if((lib == ERR_LIB_SSL) &&
 3337|     30|         ((reason == SSL_R_CERTIFICATE_VERIFY_FAILED) ||
 3338|      0|          (reason == SSL_R_SSLV3_ALERT_CERTIFICATE_EXPIRED))) {
 3339|      0|        result = CURLE_PEER_FAILED_VERIFICATION;
 3340|       |
 3341|      0|        lerr = SSL_get_verify_result(backend->handle);
 3342|      0|        if(lerr != X509_V_OK) {
 3343|      0|          SSL_SET_OPTION_LVALUE(certverifyresult) = lerr;
 3344|      0|          msnprintf(error_buffer, sizeof(error_buffer),
 3345|      0|                    "SSL certificate problem: %s",
 3346|      0|                    X509_verify_cert_error_string(lerr));
 3347|      0|        }
 3348|      0|        else
 3349|       |          /* strcpy() is fine here as long as the string fits within
 3350|       |             error_buffer */
 3351|      0|          strcpy(error_buffer, "SSL certificate verification failed");
 3352|      0|      }
 3353|       |#if (OPENSSL_VERSION_NUMBER >= 0x10101000L && \
 3354|       |    !defined(LIBRESSL_VERSION_NUMBER) && \
 3355|       |    !defined(OPENSSL_IS_BORINGSSL))
 3356|       |      /* SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED is only available on
 3357|       |         OpenSSL version above v1.1.1, not LibreSSL nor BoringSSL */
 3358|       |      else if((lib == ERR_LIB_SSL) &&
 3359|       |              (reason == SSL_R_TLSV13_ALERT_CERTIFICATE_REQUIRED)) {
 3360|       |          /* If client certificate is required, communicate the
 3361|       |             error to client */
 3362|       |          result = CURLE_SSL_CLIENTCERT;
 3363|       |          ossl_strerror(errdetail, error_buffer, sizeof(error_buffer));
 3364|       |      }
 3365|       |#endif
 3366|     30|      else {
 3367|     30|        result = CURLE_SSL_CONNECT_ERROR;
 3368|     30|        ossl_strerror(errdetail, error_buffer, sizeof(error_buffer));
 3369|     30|      }
 3370|       |
 3371|       |      /* detail is already set to the SSL error above */
 3372|       |
 3373|       |      /* If we e.g. use SSLv2 request-method and the server doesn't like us
 3374|       |       * (RST connection, etc.), OpenSSL gives no explanation whatsoever and
 3375|       |       * the SO_ERROR is also lost.
 3376|       |       */
 3377|     30|      if(CURLE_SSL_CONNECT_ERROR == result && errdetail == 0) {
 3378|     30|        const char * const hostname = SSL_HOST_NAME();
 3379|     30|        const long int port = SSL_HOST_PORT();
 3380|     30|        char extramsg[80]="";
 3381|     30|        int sockerr = SOCKERRNO;
 3382|     30|        if(sockerr && detail == SSL_ERROR_SYSCALL)
 3383|      0|          Curl_strerror(sockerr, extramsg, sizeof(extramsg));
 3384|     30|        failf(data, OSSL_PACKAGE " SSL_connect: %s in connection to %s:%ld ",
 3385|     30|              extramsg[0] ? extramsg : SSL_ERROR_to_str(detail),
 3386|     30|              hostname, port);
 3387|     30|        return result;
 3388|     30|      }
 3389|       |
 3390|       |      /* Could be a CERT problem */
 3391|      0|      failf(data, "%s", error_buffer);
 3392|       |
 3393|      0|      return result;
 3394|     30|    }
 3395|     30|  }
 3396|      0|  else {
 3397|       |    /* we connected fine, we're not waiting for anything else. */
 3398|      0|    connssl->connecting_state = ssl_connect_3;
 3399|       |
 3400|       |    /* Informational message */
 3401|      0|    infof(data, "SSL connection using %s / %s",
 3402|      0|          SSL_get_version(backend->handle),
 3403|      0|          SSL_get_cipher(backend->handle));
 3404|       |
 3405|      0|#ifdef HAS_ALPN
 3406|       |    /* Sets data and len to negotiated protocol, len is 0 if no protocol was
 3407|       |     * negotiated
 3408|       |     */
 3409|      0|    if(conn->bits.tls_enable_alpn) {
 3410|      0|      const unsigned char *neg_protocol;
 3411|      0|      unsigned int len;
 3412|      0|      SSL_get0_alpn_selected(backend->handle, &neg_protocol, &len);
 3413|      0|      if(len) {
 3414|      0|        infof(data, "ALPN, server accepted to use %.*s", len, neg_protocol);
 3415|       |
 3416|      0|#ifdef USE_HTTP2
 3417|      0|        if(len == ALPN_H2_LENGTH &&
 3418|      0|           !memcmp(ALPN_H2, neg_protocol, len)) {
 3419|      0|          conn->negnpn = CURL_HTTP_VERSION_2;
 3420|      0|        }
 3421|      0|        else
 3422|      0|#endif
 3423|      0|        if(len == ALPN_HTTP_1_1_LENGTH &&
 3424|      0|           !memcmp(ALPN_HTTP_1_1, neg_protocol, ALPN_HTTP_1_1_LENGTH)) {
 3425|      0|          conn->negnpn = CURL_HTTP_VERSION_1_1;
 3426|      0|        }
 3427|      0|      }
 3428|      0|      else
 3429|      0|        infof(data, "ALPN, server did not agree to a protocol");
 3430|       |
 3431|      0|      Curl_multiuse_state(data, conn->negnpn == CURL_HTTP_VERSION_2 ?
 3432|      0|                          BUNDLE_MULTIPLEX : BUNDLE_NO_MULTIUSE);
 3433|      0|    }
 3434|      0|#endif
 3435|       |
 3436|      0|    return CURLE_OK;
 3437|      0|  }
 3438|     30|}
openssl.c:ossl_connect_nonblocking:
 4146|     30|{
 4147|     30|  return ossl_connect_common(data, conn, sockindex, TRUE, done);
 4148|     30|}
openssl.c:ossl_close:
 1437|  6.10k|{
 1438|  6.10k|  ossl_closeone(data, conn, &conn->ssl[sockindex]);
 1439|  6.10k|#ifndef CURL_DISABLE_PROXY
 1440|  6.10k|  ossl_closeone(data, conn, &conn->proxy_ssl[sockindex]);
 1441|  6.10k|#endif
 1442|  6.10k|}
openssl.c:ossl_closeone:
 1410|  12.2k|{
 1411|  12.2k|  struct ssl_backend_data *backend = connssl->backend;
 1412|  12.2k|  if(backend->handle) {
 1413|     30|    char buf[32];
 1414|     30|    set_logger(conn, data);
 1415|       |
 1416|       |    /* Maybe the server has already sent a close notify alert.
 1417|       |       Read it to avoid an RST on the TCP connection. */
 1418|     30|    (void)SSL_read(backend->handle, buf, (int)sizeof(buf));
 1419|       |
 1420|     30|    (void)SSL_shutdown(backend->handle);
 1421|     30|    SSL_set_connect_state(backend->handle);
 1422|       |
 1423|     30|    SSL_free(backend->handle);
 1424|     30|    backend->handle = NULL;
 1425|     30|  }
 1426|  12.2k|  if(backend->ctx) {
 1427|     30|    SSL_CTX_free(backend->ctx);
 1428|     30|    backend->ctx = NULL;
 1429|     30|  }
 1430|  12.2k|}
openssl.c:ossl_close_all:
 1561|  6.25k|{
 1562|  6.25k|#ifdef USE_OPENSSL_ENGINE
 1563|  6.25k|  if(data->state.engine) {
 1564|      0|    ENGINE_finish(data->state.engine);
 1565|      0|    ENGINE_free(data->state.engine);
 1566|      0|    data->state.engine = NULL;
 1567|      0|  }
 1568|       |#else
 1569|       |  (void)data;
 1570|       |#endif
 1571|  6.25k|#if !defined(HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED) && \
 1572|  6.25k|  defined(HAVE_ERR_REMOVE_THREAD_STATE)
 1573|       |  /* OpenSSL 1.0.1 and 1.0.2 build an error queue that is stored per-thread
 1574|       |     so we need to clean it here in case the thread will be killed. All OpenSSL
 1575|       |     code should extract the error in association with the error so clearing
 1576|       |     this queue here should be harmless at worst. */
 1577|  6.25k|  ERR_remove_thread_state(NULL);
 1578|  6.25k|#endif
 1579|  6.25k|}
openssl.c:ossl_associate_connection:
 4485|  6.05k|{
 4486|  6.05k|  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 4487|  6.05k|  struct ssl_backend_data *backend = connssl->backend;
 4488|       |
 4489|       |  /* If we don't have SSL context, do nothing. */
 4490|  6.05k|  if(!backend->handle)
 4491|  5.99k|    return;
 4492|       |
 4493|     60|  if(SSL_SET_OPTION(primary.sessionid)) {
 4494|     60|    int data_idx = ossl_get_ssl_data_index();
 4495|     60|    int connectdata_idx = ossl_get_ssl_conn_index();
 4496|     60|    int sockindex_idx = ossl_get_ssl_sockindex_index();
 4497|     60|    int proxy_idx = ossl_get_proxy_index();
 4498|       |
 4499|     60|    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&
 4500|     60|       proxy_idx >= 0) {
 4501|       |      /* Store the data needed for the "new session" callback.
 4502|       |       * The sockindex is stored as a pointer to an array element. */
 4503|     60|      SSL_set_ex_data(backend->handle, data_idx, data);
 4504|     60|      SSL_set_ex_data(backend->handle, connectdata_idx, conn);
 4505|     60|      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);
 4506|     60|#ifndef CURL_DISABLE_PROXY
 4507|     60|      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:
 4508|     60|                      NULL);
 4509|       |#else
 4510|       |      SSL_set_ex_data(backend->handle, proxy_idx, NULL);
 4511|       |#endif
 4512|     60|    }
 4513|     60|  }
 4514|     60|}
openssl.c:ossl_disassociate_connection:
 4526|  6.02k|{
 4527|  6.02k|  struct connectdata *conn = data->conn;
 4528|  6.02k|  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 4529|  6.02k|  struct ssl_backend_data *backend = connssl->backend;
 4530|       |
 4531|       |  /* If we don't have SSL context, do nothing. */
 4532|  6.02k|  if(!backend->handle)
 4533|  5.99k|    return;
 4534|       |
 4535|     30|  if(SSL_SET_OPTION(primary.sessionid)) {
 4536|     30|    int data_idx = ossl_get_ssl_data_index();
 4537|     30|    int connectdata_idx = ossl_get_ssl_conn_index();
 4538|     30|    int sockindex_idx = ossl_get_ssl_sockindex_index();
 4539|     30|    int proxy_idx = ossl_get_proxy_index();
 4540|       |
 4541|     30|    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&
 4542|     30|       proxy_idx >= 0) {
 4543|       |      /* Disable references to data in "new session" callback to avoid
 4544|       |       * accessing a stale pointer. */
 4545|     30|      SSL_set_ex_data(backend->handle, data_idx, NULL);
 4546|     30|      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);
 4547|     30|      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);
 4548|     30|      SSL_set_ex_data(backend->handle, proxy_idx, NULL);
 4549|     30|    }
 4550|     30|  }
 4551|     30|}

Curl_clone_primary_ssl_config:
  168|  5.86k|{
  169|  5.86k|  dest->version = source->version;
  170|  5.86k|  dest->version_max = source->version_max;
  171|  5.86k|  dest->verifypeer = source->verifypeer;
  172|  5.86k|  dest->verifyhost = source->verifyhost;
  173|  5.86k|  dest->verifystatus = source->verifystatus;
  174|  5.86k|  dest->sessionid = source->sessionid;
  175|       |
  176|  5.86k|  CLONE_BLOB(cert_blob);
  177|  5.86k|  CLONE_BLOB(ca_info_blob);
  178|  5.86k|  CLONE_BLOB(issuercert_blob);
  179|  5.86k|  CLONE_STRING(CApath);
  180|  5.86k|  CLONE_STRING(CAfile);
  181|  5.86k|  CLONE_STRING(issuercert);
  182|  5.86k|  CLONE_STRING(clientcert);
  183|  5.86k|  CLONE_STRING(random_file);
  184|  5.86k|  CLONE_STRING(egdsocket);
  185|  5.86k|  CLONE_STRING(cipher_list);
  186|  5.86k|  CLONE_STRING(cipher_list13);
  187|  5.86k|  CLONE_STRING(pinned_key);
  188|  5.86k|  CLONE_STRING(curves);
  189|       |
  190|  5.86k|  return TRUE;
  191|  5.86k|}
Curl_free_primary_ssl_config:
  194|  6.10k|{
  195|  6.10k|  Curl_safefree(sslc->CApath);
  196|  6.10k|  Curl_safefree(sslc->CAfile);
  197|  6.10k|  Curl_safefree(sslc->issuercert);
  198|  6.10k|  Curl_safefree(sslc->clientcert);
  199|  6.10k|  Curl_safefree(sslc->random_file);
  200|  6.10k|  Curl_safefree(sslc->egdsocket);
  201|  6.10k|  Curl_safefree(sslc->cipher_list);
  202|  6.10k|  Curl_safefree(sslc->cipher_list13);
  203|  6.10k|  Curl_safefree(sslc->pinned_key);
  204|  6.10k|  Curl_safefree(sslc->cert_blob);
  205|  6.10k|  Curl_safefree(sslc->ca_info_blob);
  206|  6.10k|  Curl_safefree(sslc->issuercert_blob);
  207|  6.10k|  Curl_safefree(sslc->curves);
  208|  6.10k|}
Curl_ssl_backend:
  215|  6.25k|{
  216|  6.25k|#ifdef USE_SSL
  217|  6.25k|  multissl_setup(NULL);
  218|  6.25k|  return Curl_ssl->info.id;
  219|       |#else
  220|       |  return (int)CURLSSLBACKEND_NONE;
  221|       |#endif
  222|  6.25k|}
Curl_ssl_init:
  236|      1|{
  237|       |  /* make sure this is only done once */
  238|      1|  if(init_ssl)
  239|      0|    return 1;
  240|      1|  init_ssl = TRUE; /* never again */
  241|       |
  242|      1|  return Curl_ssl->init();
  243|      1|}
Curl_ssl_connect_nonblocking:
  346|     30|{
  347|     30|  CURLcode result;
  348|       |
  349|     30|#ifndef CURL_DISABLE_PROXY
  350|     30|  if(conn->bits.proxy_ssl_connected[sockindex]) {
  351|      0|    result = ssl_connect_init_proxy(conn, sockindex);
  352|      0|    if(result)
  353|      0|      return result;
  354|      0|  }
  355|     30|#endif
  356|     30|  if(!ssl_prefs_check(data))
  357|      0|    return CURLE_SSL_CONNECT_ERROR;
  358|       |
  359|       |  /* mark this is being ssl requested from here on. */
  360|     30|  conn->ssl[sockindex].use = TRUE;
  361|     30|  result = Curl_ssl->connect_nonblocking(data, conn, sockindex, done);
  362|     30|  if(result)
  363|     30|    conn->ssl[sockindex].use = FALSE;
  364|      0|  else if(*done && !isproxy)
  365|      0|    Curl_pgrsTime(data, TIMER_APPCONNECT); /* SSL is connected */
  366|     30|  return result;
  367|     30|}
Curl_ssl_sessionid_lock:
  373|     30|{
  374|     30|  if(SSLSESSION_SHARED(data))
  375|      0|    Curl_share_lock(data, CURL_LOCK_DATA_SSL_SESSION, CURL_LOCK_ACCESS_SINGLE);
  376|     30|}
Curl_ssl_sessionid_unlock:
  382|     30|{
  383|     30|  if(SSLSESSION_SHARED(data))
  384|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_SSL_SESSION);
  385|     30|}
Curl_ssl_getsessionid:
  397|     30|{
  398|     30|  struct Curl_ssl_session *check;
  399|     30|  size_t i;
  400|     30|  long *general_age;
  401|     30|  bool no_match = TRUE;
  402|       |
  403|     30|#ifndef CURL_DISABLE_PROXY
  404|     30|  struct ssl_primary_config * const ssl_config = isProxy ?
  405|      0|    &conn->proxy_ssl_config :
  406|     30|    &conn->ssl_config;
  407|     30|  const char * const name = isProxy ?
  408|     30|    conn->http_proxy.host.name : conn->host.name;
  409|     30|  int port = isProxy ? (int)conn->port : conn->remote_port;
  410|       |#else
  411|       |  /* no proxy support */
  412|       |  struct ssl_primary_config * const ssl_config = &conn->ssl_config;
  413|       |  const char * const name = conn->host.name;
  414|       |  int port = conn->remote_port;
  415|       |#endif
  416|     30|  (void)sockindex;
  417|     30|  *ssl_sessionid = NULL;
  418|       |
  419|       |#ifdef CURL_DISABLE_PROXY
  420|       |  if(isProxy)
  421|       |    return TRUE;
  422|       |#endif
  423|       |
  424|     30|  DEBUGASSERT(SSL_SET_OPTION(primary.sessionid));
  425|       |
  426|     30|  if(!SSL_SET_OPTION(primary.sessionid) || !data->state.session)
  427|       |    /* session ID re-use is disabled or the session cache has not been
  428|       |       setup */
  429|      0|    return TRUE;
  430|       |
  431|       |  /* Lock if shared */
  432|     30|  if(SSLSESSION_SHARED(data))
  433|      0|    general_age = &data->share->sessionage;
  434|     30|  else
  435|     30|    general_age = &data->state.sessionage;
  436|       |
  437|    180|  for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++) {
  438|    150|    check = &data->state.session[i];
  439|    150|    if(!check->sessionid)
  440|       |      /* not session ID means blank entry */
  441|    150|      continue;
  442|      0|    if(strcasecompare(name, check->name) &&
  443|      0|       ((!conn->bits.conn_to_host && !check->conn_to_host) ||
  444|      0|        (conn->bits.conn_to_host && check->conn_to_host &&
  445|      0|         strcasecompare(conn->conn_to_host.name, check->conn_to_host))) &&
  446|      0|       ((!conn->bits.conn_to_port && check->conn_to_port == -1) ||
  447|      0|        (conn->bits.conn_to_port && check->conn_to_port != -1 &&
  448|      0|         conn->conn_to_port == check->conn_to_port)) &&
  449|      0|       (port == check->remote_port) &&
  450|      0|       strcasecompare(conn->handler->scheme, check->scheme) &&
  451|      0|       Curl_ssl_config_matches(ssl_config, &check->ssl_config)) {
  452|       |      /* yes, we have a session ID! */
  453|      0|      (*general_age)++;          /* increase general age */
  454|      0|      check->age = *general_age; /* set this as used in this age */
  455|      0|      *ssl_sessionid = check->sessionid;
  456|      0|      if(idsize)
  457|      0|        *idsize = check->idsize;
  458|      0|      no_match = FALSE;
  459|      0|      break;
  460|      0|    }
  461|      0|  }
  462|       |
  463|     30|  DEBUGF(infof(data, "%s Session ID in cache for %s %s://%s:%d",
  464|     30|               no_match? "Didn't find": "Found",
  465|     30|               isProxy ? "proxy" : "host",
  466|     30|               conn->handler->scheme, name, port));
  467|     30|  return no_match;
  468|     30|}
Curl_ssl_kill_session:
  474|  14.6k|{
  475|  14.6k|  if(session->sessionid) {
  476|       |    /* defensive check */
  477|       |
  478|       |    /* free the ID the SSL-layer specific way */
  479|      0|    Curl_ssl->session_free(session->sessionid);
  480|       |
  481|      0|    session->sessionid = NULL;
  482|      0|    session->age = 0; /* fresh */
  483|       |
  484|      0|    Curl_free_primary_ssl_config(&session->ssl_config);
  485|       |
  486|      0|    Curl_safefree(session->name);
  487|      0|    Curl_safefree(session->conn_to_host);
  488|      0|  }
  489|  14.6k|}
Curl_ssl_associate_conn:
  628|  6.02k|{
  629|  6.02k|  if(Curl_ssl->associate_connection) {
  630|  6.02k|    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);
  631|  6.02k|    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)
  632|      0|      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);
  633|  6.02k|  }
  634|  6.02k|}
Curl_ssl_detach_conn:
  638|  6.02k|{
  639|  6.02k|  if(Curl_ssl->disassociate_connection) {
  640|  6.02k|    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);
  641|  6.02k|    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)
  642|      0|      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);
  643|  6.02k|  }
  644|  6.02k|}
Curl_ssl_close_all:
  647|  6.25k|{
  648|       |  /* kill the session ID cache if not shared */
  649|  6.25k|  if(data->state.session && !SSLSESSION_SHARED(data)) {
  650|  2.93k|    size_t i;
  651|  17.6k|    for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++)
  652|       |      /* the single-killer function handles empty table slots */
  653|  14.6k|      Curl_ssl_kill_session(&data->state.session[i]);
  654|       |
  655|       |    /* free the cache data */
  656|  2.93k|    Curl_safefree(data->state.session);
  657|  2.93k|  }
  658|       |
  659|  6.25k|  Curl_ssl->close_all(data);
  660|  6.25k|}
Curl_ssl_close:
  682|  6.10k|{
  683|  6.10k|  DEBUGASSERT((sockindex <= 1) && (sockindex >= -1));
  684|  6.10k|  Curl_ssl->close_one(data, conn, sockindex);
  685|  6.10k|  conn->ssl[sockindex].state = ssl_connection_none;
  686|  6.10k|}
Curl_ssl_initsessions:
  728|  2.94k|{
  729|  2.94k|  struct Curl_ssl_session *session;
  730|       |
  731|  2.94k|  if(data->state.session)
  732|       |    /* this is just a precaution to prevent multiple inits */
  733|      4|    return CURLE_OK;
  734|       |
  735|  2.93k|  session = calloc(amount, sizeof(struct Curl_ssl_session));
  736|  2.93k|  if(!session)
  737|      0|    return CURLE_OUT_OF_MEMORY;
  738|       |
  739|       |  /* store the info in the SSL section */
  740|  2.93k|  data->set.general_ssl.max_ssl_sessions = amount;
  741|  2.93k|  data->state.session = session;
  742|  2.93k|  data->state.sessionage = 1; /* this is brand new */
  743|  2.93k|  return CURLE_OK;
  744|  2.93k|}
Curl_ssl_data_pending:
  772|  10.6k|{
  773|  10.6k|  return Curl_ssl->data_pending(conn, connindex);
  774|  10.6k|}
Curl_ssl_free_certinfo:
  777|  15.4k|{
  778|  15.4k|  struct curl_certinfo *ci = &data->info.certs;
  779|       |
  780|  15.4k|  if(ci->num_of_certs) {
  781|       |    /* free all individual lists used */
  782|      0|    int i;
  783|      0|    for(i = 0; i<ci->num_of_certs; i++) {
  784|      0|      curl_slist_free_all(ci->certinfo[i]);
  785|      0|      ci->certinfo[i] = NULL;
  786|      0|    }
  787|       |
  788|      0|    free(ci->certinfo); /* free the actual array too */
  789|      0|    ci->certinfo = NULL;
  790|      0|    ci->num_of_certs = 0;
  791|      0|  }
  792|  15.4k|}
Curl_ssl_random:
  870|  3.84k|{
  871|  3.84k|  return Curl_ssl->random(data, entropy, length);
  872|  3.84k|}
vtls.c:blobdup:
   96|  17.5k|{
   97|  17.5k|  DEBUGASSERT(dest);
   98|  17.5k|  DEBUGASSERT(!*dest);
   99|  17.5k|  if(src) {
  100|       |    /* only if there's data to dupe! */
  101|      0|    struct curl_blob *d;
  102|      0|    d = malloc(sizeof(struct curl_blob) + src->len);
  103|      0|    if(!d)
  104|      0|      return CURLE_OUT_OF_MEMORY;
  105|      0|    d->len = src->len;
  106|       |    /* Always duplicate because the connection may survive longer than the
  107|       |       handle that passed in the blob. */
  108|      0|    d->flags = CURL_BLOB_COPY;
  109|      0|    d->data = (void *)((char *)d + sizeof(struct curl_blob));
  110|      0|    memcpy(d->data, src->data, src->len);
  111|      0|    *dest = d;
  112|      0|  }
  113|  17.5k|  return CURLE_OK;
  114|  17.5k|}
vtls.c:ssl_prefs_check:
  263|     30|{
  264|       |  /* check for CURLOPT_SSLVERSION invalid parameter value */
  265|     30|  const long sslver = data->set.ssl.primary.version;
  266|     30|  if((sslver < 0) || (sslver >= CURL_SSLVERSION_LAST)) {
  267|      0|    failf(data, "Unrecognized parameter value passed via CURLOPT_SSLVERSION");
  268|      0|    return FALSE;
  269|      0|  }
  270|       |
  271|     30|  switch(data->set.ssl.primary.version_max) {
  272|     30|  case CURL_SSLVERSION_MAX_NONE:
  273|     30|  case CURL_SSLVERSION_MAX_DEFAULT:
  274|     30|    break;
  275|       |
  276|      0|  default:
  277|      0|    if((data->set.ssl.primary.version_max >> 16) < sslver) {
  278|      0|      failf(data, "CURL_SSLVERSION_MAX incompatible with CURL_SSLVERSION");
  279|      0|      return FALSE;
  280|      0|    }
  281|     30|  }
  282|       |
  283|     30|  return TRUE;
  284|     30|}
vtls.c:multissl_setup:
 1389|  6.25k|{
 1390|  6.25k|  const char *env;
 1391|  6.25k|  char *env_tmp;
 1392|       |
 1393|  6.25k|  if(Curl_ssl != &Curl_ssl_multi)
 1394|  6.25k|    return 1;
 1395|       |
 1396|      0|  if(backend) {
 1397|      0|    Curl_ssl = backend;
 1398|      0|    return 0;
 1399|      0|  }
 1400|       |
 1401|      0|  if(!available_backends[0])
 1402|      0|    return 1;
 1403|       |
 1404|      0|  env = env_tmp = curl_getenv("CURL_SSL_BACKEND");
 1405|       |#ifdef CURL_DEFAULT_SSL_BACKEND
 1406|       |  if(!env)
 1407|       |    env = CURL_DEFAULT_SSL_BACKEND;
 1408|       |#endif
 1409|      0|  if(env) {
 1410|      0|    int i;
 1411|      0|    for(i = 0; available_backends[i]; i++) {
 1412|      0|      if(strcasecompare(env, available_backends[i]->info.name)) {
 1413|      0|        Curl_ssl = available_backends[i];
 1414|      0|        free(env_tmp);
 1415|      0|        return 0;
 1416|      0|      }
 1417|      0|    }
 1418|      0|  }
 1419|       |
 1420|       |  /* Fall back to first available backend */
 1421|      0|  Curl_ssl = available_backends[0];
 1422|      0|  free(env_tmp);
 1423|      0|  return 0;
 1424|      0|}

curlx_ultous:
   63|  2.97k|{
   64|       |#ifdef __INTEL_COMPILER
   65|       |#  pragma warning(push)
   66|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
   67|       |#endif
   68|       |
   69|  2.97k|  DEBUGASSERT(ulnum <= (unsigned long) CURL_MASK_USHORT);
   70|  2.97k|  return (unsigned short)(ulnum & (unsigned long) CURL_MASK_USHORT);
   71|       |
   72|       |#ifdef __INTEL_COMPILER
   73|       |#  pragma warning(pop)
   74|       |#endif
   75|  2.97k|}
curlx_ultouc:
   82|    962|{
   83|       |#ifdef __INTEL_COMPILER
   84|       |#  pragma warning(push)
   85|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
   86|       |#endif
   87|       |
   88|    962|  DEBUGASSERT(ulnum <= (unsigned long) CURL_MASK_UCHAR);
   89|    962|  return (unsigned char)(ulnum & (unsigned long) CURL_MASK_UCHAR);
   90|       |
   91|       |#ifdef __INTEL_COMPILER
   92|       |#  pragma warning(pop)
   93|       |#endif
   94|    962|}
curlx_uztosi:
  123|  3.84k|{
  124|       |#ifdef __INTEL_COMPILER
  125|       |#  pragma warning(push)
  126|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
  127|       |#endif
  128|       |
  129|  3.84k|  DEBUGASSERT(uznum <= (size_t) CURL_MASK_SINT);
  130|  3.84k|  return (int)(uznum & (size_t) CURL_MASK_SINT);
  131|       |
  132|       |#ifdef __INTEL_COMPILER
  133|       |#  pragma warning(pop)
  134|       |#endif
  135|  3.84k|}
curlx_uztoui:
  163|    297|{
  164|       |#ifdef __INTEL_COMPILER
  165|       |# pragma warning(push)
  166|       |# pragma warning(disable:810) /* conversion may lose significant bits */
  167|       |#endif
  168|       |
  169|    297|#if UINT_MAX < SIZE_T_MAX
  170|    297|  DEBUGASSERT(uznum <= (size_t) CURL_MASK_UINT);
  171|    297|#endif
  172|    297|  return (unsigned int)(uznum & (size_t) CURL_MASK_UINT);
  173|       |
  174|       |#ifdef __INTEL_COMPILER
  175|       |# pragma warning(pop)
  176|       |#endif
  177|    297|}
curlx_sltosi:
  184|  11.4k|{
  185|       |#ifdef __INTEL_COMPILER
  186|       |#  pragma warning(push)
  187|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
  188|       |#endif
  189|       |
  190|  11.4k|  DEBUGASSERT(slnum >= 0);
  191|  11.4k|#if INT_MAX < LONG_MAX
  192|  11.4k|  DEBUGASSERT((unsigned long) slnum <= (unsigned long) CURL_MASK_SINT);
  193|  11.4k|#endif
  194|  11.4k|  return (int)(slnum & (long) CURL_MASK_SINT);
  195|       |
  196|       |#ifdef __INTEL_COMPILER
  197|       |#  pragma warning(pop)
  198|       |#endif
  199|  11.4k|}
curlx_uztosz:
  248|      2|{
  249|       |#ifdef __INTEL_COMPILER
  250|       |#  pragma warning(push)
  251|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
  252|       |#endif
  253|       |
  254|      2|  DEBUGASSERT(uznum <= (size_t) CURL_MASK_SSIZE_T);
  255|      2|  return (ssize_t)(uznum & (size_t) CURL_MASK_SSIZE_T);
  256|       |
  257|       |#ifdef __INTEL_COMPILER
  258|       |#  pragma warning(pop)
  259|       |#endif
  260|      2|}
curlx_sotouz:
  267|   138k|{
  268|       |#ifdef __INTEL_COMPILER
  269|       |#  pragma warning(push)
  270|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
  271|       |#endif
  272|       |
  273|   138k|  DEBUGASSERT(sonum >= 0);
  274|   138k|  return (size_t)(sonum & (curl_off_t) CURL_MASK_USIZE_T);
  275|       |
  276|       |#ifdef __INTEL_COMPILER
  277|       |#  pragma warning(pop)
  278|       |#endif
  279|   138k|}

Curl_wildcard_init:
   42|     34|{
   43|     34|  Curl_llist_init(&wc->filelist, fileinfo_dtor);
   44|     34|  wc->state = CURLWC_INIT;
   45|       |
   46|     34|  return CURLE_OK;
   47|     34|}
Curl_wildcard_dtor:
   50|  9.34k|{
   51|  9.34k|  if(!wc)
   52|      0|    return;
   53|       |
   54|  9.34k|  if(wc->dtor) {
   55|      4|    wc->dtor(wc->protdata);
   56|      4|    wc->dtor = ZERO_NULL;
   57|      4|    wc->protdata = NULL;
   58|      4|  }
   59|  9.34k|  DEBUGASSERT(wc->protdata == NULL);
   60|       |
   61|  9.34k|  Curl_llist_destroy(&wc->filelist, NULL);
   62|       |
   63|       |
   64|  9.34k|  free(wc->path);
   65|  9.34k|  wc->path = NULL;
   66|  9.34k|  free(wc->pattern);
   67|  9.34k|  wc->pattern = NULL;
   68|       |
   69|  9.34k|  wc->customptr = NULL;
   70|  9.34k|  wc->state = CURLWC_INIT;
   71|  9.34k|}

LLVMFuzzerTestOneInput:
   35|  3.16k|{
   36|  3.16k|  int rc = 0;
   37|  3.16k|  int tlv_rc;
   38|  3.16k|  FUZZ_DATA fuzz;
   39|  3.16k|  TLV tlv;
   40|       |
   41|       |  /* Ignore SIGPIPE errors. We'll handle the errors ourselves. */
   42|  3.16k|  signal(SIGPIPE, SIG_IGN);
   43|       |
   44|       |  /* Have to set all fields to zero before getting to the terminate function */
   45|  3.16k|  memset(&fuzz, 0, sizeof(FUZZ_DATA));
   46|       |
   47|  3.16k|  if(size < sizeof(TLV_RAW)) {
   48|       |    /* Not enough data for a single TLV - don't continue */
   49|      1|    goto EXIT_LABEL;
   50|      1|  }
   51|       |
   52|       |  /* Try to initialize the fuzz data */
   53|  3.16k|  FTRY(fuzz_initialize_fuzz_data(&fuzz, data, size));
   54|       |
   55|  3.16k|  for(tlv_rc = fuzz_get_first_tlv(&fuzz, &tlv);
   56|  43.3k|      tlv_rc == 0;
   57|  40.2k|      tlv_rc = fuzz_get_next_tlv(&fuzz, &tlv)) {
   58|       |
   59|       |    /* Have the TLV in hand. Parse the TLV. */
   60|  40.2k|    rc = fuzz_parse_tlv(&fuzz, &tlv);
   61|       |
   62|  40.2k|    if(rc != 0) {
   63|       |      /* Failed to parse the TLV. Can't continue. */
   64|     42|      goto EXIT_LABEL;
   65|     42|    }
   66|  40.2k|  }
   67|       |
   68|  3.12k|  if(tlv_rc != TLV_RC_NO_MORE_TLVS) {
   69|       |    /* A TLV call failed. Can't continue. */
   70|     27|    goto EXIT_LABEL;
   71|     27|  }
   72|       |
   73|       |  /* Set up the standard easy options. */
   74|  3.09k|  FTRY(fuzz_set_easy_options(&fuzz));
   75|       |
   76|       |  /**
   77|       |   * Add in more curl options that have been accumulated over possibly
   78|       |   * multiple TLVs.
   79|       |   */
   80|  3.09k|  if(fuzz.header_list != NULL) {
   81|    148|    curl_easy_setopt(fuzz.easy, CURLOPT_HTTPHEADER, fuzz.header_list);
   82|    148|  }
   83|       |
   84|  3.09k|  if(fuzz.mail_recipients_list != NULL) {
   85|    131|    curl_easy_setopt(fuzz.easy, CURLOPT_MAIL_RCPT, fuzz.mail_recipients_list);
   86|    131|  }
   87|       |
   88|  3.09k|  if(fuzz.mime != NULL) {
   89|    270|    curl_easy_setopt(fuzz.easy, CURLOPT_MIMEPOST, fuzz.mime);
   90|    270|  }
   91|       |
   92|       |  /* Run the transfer. */
   93|  3.09k|  fuzz_handle_transfer(&fuzz);
   94|       |
   95|  3.16k|EXIT_LABEL:
   96|       |
   97|  3.16k|  fuzz_terminate_fuzz_data(&fuzz);
   98|       |
   99|       |  /* This function must always return 0. Non-zero codes are reserved. */
  100|  3.16k|  return 0;
  101|  3.09k|}
_Z6to_u32PKh:
  107|  42.9k|{
  108|  42.9k|  uint32_t u;
  109|  42.9k|  u = (b[0] << 24) + (b[1] << 16) + (b[2] << 8) + b[3];
  110|  42.9k|  return u;
  111|  42.9k|}
_Z6to_u16PKh:
  117|  42.6k|{
  118|  42.6k|  uint16_t u;
  119|  42.6k|  u = (b[0] << 8) + b[1];
  120|  42.6k|  return u;
  121|  42.6k|}
_Z25fuzz_initialize_fuzz_dataP9fuzz_dataPKhm:
  129|  3.16k|{
  130|  3.16k|  int rc = 0;
  131|  3.16k|  int ii;
  132|       |
  133|       |  /* Initialize the fuzz data. */
  134|  3.16k|  memset(fuzz, 0, sizeof(FUZZ_DATA));
  135|       |
  136|       |  /* Create an easy handle. This will have all of the settings configured on
  137|       |     it. */
  138|  3.16k|  fuzz->easy = curl_easy_init();
  139|  3.16k|  FCHECK(fuzz->easy != NULL);
  140|       |
  141|       |  /* Set up the state parser */
  142|  3.16k|  fuzz->state.data = data;
  143|  3.16k|  fuzz->state.data_len = data_len;
  144|       |
  145|       |  /* Set up the state of the server sockets. */
  146|  9.48k|  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  147|  6.32k|    fuzz->sockman[ii].index = ii;
  148|  6.32k|    fuzz->sockman[ii].fd_state = FUZZ_SOCK_CLOSED;
  149|  6.32k|  }
  150|       |
  151|       |  /* Check for verbose mode. */
  152|  3.16k|  fuzz->verbose = (getenv("FUZZ_VERBOSE") != NULL);
  153|       |
  154|  3.16k|EXIT_LABEL:
  155|       |
  156|  3.16k|  return rc;
  157|  3.16k|}
_Z21fuzz_set_easy_optionsP9fuzz_data:
  163|  3.09k|{
  164|  3.09k|  int rc = 0;
  165|  3.09k|  unsigned long allowed_protocols;
  166|       |
  167|       |  /* Set some standard options on the CURL easy handle. We need to override the
  168|       |     socket function so that we create our own sockets to present to CURL. */
  169|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy,
  170|  3.09k|                        CURLOPT_OPENSOCKETFUNCTION,
  171|  3.09k|                        fuzz_open_socket));
  172|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_OPENSOCKETDATA, fuzz));
  173|       |
  174|       |  /* In case something tries to set a socket option, intercept this. */
  175|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy,
  176|  3.09k|                        CURLOPT_SOCKOPTFUNCTION,
  177|  3.09k|                        fuzz_sockopt_callback));
  178|       |
  179|       |  /* Set the standard read function callback. */
  180|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy,
  181|  3.09k|                        CURLOPT_READFUNCTION,
  182|  3.09k|                        fuzz_read_callback));
  183|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_READDATA, fuzz));
  184|       |
  185|       |  /* Set the standard write function callback. */
  186|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy,
  187|  3.09k|                        CURLOPT_WRITEFUNCTION,
  188|  3.09k|                        fuzz_write_callback));
  189|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_WRITEDATA, fuzz));
  190|       |
  191|       |  /* Set the cookie jar so cookies are tested. */
  192|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_COOKIEJAR, FUZZ_COOKIE_JAR_PATH));
  193|       |
  194|       |  /* Time out requests quickly. */
  195|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_TIMEOUT_MS, 200L));
  196|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_SERVER_RESPONSE_TIMEOUT, 1L));
  197|       |
  198|       |  /* Can enable verbose mode by having the environment variable FUZZ_VERBOSE. */
  199|  3.09k|  if(fuzz->verbose) {
  200|      0|    FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_VERBOSE, 1L));
  201|      0|  }
  202|       |
  203|       |  /* Force resolution of all addresses to a specific IP address. */
  204|  3.09k|  fuzz->connect_to_list = curl_slist_append(NULL, "::127.0.1.127:");
  205|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_CONNECT_TO, fuzz->connect_to_list));
  206|       |
  207|       |  /* Limit the protocols in use by this fuzzer. */
  208|  3.09k|  FTRY(fuzz_set_allowed_protocols(fuzz));
  209|       |
  210|  3.09k|EXIT_LABEL:
  211|       |
  212|  3.09k|  return rc;
  213|  3.09k|}
_Z24fuzz_terminate_fuzz_dataP9fuzz_data:
  219|  3.16k|{
  220|  3.16k|  int ii;
  221|       |
  222|  3.16k|  fuzz_free((void **)&fuzz->postfields);
  223|       |
  224|  9.48k|  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  225|  6.32k|    if(fuzz->sockman[ii].fd_state != FUZZ_SOCK_CLOSED) {
  226|  2.92k|      close(fuzz->sockman[ii].fd);
  227|  2.92k|      fuzz->sockman[ii].fd_state = FUZZ_SOCK_CLOSED;
  228|  2.92k|    }
  229|  6.32k|  }
  230|       |
  231|  3.16k|  if(fuzz->connect_to_list != NULL) {
  232|  3.09k|    curl_slist_free_all(fuzz->connect_to_list);
  233|  3.09k|    fuzz->connect_to_list = NULL;
  234|  3.09k|  }
  235|       |
  236|  3.16k|  if(fuzz->header_list != NULL) {
  237|    154|    curl_slist_free_all(fuzz->header_list);
  238|    154|    fuzz->header_list = NULL;
  239|    154|  }
  240|       |
  241|  3.16k|  if(fuzz->mail_recipients_list != NULL) {
  242|    137|    curl_slist_free_all(fuzz->mail_recipients_list);
  243|    137|    fuzz->mail_recipients_list = NULL;
  244|    137|  }
  245|       |
  246|  3.16k|  if(fuzz->mime != NULL) {
  247|    285|    curl_mime_free(fuzz->mime);
  248|    285|    fuzz->mime = NULL;
  249|    285|  }
  250|       |
  251|  3.16k|  if(fuzz->easy != NULL) {
  252|  3.16k|    curl_easy_cleanup(fuzz->easy);
  253|  3.16k|    fuzz->easy = NULL;
  254|  3.16k|  }
  255|  3.16k|}
_Z9fuzz_freePPv:
  261|  43.7k|{
  262|  43.7k|  if(*ptr != NULL) {
  263|  11.2k|    free(*ptr);
  264|  11.2k|    *ptr = NULL;
  265|  11.2k|  }
  266|  43.7k|}
_Z20fuzz_handle_transferP9fuzz_data:
  273|  3.09k|{
  274|  3.09k|  int rc = 0;
  275|  3.09k|  CURLM *multi_handle;
  276|  3.09k|  int still_running; /* keep number of running handles */
  277|  3.09k|  CURLMsg *msg; /* for picking up messages with the transfer status */
  278|  3.09k|  int msgs_left; /* how many messages are left */
  279|  3.09k|  int double_timeout = 0;
  280|  3.09k|  fd_set fdread;
  281|  3.09k|  fd_set fdwrite;
  282|  3.09k|  fd_set fdexcep;
  283|  3.09k|  struct timeval timeout;
  284|  3.09k|  int select_rc;
  285|  3.09k|  CURLMcode mc;
  286|  3.09k|  int maxfd = -1;
  287|  3.09k|  long curl_timeo = -1;
  288|  3.09k|  int ii;
  289|  3.09k|  FUZZ_SOCKET_MANAGER *sman[FUZZ_NUM_CONNECTIONS];
  290|       |
  291|  9.27k|  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  292|  6.18k|    sman[ii] = &fuzz->sockman[ii];
  293|       |
  294|       |    /* Set up the starting index for responses. */
  295|  6.18k|    sman[ii]->response_index = 1;
  296|  6.18k|  }
  297|       |
  298|       |  /* init a multi stack */
  299|  3.09k|  multi_handle = curl_multi_init();
  300|       |
  301|       |  /* add the individual transfers */
  302|  3.09k|  curl_multi_add_handle(multi_handle, fuzz->easy);
  303|       |
  304|       |  /* Do an initial process. This might end the transfer immediately. */
  305|  3.09k|  curl_multi_perform(multi_handle, &still_running);
  306|  3.09k|  FV_PRINTF(fuzz,
  307|  3.09k|            "FUZZ: Initial perform; still running? %d \n",
  308|  3.09k|            still_running);
  309|       |
  310|  5.78M|  while(still_running) {
  311|       |    /* Reset the sets of file descriptors. */
  312|  5.78M|    FD_ZERO(&fdread);
  313|  5.78M|    FD_ZERO(&fdwrite);
  314|  5.78M|    FD_ZERO(&fdexcep);
  315|       |
  316|       |    /* Set a timeout of 10ms. This is lower than recommended by the multi guide
  317|       |       but we're not going to any remote servers, so everything should complete
  318|       |       very quickly. */
  319|  5.78M|    timeout.tv_sec = 0;
  320|  5.78M|    timeout.tv_usec = 10000;
  321|       |
  322|       |    /* get file descriptors from the transfers */
  323|  5.78M|    mc = curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);
  324|  5.78M|    if(mc != CURLM_OK) {
  325|      0|      fprintf(stderr, "curl_multi_fdset() failed, code %d.\n", mc);
  326|      0|      rc = -1;
  327|      0|      break;
  328|      0|    }
  329|       |
  330|  17.3M|    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  331|       |      /* Add the socket FD into the readable set if connected. */
  332|  11.5M|      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN) {
  333|    745|        FD_SET(sman[ii]->fd, &fdread);
  334|       |
  335|       |        /* Work out the maximum FD between the cURL file descriptors and the
  336|       |           server FD. */
  337|    745|        maxfd = FUZZ_MAX(sman[ii]->fd, maxfd);
  338|    745|      }
  339|  11.5M|    }
  340|       |
  341|       |    /* Work out what file descriptors need work. */
  342|  5.78M|    rc = fuzz_select(maxfd + 1, &fdread, &fdwrite, &fdexcep, &timeout);
  343|       |
  344|  5.78M|    if(rc == -1) {
  345|       |      /* Had an issue while selecting a file descriptor. Let's just exit. */
  346|      0|      FV_PRINTF(fuzz, "FUZZ: select failed, exiting \n");
  347|      0|      break;
  348|      0|    }
  349|  5.78M|    else if(rc == 0) {
  350|     69|      FV_PRINTF(fuzz,
  351|     69|                "FUZZ: Timed out; double timeout? %d \n",
  352|     69|                double_timeout);
  353|       |
  354|       |      /* Timed out. */
  355|     69|      if(double_timeout == 1) {
  356|       |        /* We don't expect multiple timeouts in a row. If there are double
  357|       |           timeouts then exit. */
  358|     30|        break;
  359|     30|      }
  360|     39|      else {
  361|       |        /* Set the timeout flag for the next time we select(). */
  362|     39|        double_timeout = 1;
  363|     39|      }
  364|     69|    }
  365|  5.78M|    else {
  366|       |      /* There's an active file descriptor. Reset the timeout flag. */
  367|  5.78M|      double_timeout = 0;
  368|  5.78M|    }
  369|       |
  370|       |    /* Check to see if a server file descriptor is readable. If it is,
  371|       |       then send the next response from the fuzzing data. */
  372|  17.3M|    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  373|  11.5M|      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN &&
  374|  11.5M|         FD_ISSET(sman[ii]->fd, &fdread)) {
  375|    619|        rc = fuzz_send_next_response(fuzz, sman[ii]);
  376|    619|        if(rc != 0) {
  377|       |          /* Failed to send a response. Break out here. */
  378|      0|          break;
  379|      0|        }
  380|    619|      }
  381|  11.5M|    }
  382|       |
  383|  5.78M|    curl_multi_perform(multi_handle, &still_running);
  384|  5.78M|  }
  385|       |
  386|       |  /* Remove the easy handle from the multi stack. */
  387|  3.09k|  curl_multi_remove_handle(multi_handle, fuzz->easy);
  388|       |
  389|       |  /* Clean up the multi handle - the top level function will handle the easy
  390|       |     handle. */
  391|  3.09k|  curl_multi_cleanup(multi_handle);
  392|       |
  393|  3.09k|  return(rc);
  394|  3.09k|}
_Z23fuzz_send_next_responseP9fuzz_dataP19fuzz_socket_manager:
  400|    619|{
  401|    619|  int rc = 0;
  402|    619|  ssize_t ret_in;
  403|    619|  ssize_t ret_out;
  404|    619|  char buffer[8192];
  405|    619|  const uint8_t *data;
  406|    619|  size_t data_len;
  407|       |
  408|       |  /* Need to read all data sent by the client so the file descriptor becomes
  409|       |     unreadable. Because the file descriptor is non-blocking we won't just
  410|       |     hang here. */
  411|  1.32k|  do {
  412|  1.32k|    ret_in = read(sman->fd, buffer, sizeof(buffer));
  413|  1.32k|    if(fuzz->verbose && ret_in > 0) {
  414|      0|      printf("FUZZ[%d]: Received %zu bytes \n==>\n", sman->index, ret_in);
  415|      0|      fwrite(buffer, ret_in, 1, stdout);
  416|      0|      printf("\n<==\n");
  417|      0|    }
  418|  1.32k|  } while (ret_in > 0);
  419|       |
  420|       |  /* Now send a response to the request that the client just made. */
  421|    619|  FV_PRINTF(fuzz,
  422|    619|            "FUZZ[%d]: Sending next response: %d \n",
  423|    619|            sman->index,
  424|    619|            sman->response_index);
  425|    619|  data = sman->responses[sman->response_index].data;
  426|    619|  data_len = sman->responses[sman->response_index].data_len;
  427|       |
  428|    619|  if(data != NULL) {
  429|    619|    if(write(sman->fd, data, data_len) != (ssize_t)data_len) {
  430|       |      /* Failed to write the data back to the client. Prevent any further
  431|       |         testing. */
  432|      0|      rc = -1;
  433|      0|    }
  434|    619|  }
  435|       |
  436|       |  /* Work out if there are any more responses. If not, then shut down the
  437|       |     server. */
  438|    619|  sman->response_index++;
  439|       |
  440|    619|  if(sman->response_index >= TLV_MAX_NUM_RESPONSES ||
  441|    619|     sman->responses[sman->response_index].data == NULL) {
  442|    214|    FV_PRINTF(fuzz,
  443|    214|              "FUZZ[%d]: Shutting down server socket: %d \n",
  444|    214|              sman->index,
  445|    214|              sman->fd);
  446|    214|    shutdown(sman->fd, SHUT_WR);
  447|    214|    sman->fd_state = FUZZ_SOCK_SHUTDOWN;
  448|    214|  }
  449|       |
  450|    619|  return(rc);
  451|    619|}
_Z11fuzz_selectiP6fd_setS0_S0_P7timeval:
  460|  5.78M|                struct timeval *timeout) {
  461|  5.78M|  return select(nfds, readfds, writefds, exceptfds, timeout);
  462|  5.78M|}
_Z26fuzz_set_allowed_protocolsP9fuzz_data:
  468|  3.09k|{
  469|  3.09k|  int rc = 0;
  470|  3.09k|  unsigned long allowed_protocols = 0;
  471|       |
  472|  3.09k|#ifdef FUZZ_PROTOCOLS_ALL
  473|       |  /* Do not allow telnet currently as it accepts input from stdin. */
  474|  3.09k|  allowed_protocols |= CURLPROTO_ALL & ~CURLPROTO_TELNET;
  475|  3.09k|#endif
  476|       |#ifdef FUZZ_PROTOCOLS_DICT
  477|       |  allowed_protocols |= CURLPROTO_DICT;
  478|       |#endif
  479|       |#ifdef FUZZ_PROTOCOLS_FILE
  480|       |  allowed_protocols |= CURLPROTO_FILE;
  481|       |#endif
  482|       |#ifdef FUZZ_PROTOCOLS_FTP
  483|       |  allowed_protocols |= CURLPROTO_FTP;
  484|       |  allowed_protocols |= CURLPROTO_FTPS;
  485|       |#endif
  486|       |#ifdef FUZZ_PROTOCOLS_GOPHER
  487|       |  allowed_protocols |= CURLPROTO_GOPHER;
  488|       |#endif
  489|       |#ifdef FUZZ_PROTOCOLS_HTTP
  490|       |  allowed_protocols |= CURLPROTO_HTTP;
  491|       |#endif
  492|       |#ifdef FUZZ_PROTOCOLS_HTTPS
  493|       |  allowed_protocols |= CURLPROTO_HTTPS;
  494|       |#endif
  495|       |#ifdef FUZZ_PROTOCOLS_IMAP
  496|       |  allowed_protocols |= CURLPROTO_IMAP;
  497|       |  allowed_protocols |= CURLPROTO_IMAPS;
  498|       |#endif
  499|       |#ifdef FUZZ_PROTOCOLS_LDAP
  500|       |  allowed_protocols |= CURLPROTO_LDAP;
  501|       |  allowed_protocols |= CURLPROTO_LDAPS;
  502|       |#endif
  503|       |#ifdef FUZZ_PROTOCOLS_MQTT
  504|       |  allowed_protocols |= CURLPROTO_MQTT;
  505|       |#endif
  506|       |#ifdef FUZZ_PROTOCOLS_POP3
  507|       |  allowed_protocols |= CURLPROTO_POP3;
  508|       |  allowed_protocols |= CURLPROTO_POP3S;
  509|       |#endif
  510|       |#ifdef FUZZ_PROTOCOLS_RTMP
  511|       |  allowed_protocols |= CURLPROTO_RTMP;
  512|       |  allowed_protocols |= CURLPROTO_RTMPE;
  513|       |  allowed_protocols |= CURLPROTO_RTMPS;
  514|       |  allowed_protocols |= CURLPROTO_RTMPT;
  515|       |  allowed_protocols |= CURLPROTO_RTMPTE;
  516|       |  allowed_protocols |= CURLPROTO_RTMPTS;
  517|       |#endif
  518|       |#ifdef FUZZ_PROTOCOLS_RTSP
  519|       |  allowed_protocols |= CURLPROTO_RTSP;
  520|       |#endif
  521|       |#ifdef FUZZ_PROTOCOLS_SCP
  522|       |  allowed_protocols |= CURLPROTO_SCP;
  523|       |#endif
  524|       |#ifdef FUZZ_PROTOCOLS_SFTP
  525|       |  allowed_protocols |= CURLPROTO_SFTP;
  526|       |#endif
  527|       |#ifdef FUZZ_PROTOCOLS_SMB
  528|       |  allowed_protocols |= CURLPROTO_SMB;
  529|       |  allowed_protocols |= CURLPROTO_SMBS;
  530|       |#endif
  531|       |#ifdef FUZZ_PROTOCOLS_SMTP
  532|       |  allowed_protocols |= CURLPROTO_SMTP;
  533|       |  allowed_protocols |= CURLPROTO_SMTPS;
  534|       |#endif
  535|       |#ifdef FUZZ_PROTOCOLS_TFTP
  536|       |  allowed_protocols |= CURLPROTO_TFTP;
  537|       |#endif
  538|       |
  539|  3.09k|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_PROTOCOLS, allowed_protocols));
  540|       |
  541|  3.09k|EXIT_LABEL:
  542|       |
  543|  3.09k|  return rc;
  544|  3.09k|}

_Z16fuzz_open_socketPv12curlsocktypeP13curl_sockaddr:
   42|  2.93k|{
   43|  2.93k|  FUZZ_DATA *fuzz = (FUZZ_DATA *)ptr;
   44|  2.93k|  int fds[2];
   45|  2.93k|  int flags;
   46|  2.93k|  int status;
   47|  2.93k|  const uint8_t *data;
   48|  2.93k|  size_t data_len;
   49|  2.93k|  struct sockaddr_un client_addr;
   50|  2.93k|  FUZZ_SOCKET_MANAGER *sman;
   51|       |
   52|       |  /* Handle unused parameters */
   53|  2.93k|  (void)purpose;
   54|  2.93k|  (void)address;
   55|       |
   56|  2.93k|  if(fuzz->sockman[0].fd_state != FUZZ_SOCK_CLOSED &&
   57|  2.93k|     fuzz->sockman[1].fd_state != FUZZ_SOCK_CLOSED) {
   58|       |    /* Both sockets have already been opened. */
   59|      9|    return CURL_SOCKET_BAD;
   60|      9|  }
   61|  2.92k|  else if(fuzz->sockman[0].fd_state != FUZZ_SOCK_CLOSED) {
   62|    104|    sman = &fuzz->sockman[1];
   63|    104|  }
   64|  2.81k|  else {
   65|  2.81k|    FV_PRINTF(fuzz, "FUZZ: Using socket manager 0 \n");
   66|  2.81k|    sman = &fuzz->sockman[0];
   67|  2.81k|  }
   68|  2.92k|  FV_PRINTF(fuzz, "FUZZ[%d]: Using socket manager %d \n",
   69|  2.92k|            sman->index,
   70|  2.92k|            sman->index);
   71|       |
   72|  2.92k|  if(socketpair(AF_UNIX, SOCK_STREAM, 0, fds)) {
   73|       |    /* Failed to create a pair of sockets. */
   74|      0|    return CURL_SOCKET_BAD;
   75|      0|  }
   76|       |
   77|  2.92k|  if(!FUZZ_VALID_SOCK(fds[0]) || !FUZZ_VALID_SOCK(fds[1])) {
   78|       |    /* One or more of the file descriptors is too large to fit in an fd_set,
   79|       |       so reject it here. Print out a message because this ought to be quite
   80|       |       rare. */
   81|      0|    printf("FUZZ[%d]: Not using file descriptors %d,%d as FD_SETSIZE is %d\n",
   82|      0|           sman->index,
   83|      0|           fds[0],
   84|      0|           fds[1],
   85|      0|           FD_SETSIZE);
   86|       |
   87|       |    /* Close the file descriptors so they don't leak. */
   88|      0|    close(fds[0]);
   89|      0|    close(fds[1]);
   90|       |
   91|      0|    return CURL_SOCKET_BAD;
   92|      0|  }
   93|       |
   94|       |  /* Make the server non-blocking. */
   95|  2.92k|  flags = fcntl(fds[0], F_GETFL, 0);
   96|  2.92k|  status = fcntl(fds[0], F_SETFL, flags | O_NONBLOCK);
   97|       |
   98|  2.92k|  if(status == -1) {
   99|       |    /* Close the file descriptors so they don't leak. */
  100|      0|    close(fds[0]);
  101|      0|    close(fds[1]);
  102|       |
  103|       |    /* Setting non-blocking failed. Return a negative response code. */
  104|      0|    return CURL_SOCKET_BAD;
  105|      0|  }
  106|       |
  107|       |  /* At this point, the file descriptors in hand should be good enough to
  108|       |     work with. */
  109|  2.92k|  sman->fd = fds[0];
  110|  2.92k|  sman->fd_state = FUZZ_SOCK_OPEN;
  111|       |
  112|       |  /* If the server should be sending data immediately, send it here. */
  113|  2.92k|  data = sman->responses[0].data;
  114|  2.92k|  data_len = sman->responses[0].data_len;
  115|       |
  116|  2.92k|  if(data != NULL) {
  117|  2.31k|    FV_PRINTF(fuzz, "FUZZ[%d]: Sending initial response \n", sman->index);
  118|       |
  119|  2.31k|    if(write(sman->fd, data, data_len) != (ssize_t)data_len) {
  120|       |      /* Close the file descriptors so they don't leak. */
  121|      0|      close(sman->fd);
  122|      0|      sman->fd = -1;
  123|       |
  124|      0|      close(fds[1]);
  125|       |
  126|       |      /* Failed to write all of the response data. */
  127|      0|      return CURL_SOCKET_BAD;
  128|      0|    }
  129|  2.31k|  }
  130|       |
  131|       |  /* Check to see if the socket should be shut down immediately. */
  132|  2.92k|  if(sman->responses[1].data == NULL) {
  133|  2.58k|    FV_PRINTF(fuzz,
  134|  2.58k|              "FUZZ[%d]: Shutting down server socket: %d \n",
  135|  2.58k|              sman->index,
  136|  2.58k|              sman->fd);
  137|  2.58k|    shutdown(sman->fd, SHUT_WR);
  138|  2.58k|    sman->fd_state = FUZZ_SOCK_SHUTDOWN;
  139|  2.58k|  }
  140|       |
  141|       |  /* Return the other half of the socket pair. */
  142|  2.92k|  return fds[1];
  143|  2.92k|}
_Z21fuzz_sockopt_callbackPvi12curlsocktype:
  152|  2.92k|{
  153|  2.92k|  (void)ptr;
  154|  2.92k|  (void)curlfd;
  155|  2.92k|  (void)purpose;
  156|       |
  157|  2.92k|  return CURL_SOCKOPT_ALREADY_CONNECTED;
  158|  2.92k|}
_Z18fuzz_read_callbackPcmmPv:
  167|     22|{
  168|     22|  FUZZ_DATA *fuzz = (FUZZ_DATA *)ptr;
  169|     22|  size_t remaining_data;
  170|     22|  size_t buffer_size = size * nitems;
  171|       |
  172|       |  /* If no upload data has been specified, then return an error code. */
  173|     22|  if(fuzz->upload1_data_len == 0) {
  174|       |    /* No data to upload */
  175|      3|    return CURL_READFUNC_ABORT;
  176|      3|  }
  177|       |
  178|       |  /* Work out how much data is remaining to upload. */
  179|     19|  remaining_data = fuzz->upload1_data_len - fuzz->upload1_data_written;
  180|       |
  181|       |  /* Respect the buffer size that libcurl is giving us! */
  182|     19|  if(remaining_data > buffer_size) {
  183|      0|    remaining_data = buffer_size;
  184|      0|  }
  185|       |
  186|     19|  if(remaining_data > 0) {
  187|     12|    FV_PRINTF(fuzz,
  188|     12|              "FUZZ: Uploading %zu bytes from position %zu \n",
  189|     12|              remaining_data,
  190|     12|              fuzz->upload1_data_written);
  191|       |
  192|       |    /* Send the upload data. */
  193|     12|    memcpy(buffer,
  194|     12|           &fuzz->upload1_data[fuzz->upload1_data_written],
  195|     12|           remaining_data);
  196|       |
  197|       |    /* Increase the count of written data */
  198|     12|    fuzz->upload1_data_written += remaining_data;
  199|     12|  }
  200|       |
  201|     19|  return(remaining_data);
  202|     22|}
_Z19fuzz_write_callbackPvmmS_:
  211|  7.03k|{
  212|  7.03k|  size_t total = size * nmemb;
  213|  7.03k|  FUZZ_DATA *fuzz = (FUZZ_DATA *)ptr;
  214|  7.03k|  size_t copy_len = total;
  215|       |
  216|       |  /* Restrict copy_len to at most TEMP_WRITE_ARRAY_SIZE. */
  217|  7.03k|  if(copy_len > TEMP_WRITE_ARRAY_SIZE) {
  218|  1.38k|    copy_len = TEMP_WRITE_ARRAY_SIZE;
  219|  1.38k|  }
  220|       |
  221|       |  /* Copy bytes to the temp store just to ensure the parameters are
  222|       |     exercised. */
  223|  7.03k|  memcpy(fuzz->write_array, contents, copy_len);
  224|       |
  225|       |  /* Add on the total to the count. If it exceeds the maximum then return
  226|       |     zero to the caller so that the transfer is terminated early. */
  227|  7.03k|  fuzz->written_data += total;
  228|       |
  229|  7.03k|  if(fuzz->written_data > MAXIMUM_WRITE_LENGTH) {
  230|      0|    FV_PRINTF(fuzz,
  231|      0|              "FUZZ: Exceeded maximum write length (%lu) \n",
  232|      0|              fuzz->written_data);
  233|      0|    total = 0;
  234|      0|  }
  235|       |
  236|  7.03k|  return total;
  237|  7.03k|}

_Z18fuzz_get_first_tlvP9fuzz_dataP3tlv:
   32|  4.98k|{
   33|       |  /* Reset the cursor. */
   34|  4.98k|  fuzz->state.data_pos = 0;
   35|  4.98k|  return fuzz_get_tlv_comn(fuzz, tlv);
   36|  4.98k|}
_Z17fuzz_get_next_tlvP9fuzz_dataP3tlv:
   43|  41.0k|{
   44|       |  /* Advance the cursor by the full length of the previous TLV. */
   45|  41.0k|  fuzz->state.data_pos += sizeof(TLV_RAW) + tlv->length;
   46|       |
   47|       |  /* Work out if there's a TLV's worth of data to read */
   48|  41.0k|  if(fuzz->state.data_pos + sizeof(TLV_RAW) > fuzz->state.data_len) {
   49|       |    /* No more TLVs to parse */
   50|  3.33k|    return TLV_RC_NO_MORE_TLVS;
   51|  3.33k|  }
   52|       |
   53|  37.6k|  return fuzz_get_tlv_comn(fuzz, tlv);
   54|  41.0k|}
_Z17fuzz_get_tlv_comnP9fuzz_dataP3tlv:
   61|  42.6k|{
   62|  42.6k|  int rc = 0;
   63|  42.6k|  size_t data_offset;
   64|  42.6k|  TLV_RAW *raw;
   65|       |
   66|       |  /* Start by casting the data stream to a TLV. */
   67|  42.6k|  raw = (TLV_RAW *)&fuzz->state.data[fuzz->state.data_pos];
   68|  42.6k|  data_offset = fuzz->state.data_pos + sizeof(TLV_RAW);
   69|       |
   70|       |  /* Set the TLV values. */
   71|  42.6k|  tlv->type = to_u16(raw->raw_type);
   72|  42.6k|  tlv->length = to_u32(raw->raw_length);
   73|  42.6k|  tlv->value = &fuzz->state.data[data_offset];
   74|       |
   75|  42.6k|  FV_PRINTF(fuzz, "TLV: type %x length %u\n", tlv->type, tlv->length);
   76|       |
   77|       |  /* Use uint64s to verify lengths of TLVs so that overflow problems don't
   78|       |     matter. */
   79|  42.6k|  uint64_t check_length = data_offset;
   80|  42.6k|  check_length += tlv->length;
   81|       |
   82|  42.6k|  uint64_t remaining_len = fuzz->state.data_len;
   83|  42.6k|  FV_PRINTF(fuzz, "Check length of data: %lu \n", check_length);
   84|  42.6k|  FV_PRINTF(fuzz, "Remaining length of data: %lu \n", remaining_len);
   85|       |
   86|       |  /* Sanity check that the TLV length is ok. */
   87|  42.6k|  if(check_length > remaining_len) {
   88|    922|    FV_PRINTF(fuzz, "Returning TLV_RC_SIZE_ERROR\n");
   89|    922|    rc = TLV_RC_SIZE_ERROR;
   90|    922|  }
   91|       |
   92|  42.6k|  return rc;
   93|  42.6k|}
_Z14fuzz_parse_tlvP9fuzz_dataP3tlv:
   99|  40.2k|{
  100|  40.2k|  int rc;
  101|  40.2k|  char *tmp = NULL;
  102|  40.2k|  uint32_t tmp_u32;
  103|       |
  104|  40.2k|  switch(tlv->type) {
  105|       |    /* The pointers in response TLVs will always be valid as long as the fuzz
  106|       |       data is in scope, which is the entirety of this file. */
  107|  2.80k|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE0, 0);
  108|    536|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE1, 1);
  109|    454|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE2, 2);
  110|    365|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE3, 3);
  111|    301|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE4, 4);
  112|    283|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE5, 5);
  113|    216|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE6, 6);
  114|    213|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE7, 7);
  115|    209|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE8, 8);
  116|    201|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE9, 9);
  117|    204|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE10, 10);
  118|       |
  119|    234|    FRESPONSETLV(&fuzz->sockman[1], TLV_TYPE_SECOND_RESPONSE0, 0);
  120|    220|    FRESPONSETLV(&fuzz->sockman[1], TLV_TYPE_SECOND_RESPONSE1, 1);
  121|       |
  122|    111|    case TLV_TYPE_UPLOAD1:
  123|       |      /* The pointers in the TLV will always be valid as long as the fuzz data
  124|       |         is in scope, which is the entirety of this file. */
  125|       |
  126|    111|      FCHECK_OPTION_UNSET(fuzz, CURLOPT_UPLOAD);
  127|       |
  128|    110|      fuzz->upload1_data = tlv->value;
  129|    110|      fuzz->upload1_data_len = tlv->length;
  130|       |
  131|    110|      FSET_OPTION(fuzz, CURLOPT_UPLOAD, 1L);
  132|    110|      FSET_OPTION(fuzz,
  133|    110|                  CURLOPT_INFILESIZE_LARGE,
  134|    110|                  (curl_off_t)fuzz->upload1_data_len);
  135|    110|      break;
  136|       |
  137|  5.94k|    case TLV_TYPE_HEADER:
  138|       |      /* Limit the number of headers that can be added to a message to prevent
  139|       |         timeouts. */
  140|  5.94k|      if(fuzz->header_list_count >= TLV_MAX_NUM_CURLOPT_HEADER) {
  141|      0|        rc = 255;
  142|      0|        goto EXIT_LABEL;
  143|      0|      }
  144|       |
  145|  5.94k|      tmp = fuzz_tlv_to_string(tlv);
  146|  5.94k|      fuzz->header_list = curl_slist_append(fuzz->header_list, tmp);
  147|  5.94k|      fuzz->header_list_count++;
  148|  5.94k|      break;
  149|       |
  150|  1.24k|    case TLV_TYPE_MAIL_RECIPIENT:
  151|  1.24k|      tmp = fuzz_tlv_to_string(tlv);
  152|  1.24k|      fuzz->mail_recipients_list =
  153|  1.24k|                            curl_slist_append(fuzz->mail_recipients_list, tmp);
  154|  1.24k|      break;
  155|       |
  156|  22.6k|    case TLV_TYPE_MIME_PART:
  157|  22.6k|      if(fuzz->mime == NULL) {
  158|    285|        fuzz->mime = curl_mime_init(fuzz->easy);
  159|    285|      }
  160|       |
  161|  22.6k|      fuzz->part = curl_mime_addpart(fuzz->mime);
  162|       |
  163|       |      /* This TLV may have sub TLVs. */
  164|  22.6k|      fuzz_add_mime_part(tlv, fuzz->part);
  165|  22.6k|      break;
  166|       |
  167|     28|    case TLV_TYPE_POSTFIELDS:
  168|     28|      FCHECK_OPTION_UNSET(fuzz, CURLOPT_POSTFIELDS);
  169|     27|      fuzz->postfields = fuzz_tlv_to_string(tlv);
  170|     27|      FSET_OPTION(fuzz, CURLOPT_POSTFIELDS, fuzz->postfields);
  171|     27|      break;
  172|       |
  173|       |    /* Define a set of u32 options. */
  174|    312|    FU32TLV(fuzz, TLV_TYPE_HTTPAUTH, CURLOPT_HTTPAUTH);
  175|     33|    FU32TLV(fuzz, TLV_TYPE_OPTHEADER, CURLOPT_HEADER);
  176|     99|    FU32TLV(fuzz, TLV_TYPE_NOBODY, CURLOPT_NOBODY);
  177|    195|    FU32TLV(fuzz, TLV_TYPE_FOLLOWLOCATION, CURLOPT_FOLLOWLOCATION);
  178|    114|    FU32TLV(fuzz, TLV_TYPE_WILDCARDMATCH, CURLOPT_WILDCARDMATCH);
  179|     15|    FU32TLV(fuzz, TLV_TYPE_RTSP_REQUEST, CURLOPT_RTSP_REQUEST);
  180|     14|    FU32TLV(fuzz, TLV_TYPE_RTSP_CLIENT_CSEQ, CURLOPT_RTSP_CLIENT_CSEQ);
  181|     15|    FU32TLV(fuzz, TLV_TYPE_HTTP_VERSION, CURLOPT_HTTP_VERSION);
  182|       |
  183|       |    /* Define a set of singleton TLVs - they can only have their value set once
  184|       |       and all follow the same pattern. */
  185|  5.90k|    FSINGLETONTLV(fuzz, TLV_TYPE_URL, CURLOPT_URL);
  186|      5|    FSINGLETONTLV(fuzz, TLV_TYPE_DOH_URL, CURLOPT_DOH_URL);
  187|    413|    FSINGLETONTLV(fuzz, TLV_TYPE_USERNAME, CURLOPT_USERNAME);
  188|    106|    FSINGLETONTLV(fuzz, TLV_TYPE_PASSWORD, CURLOPT_PASSWORD);
  189|     15|    FSINGLETONTLV(fuzz, TLV_TYPE_COOKIE, CURLOPT_COOKIE);
  190|    107|    FSINGLETONTLV(fuzz, TLV_TYPE_RANGE, CURLOPT_RANGE);
  191|    395|    FSINGLETONTLV(fuzz, TLV_TYPE_CUSTOMREQUEST, CURLOPT_CUSTOMREQUEST);
  192|    127|    FSINGLETONTLV(fuzz, TLV_TYPE_MAIL_FROM, CURLOPT_MAIL_FROM);
  193|    235|    FSINGLETONTLV(fuzz, TLV_TYPE_ACCEPTENCODING, CURLOPT_ACCEPT_ENCODING);
  194|      6|    FSINGLETONTLV(fuzz, TLV_TYPE_RTSP_SESSION_ID, CURLOPT_RTSP_SESSION_ID);
  195|     13|    FSINGLETONTLV(fuzz, TLV_TYPE_RTSP_STREAM_URI, CURLOPT_RTSP_STREAM_URI);
  196|      3|    FSINGLETONTLV(fuzz, TLV_TYPE_RTSP_TRANSPORT, CURLOPT_RTSP_TRANSPORT);
  197|      7|    FSINGLETONTLV(fuzz, TLV_TYPE_MAIL_AUTH, CURLOPT_MAIL_AUTH);
  198|       |
  199|      7|    default:
  200|       |      /* The fuzzer generates lots of unknown TLVs - we don't want these in the
  201|       |         corpus so we reject any unknown TLVs. */
  202|      7|      rc = 127;
  203|      7|      goto EXIT_LABEL;
  204|      0|      break;
  205|  40.2k|  }
  206|       |
  207|  40.1k|  rc = 0;
  208|       |
  209|  40.2k|EXIT_LABEL:
  210|       |
  211|  40.2k|  fuzz_free((void **)&tmp);
  212|       |
  213|  40.2k|  return rc;
  214|  40.1k|}
_Z18fuzz_tlv_to_stringP3tlv:
  220|  11.2k|{
  221|  11.2k|  char *tlvstr;
  222|       |
  223|       |  /* Allocate enough space, plus a null terminator */
  224|  11.2k|  tlvstr = (char *)malloc(tlv->length + 1);
  225|       |
  226|  11.2k|  if(tlvstr != NULL) {
  227|  11.2k|    memcpy(tlvstr, tlv->value, tlv->length);
  228|  11.2k|    tlvstr[tlv->length] = 0;
  229|  11.2k|  }
  230|       |
  231|  11.2k|  return tlvstr;
  232|  11.2k|}
_Z18fuzz_add_mime_partP3tlvP13curl_mimepart:
  238|  22.6k|{
  239|  22.6k|  FUZZ_DATA part_fuzz;
  240|  22.6k|  TLV tlv;
  241|  22.6k|  int rc = 0;
  242|  22.6k|  int tlv_rc;
  243|       |
  244|  22.6k|  memset(&part_fuzz, 0, sizeof(FUZZ_DATA));
  245|       |
  246|  22.6k|  if(src_tlv->length < sizeof(TLV_RAW)) {
  247|       |    /* Not enough data for a single TLV - don't continue */
  248|  20.8k|    goto EXIT_LABEL;
  249|  20.8k|  }
  250|       |
  251|       |  /* Set up the state parser */
  252|  1.82k|  part_fuzz.state.data = src_tlv->value;
  253|  1.82k|  part_fuzz.state.data_len = src_tlv->length;
  254|       |
  255|  1.82k|  for(tlv_rc = fuzz_get_first_tlv(&part_fuzz, &tlv);
  256|  2.64k|      tlv_rc == 0;
  257|  1.82k|      tlv_rc = fuzz_get_next_tlv(&part_fuzz, &tlv)) {
  258|       |
  259|       |    /* Have the TLV in hand. Parse the TLV. */
  260|  1.50k|    rc = fuzz_parse_mime_tlv(part, &tlv);
  261|       |
  262|  1.50k|    if(rc != 0) {
  263|       |      /* Failed to parse the TLV. Can't continue. */
  264|    682|      goto EXIT_LABEL;
  265|    682|    }
  266|  1.50k|  }
  267|       |
  268|  1.13k|  if(tlv_rc != TLV_RC_NO_MORE_TLVS) {
  269|       |    /* A TLV call failed. Can't continue. */
  270|    895|    goto EXIT_LABEL;
  271|    895|  }
  272|       |
  273|  22.6k|EXIT_LABEL:
  274|       |
  275|  22.6k|  return(rc);
  276|  1.13k|}
_Z19fuzz_parse_mime_tlvP13curl_mimepartP3tlv:
  282|  1.50k|{
  283|  1.50k|  int rc;
  284|  1.50k|  char *tmp;
  285|       |
  286|  1.50k|  switch(tlv->type) {
  287|    353|    case TLV_TYPE_MIME_PART_NAME:
  288|    353|      tmp = fuzz_tlv_to_string(tlv);
  289|    353|      curl_mime_name(part, tmp);
  290|    353|      fuzz_free((void **)&tmp);
  291|    353|      break;
  292|       |
  293|    467|    case TLV_TYPE_MIME_PART_DATA:
  294|    467|      curl_mime_data(part, (const char *)tlv->value, tlv->length);
  295|    467|      break;
  296|       |
  297|    682|    default:
  298|       |      /* The fuzzer generates lots of unknown TLVs - we don't want these in the
  299|       |         corpus so we reject any unknown TLVs. */
  300|    682|      rc = 255;
  301|    682|      goto EXIT_LABEL;
  302|      0|      break;
  303|  1.50k|  }
  304|       |
  305|    820|  rc = 0;
  306|       |
  307|  1.50k|EXIT_LABEL:
  308|       |
  309|  1.50k|  return rc;
  310|    820|}

ex_data.c:ex_class_item_LHASH_HASH:
  105|  8.13k|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|  8.13k|                const o_type *a = arg; \
  107|  8.13k|                return name##_hash(a); }
ex_data.c:ex_class_item_LHASH_COMP:
  114|  8.11k|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|  8.11k|                const o_type *a = arg1;             \
  116|  8.11k|                const o_type *b = arg2; \
  117|  8.11k|                return name##_cmp(a,b); }

X509_NAME_ENTRY_new:
  848|  28.9k|        { \
  849|  28.9k|                return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
  850|  28.9k|        } \
X509_NAME_ENTRY_free:
  852|  57.9k|        { \
  853|  57.9k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  57.9k|        }
d2i_X509:
  862|  3.84k|        { \
  863|  3.84k|                return (stname *)ASN1_item_d2i((ASN1_VALUE **)a, in, len, ASN1_ITEM_rptr(itname));\
  864|  3.84k|        } \
X509_free:
  852|  7.68k|        { \
  853|  7.68k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  7.68k|        }
X509_CERT_AUX_free:
  852|  3.84k|        { \
  853|  3.84k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  3.84k|        }
ASN1_OCTET_STRING_free:
  852|  3.84k|        { \
  853|  3.84k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  3.84k|        }
ASN1_TYPE_new:
  848|  10.1k|        { \
  849|  10.1k|                return (stname *)ASN1_item_new(ASN1_ITEM_rptr(itname)); \
  850|  10.1k|        } \

c2i_ASN1_BIT_STRING:
  129|  7.68k|{
  130|  7.68k|    ASN1_BIT_STRING *ret = NULL;
  131|  7.68k|    const unsigned char *p;
  132|  7.68k|    unsigned char *s;
  133|  7.68k|    int i;
  134|       |
  135|  7.68k|    if (len < 1) {
  136|      0|        i = ASN1_R_STRING_TOO_SHORT;
  137|      0|        goto err;
  138|      0|    }
  139|       |
  140|  7.68k|    if (len > INT_MAX) {
  141|      0|        i = ASN1_R_STRING_TOO_LONG;
  142|      0|        goto err;
  143|      0|    }
  144|       |
  145|  7.68k|    if ((a == NULL) || ((*a) == NULL)) {
  146|      0|        if ((ret = M_ASN1_BIT_STRING_new()) == NULL)
  147|      0|            return (NULL);
  148|      0|    } else
  149|  7.68k|        ret = (*a);
  150|       |
  151|  7.68k|    p = *pp;
  152|  7.68k|    i = *(p++);
  153|  7.68k|    if (i > 7) {
  154|      0|        i = ASN1_R_INVALID_BIT_STRING_BITS_LEFT;
  155|      0|        goto err;
  156|      0|    }
  157|       |    /*
  158|       |     * We do this to preserve the settings.  If we modify the settings, via
  159|       |     * the _set_bit function, we will recalculate on output
  160|       |     */
  161|  7.68k|    ret->flags &= ~(ASN1_STRING_FLAG_BITS_LEFT | 0x07); /* clear */
  162|  7.68k|    ret->flags |= (ASN1_STRING_FLAG_BITS_LEFT | i); /* set */
  163|       |
  164|  7.68k|    if (len-- > 1) {            /* using one because of the bits left byte */
  165|  7.68k|        s = (unsigned char *)OPENSSL_malloc((int)len);
  166|  7.68k|        if (s == NULL) {
  167|      0|            i = ERR_R_MALLOC_FAILURE;
  168|      0|            goto err;
  169|      0|        }
  170|  7.68k|        memcpy(s, p, (int)len);
  171|  7.68k|        s[len - 1] &= (0xff << i);
  172|  7.68k|        p += len;
  173|  7.68k|    } else
  174|      0|        s = NULL;
  175|       |
  176|  7.68k|    ret->length = (int)len;
  177|  7.68k|    if (ret->data != NULL)
  178|      0|        OPENSSL_free(ret->data);
  179|  7.68k|    ret->data = s;
  180|  7.68k|    ret->type = V_ASN1_BIT_STRING;
  181|  7.68k|    if (a != NULL)
  182|  7.68k|        (*a) = ret;
  183|  7.68k|    *pp = p;
  184|  7.68k|    return (ret);
  185|      0| err:
  186|      0|    ASN1err(ASN1_F_C2I_ASN1_BIT_STRING, i);
  187|      0|    if ((ret != NULL) && ((a == NULL) || (*a != ret)))
  188|      0|        M_ASN1_BIT_STRING_free(ret);
  189|      0|    return (NULL);
  190|  7.68k|}

c2i_ASN1_INTEGER:
  188|  7.68k|{
  189|  7.68k|    ASN1_INTEGER *ret = NULL;
  190|  7.68k|    const unsigned char *p, *pend;
  191|  7.68k|    unsigned char *to, *s;
  192|  7.68k|    int i;
  193|       |
  194|  7.68k|    if ((a == NULL) || ((*a) == NULL)) {
  195|  3.84k|        if ((ret = M_ASN1_INTEGER_new()) == NULL)
  196|      0|            return (NULL);
  197|  3.84k|        ret->type = V_ASN1_INTEGER;
  198|  3.84k|    } else
  199|  3.84k|        ret = (*a);
  200|       |
  201|  7.68k|    p = *pp;
  202|  7.68k|    pend = p + len;
  203|       |
  204|       |    /*
  205|       |     * We must OPENSSL_malloc stuff, even for 0 bytes otherwise it signifies
  206|       |     * a missing NULL parameter.
  207|       |     */
  208|  7.68k|    s = (unsigned char *)OPENSSL_malloc((int)len + 1);
  209|  7.68k|    if (s == NULL) {
  210|      0|        i = ERR_R_MALLOC_FAILURE;
  211|      0|        goto err;
  212|      0|    }
  213|  7.68k|    to = s;
  214|  7.68k|    if (!len) {
  215|       |        /*
  216|       |         * Strictly speaking this is an illegal INTEGER but we tolerate it.
  217|       |         */
  218|      0|        ret->type = V_ASN1_INTEGER;
  219|  7.68k|    } else if (*p & 0x80) {     /* a negative number */
  220|     30|        ret->type = V_ASN1_NEG_INTEGER;
  221|     30|        if ((*p == 0xff) && (len != 1)) {
  222|      0|            p++;
  223|      0|            len--;
  224|      0|        }
  225|     30|        i = len;
  226|     30|        p += i - 1;
  227|     30|        to += i - 1;
  228|     30|        while ((!*p) && i) {
  229|      0|            *(to--) = 0;
  230|      0|            i--;
  231|      0|            p--;
  232|      0|        }
  233|       |        /*
  234|       |         * Special case: if all zeros then the number will be of the form FF
  235|       |         * followed by n zero bytes: this corresponds to 1 followed by n zero
  236|       |         * bytes. We've already written n zeros so we just append an extra
  237|       |         * one and set the first byte to a 1. This is treated separately
  238|       |         * because it is the only case where the number of bytes is larger
  239|       |         * than len.
  240|       |         */
  241|     30|        if (!i) {
  242|      0|            *s = 1;
  243|      0|            s[len] = 0;
  244|      0|            len++;
  245|     30|        } else {
  246|     30|            *(to--) = (*(p--) ^ 0xff) + 1;
  247|     30|            i--;
  248|    480|            for (; i > 0; i--)
  249|    450|                *(to--) = *(p--) ^ 0xff;
  250|     30|        }
  251|  7.65k|    } else {
  252|  7.65k|        ret->type = V_ASN1_INTEGER;
  253|  7.65k|        if ((*p == 0) && (len != 1)) {
  254|    510|            p++;
  255|    510|            len--;
  256|    510|        }
  257|  7.65k|        memcpy(s, p, (int)len);
  258|  7.65k|    }
  259|       |
  260|  7.68k|    if (ret->data != NULL)
  261|      0|        OPENSSL_free(ret->data);
  262|  7.68k|    ret->data = s;
  263|  7.68k|    ret->length = (int)len;
  264|  7.68k|    if (a != NULL)
  265|  7.68k|        (*a) = ret;
  266|  7.68k|    *pp = pend;
  267|  7.68k|    return (ret);
  268|      0| err:
  269|      0|    ASN1err(ASN1_F_C2I_ASN1_INTEGER, i);
  270|      0|    if ((ret != NULL) && ((a == NULL) || (*a != ret)))
  271|      0|        M_ASN1_INTEGER_free(ret);
  272|      0|    return (NULL);
  273|  7.68k|}

ASN1_mbstring_copy:
   88|  28.9k|{
   89|  28.9k|    return ASN1_mbstring_ncopy(out, in, len, inform, mask, 0, 0);
   90|  28.9k|}
ASN1_mbstring_ncopy:
   95|  28.9k|{
   96|  28.9k|    int str_type;
   97|  28.9k|    int ret;
   98|  28.9k|    char free_out;
   99|  28.9k|    int outform, outlen = 0;
  100|  28.9k|    ASN1_STRING *dest;
  101|  28.9k|    unsigned char *p;
  102|  28.9k|    int nchar;
  103|  28.9k|    char strbuf[32];
  104|  28.9k|    int (*cpyfunc) (unsigned long, void *) = NULL;
  105|  28.9k|    if (len == -1)
  106|      0|        len = strlen((const char *)in);
  107|  28.9k|    if (!mask)
  108|      0|        mask = DIRSTRING_TYPE;
  109|       |
  110|       |    /* First do a string check and work out the number of characters */
  111|  28.9k|    switch (inform) {
  112|       |
  113|      0|    case MBSTRING_BMP:
  114|      0|        if (len & 1) {
  115|      0|            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
  116|      0|                    ASN1_R_INVALID_BMPSTRING_LENGTH);
  117|      0|            return -1;
  118|      0|        }
  119|      0|        nchar = len >> 1;
  120|      0|        break;
  121|       |
  122|      0|    case MBSTRING_UNIV:
  123|      0|        if (len & 3) {
  124|      0|            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY,
  125|      0|                    ASN1_R_INVALID_UNIVERSALSTRING_LENGTH);
  126|      0|            return -1;
  127|      0|        }
  128|      0|        nchar = len >> 2;
  129|      0|        break;
  130|       |
  131|  7.02k|    case MBSTRING_UTF8:
  132|  7.02k|        nchar = 0;
  133|       |        /* This counts the characters and does utf8 syntax checking */
  134|  7.02k|        ret = traverse_string(in, len, MBSTRING_UTF8, in_utf8, &nchar);
  135|  7.02k|        if (ret < 0) {
  136|      0|            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_INVALID_UTF8STRING);
  137|      0|            return -1;
  138|      0|        }
  139|  7.02k|        break;
  140|       |
  141|  21.9k|    case MBSTRING_ASC:
  142|  21.9k|        nchar = len;
  143|  21.9k|        break;
  144|       |
  145|      0|    default:
  146|      0|        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_UNKNOWN_FORMAT);
  147|      0|        return -1;
  148|  28.9k|    }
  149|       |
  150|  28.9k|    if ((minsize > 0) && (nchar < minsize)) {
  151|      0|        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_SHORT);
  152|      0|        BIO_snprintf(strbuf, sizeof strbuf, "%ld", minsize);
  153|      0|        ERR_add_error_data(2, "minsize=", strbuf);
  154|      0|        return -1;
  155|      0|    }
  156|       |
  157|  28.9k|    if ((maxsize > 0) && (nchar > maxsize)) {
  158|      0|        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_STRING_TOO_LONG);
  159|      0|        BIO_snprintf(strbuf, sizeof strbuf, "%ld", maxsize);
  160|      0|        ERR_add_error_data(2, "maxsize=", strbuf);
  161|      0|        return -1;
  162|      0|    }
  163|       |
  164|       |    /* Now work out minimal type (if any) */
  165|  28.9k|    if (traverse_string(in, len, inform, type_str, &mask) < 0) {
  166|      0|        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ASN1_R_ILLEGAL_CHARACTERS);
  167|      0|        return -1;
  168|      0|    }
  169|       |
  170|       |    /* Now work out output format and string type */
  171|  28.9k|    outform = MBSTRING_ASC;
  172|  28.9k|    if (mask & B_ASN1_PRINTABLESTRING)
  173|      0|        str_type = V_ASN1_PRINTABLESTRING;
  174|  28.9k|    else if (mask & B_ASN1_IA5STRING)
  175|      0|        str_type = V_ASN1_IA5STRING;
  176|  28.9k|    else if (mask & B_ASN1_T61STRING)
  177|      0|        str_type = V_ASN1_T61STRING;
  178|  28.9k|    else if (mask & B_ASN1_BMPSTRING) {
  179|      0|        str_type = V_ASN1_BMPSTRING;
  180|      0|        outform = MBSTRING_BMP;
  181|  28.9k|    } else if (mask & B_ASN1_UNIVERSALSTRING) {
  182|      0|        str_type = V_ASN1_UNIVERSALSTRING;
  183|      0|        outform = MBSTRING_UNIV;
  184|  28.9k|    } else {
  185|  28.9k|        str_type = V_ASN1_UTF8STRING;
  186|  28.9k|        outform = MBSTRING_UTF8;
  187|  28.9k|    }
  188|  28.9k|    if (!out)
  189|      0|        return str_type;
  190|  28.9k|    if (*out) {
  191|  28.9k|        free_out = 0;
  192|  28.9k|        dest = *out;
  193|  28.9k|        if (dest->data) {
  194|      0|            dest->length = 0;
  195|      0|            OPENSSL_free(dest->data);
  196|      0|            dest->data = NULL;
  197|      0|        }
  198|  28.9k|        dest->type = str_type;
  199|  28.9k|    } else {
  200|      0|        free_out = 1;
  201|      0|        dest = ASN1_STRING_type_new(str_type);
  202|      0|        if (!dest) {
  203|      0|            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);
  204|      0|            return -1;
  205|      0|        }
  206|      0|        *out = dest;
  207|      0|    }
  208|       |    /* If both the same type just copy across */
  209|  28.9k|    if (inform == outform) {
  210|  7.02k|        if (!ASN1_STRING_set(dest, in, len)) {
  211|      0|            ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);
  212|      0|            return -1;
  213|      0|        }
  214|  7.02k|        return str_type;
  215|  7.02k|    }
  216|       |
  217|       |    /* Work out how much space the destination will need */
  218|  21.9k|    switch (outform) {
  219|      0|    case MBSTRING_ASC:
  220|      0|        outlen = nchar;
  221|      0|        cpyfunc = cpy_asc;
  222|      0|        break;
  223|       |
  224|      0|    case MBSTRING_BMP:
  225|      0|        outlen = nchar << 1;
  226|      0|        cpyfunc = cpy_bmp;
  227|      0|        break;
  228|       |
  229|      0|    case MBSTRING_UNIV:
  230|      0|        outlen = nchar << 2;
  231|      0|        cpyfunc = cpy_univ;
  232|      0|        break;
  233|       |
  234|  21.9k|    case MBSTRING_UTF8:
  235|  21.9k|        outlen = 0;
  236|  21.9k|        traverse_string(in, len, inform, out_utf8, &outlen);
  237|  21.9k|        cpyfunc = cpy_utf8;
  238|  21.9k|        break;
  239|  21.9k|    }
  240|  21.9k|    if (!(p = OPENSSL_malloc(outlen + 1))) {
  241|      0|        if (free_out)
  242|      0|            ASN1_STRING_free(dest);
  243|      0|        ASN1err(ASN1_F_ASN1_MBSTRING_NCOPY, ERR_R_MALLOC_FAILURE);
  244|      0|        return -1;
  245|      0|    }
  246|  21.9k|    dest->length = outlen;
  247|  21.9k|    dest->data = p;
  248|  21.9k|    p[outlen] = 0;
  249|  21.9k|    traverse_string(in, len, inform, cpyfunc, &p);
  250|  21.9k|    return str_type;
  251|  21.9k|}
a_mbstr.c:traverse_string:
  261|  79.9k|{
  262|  79.9k|    unsigned long value;
  263|  79.9k|    int ret;
  264|  1.39M|    while (len) {
  265|  1.31M|        if (inform == MBSTRING_ASC) {
  266|  1.03M|            value = *p++;
  267|  1.03M|            len--;
  268|  1.03M|        } else if (inform == MBSTRING_BMP) {
  269|      0|            value = *p++ << 8;
  270|      0|            value |= *p++;
  271|      0|            len -= 2;
  272|   277k|        } else if (inform == MBSTRING_UNIV) {
  273|      0|            value = ((unsigned long)*p++) << 24;
  274|      0|            value |= ((unsigned long)*p++) << 16;
  275|      0|            value |= *p++ << 8;
  276|      0|            value |= *p++;
  277|      0|            len -= 4;
  278|   277k|        } else {
  279|   277k|            ret = UTF8_getc(p, len, &value);
  280|   277k|            if (ret < 0)
  281|      0|                return -1;
  282|   277k|            len -= ret;
  283|   277k|            p += ret;
  284|   277k|        }
  285|  1.31M|        if (rfunc) {
  286|  1.31M|            ret = rfunc(value, arg);
  287|  1.31M|            if (ret <= 0)
  288|      0|                return ret;
  289|  1.31M|        }
  290|  1.31M|    }
  291|  79.9k|    return 1;
  292|  79.9k|}
a_mbstr.c:in_utf8:
  299|   138k|{
  300|   138k|    int *nchar;
  301|   138k|    nchar = arg;
  302|   138k|    (*nchar)++;
  303|   138k|    return 1;
  304|   138k|}
a_mbstr.c:out_utf8:
  309|   344k|{
  310|   344k|    int *outlen;
  311|   344k|    outlen = arg;
  312|   344k|    *outlen += UTF8_putc(NULL, -1, value);
  313|   344k|    return 1;
  314|   344k|}
a_mbstr.c:type_str:
  322|   483k|{
  323|   483k|    unsigned long types;
  324|   483k|    types = *((unsigned long *)arg);
  325|   483k|    if ((types & B_ASN1_PRINTABLESTRING) && !is_printable(value))
  326|      0|        types &= ~B_ASN1_PRINTABLESTRING;
  327|   483k|    if ((types & B_ASN1_IA5STRING) && (value > 127))
  328|      0|        types &= ~B_ASN1_IA5STRING;
  329|   483k|    if ((types & B_ASN1_T61STRING) && (value > 0xff))
  330|      0|        types &= ~B_ASN1_T61STRING;
  331|   483k|    if ((types & B_ASN1_BMPSTRING) && (value > 0xffff))
  332|      0|        types &= ~B_ASN1_BMPSTRING;
  333|   483k|    if (!types)
  334|      0|        return -1;
  335|   483k|    *((unsigned long *)arg) = types;
  336|   483k|    return 1;
  337|   483k|}
a_mbstr.c:cpy_utf8:
  382|   344k|{
  383|   344k|    unsigned char **p;
  384|   344k|    int ret;
  385|   344k|    p = arg;
  386|       |    /* We already know there is enough room so pass 0xff as the length */
  387|   344k|    ret = UTF8_putc(*p, 0xff, value);
  388|   344k|    *p += ret;
  389|   344k|    return 1;
  390|   344k|}

i2t_ASN1_OBJECT:
  218|     30|{
  219|     30|    return OBJ_obj2txt(buf, buf_len, a, 0);
  220|     30|}
c2i_ASN1_OBJECT:
  274|  54.9k|{
  275|  54.9k|    ASN1_OBJECT *ret = NULL;
  276|  54.9k|    const unsigned char *p;
  277|  54.9k|    unsigned char *data;
  278|  54.9k|    int i, length;
  279|       |
  280|       |    /*
  281|       |     * Sanity check OID encoding. Need at least one content octet. MSB must
  282|       |     * be clear in the last octet. can't have leading 0x80 in subidentifiers,
  283|       |     * see: X.690 8.19.2
  284|       |     */
  285|  54.9k|    if (len <= 0 || len > INT_MAX || pp == NULL || (p = *pp) == NULL ||
  286|  54.9k|        p[len - 1] & 0x80) {
  287|      0|        ASN1err(ASN1_F_C2I_ASN1_OBJECT, ASN1_R_INVALID_OBJECT_ENCODING);
  288|      0|        return NULL;
  289|      0|    }
  290|       |    /* Now 0 < len <= INT_MAX, so the cast is safe. */
  291|  54.9k|    length = (int)len;
  292|   290k|    for (i = 0; i < length; i++, p++) {
  293|   235k|        if (*p == 0x80 && (!i || !(p[-1] & 0x80))) {
  294|      0|            ASN1err(ASN1_F_C2I_ASN1_OBJECT, ASN1_R_INVALID_OBJECT_ENCODING);
  295|      0|            return NULL;
  296|      0|        }
  297|   235k|    }
  298|       |
  299|       |    /*
  300|       |     * only the ASN1_OBJECTs from the 'table' will have values for ->sn or
  301|       |     * ->ln
  302|       |     */
  303|  54.9k|    if ((a == NULL) || ((*a) == NULL) ||
  304|  54.9k|        !((*a)->flags & ASN1_OBJECT_FLAG_DYNAMIC)) {
  305|  54.9k|        if ((ret = ASN1_OBJECT_new()) == NULL)
  306|      0|            return (NULL);
  307|  54.9k|    } else
  308|      0|        ret = (*a);
  309|       |
  310|  54.9k|    p = *pp;
  311|       |    /* detach data from object */
  312|  54.9k|    data = (unsigned char *)ret->data;
  313|  54.9k|    ret->data = NULL;
  314|       |    /* once detached we can change it */
  315|  54.9k|    if ((data == NULL) || (ret->length < length)) {
  316|  54.9k|        ret->length = 0;
  317|  54.9k|        if (data != NULL)
  318|      0|            OPENSSL_free(data);
  319|  54.9k|        data = (unsigned char *)OPENSSL_malloc(length);
  320|  54.9k|        if (data == NULL) {
  321|      0|            i = ERR_R_MALLOC_FAILURE;
  322|      0|            goto err;
  323|      0|        }
  324|  54.9k|        ret->flags |= ASN1_OBJECT_FLAG_DYNAMIC_DATA;
  325|  54.9k|    }
  326|  54.9k|    memcpy(data, p, length);
  327|       |    /* reattach data to object, after which it remains const */
  328|  54.9k|    ret->data = data;
  329|  54.9k|    ret->length = length;
  330|  54.9k|    ret->sn = NULL;
  331|  54.9k|    ret->ln = NULL;
  332|       |    /* ret->flags=ASN1_OBJECT_FLAG_DYNAMIC; we know it is dynamic */
  333|  54.9k|    p += length;
  334|       |
  335|  54.9k|    if (a != NULL)
  336|  54.9k|        (*a) = ret;
  337|  54.9k|    *pp = p;
  338|  54.9k|    return (ret);
  339|      0| err:
  340|      0|    ASN1err(ASN1_F_C2I_ASN1_OBJECT, i);
  341|      0|    if ((ret != NULL) && ((a == NULL) || (*a != ret)))
  342|      0|        ASN1_OBJECT_free(ret);
  343|      0|    return (NULL);
  344|  54.9k|}
ASN1_OBJECT_new:
  347|  83.9k|{
  348|  83.9k|    ASN1_OBJECT *ret;
  349|       |
  350|  83.9k|    ret = (ASN1_OBJECT *)OPENSSL_malloc(sizeof(ASN1_OBJECT));
  351|  83.9k|    if (ret == NULL) {
  352|      0|        ASN1err(ASN1_F_ASN1_OBJECT_NEW, ERR_R_MALLOC_FAILURE);
  353|      0|        return (NULL);
  354|      0|    }
  355|  83.9k|    ret->length = 0;
  356|  83.9k|    ret->data = NULL;
  357|  83.9k|    ret->nid = 0;
  358|  83.9k|    ret->sn = NULL;
  359|  83.9k|    ret->ln = NULL;
  360|  83.9k|    ret->flags = ASN1_OBJECT_FLAG_DYNAMIC;
  361|  83.9k|    return (ret);
  362|  83.9k|}
ASN1_OBJECT_free:
  365|  83.9k|{
  366|  83.9k|    if (a == NULL)
  367|      0|        return;
  368|  83.9k|    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_STRINGS) {
  369|  28.9k|#ifndef CONST_STRICT            /* disable purely for compile-time strict
  370|       |                                 * const checking. Doing this on a "real"
  371|       |                                 * compile will cause memory leaks */
  372|  28.9k|        if (a->sn != NULL)
  373|      0|            OPENSSL_free((void *)a->sn);
  374|  28.9k|        if (a->ln != NULL)
  375|      0|            OPENSSL_free((void *)a->ln);
  376|  28.9k|#endif
  377|  28.9k|        a->sn = a->ln = NULL;
  378|  28.9k|    }
  379|  83.9k|    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC_DATA) {
  380|  83.9k|        if (a->data != NULL)
  381|  83.9k|            OPENSSL_free((void *)a->data);
  382|  83.9k|        a->data = NULL;
  383|  83.9k|        a->length = 0;
  384|  83.9k|    }
  385|  83.9k|    if (a->flags & ASN1_OBJECT_FLAG_DYNAMIC)
  386|  83.9k|        OPENSSL_free(a);
  387|  83.9k|}

ASN1_STRING_to_UTF8:
  627|  28.9k|{
  628|  28.9k|    ASN1_STRING stmp, *str = &stmp;
  629|  28.9k|    int mbflag, type, ret;
  630|  28.9k|    if (!in)
  631|      0|        return -1;
  632|  28.9k|    type = in->type;
  633|  28.9k|    if ((type < 0) || (type > 30))
  634|      0|        return -1;
  635|  28.9k|    mbflag = tag2nbyte[type];
  636|  28.9k|    if (mbflag == -1)
  637|      0|        return -1;
  638|  28.9k|    mbflag |= MBSTRING_FLAG;
  639|  28.9k|    stmp.data = NULL;
  640|  28.9k|    stmp.length = 0;
  641|  28.9k|    stmp.flags = 0;
  642|  28.9k|    ret =
  643|  28.9k|        ASN1_mbstring_copy(&str, in->data, in->length, mbflag,
  644|  28.9k|                           B_ASN1_UTF8STRING);
  645|  28.9k|    if (ret < 0)
  646|      0|        return ret;
  647|  28.9k|    *out = stmp.data;
  648|  28.9k|    return stmp.length;
  649|  28.9k|}

ASN1_TYPE_set:
   73|  10.1k|{
   74|  10.1k|    if (a->value.ptr != NULL) {
   75|      0|        ASN1_TYPE **tmp_a = &a;
   76|      0|        ASN1_primitive_free((ASN1_VALUE **)tmp_a, NULL);
   77|      0|    }
   78|  10.1k|    a->type = type;
   79|  10.1k|    if (type == V_ASN1_BOOLEAN)
   80|      0|        a->value.boolean = value ? 0xff : 0;
   81|  10.1k|    else
   82|  10.1k|        a->value.ptr = value;
   83|  10.1k|}

UTF8_getc:
   77|   277k|{
   78|   277k|    const unsigned char *p;
   79|   277k|    unsigned long value;
   80|   277k|    int ret;
   81|   277k|    if (len <= 0)
   82|      0|        return 0;
   83|   277k|    p = str;
   84|       |
   85|       |    /* Check syntax and work out the encoded value (if correct) */
   86|   277k|    if ((*p & 0x80) == 0) {
   87|   275k|        value = *p++ & 0x7f;
   88|   275k|        ret = 1;
   89|   275k|    } else if ((*p & 0xe0) == 0xc0) {
   90|  1.32k|        if (len < 2)
   91|      0|            return -1;
   92|  1.32k|        if ((p[1] & 0xc0) != 0x80)
   93|      0|            return -3;
   94|  1.32k|        value = (*p++ & 0x1f) << 6;
   95|  1.32k|        value |= *p++ & 0x3f;
   96|  1.32k|        if (value < 0x80)
   97|      0|            return -4;
   98|  1.32k|        ret = 2;
   99|  1.32k|    } else if ((*p & 0xf0) == 0xe0) {
  100|      0|        if (len < 3)
  101|      0|            return -1;
  102|      0|        if (((p[1] & 0xc0) != 0x80)
  103|      0|            || ((p[2] & 0xc0) != 0x80))
  104|      0|            return -3;
  105|      0|        value = (*p++ & 0xf) << 12;
  106|      0|        value |= (*p++ & 0x3f) << 6;
  107|      0|        value |= *p++ & 0x3f;
  108|      0|        if (value < 0x800)
  109|      0|            return -4;
  110|      0|        ret = 3;
  111|      0|    } else if ((*p & 0xf8) == 0xf0) {
  112|      0|        if (len < 4)
  113|      0|            return -1;
  114|      0|        if (((p[1] & 0xc0) != 0x80)
  115|      0|            || ((p[2] & 0xc0) != 0x80)
  116|      0|            || ((p[3] & 0xc0) != 0x80))
  117|      0|            return -3;
  118|      0|        value = ((unsigned long)(*p++ & 0x7)) << 18;
  119|      0|        value |= (*p++ & 0x3f) << 12;
  120|      0|        value |= (*p++ & 0x3f) << 6;
  121|      0|        value |= *p++ & 0x3f;
  122|      0|        if (value < 0x10000)
  123|      0|            return -4;
  124|      0|        ret = 4;
  125|      0|    } else if ((*p & 0xfc) == 0xf8) {
  126|      0|        if (len < 5)
  127|      0|            return -1;
  128|      0|        if (((p[1] & 0xc0) != 0x80)
  129|      0|            || ((p[2] & 0xc0) != 0x80)
  130|      0|            || ((p[3] & 0xc0) != 0x80)
  131|      0|            || ((p[4] & 0xc0) != 0x80))
  132|      0|            return -3;
  133|      0|        value = ((unsigned long)(*p++ & 0x3)) << 24;
  134|      0|        value |= ((unsigned long)(*p++ & 0x3f)) << 18;
  135|      0|        value |= ((unsigned long)(*p++ & 0x3f)) << 12;
  136|      0|        value |= (*p++ & 0x3f) << 6;
  137|      0|        value |= *p++ & 0x3f;
  138|      0|        if (value < 0x200000)
  139|      0|            return -4;
  140|      0|        ret = 5;
  141|      0|    } else if ((*p & 0xfe) == 0xfc) {
  142|      0|        if (len < 6)
  143|      0|            return -1;
  144|      0|        if (((p[1] & 0xc0) != 0x80)
  145|      0|            || ((p[2] & 0xc0) != 0x80)
  146|      0|            || ((p[3] & 0xc0) != 0x80)
  147|      0|            || ((p[4] & 0xc0) != 0x80)
  148|      0|            || ((p[5] & 0xc0) != 0x80))
  149|      0|            return -3;
  150|      0|        value = ((unsigned long)(*p++ & 0x1)) << 30;
  151|      0|        value |= ((unsigned long)(*p++ & 0x3f)) << 24;
  152|      0|        value |= ((unsigned long)(*p++ & 0x3f)) << 18;
  153|      0|        value |= ((unsigned long)(*p++ & 0x3f)) << 12;
  154|      0|        value |= (*p++ & 0x3f) << 6;
  155|      0|        value |= *p++ & 0x3f;
  156|      0|        if (value < 0x4000000)
  157|      0|            return -4;
  158|      0|        ret = 6;
  159|      0|    } else
  160|      0|        return -2;
  161|   277k|    *val = value;
  162|   277k|    return ret;
  163|   277k|}
UTF8_putc:
  174|   689k|{
  175|   689k|    if (!str)
  176|   344k|        len = 6;                /* Maximum we will need */
  177|   344k|    else if (len <= 0)
  178|      0|        return -1;
  179|   689k|    if (value < 0x80) {
  180|   689k|        if (str)
  181|   344k|            *str = (unsigned char)value;
  182|   689k|        return 1;
  183|   689k|    }
  184|      0|    if (value < 0x800) {
  185|      0|        if (len < 2)
  186|      0|            return -1;
  187|      0|        if (str) {
  188|      0|            *str++ = (unsigned char)(((value >> 6) & 0x1f) | 0xc0);
  189|      0|            *str = (unsigned char)((value & 0x3f) | 0x80);
  190|      0|        }
  191|      0|        return 2;
  192|      0|    }
  193|      0|    if (value < 0x10000) {
  194|      0|        if (len < 3)
  195|      0|            return -1;
  196|      0|        if (str) {
  197|      0|            *str++ = (unsigned char)(((value >> 12) & 0xf) | 0xe0);
  198|      0|            *str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);
  199|      0|            *str = (unsigned char)((value & 0x3f) | 0x80);
  200|      0|        }
  201|      0|        return 3;
  202|      0|    }
  203|      0|    if (value < 0x200000) {
  204|      0|        if (len < 4)
  205|      0|            return -1;
  206|      0|        if (str) {
  207|      0|            *str++ = (unsigned char)(((value >> 18) & 0x7) | 0xf0);
  208|      0|            *str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);
  209|      0|            *str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);
  210|      0|            *str = (unsigned char)((value & 0x3f) | 0x80);
  211|      0|        }
  212|      0|        return 4;
  213|      0|    }
  214|      0|    if (value < 0x4000000) {
  215|      0|        if (len < 5)
  216|      0|            return -1;
  217|      0|        if (str) {
  218|      0|            *str++ = (unsigned char)(((value >> 24) & 0x3) | 0xf8);
  219|      0|            *str++ = (unsigned char)(((value >> 18) & 0x3f) | 0x80);
  220|      0|            *str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);
  221|      0|            *str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);
  222|      0|            *str = (unsigned char)((value & 0x3f) | 0x80);
  223|      0|        }
  224|      0|        return 5;
  225|      0|    }
  226|      0|    if (len < 6)
  227|      0|        return -1;
  228|      0|    if (str) {
  229|      0|        *str++ = (unsigned char)(((value >> 30) & 0x1) | 0xfc);
  230|      0|        *str++ = (unsigned char)(((value >> 24) & 0x3f) | 0x80);
  231|      0|        *str++ = (unsigned char)(((value >> 18) & 0x3f) | 0x80);
  232|      0|        *str++ = (unsigned char)(((value >> 12) & 0x3f) | 0x80);
  233|      0|        *str++ = (unsigned char)(((value >> 6) & 0x3f) | 0x80);
  234|      0|        *str = (unsigned char)((value & 0x3f) | 0x80);
  235|      0|    }
  236|      0|    return 6;
  237|      0|}

EVP_PKEY_asn1_get_count:
  133|  1.57k|{
  134|  1.57k|    int num = sizeof(standard_methods) / sizeof(EVP_PKEY_ASN1_METHOD *);
  135|  1.57k|    if (app_methods)
  136|      0|        num += sk_EVP_PKEY_ASN1_METHOD_num(app_methods);
  137|  1.57k|    return num;
  138|  1.57k|}
EVP_PKEY_asn1_get0:
  141|  1.45k|{
  142|  1.45k|    int num = sizeof(standard_methods) / sizeof(EVP_PKEY_ASN1_METHOD *);
  143|  1.45k|    if (idx < 0)
  144|      0|        return NULL;
  145|  1.45k|    if (idx < num)
  146|  1.45k|        return standard_methods[idx];
  147|      0|    idx -= num;
  148|      0|    return sk_EVP_PKEY_ASN1_METHOD_value(app_methods, idx);
  149|  1.45k|}
EVP_PKEY_asn1_find_str:
  202|    121|{
  203|    121|    int i;
  204|    121|    const EVP_PKEY_ASN1_METHOD *ameth;
  205|    121|    if (len == -1)
  206|    121|        len = strlen(str);
  207|    121|    if (pe) {
  208|    121|#ifndef OPENSSL_NO_ENGINE
  209|    121|        ENGINE *e;
  210|    121|        ameth = ENGINE_pkey_asn1_find_str(&e, str, len);
  211|    121|        if (ameth) {
  212|       |            /*
  213|       |             * Convert structural into functional reference
  214|       |             */
  215|      0|            if (!ENGINE_init(e))
  216|      0|                ameth = NULL;
  217|      0|            ENGINE_free(e);
  218|      0|            *pe = e;
  219|      0|            return ameth;
  220|      0|        }
  221|    121|#endif
  222|    121|        *pe = NULL;
  223|    121|    }
  224|  1.57k|    for (i = 0; i < EVP_PKEY_asn1_get_count(); i++) {
  225|  1.45k|        ameth = EVP_PKEY_asn1_get0(i);
  226|  1.45k|        if (ameth->pkey_flags & ASN1_PKEY_ALIAS)
  227|    605|            continue;
  228|    847|        if (((int)strlen(ameth->pem_str) == len) &&
  229|    847|            !strncasecmp(ameth->pem_str, str, len))
  230|      0|            return ameth;
  231|    847|    }
  232|    121|    return NULL;
  233|    121|}
EVP_PKEY_asn1_new:
  289|      3|{
  290|      3|    EVP_PKEY_ASN1_METHOD *ameth;
  291|      3|    ameth = OPENSSL_malloc(sizeof(EVP_PKEY_ASN1_METHOD));
  292|      3|    if (!ameth)
  293|      0|        return NULL;
  294|       |
  295|      3|    memset(ameth, 0, sizeof(EVP_PKEY_ASN1_METHOD));
  296|       |
  297|      3|    ameth->pkey_id = id;
  298|      3|    ameth->pkey_base_id = id;
  299|      3|    ameth->pkey_flags = flags | ASN1_PKEY_DYNAMIC;
  300|       |
  301|      3|    if (info) {
  302|      3|        ameth->info = BUF_strdup(info);
  303|      3|        if (!ameth->info)
  304|      0|            goto err;
  305|      3|    } else
  306|      0|        ameth->info = NULL;
  307|       |
  308|      3|    if (pem_str) {
  309|      3|        ameth->pem_str = BUF_strdup(pem_str);
  310|      3|        if (!ameth->pem_str)
  311|      0|            goto err;
  312|      3|    } else
  313|      0|        ameth->pem_str = NULL;
  314|       |
  315|      3|    ameth->pub_decode = 0;
  316|      3|    ameth->pub_encode = 0;
  317|      3|    ameth->pub_cmp = 0;
  318|      3|    ameth->pub_print = 0;
  319|       |
  320|      3|    ameth->priv_decode = 0;
  321|      3|    ameth->priv_encode = 0;
  322|      3|    ameth->priv_print = 0;
  323|       |
  324|      3|    ameth->old_priv_encode = 0;
  325|      3|    ameth->old_priv_decode = 0;
  326|       |
  327|      3|    ameth->item_verify = 0;
  328|      3|    ameth->item_sign = 0;
  329|       |
  330|      3|    ameth->pkey_size = 0;
  331|      3|    ameth->pkey_bits = 0;
  332|       |
  333|      3|    ameth->param_decode = 0;
  334|      3|    ameth->param_encode = 0;
  335|      3|    ameth->param_missing = 0;
  336|      3|    ameth->param_copy = 0;
  337|      3|    ameth->param_cmp = 0;
  338|      3|    ameth->param_print = 0;
  339|       |
  340|      3|    ameth->pkey_free = 0;
  341|      3|    ameth->pkey_ctrl = 0;
  342|       |
  343|      3|    return ameth;
  344|       |
  345|      0| err:
  346|       |
  347|      0|    EVP_PKEY_asn1_free(ameth);
  348|      0|    return NULL;
  349|       |
  350|      3|}
EVP_PKEY_asn1_set_public:
  409|      2|{
  410|      2|    ameth->pub_decode = pub_decode;
  411|      2|    ameth->pub_encode = pub_encode;
  412|      2|    ameth->pub_cmp = pub_cmp;
  413|      2|    ameth->pub_print = pub_print;
  414|      2|    ameth->pkey_size = pkey_size;
  415|      2|    ameth->pkey_bits = pkey_bits;
  416|      2|}
EVP_PKEY_asn1_set_private:
  428|      2|{
  429|      2|    ameth->priv_decode = priv_decode;
  430|      2|    ameth->priv_encode = priv_encode;
  431|      2|    ameth->priv_print = priv_print;
  432|      2|}
EVP_PKEY_asn1_set_param:
  448|      2|{
  449|      2|    ameth->param_decode = param_decode;
  450|      2|    ameth->param_encode = param_encode;
  451|      2|    ameth->param_missing = param_missing;
  452|      2|    ameth->param_copy = param_copy;
  453|      2|    ameth->param_cmp = param_cmp;
  454|      2|    ameth->param_print = param_print;
  455|      2|}
EVP_PKEY_asn1_set_free:
  459|      3|{
  460|      3|    ameth->pkey_free = pkey_free;
  461|      3|}
EVP_PKEY_asn1_set_ctrl:
  466|      3|{
  467|      3|    ameth->pkey_ctrl = pkey_ctrl;
  468|      3|}

ERR_load_ASN1_strings:
  346|      1|{
  347|      1|#ifndef OPENSSL_NO_ERR
  348|       |
  349|      1|    if (ERR_func_error_string(ASN1_str_functs[0].error) == NULL) {
  350|      1|        ERR_load_strings(0, ASN1_str_functs);
  351|      1|        ERR_load_strings(0, ASN1_str_reasons);
  352|      1|    }
  353|      1|#endif
  354|      1|}

ASN1_get_object:
   96|   255k|{
   97|   255k|    int i, ret;
   98|   255k|    long l;
   99|   255k|    const unsigned char *p = *pp;
  100|   255k|    int tag, xclass, inf;
  101|   255k|    long max = omax;
  102|       |
  103|   255k|    if (!max)
  104|      0|        goto err;
  105|   255k|    ret = (*p & V_ASN1_CONSTRUCTED);
  106|   255k|    xclass = (*p & V_ASN1_PRIVATE);
  107|   255k|    i = *p & V_ASN1_PRIMITIVE_TAG;
  108|   255k|    if (i == V_ASN1_PRIMITIVE_TAG) { /* high-tag */
  109|      0|        p++;
  110|      0|        if (--max == 0)
  111|      0|            goto err;
  112|      0|        l = 0;
  113|      0|        while (*p & 0x80) {
  114|      0|            l <<= 7L;
  115|      0|            l |= *(p++) & 0x7f;
  116|      0|            if (--max == 0)
  117|      0|                goto err;
  118|      0|            if (l > (INT_MAX >> 7L))
  119|      0|                goto err;
  120|      0|        }
  121|      0|        l <<= 7L;
  122|      0|        l |= *(p++) & 0x7f;
  123|      0|        tag = (int)l;
  124|      0|        if (--max == 0)
  125|      0|            goto err;
  126|   255k|    } else {
  127|   255k|        tag = i;
  128|   255k|        p++;
  129|   255k|        if (--max == 0)
  130|      0|            goto err;
  131|   255k|    }
  132|   255k|    *ptag = tag;
  133|   255k|    *pclass = xclass;
  134|   255k|    if (!asn1_get_length(&p, &inf, plength, max))
  135|      0|        goto err;
  136|       |
  137|   255k|    if (inf && !(ret & V_ASN1_CONSTRUCTED))
  138|      0|        goto err;
  139|       |
  140|       |#if 0
  141|       |    fprintf(stderr, "p=%d + *plength=%ld > omax=%ld + *pp=%d  (%d > %d)\n",
  142|       |            (int)p, *plength, omax, (int)*pp, (int)(p + *plength),
  143|       |            (int)(omax + *pp));
  144|       |
  145|       |#endif
  146|   255k|    if (*plength > (omax - (p - *pp))) {
  147|      0|        ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_TOO_LONG);
  148|       |        /*
  149|       |         * Set this so that even if things are not long enough the values are
  150|       |         * set correctly
  151|       |         */
  152|      0|        ret |= 0x80;
  153|      0|    }
  154|   255k|    *pp = p;
  155|   255k|    return (ret | inf);
  156|      0| err:
  157|      0|    ASN1err(ASN1_F_ASN1_GET_OBJECT, ASN1_R_HEADER_TOO_LONG);
  158|      0|    return (0x80);
  159|   255k|}
ASN1_put_object:
  199|   115k|{
  200|   115k|    unsigned char *p = *pp;
  201|   115k|    int i, ttag;
  202|       |
  203|   115k|    i = (constructed) ? V_ASN1_CONSTRUCTED : 0;
  204|   115k|    i |= (xclass & V_ASN1_PRIVATE);
  205|   115k|    if (tag < 31)
  206|   115k|        *(p++) = i | (tag & V_ASN1_PRIMITIVE_TAG);
  207|      0|    else {
  208|      0|        *(p++) = i | V_ASN1_PRIMITIVE_TAG;
  209|      0|        for (i = 0, ttag = tag; ttag > 0; i++)
  210|      0|            ttag >>= 7;
  211|      0|        ttag = i;
  212|      0|        while (i-- > 0) {
  213|      0|            p[i] = tag & 0x7f;
  214|      0|            if (i != (ttag - 1))
  215|      0|                p[i] |= 0x80;
  216|      0|            tag >>= 7;
  217|      0|        }
  218|      0|        p += ttag;
  219|      0|    }
  220|   115k|    if (constructed == 2)
  221|      0|        *(p++) = 0x80;
  222|   115k|    else
  223|   115k|        asn1_put_length(&p, length);
  224|   115k|    *pp = p;
  225|   115k|}
ASN1_object_size:
  258|   376k|{
  259|   376k|    int ret = 1;
  260|   376k|    if (length < 0)
  261|      0|        return -1;
  262|   376k|    if (tag >= 31) {
  263|      0|        while (tag > 0) {
  264|      0|            tag >>= 7;
  265|      0|            ret++;
  266|      0|        }
  267|      0|    }
  268|   376k|    if (constructed == 2) {
  269|      0|        ret += 3;
  270|   376k|    } else {
  271|   376k|        ret++;
  272|   376k|        if (length > 127) {
  273|      0|            int tmplen = length;
  274|      0|            while (tmplen > 0) {
  275|      0|                tmplen >>= 8;
  276|      0|                ret++;
  277|      0|            }
  278|      0|        }
  279|   376k|    }
  280|   376k|    if (ret >= INT_MAX - length)
  281|      0|        return -1;
  282|   376k|    return ret + length;
  283|   376k|}
ASN1_STRING_set:
  363|  57.4k|{
  364|  57.4k|    unsigned char *c;
  365|  57.4k|    const char *data = _data;
  366|       |
  367|  57.4k|    if (len < 0) {
  368|      0|        if (data == NULL)
  369|      0|            return (0);
  370|      0|        else
  371|      0|            len = strlen(data);
  372|      0|    }
  373|  57.4k|    if ((str->length <= len) || (str->data == NULL)) {
  374|  57.4k|        c = str->data;
  375|  57.4k|        if (c == NULL)
  376|  57.4k|            str->data = OPENSSL_malloc(len + 1);
  377|      0|        else
  378|      0|            str->data = OPENSSL_realloc(c, len + 1);
  379|       |
  380|  57.4k|        if (str->data == NULL) {
  381|      0|            ASN1err(ASN1_F_ASN1_STRING_SET, ERR_R_MALLOC_FAILURE);
  382|      0|            str->data = c;
  383|      0|            return (0);
  384|      0|        }
  385|  57.4k|    }
  386|  57.4k|    str->length = len;
  387|  57.4k|    if (data != NULL) {
  388|  57.4k|        memcpy(str->data, data, len);
  389|       |        /* an allowance for strings :-) */
  390|  57.4k|        str->data[len] = '\0';
  391|  57.4k|    }
  392|  57.4k|    return (1);
  393|  57.4k|}
ASN1_STRING_type_new:
  409|  94.7k|{
  410|  94.7k|    ASN1_STRING *ret;
  411|       |
  412|  94.7k|    ret = (ASN1_STRING *)OPENSSL_malloc(sizeof(ASN1_STRING));
  413|  94.7k|    if (ret == NULL) {
  414|      0|        ASN1err(ASN1_F_ASN1_STRING_TYPE_NEW, ERR_R_MALLOC_FAILURE);
  415|      0|        return (NULL);
  416|      0|    }
  417|  94.7k|    ret->length = 0;
  418|  94.7k|    ret->type = type;
  419|  94.7k|    ret->data = NULL;
  420|  94.7k|    ret->flags = 0;
  421|  94.7k|    return (ret);
  422|  94.7k|}
ASN1_STRING_free:
  425|  94.7k|{
  426|  94.7k|    if (a == NULL)
  427|      0|        return;
  428|  94.7k|    if (a->data && !(a->flags & ASN1_STRING_FLAG_NDEF))
  429|  94.7k|        OPENSSL_free(a->data);
  430|  94.7k|    OPENSSL_free(a);
  431|  94.7k|}
asn1_lib.c:asn1_get_length:
  163|   255k|{
  164|   255k|    const unsigned char *p = *pp;
  165|   255k|    unsigned long ret = 0;
  166|   255k|    unsigned long i;
  167|       |
  168|   255k|    if (max-- < 1)
  169|      0|        return 0;
  170|   255k|    if (*p == 0x80) {
  171|      0|        *inf = 1;
  172|      0|        ret = 0;
  173|      0|        p++;
  174|   255k|    } else {
  175|   255k|        *inf = 0;
  176|   255k|        i = *p & 0x7f;
  177|   255k|        if (*(p++) & 0x80) {
  178|  21.7k|            if (i > sizeof(ret) || max < (long)i)
  179|      0|                return 0;
  180|  61.2k|            while (i-- > 0) {
  181|  39.5k|                ret <<= 8L;
  182|  39.5k|                ret |= *(p++);
  183|  39.5k|            }
  184|  21.7k|        } else
  185|   233k|            ret = i;
  186|   255k|    }
  187|   255k|    if (ret > LONG_MAX)
  188|      0|        return 0;
  189|   255k|    *pp = p;
  190|   255k|    *rl = (long)ret;
  191|   255k|    return 1;
  192|   255k|}
asn1_lib.c:asn1_put_length:
  237|   115k|{
  238|   115k|    unsigned char *p = *pp;
  239|   115k|    int i, l;
  240|   115k|    if (length <= 127)
  241|   115k|        *(p++) = (unsigned char)length;
  242|      0|    else {
  243|      0|        l = length;
  244|      0|        for (i = 0; l > 0; i++)
  245|      0|            l >>= 8;
  246|      0|        *(p++) = i | 0x80;
  247|      0|        l = i;
  248|      0|        while (i-- > 0) {
  249|      0|            p[i] = length & 0xff;
  250|      0|            length >>= 8;
  251|      0|        }
  252|      0|        p += l;
  253|      0|    }
  254|   115k|    *pp = p;
  255|   115k|}

ASN1_add_oid_module:
   99|      1|{
  100|      1|    CONF_module_add("oid_section", oid_module_init, oid_module_finish);
  101|      1|}

ASN1_tag2bit:
  118|  65.6k|{
  119|  65.6k|    if ((tag < 0) || (tag > 30))
  120|      0|        return 0;
  121|  65.6k|    return tag2bit[tag];
  122|  65.6k|}
ASN1_item_d2i:
  140|  3.84k|{
  141|  3.84k|    ASN1_TLC c;
  142|  3.84k|    ASN1_VALUE *ptmpval = NULL;
  143|  3.84k|    if (!pval)
  144|      0|        pval = &ptmpval;
  145|  3.84k|    asn1_tlc_clear_nc(&c);
  146|  3.84k|    if (ASN1_item_ex_d2i(pval, in, len, it, -1, 0, 0, &c) > 0)
  147|  3.84k|        return *pval;
  148|      0|    return NULL;
  149|  3.84k|}
ASN1_item_ex_d2i:
  168|   265k|{
  169|   265k|    const ASN1_TEMPLATE *tt, *errtt = NULL;
  170|   265k|    const ASN1_COMPAT_FUNCS *cf;
  171|   265k|    const ASN1_EXTERN_FUNCS *ef;
  172|   265k|    const ASN1_AUX *aux = it->funcs;
  173|   265k|    ASN1_aux_cb *asn1_cb;
  174|   265k|    const unsigned char *p = NULL, *q;
  175|   265k|    unsigned char *wp = NULL;   /* BIG FAT WARNING! BREAKS CONST WHERE USED */
  176|   265k|    unsigned char imphack = 0, oclass;
  177|   265k|    char seq_eoc, seq_nolen, cst, isopt;
  178|   265k|    long tmplen;
  179|   265k|    int i;
  180|   265k|    int otag;
  181|   265k|    int ret = 0;
  182|   265k|    ASN1_VALUE **pchptr, *ptmpval;
  183|   265k|    int combine = aclass & ASN1_TFLG_COMBINE;
  184|   265k|    aclass &= ~ASN1_TFLG_COMBINE;
  185|   265k|    if (!pval)
  186|      0|        return 0;
  187|   265k|    if (aux && aux->asn1_cb)
  188|  7.68k|        asn1_cb = aux->asn1_cb;
  189|   257k|    else
  190|   257k|        asn1_cb = 0;
  191|       |
  192|   265k|    switch (it->itype) {
  193|   151k|    case ASN1_ITYPE_PRIMITIVE:
  194|   151k|        if (it->templates) {
  195|       |            /*
  196|       |             * tagging or OPTIONAL is currently illegal on an item template
  197|       |             * because the flags can't get passed down. In practice this
  198|       |             * isn't a problem: we include the relevant flags from the item
  199|       |             * template in the template itself.
  200|       |             */
  201|  36.6k|            if ((tag != -1) || opt) {
  202|      0|                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I,
  203|      0|                        ASN1_R_ILLEGAL_OPTIONS_ON_ITEM_TEMPLATE);
  204|      0|                goto err;
  205|      0|            }
  206|  36.6k|            return asn1_template_ex_d2i(pval, in, len,
  207|  36.6k|                                        it->templates, opt, ctx);
  208|  36.6k|        }
  209|   114k|        return asn1_d2i_ex_primitive(pval, in, len, it,
  210|   114k|                                     tag, aclass, opt, ctx);
  211|      0|        break;
  212|       |
  213|  36.6k|    case ASN1_ITYPE_MSTRING:
  214|  36.6k|        p = *in;
  215|       |        /* Just read in tag and class */
  216|  36.6k|        ret = asn1_check_tlen(NULL, &otag, &oclass, NULL, NULL,
  217|  36.6k|                              &p, len, -1, 0, 1, ctx);
  218|  36.6k|        if (!ret) {
  219|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  220|      0|            goto err;
  221|      0|        }
  222|       |
  223|       |        /* Must be UNIVERSAL class */
  224|  36.6k|        if (oclass != V_ASN1_UNIVERSAL) {
  225|       |            /* If OPTIONAL, assume this is OK */
  226|      0|            if (opt)
  227|      0|                return -1;
  228|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_NOT_UNIVERSAL);
  229|      0|            goto err;
  230|      0|        }
  231|       |        /* Check tag matches bit map */
  232|  36.6k|        if (!(ASN1_tag2bit(otag) & it->utype)) {
  233|       |            /* If OPTIONAL, assume this is OK */
  234|      0|            if (opt)
  235|      0|                return -1;
  236|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MSTRING_WRONG_TAG);
  237|      0|            goto err;
  238|      0|        }
  239|  36.6k|        return asn1_d2i_ex_primitive(pval, in, len, it, otag, 0, 0, ctx);
  240|       |
  241|  7.68k|    case ASN1_ITYPE_EXTERN:
  242|       |        /* Use new style d2i */
  243|  7.68k|        ef = it->funcs;
  244|  7.68k|        return ef->asn1_ex_d2i(pval, in, len, it, tag, aclass, opt, ctx);
  245|       |
  246|      0|    case ASN1_ITYPE_COMPAT:
  247|       |        /* we must resort to old style evil hackery */
  248|      0|        cf = it->funcs;
  249|       |
  250|       |        /* If OPTIONAL see if it is there */
  251|      0|        if (opt) {
  252|      0|            int exptag;
  253|      0|            p = *in;
  254|      0|            if (tag == -1)
  255|      0|                exptag = it->utype;
  256|      0|            else
  257|      0|                exptag = tag;
  258|       |            /*
  259|       |             * Don't care about anything other than presence of expected tag
  260|       |             */
  261|       |
  262|      0|            ret = asn1_check_tlen(NULL, NULL, NULL, NULL, NULL,
  263|      0|                                  &p, len, exptag, aclass, 1, ctx);
  264|      0|            if (!ret) {
  265|      0|                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  266|      0|                goto err;
  267|      0|            }
  268|      0|            if (ret == -1)
  269|      0|                return -1;
  270|      0|        }
  271|       |
  272|       |        /*
  273|       |         * This is the old style evil hack IMPLICIT handling: since the
  274|       |         * underlying code is expecting a tag and class other than the one
  275|       |         * present we change the buffer temporarily then change it back
  276|       |         * afterwards. This doesn't and never did work for tags > 30. Yes
  277|       |         * this is *horrible* but it is only needed for old style d2i which
  278|       |         * will hopefully not be around for much longer. FIXME: should copy
  279|       |         * the buffer then modify it so the input buffer can be const: we
  280|       |         * should *always* copy because the old style d2i might modify the
  281|       |         * buffer.
  282|       |         */
  283|       |
  284|      0|        if (tag != -1) {
  285|      0|            wp = *(unsigned char **)in;
  286|      0|            imphack = *wp;
  287|      0|            if (p == NULL) {
  288|      0|                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  289|      0|                goto err;
  290|      0|            }
  291|      0|            *wp = (unsigned char)((*p & V_ASN1_CONSTRUCTED)
  292|      0|                                  | it->utype);
  293|      0|        }
  294|       |
  295|      0|        ptmpval = cf->asn1_d2i(pval, in, len);
  296|       |
  297|      0|        if (tag != -1)
  298|      0|            *wp = imphack;
  299|       |
  300|      0|        if (ptmpval)
  301|      0|            return 1;
  302|       |
  303|      0|        ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  304|      0|        goto err;
  305|       |
  306|      0|    case ASN1_ITYPE_CHOICE:
  307|      0|        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
  308|      0|            goto auxerr;
  309|      0|        if (*pval) {
  310|       |            /* Free up and zero CHOICE value if initialised */
  311|      0|            i = asn1_get_choice_selector(pval, it);
  312|      0|            if ((i >= 0) && (i < it->tcount)) {
  313|      0|                tt = it->templates + i;
  314|      0|                pchptr = asn1_get_field_ptr(pval, tt);
  315|      0|                ASN1_template_free(pchptr, tt);
  316|      0|                asn1_set_choice_selector(pval, -1, it);
  317|      0|            }
  318|      0|        } else if (!ASN1_item_ex_new(pval, it)) {
  319|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  320|      0|            goto err;
  321|      0|        }
  322|       |        /* CHOICE type, try each possibility in turn */
  323|      0|        p = *in;
  324|      0|        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
  325|      0|            pchptr = asn1_get_field_ptr(pval, tt);
  326|       |            /*
  327|       |             * We mark field as OPTIONAL so its absence can be recognised.
  328|       |             */
  329|      0|            ret = asn1_template_ex_d2i(pchptr, &p, len, tt, 1, ctx);
  330|       |            /* If field not present, try the next one */
  331|      0|            if (ret == -1)
  332|      0|                continue;
  333|       |            /* If positive return, read OK, break loop */
  334|      0|            if (ret > 0)
  335|      0|                break;
  336|       |            /* Otherwise must be an ASN1 parsing error */
  337|      0|            errtt = tt;
  338|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  339|      0|            goto err;
  340|      0|        }
  341|       |
  342|       |        /* Did we fall off the end without reading anything? */
  343|      0|        if (i == it->tcount) {
  344|       |            /* If OPTIONAL, this is OK */
  345|      0|            if (opt) {
  346|       |                /* Free and zero it */
  347|      0|                ASN1_item_ex_free(pval, it);
  348|      0|                return -1;
  349|      0|            }
  350|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_NO_MATCHING_CHOICE_TYPE);
  351|      0|            goto err;
  352|      0|        }
  353|       |
  354|      0|        asn1_set_choice_selector(pval, i, it);
  355|      0|        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
  356|      0|            goto auxerr;
  357|      0|        *in = p;
  358|      0|        return 1;
  359|       |
  360|      0|    case ASN1_ITYPE_NDEF_SEQUENCE:
  361|  69.6k|    case ASN1_ITYPE_SEQUENCE:
  362|  69.6k|        p = *in;
  363|  69.6k|        tmplen = len;
  364|       |
  365|       |        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
  366|  69.6k|        if (tag == -1) {
  367|  69.6k|            tag = V_ASN1_SEQUENCE;
  368|  69.6k|            aclass = V_ASN1_UNIVERSAL;
  369|  69.6k|        }
  370|       |        /* Get SEQUENCE length and update len, p */
  371|  69.6k|        ret = asn1_check_tlen(&len, NULL, NULL, &seq_eoc, &cst,
  372|  69.6k|                              &p, len, tag, aclass, opt, ctx);
  373|  69.6k|        if (!ret) {
  374|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  375|      0|            goto err;
  376|  69.6k|        } else if (ret == -1)
  377|      0|            return -1;
  378|  69.6k|        if (aux && (aux->flags & ASN1_AFLG_BROKEN)) {
  379|      0|            len = tmplen - (p - *in);
  380|      0|            seq_nolen = 1;
  381|      0|        }
  382|       |        /* If indefinite we don't do a length check */
  383|  69.6k|        else
  384|  69.6k|            seq_nolen = seq_eoc;
  385|  69.6k|        if (!cst) {
  386|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_NOT_CONSTRUCTED);
  387|      0|            goto err;
  388|      0|        }
  389|       |
  390|  69.6k|        if (!*pval && !ASN1_item_ex_new(pval, it)) {
  391|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  392|      0|            goto err;
  393|      0|        }
  394|       |
  395|  69.6k|        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_PRE, pval, it, NULL))
  396|      0|            goto auxerr;
  397|       |
  398|       |        /* Free up and zero any ADB found */
  399|   257k|        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
  400|   187k|            if (tt->flags & ASN1_TFLG_ADB_MASK) {
  401|      0|                const ASN1_TEMPLATE *seqtt;
  402|      0|                ASN1_VALUE **pseqval;
  403|      0|                seqtt = asn1_do_adb(pval, tt, 0);
  404|      0|                if (seqtt == NULL)
  405|      0|                    continue;
  406|      0|                pseqval = asn1_get_field_ptr(pval, seqtt);
  407|      0|                ASN1_template_free(pseqval, seqtt);
  408|      0|            }
  409|   187k|        }
  410|       |
  411|       |        /* Get each field entry */
  412|   255k|        for (i = 0, tt = it->templates; i < it->tcount; i++, tt++) {
  413|   187k|            const ASN1_TEMPLATE *seqtt;
  414|   187k|            ASN1_VALUE **pseqval;
  415|   187k|            seqtt = asn1_do_adb(pval, tt, 1);
  416|   187k|            if (seqtt == NULL)
  417|      0|                goto err;
  418|   187k|            pseqval = asn1_get_field_ptr(pval, seqtt);
  419|       |            /* Have we ran out of data? */
  420|   187k|            if (!len)
  421|  1.38k|                break;
  422|   186k|            q = p;
  423|   186k|            if (asn1_check_eoc(&p, len)) {
  424|      0|                if (!seq_eoc) {
  425|      0|                    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_UNEXPECTED_EOC);
  426|      0|                    goto err;
  427|      0|                }
  428|      0|                len -= p - q;
  429|      0|                seq_eoc = 0;
  430|      0|                q = p;
  431|      0|                break;
  432|      0|            }
  433|       |            /*
  434|       |             * This determines the OPTIONAL flag value. The field cannot be
  435|       |             * omitted if it is the last of a SEQUENCE and there is still
  436|       |             * data to be read. This isn't strictly necessary but it
  437|       |             * increases efficiency in some cases.
  438|       |             */
  439|   186k|            if (i == (it->tcount - 1))
  440|  68.2k|                isopt = 0;
  441|   117k|            else
  442|   117k|                isopt = (char)(seqtt->flags & ASN1_TFLG_OPTIONAL);
  443|       |            /*
  444|       |             * attempt to read in field, allowing each to be OPTIONAL
  445|       |             */
  446|       |
  447|   186k|            ret = asn1_template_ex_d2i(pseqval, &p, len, seqtt, isopt, ctx);
  448|   186k|            if (!ret) {
  449|      0|                errtt = seqtt;
  450|      0|                goto err;
  451|   186k|            } else if (ret == -1) {
  452|       |                /*
  453|       |                 * OPTIONAL component absent. Free and zero the field.
  454|       |                 */
  455|  14.2k|                ASN1_template_free(pseqval, seqtt);
  456|  14.2k|                continue;
  457|  14.2k|            }
  458|       |            /* Update length */
  459|   171k|            len -= p - q;
  460|   171k|        }
  461|       |
  462|       |        /* Check for EOC if expecting one */
  463|  69.6k|        if (seq_eoc && !asn1_check_eoc(&p, len)) {
  464|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_MISSING_EOC);
  465|      0|            goto err;
  466|      0|        }
  467|       |        /* Check all data read */
  468|  69.6k|        if (!seq_nolen && len) {
  469|      0|            ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_SEQUENCE_LENGTH_MISMATCH);
  470|      0|            goto err;
  471|      0|        }
  472|       |
  473|       |        /*
  474|       |         * If we get here we've got no more data in the SEQUENCE, however we
  475|       |         * may not have read all fields so check all remaining are OPTIONAL
  476|       |         * and clear any that are.
  477|       |         */
  478|  70.9k|        for (; i < it->tcount; tt++, i++) {
  479|  1.38k|            const ASN1_TEMPLATE *seqtt;
  480|  1.38k|            seqtt = asn1_do_adb(pval, tt, 1);
  481|  1.38k|            if (seqtt == NULL)
  482|      0|                goto err;
  483|  1.38k|            if (seqtt->flags & ASN1_TFLG_OPTIONAL) {
  484|  1.38k|                ASN1_VALUE **pseqval;
  485|  1.38k|                pseqval = asn1_get_field_ptr(pval, seqtt);
  486|  1.38k|                ASN1_template_free(pseqval, seqtt);
  487|  1.38k|            } else {
  488|      0|                errtt = seqtt;
  489|      0|                ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_FIELD_MISSING);
  490|      0|                goto err;
  491|      0|            }
  492|  1.38k|        }
  493|       |        /* Save encoding */
  494|  69.6k|        if (!asn1_enc_save(pval, *in, p - *in, it))
  495|      0|            goto auxerr;
  496|  69.6k|        if (asn1_cb && !asn1_cb(ASN1_OP_D2I_POST, pval, it, NULL))
  497|      0|            goto auxerr;
  498|  69.6k|        *in = p;
  499|  69.6k|        return 1;
  500|       |
  501|      0|    default:
  502|      0|        return 0;
  503|   265k|    }
  504|      0| auxerr:
  505|      0|    ASN1err(ASN1_F_ASN1_ITEM_EX_D2I, ASN1_R_AUX_ERROR);
  506|      0| err:
  507|      0|    if (combine == 0)
  508|      0|        ASN1_item_ex_free(pval, it);
  509|      0|    if (errtt)
  510|      0|        ERR_add_error_data(4, "Field=", errtt->field_name,
  511|      0|                           ", Type=", it->sname);
  512|      0|    else
  513|      0|        ERR_add_error_data(2, "Type=", it->sname);
  514|      0|    return 0;
  515|      0|}
asn1_ex_c2i:
  850|   137k|{
  851|   137k|    ASN1_VALUE **opval = NULL;
  852|   137k|    ASN1_STRING *stmp;
  853|   137k|    ASN1_TYPE *typ = NULL;
  854|   137k|    int ret = 0;
  855|   137k|    const ASN1_PRIMITIVE_FUNCS *pf;
  856|   137k|    ASN1_INTEGER **tint;
  857|   137k|    pf = it->funcs;
  858|       |
  859|   137k|    if (pf && pf->prim_c2i)
  860|      0|        return pf->prim_c2i(pval, cont, len, utype, free_cont, it);
  861|       |    /* If ANY type clear type and set pointer to internal value */
  862|   137k|    if (it->utype == V_ASN1_ANY) {
  863|  10.1k|        if (!*pval) {
  864|  10.1k|            typ = ASN1_TYPE_new();
  865|  10.1k|            if (typ == NULL)
  866|      0|                goto err;
  867|  10.1k|            *pval = (ASN1_VALUE *)typ;
  868|  10.1k|        } else
  869|      0|            typ = (ASN1_TYPE *)*pval;
  870|       |
  871|  10.1k|        if (utype != typ->type)
  872|  10.1k|            ASN1_TYPE_set(typ, utype, NULL);
  873|  10.1k|        opval = pval;
  874|  10.1k|        pval = &typ->value.asn1_value;
  875|  10.1k|    }
  876|   137k|    switch (utype) {
  877|  54.9k|    case V_ASN1_OBJECT:
  878|  54.9k|        if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len))
  879|      0|            goto err;
  880|  54.9k|        break;
  881|       |
  882|  54.9k|    case V_ASN1_NULL:
  883|  9.45k|        if (len) {
  884|      0|            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_NULL_IS_WRONG_LENGTH);
  885|      0|            goto err;
  886|      0|        }
  887|  9.45k|        *pval = (ASN1_VALUE *)1;
  888|  9.45k|        break;
  889|       |
  890|  7.17k|    case V_ASN1_BOOLEAN:
  891|  7.17k|        if (len != 1) {
  892|      0|            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BOOLEAN_IS_WRONG_LENGTH);
  893|      0|            goto err;
  894|  7.17k|        } else {
  895|  7.17k|            ASN1_BOOLEAN *tbool;
  896|  7.17k|            tbool = (ASN1_BOOLEAN *)pval;
  897|  7.17k|            *tbool = *cont;
  898|  7.17k|        }
  899|  7.17k|        break;
  900|       |
  901|  7.68k|    case V_ASN1_BIT_STRING:
  902|  7.68k|        if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len))
  903|      0|            goto err;
  904|  7.68k|        break;
  905|       |
  906|  7.68k|    case V_ASN1_INTEGER:
  907|  7.68k|    case V_ASN1_ENUMERATED:
  908|  7.68k|        tint = (ASN1_INTEGER **)pval;
  909|  7.68k|        if (!c2i_ASN1_INTEGER(tint, &cont, len))
  910|      0|            goto err;
  911|       |        /* Fixup type to match the expected form */
  912|  7.68k|        (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG);
  913|  7.68k|        break;
  914|       |
  915|  13.7k|    case V_ASN1_OCTET_STRING:
  916|  13.7k|    case V_ASN1_NUMERICSTRING:
  917|  35.5k|    case V_ASN1_PRINTABLESTRING:
  918|  35.6k|    case V_ASN1_T61STRING:
  919|  35.6k|    case V_ASN1_VIDEOTEXSTRING:
  920|  35.7k|    case V_ASN1_IA5STRING:
  921|  43.3k|    case V_ASN1_UTCTIME:
  922|  43.3k|    case V_ASN1_GENERALIZEDTIME:
  923|  43.3k|    case V_ASN1_GRAPHICSTRING:
  924|  43.3k|    case V_ASN1_VISIBLESTRING:
  925|  43.3k|    case V_ASN1_GENERALSTRING:
  926|  43.3k|    case V_ASN1_UNIVERSALSTRING:
  927|  43.3k|    case V_ASN1_BMPSTRING:
  928|  50.4k|    case V_ASN1_UTF8STRING:
  929|  50.4k|    case V_ASN1_OTHER:
  930|  50.4k|    case V_ASN1_SET:
  931|  50.4k|    case V_ASN1_SEQUENCE:
  932|  50.4k|    default:
  933|  50.4k|        if (utype == V_ASN1_BMPSTRING && (len & 1)) {
  934|      0|            ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BMPSTRING_IS_WRONG_LENGTH);
  935|      0|            goto err;
  936|      0|        }
  937|  50.4k|        if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) {
  938|      0|            ASN1err(ASN1_F_ASN1_EX_C2I,
  939|      0|                    ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH);
  940|      0|            goto err;
  941|      0|        }
  942|       |        /* All based on ASN1_STRING and handled the same */
  943|  50.4k|        if (!*pval) {
  944|      0|            stmp = ASN1_STRING_type_new(utype);
  945|      0|            if (!stmp) {
  946|      0|                ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);
  947|      0|                goto err;
  948|      0|            }
  949|      0|            *pval = (ASN1_VALUE *)stmp;
  950|  50.4k|        } else {
  951|  50.4k|            stmp = (ASN1_STRING *)*pval;
  952|  50.4k|            stmp->type = utype;
  953|  50.4k|        }
  954|       |        /* If we've already allocated a buffer use it */
  955|  50.4k|        if (*free_cont) {
  956|      0|            if (stmp->data)
  957|      0|                OPENSSL_free(stmp->data);
  958|      0|            stmp->data = (unsigned char *)cont; /* UGLY CAST! RL */
  959|      0|            stmp->length = len;
  960|      0|            *free_cont = 0;
  961|  50.4k|        } else {
  962|  50.4k|            if (!ASN1_STRING_set(stmp, cont, len)) {
  963|      0|                ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE);
  964|      0|                ASN1_STRING_free(stmp);
  965|      0|                *pval = NULL;
  966|      0|                goto err;
  967|      0|            }
  968|  50.4k|        }
  969|  50.4k|        break;
  970|   137k|    }
  971|       |    /* If ASN1_ANY and NULL type fix up value */
  972|   137k|    if (typ && (utype == V_ASN1_NULL))
  973|  9.45k|        typ->value.ptr = NULL;
  974|       |
  975|   137k|    ret = 1;
  976|   137k| err:
  977|   137k|    if (!ret) {
  978|      0|        ASN1_TYPE_free(typ);
  979|      0|        if (opval)
  980|      0|            *opval = NULL;
  981|      0|    }
  982|   137k|    return ret;
  983|   137k|}
tasn_dec.c:asn1_template_ex_d2i:
  526|   222k|{
  527|   222k|    int flags, aclass;
  528|   222k|    int ret;
  529|   222k|    long len;
  530|   222k|    const unsigned char *p, *q;
  531|   222k|    char exp_eoc;
  532|   222k|    if (!val)
  533|      0|        return 0;
  534|   222k|    flags = tt->flags;
  535|   222k|    aclass = flags & ASN1_TFLG_TAG_CLASS;
  536|       |
  537|   222k|    p = *in;
  538|       |
  539|       |    /* Check if EXPLICIT tag expected */
  540|   222k|    if (flags & ASN1_TFLG_EXPTAG) {
  541|  7.68k|        char cst;
  542|       |        /*
  543|       |         * Need to work out amount of data available to the inner content and
  544|       |         * where it starts: so read in EXPLICIT header to get the info.
  545|       |         */
  546|  7.68k|        ret = asn1_check_tlen(&len, NULL, NULL, &exp_eoc, &cst,
  547|  7.68k|                              &p, inlen, tt->tag, aclass, opt, ctx);
  548|  7.68k|        q = p;
  549|  7.68k|        if (!ret) {
  550|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  551|      0|            return 0;
  552|  7.68k|        } else if (ret == -1)
  553|      0|            return -1;
  554|  7.68k|        if (!cst) {
  555|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
  556|      0|                    ASN1_R_EXPLICIT_TAG_NOT_CONSTRUCTED);
  557|      0|            return 0;
  558|      0|        }
  559|       |        /* We've found the field so it can't be OPTIONAL now */
  560|  7.68k|        ret = asn1_template_noexp_d2i(val, &p, len, tt, 0, ctx);
  561|  7.68k|        if (!ret) {
  562|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  563|      0|            return 0;
  564|      0|        }
  565|       |        /* We read the field in OK so update length */
  566|  7.68k|        len -= p - q;
  567|  7.68k|        if (exp_eoc) {
  568|       |            /* If NDEF we must have an EOC here */
  569|      0|            if (!asn1_check_eoc(&p, len)) {
  570|      0|                ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I, ASN1_R_MISSING_EOC);
  571|      0|                goto err;
  572|      0|            }
  573|  7.68k|        } else {
  574|       |            /*
  575|       |             * Otherwise we must hit the EXPLICIT tag end or its an error
  576|       |             */
  577|  7.68k|            if (len) {
  578|      0|                ASN1err(ASN1_F_ASN1_TEMPLATE_EX_D2I,
  579|      0|                        ASN1_R_EXPLICIT_LENGTH_MISMATCH);
  580|      0|                goto err;
  581|      0|            }
  582|  7.68k|        }
  583|  7.68k|    } else
  584|   215k|        return asn1_template_noexp_d2i(val, in, inlen, tt, opt, ctx);
  585|       |
  586|  7.68k|    *in = p;
  587|  7.68k|    return 1;
  588|       |
  589|      0| err:
  590|      0|    ASN1_template_free(val, tt);
  591|      0|    return 0;
  592|   222k|}
tasn_dec.c:asn1_template_noexp_d2i:
  598|   222k|{
  599|   222k|    int flags, aclass;
  600|   222k|    int ret;
  601|   222k|    const unsigned char *p, *q;
  602|   222k|    if (!val)
  603|      0|        return 0;
  604|   222k|    flags = tt->flags;
  605|   222k|    aclass = flags & ASN1_TFLG_TAG_CLASS;
  606|       |
  607|   222k|    p = *in;
  608|   222k|    q = p;
  609|       |
  610|   222k|    if (flags & ASN1_TFLG_SK_MASK) {
  611|       |        /* SET OF, SEQUENCE OF */
  612|  40.5k|        int sktag, skaclass;
  613|  40.5k|        char sk_eoc;
  614|       |        /* First work out expected inner tag value */
  615|  40.5k|        if (flags & ASN1_TFLG_IMPTAG) {
  616|      0|            sktag = tt->tag;
  617|      0|            skaclass = aclass;
  618|  40.5k|        } else {
  619|  40.5k|            skaclass = V_ASN1_UNIVERSAL;
  620|  40.5k|            if (flags & ASN1_TFLG_SET_OF)
  621|  28.9k|                sktag = V_ASN1_SET;
  622|  11.5k|            else
  623|  11.5k|                sktag = V_ASN1_SEQUENCE;
  624|  40.5k|        }
  625|       |        /* Get the tag */
  626|  40.5k|        ret = asn1_check_tlen(&len, NULL, NULL, &sk_eoc, NULL,
  627|  40.5k|                              &p, len, sktag, skaclass, opt, ctx);
  628|  40.5k|        if (!ret) {
  629|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
  630|      0|            return 0;
  631|  40.5k|        } else if (ret == -1)
  632|      0|            return -1;
  633|  40.5k|        if (!*val)
  634|  40.5k|            *val = (ASN1_VALUE *)sk_new_null();
  635|      0|        else {
  636|       |            /*
  637|       |             * We've got a valid STACK: free up any items present
  638|       |             */
  639|      0|            STACK_OF(ASN1_VALUE) *sktmp = (STACK_OF(ASN1_VALUE) *)*val;
  640|      0|            ASN1_VALUE *vtmp;
  641|      0|            while (sk_ASN1_VALUE_num(sktmp) > 0) {
  642|      0|                vtmp = sk_ASN1_VALUE_pop(sktmp);
  643|      0|                ASN1_item_ex_free(&vtmp, ASN1_ITEM_ptr(tt->item));
  644|      0|            }
  645|      0|        }
  646|       |
  647|  40.5k|        if (!*val) {
  648|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE);
  649|      0|            goto err;
  650|      0|        }
  651|       |
  652|       |        /* Read as many items as we can */
  653|   112k|        while (len > 0) {
  654|  71.7k|            ASN1_VALUE *skfield;
  655|  71.7k|            q = p;
  656|       |            /* See if EOC found */
  657|  71.7k|            if (asn1_check_eoc(&p, len)) {
  658|      0|                if (!sk_eoc) {
  659|      0|                    ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
  660|      0|                            ASN1_R_UNEXPECTED_EOC);
  661|      0|                    goto err;
  662|      0|                }
  663|      0|                len -= p - q;
  664|      0|                sk_eoc = 0;
  665|      0|                break;
  666|      0|            }
  667|  71.7k|            skfield = NULL;
  668|  71.7k|            if (!ASN1_item_ex_d2i(&skfield, &p, len,
  669|  71.7k|                                  ASN1_ITEM_ptr(tt->item), -1, 0, 0, ctx)) {
  670|      0|                ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I,
  671|      0|                        ERR_R_NESTED_ASN1_ERROR);
  672|      0|                goto err;
  673|      0|            }
  674|  71.7k|            len -= p - q;
  675|  71.7k|            if (!sk_ASN1_VALUE_push((STACK_OF(ASN1_VALUE) *)*val, skfield)) {
  676|      0|                ASN1_item_ex_free(&skfield, ASN1_ITEM_ptr(tt->item));
  677|      0|                ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_MALLOC_FAILURE);
  678|      0|                goto err;
  679|      0|            }
  680|  71.7k|        }
  681|  40.5k|        if (sk_eoc) {
  682|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ASN1_R_MISSING_EOC);
  683|      0|            goto err;
  684|      0|        }
  685|   182k|    } else if (flags & ASN1_TFLG_IMPTAG) {
  686|       |        /* IMPLICIT tagging */
  687|  7.68k|        ret = ASN1_item_ex_d2i(val, &p, len,
  688|  7.68k|                               ASN1_ITEM_ptr(tt->item), tt->tag, aclass, opt,
  689|  7.68k|                               ctx);
  690|  7.68k|        if (!ret) {
  691|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
  692|      0|            goto err;
  693|  7.68k|        } else if (ret == -1)
  694|  7.68k|            return -1;
  695|   174k|    } else {
  696|       |        /* Nothing special */
  697|   174k|        ret = ASN1_item_ex_d2i(val, &p, len, ASN1_ITEM_ptr(tt->item),
  698|   174k|                               -1, tt->flags & ASN1_TFLG_COMBINE, opt, ctx);
  699|   174k|        if (!ret) {
  700|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_NOEXP_D2I, ERR_R_NESTED_ASN1_ERROR);
  701|      0|            goto err;
  702|   174k|        } else if (ret == -1)
  703|  6.57k|            return -1;
  704|   174k|    }
  705|       |
  706|   208k|    *in = p;
  707|   208k|    return 1;
  708|       |
  709|      0| err:
  710|      0|    ASN1_template_free(val, tt);
  711|      0|    return 0;
  712|   222k|}
tasn_dec.c:asn1_d2i_ex_primitive:
  718|   151k|{
  719|   151k|    int ret = 0, utype;
  720|   151k|    long plen;
  721|   151k|    char cst, inf, free_cont = 0;
  722|   151k|    const unsigned char *p;
  723|   151k|    BUF_MEM buf = { 0, NULL, 0 };
  724|   151k|    const unsigned char *cont = NULL;
  725|   151k|    long len;
  726|   151k|    if (!pval) {
  727|      0|        ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_NULL);
  728|      0|        return 0;               /* Should never happen */
  729|      0|    }
  730|       |
  731|   151k|    if (it->itype == ASN1_ITYPE_MSTRING) {
  732|  36.6k|        utype = tag;
  733|  36.6k|        tag = -1;
  734|  36.6k|    } else
  735|   114k|        utype = it->utype;
  736|       |
  737|   151k|    if (utype == V_ASN1_ANY) {
  738|       |        /* If type is ANY need to figure out type from tag */
  739|  10.1k|        unsigned char oclass;
  740|  10.1k|        if (tag >= 0) {
  741|      0|            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_ILLEGAL_TAGGED_ANY);
  742|      0|            return 0;
  743|      0|        }
  744|  10.1k|        if (opt) {
  745|      0|            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
  746|      0|                    ASN1_R_ILLEGAL_OPTIONAL_ANY);
  747|      0|            return 0;
  748|      0|        }
  749|  10.1k|        p = *in;
  750|  10.1k|        ret = asn1_check_tlen(NULL, &utype, &oclass, NULL, NULL,
  751|  10.1k|                              &p, inlen, -1, 0, 0, ctx);
  752|  10.1k|        if (!ret) {
  753|      0|            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);
  754|      0|            return 0;
  755|      0|        }
  756|  10.1k|        if (oclass != V_ASN1_UNIVERSAL)
  757|      0|            utype = V_ASN1_OTHER;
  758|  10.1k|    }
  759|   151k|    if (tag == -1) {
  760|   143k|        tag = utype;
  761|   143k|        aclass = V_ASN1_UNIVERSAL;
  762|   143k|    }
  763|   151k|    p = *in;
  764|       |    /* Check header */
  765|   151k|    ret = asn1_check_tlen(&plen, NULL, NULL, &inf, &cst,
  766|   151k|                          &p, inlen, tag, aclass, opt, ctx);
  767|   151k|    if (!ret) {
  768|      0|        ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_NESTED_ASN1_ERROR);
  769|      0|        return 0;
  770|   151k|    } else if (ret == -1)
  771|  14.2k|        return -1;
  772|   137k|    ret = 0;
  773|       |    /* SEQUENCE, SET and "OTHER" are left in encoded form */
  774|   137k|    if ((utype == V_ASN1_SEQUENCE)
  775|   137k|        || (utype == V_ASN1_SET) || (utype == V_ASN1_OTHER)) {
  776|       |        /*
  777|       |         * Clear context cache for type OTHER because the auto clear when we
  778|       |         * have a exact match wont work
  779|       |         */
  780|      0|        if (utype == V_ASN1_OTHER) {
  781|      0|            asn1_tlc_clear(ctx);
  782|      0|        }
  783|       |        /* SEQUENCE and SET must be constructed */
  784|      0|        else if (!cst) {
  785|      0|            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE,
  786|      0|                    ASN1_R_TYPE_NOT_CONSTRUCTED);
  787|      0|            return 0;
  788|      0|        }
  789|       |
  790|      0|        cont = *in;
  791|       |        /* If indefinite length constructed find the real end */
  792|      0|        if (inf) {
  793|      0|            if (!asn1_find_end(&p, plen, inf))
  794|      0|                goto err;
  795|      0|            len = p - cont;
  796|      0|        } else {
  797|      0|            len = p - cont + plen;
  798|      0|            p += plen;
  799|      0|        }
  800|   137k|    } else if (cst) {
  801|      0|        if (utype == V_ASN1_NULL || utype == V_ASN1_BOOLEAN
  802|      0|            || utype == V_ASN1_OBJECT || utype == V_ASN1_INTEGER
  803|      0|            || utype == V_ASN1_ENUMERATED) {
  804|      0|            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ASN1_R_TYPE_NOT_PRIMITIVE);
  805|      0|            return 0;
  806|      0|        }
  807|       |
  808|       |        /* Free any returned 'buf' content */
  809|      0|        free_cont = 1;
  810|       |        /*
  811|       |         * Should really check the internal tags are correct but some things
  812|       |         * may get this wrong. The relevant specs say that constructed string
  813|       |         * types should be OCTET STRINGs internally irrespective of the type.
  814|       |         * So instead just check for UNIVERSAL class and ignore the tag.
  815|       |         */
  816|      0|        if (!asn1_collect(&buf, &p, plen, inf, -1, V_ASN1_UNIVERSAL, 0)) {
  817|      0|            goto err;
  818|      0|        }
  819|      0|        len = buf.length;
  820|       |        /* Append a final null to string */
  821|      0|        if (!BUF_MEM_grow_clean(&buf, len + 1)) {
  822|      0|            ASN1err(ASN1_F_ASN1_D2I_EX_PRIMITIVE, ERR_R_MALLOC_FAILURE);
  823|      0|            goto err;
  824|      0|        }
  825|      0|        buf.data[len] = 0;
  826|      0|        cont = (const unsigned char *)buf.data;
  827|   137k|    } else {
  828|   137k|        cont = p;
  829|   137k|        len = plen;
  830|   137k|        p += plen;
  831|   137k|    }
  832|       |
  833|       |    /* We now have content length and type: translate into a structure */
  834|       |    /* asn1_ex_c2i may reuse allocated buffer, and so sets free_cont to 0 */
  835|   137k|    if (!asn1_ex_c2i(pval, cont, len, utype, &free_cont, it))
  836|      0|        goto err;
  837|       |
  838|   137k|    *in = p;
  839|   137k|    ret = 1;
  840|   137k| err:
  841|   137k|    if (free_cont && buf.data)
  842|      0|        OPENSSL_free(buf.data);
  843|   137k|    return ret;
  844|   137k|}
tasn_dec.c:asn1_check_eoc:
 1129|   257k|{
 1130|   257k|    const unsigned char *p;
 1131|   257k|    if (len < 2)
 1132|      0|        return 0;
 1133|   257k|    p = *in;
 1134|   257k|    if (!p[0] && !p[1]) {
 1135|      0|        *in += 2;
 1136|      0|        return 1;
 1137|      0|    }
 1138|   257k|    return 0;
 1139|   257k|}
tasn_dec.c:asn1_check_tlen:
 1152|   316k|{
 1153|   316k|    int i;
 1154|   316k|    int ptag, pclass;
 1155|   316k|    long plen;
 1156|   316k|    const unsigned char *p, *q;
 1157|   316k|    p = *in;
 1158|   316k|    q = p;
 1159|       |
 1160|   316k|    if (ctx && ctx->valid) {
 1161|  61.0k|        i = ctx->ret;
 1162|  61.0k|        plen = ctx->plen;
 1163|  61.0k|        pclass = ctx->pclass;
 1164|  61.0k|        ptag = ctx->ptag;
 1165|  61.0k|        p += ctx->hdrlen;
 1166|   255k|    } else {
 1167|   255k|        i = ASN1_get_object(&p, &plen, &ptag, &pclass, len);
 1168|   255k|        if (ctx) {
 1169|   255k|            ctx->ret = i;
 1170|   255k|            ctx->plen = plen;
 1171|   255k|            ctx->pclass = pclass;
 1172|   255k|            ctx->ptag = ptag;
 1173|   255k|            ctx->hdrlen = p - q;
 1174|   255k|            ctx->valid = 1;
 1175|       |            /*
 1176|       |             * If definite length, and no error, length + header can't exceed
 1177|       |             * total amount of data available.
 1178|       |             */
 1179|   255k|            if (!(i & 0x81) && ((plen + ctx->hdrlen) > len)) {
 1180|      0|                ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_TOO_LONG);
 1181|      0|                asn1_tlc_clear(ctx);
 1182|      0|                return 0;
 1183|      0|            }
 1184|   255k|        }
 1185|   255k|    }
 1186|       |
 1187|   316k|    if (i & 0x80) {
 1188|      0|        ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_BAD_OBJECT_HEADER);
 1189|      0|        asn1_tlc_clear(ctx);
 1190|      0|        return 0;
 1191|      0|    }
 1192|   316k|    if (exptag >= 0) {
 1193|   269k|        if ((exptag != ptag) || (expclass != pclass)) {
 1194|       |            /*
 1195|       |             * If type is OPTIONAL, not an error: indicate missing type.
 1196|       |             */
 1197|  14.2k|            if (opt)
 1198|  14.2k|                return -1;
 1199|      0|            asn1_tlc_clear(ctx);
 1200|      0|            ASN1err(ASN1_F_ASN1_CHECK_TLEN, ASN1_R_WRONG_TAG);
 1201|      0|            return 0;
 1202|  14.2k|        }
 1203|       |        /*
 1204|       |         * We have a tag and class match: assume we are going to do something
 1205|       |         * with it
 1206|       |         */
 1207|   255k|        asn1_tlc_clear(ctx);
 1208|   255k|    }
 1209|       |
 1210|   301k|    if (i & 1)
 1211|      0|        plen = len - (p - q);
 1212|       |
 1213|   301k|    if (inf)
 1214|   255k|        *inf = i & 1;
 1215|       |
 1216|   301k|    if (cst)
 1217|   214k|        *cst = i & V_ASN1_CONSTRUCTED;
 1218|       |
 1219|   301k|    if (olen)
 1220|   255k|        *olen = plen;
 1221|       |
 1222|   301k|    if (oclass)
 1223|  46.8k|        *oclass = pclass;
 1224|       |
 1225|   301k|    if (otag)
 1226|  46.8k|        *otag = ptag;
 1227|       |
 1228|   301k|    *in = p;
 1229|   301k|    return 1;
 1230|   316k|}

ASN1_item_ex_i2d:
  129|   376k|{
  130|   376k|    const ASN1_TEMPLATE *tt = NULL;
  131|   376k|    unsigned char *p = NULL;
  132|   376k|    int i, seqcontlen, seqlen, ndef = 1;
  133|   376k|    const ASN1_COMPAT_FUNCS *cf;
  134|   376k|    const ASN1_EXTERN_FUNCS *ef;
  135|   376k|    const ASN1_AUX *aux = it->funcs;
  136|   376k|    ASN1_aux_cb *asn1_cb = 0;
  137|       |
  138|   376k|    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)
  139|      0|        return 0;
  140|       |
  141|   376k|    if (aux && aux->asn1_cb)
  142|      0|        asn1_cb = aux->asn1_cb;
  143|       |
  144|   376k|    switch (it->itype) {
  145|       |
  146|   173k|    case ASN1_ITYPE_PRIMITIVE:
  147|   173k|        if (it->templates)
  148|  57.9k|            return asn1_template_ex_i2d(pval, out, it->templates,
  149|  57.9k|                                        tag, aclass);
  150|   115k|        return asn1_i2d_ex_primitive(pval, out, it, tag, aclass);
  151|      0|        break;
  152|       |
  153|   115k|    case ASN1_ITYPE_MSTRING:
  154|   115k|        return asn1_i2d_ex_primitive(pval, out, it, -1, aclass);
  155|       |
  156|      0|    case ASN1_ITYPE_CHOICE:
  157|      0|        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))
  158|      0|            return 0;
  159|      0|        i = asn1_get_choice_selector(pval, it);
  160|      0|        if ((i >= 0) && (i < it->tcount)) {
  161|      0|            ASN1_VALUE **pchval;
  162|      0|            const ASN1_TEMPLATE *chtt;
  163|      0|            chtt = it->templates + i;
  164|      0|            pchval = asn1_get_field_ptr(pval, chtt);
  165|      0|            return asn1_template_ex_i2d(pchval, out, chtt, -1, aclass);
  166|      0|        }
  167|       |        /* Fixme: error condition if selector out of range */
  168|      0|        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))
  169|      0|            return 0;
  170|      0|        break;
  171|       |
  172|      0|    case ASN1_ITYPE_EXTERN:
  173|       |        /* If new style i2d it does all the work */
  174|      0|        ef = it->funcs;
  175|      0|        return ef->asn1_ex_i2d(pval, out, it, tag, aclass);
  176|       |
  177|      0|    case ASN1_ITYPE_COMPAT:
  178|       |        /* old style hackery... */
  179|      0|        cf = it->funcs;
  180|      0|        if (out)
  181|      0|            p = *out;
  182|      0|        i = cf->asn1_i2d(*pval, out);
  183|       |        /*
  184|       |         * Fixup for IMPLICIT tag: note this messes up for tags > 30, but so
  185|       |         * did the old code. Tags > 30 are very rare anyway.
  186|       |         */
  187|      0|        if (out && (tag != -1))
  188|      0|            *p = aclass | tag | (*p & V_ASN1_CONSTRUCTED);
  189|      0|        return i;
  190|       |
  191|      0|    case ASN1_ITYPE_NDEF_SEQUENCE:
  192|       |        /* Use indefinite length constructed if requested */
  193|      0|        if (aclass & ASN1_TFLG_NDEF)
  194|      0|            ndef = 2;
  195|       |        /* fall through */
  196|       |
  197|  86.9k|    case ASN1_ITYPE_SEQUENCE:
  198|  86.9k|        i = asn1_enc_restore(&seqcontlen, out, pval, it);
  199|       |        /* An error occurred */
  200|  86.9k|        if (i < 0)
  201|      0|            return 0;
  202|       |        /* We have a valid cached encoding... */
  203|  86.9k|        if (i > 0)
  204|      0|            return seqcontlen;
  205|       |        /* Otherwise carry on */
  206|  86.9k|        seqcontlen = 0;
  207|       |        /* If no IMPLICIT tagging set to SEQUENCE, UNIVERSAL */
  208|  86.9k|        if (tag == -1) {
  209|  86.9k|            tag = V_ASN1_SEQUENCE;
  210|       |            /* Retain any other flags in aclass */
  211|  86.9k|            aclass = (aclass & ~ASN1_TFLG_TAG_CLASS)
  212|  86.9k|                | V_ASN1_UNIVERSAL;
  213|  86.9k|        }
  214|  86.9k|        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_PRE, pval, it, NULL))
  215|      0|            return 0;
  216|       |        /* First work out sequence content length */
  217|   260k|        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
  218|   173k|            const ASN1_TEMPLATE *seqtt;
  219|   173k|            ASN1_VALUE **pseqval;
  220|   173k|            int tmplen;
  221|   173k|            seqtt = asn1_do_adb(pval, tt, 1);
  222|   173k|            if (!seqtt)
  223|      0|                return 0;
  224|   173k|            pseqval = asn1_get_field_ptr(pval, seqtt);
  225|   173k|            tmplen = asn1_template_ex_i2d(pseqval, NULL, seqtt, -1, aclass);
  226|   173k|            if (tmplen == -1 || (tmplen > INT_MAX - seqcontlen))
  227|      0|                return -1;
  228|   173k|            seqcontlen += tmplen;
  229|   173k|        }
  230|       |
  231|  86.9k|        seqlen = ASN1_object_size(ndef, seqcontlen, tag);
  232|  86.9k|        if (!out || seqlen == -1)
  233|  57.9k|            return seqlen;
  234|       |        /* Output SEQUENCE header */
  235|  28.9k|        ASN1_put_object(out, ndef, seqcontlen, tag, aclass);
  236|  86.9k|        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
  237|  57.9k|            const ASN1_TEMPLATE *seqtt;
  238|  57.9k|            ASN1_VALUE **pseqval;
  239|  57.9k|            seqtt = asn1_do_adb(pval, tt, 1);
  240|  57.9k|            if (!seqtt)
  241|      0|                return 0;
  242|  57.9k|            pseqval = asn1_get_field_ptr(pval, seqtt);
  243|       |            /* FIXME: check for errors in enhanced version */
  244|  57.9k|            asn1_template_ex_i2d(pseqval, out, seqtt, -1, aclass);
  245|  57.9k|        }
  246|  28.9k|        if (ndef == 2)
  247|      0|            ASN1_put_eoc(out);
  248|  28.9k|        if (asn1_cb && !asn1_cb(ASN1_OP_I2D_POST, pval, it, NULL))
  249|      0|            return 0;
  250|  28.9k|        return seqlen;
  251|       |
  252|      0|    default:
  253|      0|        return 0;
  254|       |
  255|   376k|    }
  256|      0|    return 0;
  257|   376k|}
asn1_ex_i2c:
  551|   289k|{
  552|   289k|    ASN1_BOOLEAN *tbool = NULL;
  553|   289k|    ASN1_STRING *strtmp;
  554|   289k|    ASN1_OBJECT *otmp;
  555|   289k|    int utype;
  556|   289k|    const unsigned char *cont;
  557|   289k|    unsigned char c;
  558|   289k|    int len;
  559|   289k|    const ASN1_PRIMITIVE_FUNCS *pf;
  560|   289k|    pf = it->funcs;
  561|   289k|    if (pf && pf->prim_i2c)
  562|      0|        return pf->prim_i2c(pval, cout, putype, it);
  563|       |
  564|       |    /* Should type be omitted? */
  565|   289k|    if ((it->itype != ASN1_ITYPE_PRIMITIVE)
  566|   289k|        || (it->utype != V_ASN1_BOOLEAN)) {
  567|   289k|        if (!*pval)
  568|      0|            return -1;
  569|   289k|    }
  570|       |
  571|   289k|    if (it->itype == ASN1_ITYPE_MSTRING) {
  572|       |        /* If MSTRING type set the underlying type */
  573|   144k|        strtmp = (ASN1_STRING *)*pval;
  574|   144k|        utype = strtmp->type;
  575|   144k|        *putype = utype;
  576|   144k|    } else if (it->utype == V_ASN1_ANY) {
  577|       |        /* If ANY set type and pointer to value */
  578|      0|        ASN1_TYPE *typ;
  579|      0|        typ = (ASN1_TYPE *)*pval;
  580|      0|        utype = typ->type;
  581|      0|        *putype = utype;
  582|      0|        pval = &typ->value.asn1_value;
  583|      0|    } else
  584|   144k|        utype = *putype;
  585|       |
  586|   289k|    switch (utype) {
  587|   144k|    case V_ASN1_OBJECT:
  588|   144k|        otmp = (ASN1_OBJECT *)*pval;
  589|   144k|        cont = otmp->data;
  590|   144k|        len = otmp->length;
  591|   144k|        break;
  592|       |
  593|      0|    case V_ASN1_NULL:
  594|      0|        cont = NULL;
  595|      0|        len = 0;
  596|      0|        break;
  597|       |
  598|      0|    case V_ASN1_BOOLEAN:
  599|      0|        tbool = (ASN1_BOOLEAN *)pval;
  600|      0|        if (*tbool == -1)
  601|      0|            return -1;
  602|      0|        if (it->utype != V_ASN1_ANY) {
  603|       |            /*
  604|       |             * Default handling if value == size field then omit
  605|       |             */
  606|      0|            if (*tbool && (it->size > 0))
  607|      0|                return -1;
  608|      0|            if (!*tbool && !it->size)
  609|      0|                return -1;
  610|      0|        }
  611|      0|        c = (unsigned char)*tbool;
  612|      0|        cont = &c;
  613|      0|        len = 1;
  614|      0|        break;
  615|       |
  616|      0|    case V_ASN1_BIT_STRING:
  617|      0|        return i2c_ASN1_BIT_STRING((ASN1_BIT_STRING *)*pval,
  618|      0|                                   cout ? &cout : NULL);
  619|      0|        break;
  620|       |
  621|      0|    case V_ASN1_INTEGER:
  622|      0|    case V_ASN1_ENUMERATED:
  623|       |        /*
  624|       |         * These are all have the same content format as ASN1_INTEGER
  625|       |         */
  626|      0|        return i2c_ASN1_INTEGER((ASN1_INTEGER *)*pval, cout ? &cout : NULL);
  627|      0|        break;
  628|       |
  629|      0|    case V_ASN1_OCTET_STRING:
  630|      0|    case V_ASN1_NUMERICSTRING:
  631|      0|    case V_ASN1_PRINTABLESTRING:
  632|      0|    case V_ASN1_T61STRING:
  633|      0|    case V_ASN1_VIDEOTEXSTRING:
  634|      0|    case V_ASN1_IA5STRING:
  635|      0|    case V_ASN1_UTCTIME:
  636|      0|    case V_ASN1_GENERALIZEDTIME:
  637|      0|    case V_ASN1_GRAPHICSTRING:
  638|      0|    case V_ASN1_VISIBLESTRING:
  639|      0|    case V_ASN1_GENERALSTRING:
  640|      0|    case V_ASN1_UNIVERSALSTRING:
  641|      0|    case V_ASN1_BMPSTRING:
  642|   144k|    case V_ASN1_UTF8STRING:
  643|   144k|    case V_ASN1_SEQUENCE:
  644|   144k|    case V_ASN1_SET:
  645|   144k|    default:
  646|       |        /* All based on ASN1_STRING and handled the same */
  647|   144k|        strtmp = (ASN1_STRING *)*pval;
  648|       |        /* Special handling for NDEF */
  649|   144k|        if ((it->size == ASN1_TFLG_NDEF)
  650|   144k|            && (strtmp->flags & ASN1_STRING_FLAG_NDEF)) {
  651|      0|            if (cout) {
  652|      0|                strtmp->data = cout;
  653|      0|                strtmp->length = 0;
  654|      0|            }
  655|       |            /* Special return code */
  656|      0|            return -2;
  657|      0|        }
  658|   144k|        cont = strtmp->data;
  659|   144k|        len = strtmp->length;
  660|       |
  661|   144k|        break;
  662|       |
  663|   289k|    }
  664|   289k|    if (cout && len)
  665|  57.9k|        memcpy(cout, cont, len);
  666|   289k|    return len;
  667|   289k|}
tasn_enc.c:asn1_template_ex_i2d:
  267|   289k|{
  268|   289k|    int i, ret, flags, ttag, tclass, ndef;
  269|   289k|    flags = tt->flags;
  270|       |    /*
  271|       |     * Work out tag and class to use: tagging may come either from the
  272|       |     * template or the arguments, not both because this would create
  273|       |     * ambiguity. Additionally the iclass argument may contain some
  274|       |     * additional flags which should be noted and passed down to other
  275|       |     * levels.
  276|       |     */
  277|   289k|    if (flags & ASN1_TFLG_TAG_MASK) {
  278|       |        /* Error if argument and template tagging */
  279|      0|        if (tag != -1)
  280|       |            /* FIXME: error code here */
  281|      0|            return -1;
  282|       |        /* Get tagging from template */
  283|      0|        ttag = tt->tag;
  284|      0|        tclass = flags & ASN1_TFLG_TAG_CLASS;
  285|   289k|    } else if (tag != -1) {
  286|       |        /* No template tagging, get from arguments */
  287|      0|        ttag = tag;
  288|      0|        tclass = iclass & ASN1_TFLG_TAG_CLASS;
  289|   289k|    } else {
  290|   289k|        ttag = -1;
  291|   289k|        tclass = 0;
  292|   289k|    }
  293|       |    /*
  294|       |     * Remove any class mask from iflag.
  295|       |     */
  296|   289k|    iclass &= ~ASN1_TFLG_TAG_CLASS;
  297|       |
  298|       |    /*
  299|       |     * At this point 'ttag' contains the outer tag to use, 'tclass' is the
  300|       |     * class and iclass is any flags passed to this function.
  301|       |     */
  302|       |
  303|       |    /* if template and arguments require ndef, use it */
  304|   289k|    if ((flags & ASN1_TFLG_NDEF) && (iclass & ASN1_TFLG_NDEF))
  305|      0|        ndef = 2;
  306|   289k|    else
  307|   289k|        ndef = 1;
  308|       |
  309|   289k|    if (flags & ASN1_TFLG_SK_MASK) {
  310|       |        /* SET OF, SEQUENCE OF */
  311|  57.9k|        STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
  312|  57.9k|        int isset, sktag, skaclass;
  313|  57.9k|        int skcontlen, sklen;
  314|  57.9k|        ASN1_VALUE *skitem;
  315|       |
  316|  57.9k|        if (!*pval)
  317|      0|            return 0;
  318|       |
  319|  57.9k|        if (flags & ASN1_TFLG_SET_OF) {
  320|  57.9k|            isset = 1;
  321|       |            /* 2 means we reorder */
  322|  57.9k|            if (flags & ASN1_TFLG_SEQUENCE_OF)
  323|      0|                isset = 2;
  324|  57.9k|        } else
  325|      0|            isset = 0;
  326|       |
  327|       |        /*
  328|       |         * Work out inner tag value: if EXPLICIT or no tagging use underlying
  329|       |         * type.
  330|       |         */
  331|  57.9k|        if ((ttag != -1) && !(flags & ASN1_TFLG_EXPTAG)) {
  332|      0|            sktag = ttag;
  333|      0|            skaclass = tclass;
  334|  57.9k|        } else {
  335|  57.9k|            skaclass = V_ASN1_UNIVERSAL;
  336|  57.9k|            if (isset)
  337|  57.9k|                sktag = V_ASN1_SET;
  338|      0|            else
  339|      0|                sktag = V_ASN1_SEQUENCE;
  340|  57.9k|        }
  341|       |
  342|       |        /* Determine total length of items */
  343|  57.9k|        skcontlen = 0;
  344|   115k|        for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  345|  57.9k|            int tmplen;
  346|  57.9k|            skitem = sk_ASN1_VALUE_value(sk, i);
  347|  57.9k|            tmplen = ASN1_item_ex_i2d(&skitem, NULL, ASN1_ITEM_ptr(tt->item),
  348|  57.9k|                                      -1, iclass);
  349|  57.9k|            if (tmplen == -1 || (skcontlen > INT_MAX - tmplen))
  350|      0|                return -1;
  351|  57.9k|            skcontlen += tmplen;
  352|  57.9k|        }
  353|  57.9k|        sklen = ASN1_object_size(ndef, skcontlen, sktag);
  354|  57.9k|        if (sklen == -1)
  355|      0|            return -1;
  356|       |        /* If EXPLICIT need length of surrounding tag */
  357|  57.9k|        if (flags & ASN1_TFLG_EXPTAG)
  358|      0|            ret = ASN1_object_size(ndef, sklen, ttag);
  359|  57.9k|        else
  360|  57.9k|            ret = sklen;
  361|       |
  362|  57.9k|        if (!out || ret == -1)
  363|  28.9k|            return ret;
  364|       |
  365|       |        /* Now encode this lot... */
  366|       |        /* EXPLICIT tag */
  367|  28.9k|        if (flags & ASN1_TFLG_EXPTAG)
  368|      0|            ASN1_put_object(out, ndef, sklen, ttag, tclass);
  369|       |        /* SET or SEQUENCE and IMPLICIT tag */
  370|  28.9k|        ASN1_put_object(out, ndef, skcontlen, sktag, skaclass);
  371|       |        /* And the stuff itself */
  372|  28.9k|        asn1_set_seq_out(sk, out, skcontlen, ASN1_ITEM_ptr(tt->item),
  373|  28.9k|                         isset, iclass);
  374|  28.9k|        if (ndef == 2) {
  375|      0|            ASN1_put_eoc(out);
  376|      0|            if (flags & ASN1_TFLG_EXPTAG)
  377|      0|                ASN1_put_eoc(out);
  378|      0|        }
  379|       |
  380|  28.9k|        return ret;
  381|  57.9k|    }
  382|       |
  383|   231k|    if (flags & ASN1_TFLG_EXPTAG) {
  384|       |        /* EXPLICIT tagging */
  385|       |        /* Find length of tagged item */
  386|      0|        i = ASN1_item_ex_i2d(pval, NULL, ASN1_ITEM_ptr(tt->item), -1, iclass);
  387|      0|        if (!i)
  388|      0|            return 0;
  389|       |        /* Find length of EXPLICIT tag */
  390|      0|        ret = ASN1_object_size(ndef, i, ttag);
  391|      0|        if (out && ret != -1) {
  392|       |            /* Output tag and item */
  393|      0|            ASN1_put_object(out, ndef, i, ttag, tclass);
  394|      0|            ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item), -1, iclass);
  395|      0|            if (ndef == 2)
  396|      0|                ASN1_put_eoc(out);
  397|      0|        }
  398|      0|        return ret;
  399|      0|    }
  400|       |
  401|       |    /* Either normal or IMPLICIT tagging: combine class and flags */
  402|   231k|    return ASN1_item_ex_i2d(pval, out, ASN1_ITEM_ptr(tt->item),
  403|   231k|                            ttag, tclass | iclass);
  404|       |
  405|   231k|}
tasn_enc.c:asn1_set_seq_out:
  431|  28.9k|{
  432|  28.9k|    int i;
  433|  28.9k|    ASN1_VALUE *skitem;
  434|  28.9k|    unsigned char *tmpdat = NULL, *p = NULL;
  435|  28.9k|    DER_ENC *derlst = NULL, *tder;
  436|  28.9k|    if (do_sort) {
  437|       |        /* Don't need to sort less than 2 items */
  438|  28.9k|        if (sk_ASN1_VALUE_num(sk) < 2)
  439|  28.9k|            do_sort = 0;
  440|      0|        else {
  441|      0|            derlst = OPENSSL_malloc(sk_ASN1_VALUE_num(sk)
  442|      0|                                    * sizeof(*derlst));
  443|      0|            if (!derlst)
  444|      0|                return 0;
  445|      0|            tmpdat = OPENSSL_malloc(skcontlen);
  446|      0|            if (!tmpdat) {
  447|      0|                OPENSSL_free(derlst);
  448|      0|                return 0;
  449|      0|            }
  450|      0|        }
  451|  28.9k|    }
  452|       |    /* If not sorting just output each item */
  453|  28.9k|    if (!do_sort) {
  454|  57.9k|        for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  455|  28.9k|            skitem = sk_ASN1_VALUE_value(sk, i);
  456|  28.9k|            ASN1_item_ex_i2d(&skitem, out, item, -1, iclass);
  457|  28.9k|        }
  458|  28.9k|        return 1;
  459|  28.9k|    }
  460|      0|    p = tmpdat;
  461|       |
  462|       |    /* Doing sort: build up a list of each member's DER encoding */
  463|      0|    for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++) {
  464|      0|        skitem = sk_ASN1_VALUE_value(sk, i);
  465|      0|        tder->data = p;
  466|      0|        tder->length = ASN1_item_ex_i2d(&skitem, &p, item, -1, iclass);
  467|      0|        tder->field = skitem;
  468|      0|    }
  469|       |
  470|       |    /* Now sort them */
  471|      0|    qsort(derlst, sk_ASN1_VALUE_num(sk), sizeof(*derlst), der_cmp);
  472|       |    /* Output sorted DER encoding */
  473|      0|    p = *out;
  474|      0|    for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++) {
  475|      0|        memcpy(p, tder->data, tder->length);
  476|      0|        p += tder->length;
  477|      0|    }
  478|      0|    *out = p;
  479|       |    /* If do_sort is 2 then reorder the STACK */
  480|      0|    if (do_sort == 2) {
  481|      0|        for (i = 0, tder = derlst; i < sk_ASN1_VALUE_num(sk); i++, tder++)
  482|      0|            (void)sk_ASN1_VALUE_set(sk, i, tder->field);
  483|      0|    }
  484|      0|    OPENSSL_free(derlst);
  485|      0|    OPENSSL_free(tmpdat);
  486|      0|    return 1;
  487|  28.9k|}
tasn_enc.c:asn1_i2d_ex_primitive:
  491|   231k|{
  492|   231k|    int len;
  493|   231k|    int utype;
  494|   231k|    int usetag;
  495|   231k|    int ndef = 0;
  496|       |
  497|   231k|    utype = it->utype;
  498|       |
  499|       |    /*
  500|       |     * Get length of content octets and maybe find out the underlying type.
  501|       |     */
  502|       |
  503|   231k|    len = asn1_ex_i2c(pval, NULL, &utype, it);
  504|       |
  505|       |    /*
  506|       |     * If SEQUENCE, SET or OTHER then header is included in pseudo content
  507|       |     * octets so don't include tag+length. We need to check here because the
  508|       |     * call to asn1_ex_i2c() could change utype.
  509|       |     */
  510|   231k|    if ((utype == V_ASN1_SEQUENCE) || (utype == V_ASN1_SET) ||
  511|   231k|        (utype == V_ASN1_OTHER))
  512|      0|        usetag = 0;
  513|   231k|    else
  514|   231k|        usetag = 1;
  515|       |
  516|       |    /* -1 means omit type */
  517|       |
  518|   231k|    if (len == -1)
  519|      0|        return 0;
  520|       |
  521|       |    /* -2 return is special meaning use ndef */
  522|   231k|    if (len == -2) {
  523|      0|        ndef = 2;
  524|      0|        len = 0;
  525|      0|    }
  526|       |
  527|       |    /* If not implicitly tagged get tag from underlying type */
  528|   231k|    if (tag == -1)
  529|   231k|        tag = utype;
  530|       |
  531|       |    /* Output tag+length followed by content octets */
  532|   231k|    if (out) {
  533|  57.9k|        if (usetag)
  534|  57.9k|            ASN1_put_object(out, ndef, len, tag, aclass);
  535|  57.9k|        asn1_ex_i2c(pval, *out, &utype, it);
  536|  57.9k|        if (ndef)
  537|      0|            ASN1_put_eoc(out);
  538|  57.9k|        else
  539|  57.9k|            *out += len;
  540|  57.9k|    }
  541|       |
  542|   231k|    if (usetag)
  543|   231k|        return ASN1_object_size(ndef, len, tag);
  544|      0|    return len;
  545|   231k|}

ASN1_item_free:
   69|  88.6k|{
   70|  88.6k|    asn1_item_combine_free(&val, it, 0);
   71|  88.6k|}
asn1_item_combine_free:
   79|   359k|{
   80|   359k|    const ASN1_TEMPLATE *tt = NULL, *seqtt;
   81|   359k|    const ASN1_EXTERN_FUNCS *ef;
   82|   359k|    const ASN1_COMPAT_FUNCS *cf;
   83|   359k|    const ASN1_AUX *aux = it->funcs;
   84|   359k|    ASN1_aux_cb *asn1_cb;
   85|   359k|    int i;
   86|   359k|    if (!pval)
   87|      0|        return;
   88|   359k|    if ((it->itype != ASN1_ITYPE_PRIMITIVE) && !*pval)
   89|  11.5k|        return;
   90|   348k|    if (aux && aux->asn1_cb)
   91|  11.5k|        asn1_cb = aux->asn1_cb;
   92|   336k|    else
   93|   336k|        asn1_cb = 0;
   94|       |
   95|   348k|    switch (it->itype) {
   96|       |
   97|   172k|    case ASN1_ITYPE_PRIMITIVE:
   98|   172k|        if (it->templates)
   99|  7.68k|            ASN1_template_free(pval, it->templates);
  100|   164k|        else
  101|   164k|            ASN1_primitive_free(pval, it);
  102|   172k|        break;
  103|       |
  104|  65.6k|    case ASN1_ITYPE_MSTRING:
  105|  65.6k|        ASN1_primitive_free(pval, it);
  106|  65.6k|        break;
  107|       |
  108|      0|    case ASN1_ITYPE_CHOICE:
  109|      0|        if (asn1_cb) {
  110|      0|            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
  111|      0|            if (i == 2)
  112|      0|                return;
  113|      0|        }
  114|      0|        i = asn1_get_choice_selector(pval, it);
  115|      0|        if ((i >= 0) && (i < it->tcount)) {
  116|      0|            ASN1_VALUE **pchval;
  117|      0|            tt = it->templates + i;
  118|      0|            pchval = asn1_get_field_ptr(pval, tt);
  119|      0|            ASN1_template_free(pchval, tt);
  120|      0|        }
  121|      0|        if (asn1_cb)
  122|      0|            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
  123|      0|        if (!combine) {
  124|      0|            OPENSSL_free(*pval);
  125|      0|            *pval = NULL;
  126|      0|        }
  127|      0|        break;
  128|       |
  129|      0|    case ASN1_ITYPE_COMPAT:
  130|      0|        cf = it->funcs;
  131|      0|        if (cf && cf->asn1_free)
  132|      0|            cf->asn1_free(*pval);
  133|      0|        break;
  134|       |
  135|  7.68k|    case ASN1_ITYPE_EXTERN:
  136|  7.68k|        ef = it->funcs;
  137|  7.68k|        if (ef && ef->asn1_ex_free)
  138|  7.68k|            ef->asn1_ex_free(pval, it);
  139|  7.68k|        break;
  140|       |
  141|      0|    case ASN1_ITYPE_NDEF_SEQUENCE:
  142|   102k|    case ASN1_ITYPE_SEQUENCE:
  143|   102k|        if (asn1_do_lock(pval, -1, it) > 0)
  144|  3.84k|            return;
  145|  98.5k|        if (asn1_cb) {
  146|  7.68k|            i = asn1_cb(ASN1_OP_FREE_PRE, pval, it, NULL);
  147|  7.68k|            if (i == 2)
  148|      0|                return;
  149|  7.68k|        }
  150|  98.5k|        asn1_enc_free(pval, it);
  151|       |        /*
  152|       |         * If we free up as normal we will invalidate any ANY DEFINED BY
  153|       |         * field and we wont be able to determine the type of the field it
  154|       |         * defines. So free up in reverse order.
  155|       |         */
  156|  98.5k|        tt = it->templates + it->tcount - 1;
  157|   344k|        for (i = 0; i < it->tcount; tt--, i++) {
  158|   245k|            ASN1_VALUE **pseqval;
  159|   245k|            seqtt = asn1_do_adb(pval, tt, 0);
  160|   245k|            if (!seqtt)
  161|      0|                continue;
  162|   245k|            pseqval = asn1_get_field_ptr(pval, seqtt);
  163|   245k|            ASN1_template_free(pseqval, seqtt);
  164|   245k|        }
  165|  98.5k|        if (asn1_cb)
  166|  7.68k|            asn1_cb(ASN1_OP_FREE_POST, pval, it, NULL);
  167|  98.5k|        if (!combine) {
  168|  98.5k|            OPENSSL_free(*pval);
  169|  98.5k|            *pval = NULL;
  170|  98.5k|        }
  171|  98.5k|        break;
  172|   348k|    }
  173|   348k|}
ASN1_template_free:
  176|   268k|{
  177|   268k|    int i;
  178|   268k|    if (tt->flags & ASN1_TFLG_SK_MASK) {
  179|  11.5k|        STACK_OF(ASN1_VALUE) *sk = (STACK_OF(ASN1_VALUE) *)*pval;
  180|  25.2k|        for (i = 0; i < sk_ASN1_VALUE_num(sk); i++) {
  181|  13.7k|            ASN1_VALUE *vtmp;
  182|  13.7k|            vtmp = sk_ASN1_VALUE_value(sk, i);
  183|  13.7k|            asn1_item_combine_free(&vtmp, ASN1_ITEM_ptr(tt->item), 0);
  184|  13.7k|        }
  185|  11.5k|        sk_ASN1_VALUE_free(sk);
  186|  11.5k|        *pval = NULL;
  187|  11.5k|    } else
  188|   257k|        asn1_item_combine_free(pval, ASN1_ITEM_ptr(tt->item),
  189|   257k|                               tt->flags & ASN1_TFLG_COMBINE);
  190|   268k|}
ASN1_primitive_free:
  193|   240k|{
  194|   240k|    int utype;
  195|   240k|    if (it) {
  196|   230k|        const ASN1_PRIMITIVE_FUNCS *pf;
  197|   230k|        pf = it->funcs;
  198|   230k|        if (pf && pf->prim_free) {
  199|      0|            pf->prim_free(pval, it);
  200|      0|            return;
  201|      0|        }
  202|   230k|    }
  203|       |    /* Special case: if 'it' is NULL free contents of ASN1_TYPE */
  204|   240k|    if (!it) {
  205|  10.1k|        ASN1_TYPE *typ = (ASN1_TYPE *)*pval;
  206|  10.1k|        utype = typ->type;
  207|  10.1k|        pval = &typ->value.asn1_value;
  208|  10.1k|        if (!*pval)
  209|  9.45k|            return;
  210|   230k|    } else if (it->itype == ASN1_ITYPE_MSTRING) {
  211|  65.6k|        utype = -1;
  212|  65.6k|        if (!*pval)
  213|      0|            return;
  214|   164k|    } else {
  215|   164k|        utype = it->utype;
  216|   164k|        if ((utype != V_ASN1_BOOLEAN) && !*pval)
  217|  21.9k|            return;
  218|   164k|    }
  219|       |
  220|   209k|    switch (utype) {
  221|  83.9k|    case V_ASN1_OBJECT:
  222|  83.9k|        ASN1_OBJECT_free((ASN1_OBJECT *)*pval);
  223|  83.9k|        break;
  224|       |
  225|  20.3k|    case V_ASN1_BOOLEAN:
  226|  20.3k|        if (it)
  227|  20.3k|            *(ASN1_BOOLEAN *)pval = it->size;
  228|      0|        else
  229|      0|            *(ASN1_BOOLEAN *)pval = -1;
  230|  20.3k|        return;
  231|       |
  232|      0|    case V_ASN1_NULL:
  233|      0|        break;
  234|       |
  235|  10.1k|    case V_ASN1_ANY:
  236|  10.1k|        ASN1_primitive_free(pval, NULL);
  237|  10.1k|        OPENSSL_free(*pval);
  238|  10.1k|        break;
  239|       |
  240|  94.7k|    default:
  241|  94.7k|        ASN1_STRING_free((ASN1_STRING *)*pval);
  242|  94.7k|        *pval = NULL;
  243|  94.7k|        break;
  244|   209k|    }
  245|   188k|    *pval = NULL;
  246|   188k|}

ASN1_item_new:
   75|  39.1k|{
   76|  39.1k|    ASN1_VALUE *ret = NULL;
   77|  39.1k|    if (ASN1_item_ex_new(&ret, it) > 0)
   78|  39.1k|        return ret;
   79|      0|    return NULL;
   80|  39.1k|}
ASN1_item_ex_new:
   85|  85.6k|{
   86|  85.6k|    return asn1_item_ex_combine_new(pval, it, 0);
   87|  85.6k|}
ASN1_template_new:
  259|   245k|{
  260|   245k|    const ASN1_ITEM *it = ASN1_ITEM_ptr(tt->item);
  261|   245k|    int ret;
  262|   245k|    if (tt->flags & ASN1_TFLG_OPTIONAL) {
  263|  40.6k|        asn1_template_clear(pval, tt);
  264|  40.6k|        return 1;
  265|  40.6k|    }
  266|       |    /* If ANY DEFINED BY nothing to do */
  267|       |
  268|   204k|    if (tt->flags & ASN1_TFLG_ADB_MASK) {
  269|      0|        *pval = NULL;
  270|      0|        return 1;
  271|      0|    }
  272|       |#ifdef CRYPTO_MDEBUG
  273|       |    if (tt->field_name)
  274|       |        CRYPTO_push_info(tt->field_name);
  275|       |#endif
  276|       |    /* If SET OF or SEQUENCE OF, its a STACK */
  277|   204k|    if (tt->flags & ASN1_TFLG_SK_MASK) {
  278|      0|        STACK_OF(ASN1_VALUE) *skval;
  279|      0|        skval = sk_ASN1_VALUE_new_null();
  280|      0|        if (!skval) {
  281|      0|            ASN1err(ASN1_F_ASN1_TEMPLATE_NEW, ERR_R_MALLOC_FAILURE);
  282|      0|            ret = 0;
  283|      0|            goto done;
  284|      0|        }
  285|      0|        *pval = (ASN1_VALUE *)skval;
  286|      0|        ret = 1;
  287|      0|        goto done;
  288|      0|    }
  289|       |    /* Otherwise pass it back to the item routine */
  290|   204k|    ret = asn1_item_ex_combine_new(pval, it, tt->flags & ASN1_TFLG_COMBINE);
  291|   204k| done:
  292|       |#ifdef CRYPTO_MDEBUG
  293|       |    if (it->sname)
  294|       |        CRYPTO_pop_info();
  295|       |#endif
  296|   204k|    return ret;
  297|   204k|}
ASN1_primitive_new:
  314|   184k|{
  315|   184k|    ASN1_TYPE *typ;
  316|   184k|    ASN1_STRING *str;
  317|   184k|    int utype;
  318|       |
  319|   184k|    if (!it)
  320|      0|        return 0;
  321|       |
  322|   184k|    if (it->funcs) {
  323|      0|        const ASN1_PRIMITIVE_FUNCS *pf = it->funcs;
  324|      0|        if (pf->prim_new)
  325|      0|            return pf->prim_new(pval, it);
  326|      0|    }
  327|       |
  328|   184k|    if (it->itype == ASN1_ITYPE_MSTRING)
  329|  65.6k|        utype = -1;
  330|   118k|    else
  331|   118k|        utype = it->utype;
  332|   184k|    switch (utype) {
  333|  83.2k|    case V_ASN1_OBJECT:
  334|  83.2k|        *pval = (ASN1_VALUE *)OBJ_nid2obj(NID_undef);
  335|  83.2k|        return 1;
  336|       |
  337|      0|    case V_ASN1_BOOLEAN:
  338|      0|        *(ASN1_BOOLEAN *)pval = it->size;
  339|      0|        return 1;
  340|       |
  341|      0|    case V_ASN1_NULL:
  342|      0|        *pval = (ASN1_VALUE *)1;
  343|      0|        return 1;
  344|       |
  345|  10.1k|    case V_ASN1_ANY:
  346|  10.1k|        typ = OPENSSL_malloc(sizeof(ASN1_TYPE));
  347|  10.1k|        if (!typ)
  348|      0|            return 0;
  349|  10.1k|        typ->value.ptr = NULL;
  350|  10.1k|        typ->type = -1;
  351|  10.1k|        *pval = (ASN1_VALUE *)typ;
  352|  10.1k|        break;
  353|       |
  354|  90.9k|    default:
  355|  90.9k|        str = ASN1_STRING_type_new(utype);
  356|  90.9k|        if (it->itype == ASN1_ITYPE_MSTRING && str)
  357|  65.6k|            str->flags |= ASN1_STRING_FLAG_MSTRING;
  358|  90.9k|        *pval = (ASN1_VALUE *)str;
  359|  90.9k|        break;
  360|   184k|    }
  361|   101k|    if (*pval)
  362|   101k|        return 1;
  363|      0|    return 0;
  364|   101k|}
tasn_new.c:asn1_item_ex_combine_new:
   91|   290k|{
   92|   290k|    const ASN1_TEMPLATE *tt = NULL;
   93|   290k|    const ASN1_COMPAT_FUNCS *cf;
   94|   290k|    const ASN1_EXTERN_FUNCS *ef;
   95|   290k|    const ASN1_AUX *aux = it->funcs;
   96|   290k|    ASN1_aux_cb *asn1_cb;
   97|   290k|    ASN1_VALUE **pseqval;
   98|   290k|    int i;
   99|   290k|    if (aux && aux->asn1_cb)
  100|  7.68k|        asn1_cb = aux->asn1_cb;
  101|   282k|    else
  102|   282k|        asn1_cb = 0;
  103|       |
  104|       |#ifdef CRYPTO_MDEBUG
  105|       |    if (it->sname)
  106|       |        CRYPTO_push_info(it->sname);
  107|       |#endif
  108|       |
  109|   290k|    switch (it->itype) {
  110|       |
  111|  7.68k|    case ASN1_ITYPE_EXTERN:
  112|  7.68k|        ef = it->funcs;
  113|  7.68k|        if (ef && ef->asn1_ex_new) {
  114|  7.68k|            if (!ef->asn1_ex_new(pval, it))
  115|      0|                goto memerr;
  116|  7.68k|        }
  117|  7.68k|        break;
  118|       |
  119|  7.68k|    case ASN1_ITYPE_COMPAT:
  120|      0|        cf = it->funcs;
  121|      0|        if (cf && cf->asn1_new) {
  122|      0|            *pval = cf->asn1_new();
  123|      0|            if (!*pval)
  124|      0|                goto memerr;
  125|      0|        }
  126|      0|        break;
  127|       |
  128|   118k|    case ASN1_ITYPE_PRIMITIVE:
  129|   118k|        if (it->templates) {
  130|      0|            if (!ASN1_template_new(pval, it->templates))
  131|      0|                goto memerr;
  132|   118k|        } else if (!ASN1_primitive_new(pval, it))
  133|      0|            goto memerr;
  134|   118k|        break;
  135|       |
  136|   118k|    case ASN1_ITYPE_MSTRING:
  137|  65.6k|        if (!ASN1_primitive_new(pval, it))
  138|      0|            goto memerr;
  139|  65.6k|        break;
  140|       |
  141|  65.6k|    case ASN1_ITYPE_CHOICE:
  142|      0|        if (asn1_cb) {
  143|      0|            i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
  144|      0|            if (!i)
  145|      0|                goto auxerr;
  146|      0|            if (i == 2) {
  147|       |#ifdef CRYPTO_MDEBUG
  148|       |                if (it->sname)
  149|       |                    CRYPTO_pop_info();
  150|       |#endif
  151|      0|                return 1;
  152|      0|            }
  153|      0|        }
  154|      0|        if (!combine) {
  155|      0|            *pval = OPENSSL_malloc(it->size);
  156|      0|            if (!*pval)
  157|      0|                goto memerr;
  158|      0|            memset(*pval, 0, it->size);
  159|      0|        }
  160|      0|        asn1_set_choice_selector(pval, -1, it);
  161|      0|        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))
  162|      0|            goto auxerr2;
  163|      0|        break;
  164|       |
  165|      0|    case ASN1_ITYPE_NDEF_SEQUENCE:
  166|  98.5k|    case ASN1_ITYPE_SEQUENCE:
  167|  98.5k|        if (asn1_cb) {
  168|  7.68k|            i = asn1_cb(ASN1_OP_NEW_PRE, pval, it, NULL);
  169|  7.68k|            if (!i)
  170|      0|                goto auxerr;
  171|  7.68k|            if (i == 2) {
  172|       |#ifdef CRYPTO_MDEBUG
  173|       |                if (it->sname)
  174|       |                    CRYPTO_pop_info();
  175|       |#endif
  176|      0|                return 1;
  177|      0|            }
  178|  7.68k|        }
  179|  98.5k|        if (!combine) {
  180|  98.5k|            *pval = OPENSSL_malloc(it->size);
  181|  98.5k|            if (!*pval)
  182|      0|                goto memerr;
  183|  98.5k|            memset(*pval, 0, it->size);
  184|  98.5k|            asn1_do_lock(pval, 0, it);
  185|  98.5k|            asn1_enc_init(pval, it);
  186|  98.5k|        }
  187|   344k|        for (i = 0, tt = it->templates; i < it->tcount; tt++, i++) {
  188|   245k|            pseqval = asn1_get_field_ptr(pval, tt);
  189|   245k|            if (!ASN1_template_new(pseqval, tt))
  190|      0|                goto memerr2;
  191|   245k|        }
  192|  98.5k|        if (asn1_cb && !asn1_cb(ASN1_OP_NEW_POST, pval, it, NULL))
  193|      0|            goto auxerr2;
  194|  98.5k|        break;
  195|   290k|    }
  196|       |#ifdef CRYPTO_MDEBUG
  197|       |    if (it->sname)
  198|       |        CRYPTO_pop_info();
  199|       |#endif
  200|   290k|    return 1;
  201|       |
  202|      0| memerr2:
  203|      0|    asn1_item_combine_free(pval, it, combine);
  204|      0| memerr:
  205|      0|    ASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ERR_R_MALLOC_FAILURE);
  206|       |#ifdef CRYPTO_MDEBUG
  207|       |    if (it->sname)
  208|       |        CRYPTO_pop_info();
  209|       |#endif
  210|      0|    return 0;
  211|       |
  212|      0| auxerr2:
  213|      0|    asn1_item_combine_free(pval, it, combine);
  214|      0| auxerr:
  215|      0|    ASN1err(ASN1_F_ASN1_ITEM_EX_COMBINE_NEW, ASN1_R_AUX_ERROR);
  216|       |#ifdef CRYPTO_MDEBUG
  217|       |    if (it->sname)
  218|       |        CRYPTO_pop_info();
  219|       |#endif
  220|      0|    return 0;
  221|       |
  222|      0|}
tasn_new.c:asn1_template_clear:
  300|  40.6k|{
  301|       |    /* If ADB or STACK just NULL the field */
  302|  40.6k|    if (tt->flags & (ASN1_TFLG_ADB_MASK | ASN1_TFLG_SK_MASK))
  303|  3.84k|        *pval = NULL;
  304|  36.7k|    else
  305|  36.7k|        asn1_item_clear(pval, ASN1_ITEM_ptr(tt->item));
  306|  40.6k|}
tasn_new.c:asn1_item_clear:
  225|  36.7k|{
  226|  36.7k|    const ASN1_EXTERN_FUNCS *ef;
  227|       |
  228|  36.7k|    switch (it->itype) {
  229|       |
  230|      0|    case ASN1_ITYPE_EXTERN:
  231|      0|        ef = it->funcs;
  232|      0|        if (ef && ef->asn1_ex_clear)
  233|      0|            ef->asn1_ex_clear(pval, it);
  234|      0|        else
  235|      0|            *pval = NULL;
  236|      0|        break;
  237|       |
  238|  36.7k|    case ASN1_ITYPE_PRIMITIVE:
  239|  36.7k|        if (it->templates)
  240|      0|            asn1_template_clear(pval, it->templates);
  241|  36.7k|        else
  242|  36.7k|            asn1_primitive_clear(pval, it);
  243|  36.7k|        break;
  244|       |
  245|      0|    case ASN1_ITYPE_MSTRING:
  246|      0|        asn1_primitive_clear(pval, it);
  247|      0|        break;
  248|       |
  249|      0|    case ASN1_ITYPE_COMPAT:
  250|      0|    case ASN1_ITYPE_CHOICE:
  251|      0|    case ASN1_ITYPE_SEQUENCE:
  252|      0|    case ASN1_ITYPE_NDEF_SEQUENCE:
  253|      0|        *pval = NULL;
  254|      0|        break;
  255|  36.7k|    }
  256|  36.7k|}
tasn_new.c:asn1_primitive_clear:
  367|  36.7k|{
  368|  36.7k|    int utype;
  369|  36.7k|    if (it && it->funcs) {
  370|      0|        const ASN1_PRIMITIVE_FUNCS *pf = it->funcs;
  371|      0|        if (pf->prim_clear)
  372|      0|            pf->prim_clear(pval, it);
  373|      0|        else
  374|      0|            *pval = NULL;
  375|      0|        return;
  376|      0|    }
  377|  36.7k|    if (!it || (it->itype == ASN1_ITYPE_MSTRING))
  378|      0|        utype = -1;
  379|  36.7k|    else
  380|  36.7k|        utype = it->utype;
  381|  36.7k|    if (utype == V_ASN1_BOOLEAN)
  382|  13.7k|        *(ASN1_BOOLEAN *)pval = it->size;
  383|  23.0k|    else
  384|  23.0k|        *pval = NULL;
  385|  36.7k|}

asn1_do_lock:
  104|   201k|{
  105|   201k|    const ASN1_AUX *aux;
  106|   201k|    int *lck, ret;
  107|   201k|    if ((it->itype != ASN1_ITYPE_SEQUENCE)
  108|   201k|        && (it->itype != ASN1_ITYPE_NDEF_SEQUENCE))
  109|      0|        return 0;
  110|   201k|    aux = it->funcs;
  111|   201k|    if (!aux || !(aux->flags & ASN1_AFLG_REFCOUNT))
  112|   189k|        return 0;
  113|  11.5k|    lck = offset2ptr(*pval, aux->ref_offset);
  114|  11.5k|    if (op == 0) {
  115|  3.84k|        *lck = 1;
  116|  3.84k|        return 1;
  117|  3.84k|    }
  118|  7.68k|    ret = CRYPTO_add(lck, op, aux->ref_lock);
  119|       |#ifdef REF_PRINT
  120|       |    fprintf(stderr, "%s: Reference Count: %d\n", it->sname, *lck);
  121|       |#endif
  122|       |#ifdef REF_CHECK
  123|       |    if (ret < 0)
  124|       |        fprintf(stderr, "%s, bad reference count\n", it->sname);
  125|       |#endif
  126|  7.68k|    return ret;
  127|  11.5k|}
asn1_enc_init:
  141|  98.5k|{
  142|  98.5k|    ASN1_ENCODING *enc;
  143|  98.5k|    enc = asn1_get_enc_ptr(pval, it);
  144|  98.5k|    if (enc) {
  145|  3.84k|        enc->enc = NULL;
  146|  3.84k|        enc->len = 0;
  147|  3.84k|        enc->modified = 1;
  148|  3.84k|    }
  149|  98.5k|}
asn1_enc_free:
  152|  98.5k|{
  153|  98.5k|    ASN1_ENCODING *enc;
  154|  98.5k|    enc = asn1_get_enc_ptr(pval, it);
  155|  98.5k|    if (enc) {
  156|  3.84k|        if (enc->enc)
  157|  3.84k|            OPENSSL_free(enc->enc);
  158|  3.84k|        enc->enc = NULL;
  159|  3.84k|        enc->len = 0;
  160|  3.84k|        enc->modified = 1;
  161|  3.84k|    }
  162|  98.5k|}
asn1_enc_save:
  166|  69.6k|{
  167|  69.6k|    ASN1_ENCODING *enc;
  168|  69.6k|    enc = asn1_get_enc_ptr(pval, it);
  169|  69.6k|    if (!enc)
  170|  65.7k|        return 1;
  171|       |
  172|  3.84k|    if (enc->enc)
  173|      0|        OPENSSL_free(enc->enc);
  174|  3.84k|    enc->enc = OPENSSL_malloc(inlen);
  175|  3.84k|    if (!enc->enc)
  176|      0|        return 0;
  177|  3.84k|    memcpy(enc->enc, in, inlen);
  178|  3.84k|    enc->len = inlen;
  179|  3.84k|    enc->modified = 0;
  180|       |
  181|  3.84k|    return 1;
  182|  3.84k|}
asn1_enc_restore:
  186|  86.9k|{
  187|  86.9k|    ASN1_ENCODING *enc;
  188|  86.9k|    enc = asn1_get_enc_ptr(pval, it);
  189|  86.9k|    if (!enc || enc->modified)
  190|  86.9k|        return 0;
  191|      0|    if (out) {
  192|      0|        memcpy(*out, enc->enc, enc->len);
  193|      0|        *out += enc->len;
  194|      0|    }
  195|      0|    if (len)
  196|      0|        *len = enc->len;
  197|      0|    return 1;
  198|  86.9k|}
asn1_get_field_ptr:
  202|   911k|{
  203|   911k|    ASN1_VALUE **pvaltmp;
  204|   911k|    if (tt->flags & ASN1_TFLG_COMBINE)
  205|      0|        return pval;
  206|   911k|    pvaltmp = offset2ptr(*pval, tt->offset);
  207|       |    /*
  208|       |     * NOTE for BOOLEAN types the field is just a plain int so we can't
  209|       |     * return int **, so settle for (int *).
  210|       |     */
  211|   911k|    return pvaltmp;
  212|   911k|}
asn1_do_adb:
  221|   666k|{
  222|   666k|    const ASN1_ADB *adb;
  223|   666k|    const ASN1_ADB_TABLE *atbl;
  224|   666k|    long selector;
  225|   666k|    ASN1_VALUE **sfld;
  226|   666k|    int i;
  227|   666k|    if (!(tt->flags & ASN1_TFLG_ADB_MASK))
  228|   666k|        return tt;
  229|       |
  230|       |    /* Else ANY DEFINED BY ... get the table */
  231|      0|    adb = ASN1_ADB_ptr(tt->item);
  232|       |
  233|       |    /* Get the selector field */
  234|      0|    sfld = offset2ptr(*pval, adb->offset);
  235|       |
  236|       |    /* Check if NULL */
  237|      0|    if (*sfld == NULL) {
  238|      0|        if (!adb->null_tt)
  239|      0|            goto err;
  240|      0|        return adb->null_tt;
  241|      0|    }
  242|       |
  243|       |    /*
  244|       |     * Convert type to a long: NB: don't check for NID_undef here because it
  245|       |     * might be a legitimate value in the table
  246|       |     */
  247|      0|    if (tt->flags & ASN1_TFLG_ADB_OID)
  248|      0|        selector = OBJ_obj2nid((ASN1_OBJECT *)*sfld);
  249|      0|    else
  250|      0|        selector = ASN1_INTEGER_get((ASN1_INTEGER *)*sfld);
  251|       |
  252|       |    /*
  253|       |     * Try to find matching entry in table Maybe should check application
  254|       |     * types first to allow application override? Might also be useful to
  255|       |     * have a flag which indicates table is sorted and we can do a binary
  256|       |     * search. For now stick to a linear search.
  257|       |     */
  258|       |
  259|      0|    for (atbl = adb->tbl, i = 0; i < adb->tblcount; i++, atbl++)
  260|      0|        if (atbl->value == selector)
  261|      0|            return &atbl->tt;
  262|       |
  263|       |    /* FIXME: need to search application table too */
  264|       |
  265|       |    /* No match, return default type */
  266|      0|    if (!adb->default_tt)
  267|      0|        goto err;
  268|      0|    return adb->default_tt;
  269|       |
  270|      0| err:
  271|       |    /* FIXME: should log the value or OID of unsupported type */
  272|      0|    if (nullerr)
  273|      0|        ASN1err(ASN1_F_ASN1_DO_ADB, ASN1_R_UNSUPPORTED_ANY_DEFINED_BY_TYPE);
  274|      0|    return NULL;
  275|      0|}
tasn_utl.c:asn1_get_enc_ptr:
  130|   353k|{
  131|   353k|    const ASN1_AUX *aux;
  132|   353k|    if (!pval || !*pval)
  133|      0|        return NULL;
  134|   353k|    aux = it->funcs;
  135|   353k|    if (!aux || !(aux->flags & ASN1_AFLG_ENCODING))
  136|   342k|        return NULL;
  137|  11.5k|    return offset2ptr(*pval, aux->enc_offset);
  138|   353k|}

X509_INFO_new:
   66|  3.84k|{
   67|  3.84k|    X509_INFO *ret = NULL;
   68|       |
   69|  3.84k|    ret = (X509_INFO *)OPENSSL_malloc(sizeof(X509_INFO));
   70|  3.84k|    if (ret == NULL) {
   71|      0|        ASN1err(ASN1_F_X509_INFO_NEW, ERR_R_MALLOC_FAILURE);
   72|      0|        return (NULL);
   73|      0|    }
   74|       |
   75|  3.84k|    ret->enc_cipher.cipher = NULL;
   76|  3.84k|    ret->enc_len = 0;
   77|  3.84k|    ret->enc_data = NULL;
   78|       |
   79|  3.84k|    ret->references = 1;
   80|  3.84k|    ret->x509 = NULL;
   81|  3.84k|    ret->crl = NULL;
   82|  3.84k|    ret->x_pkey = NULL;
   83|  3.84k|    return (ret);
   84|  3.84k|}
X509_INFO_free:
   87|  3.84k|{
   88|  3.84k|    int i;
   89|       |
   90|  3.84k|    if (x == NULL)
   91|      0|        return;
   92|       |
   93|  3.84k|    i = CRYPTO_add(&x->references, -1, CRYPTO_LOCK_X509_INFO);
   94|       |#ifdef REF_PRINT
   95|       |    REF_PRINT("X509_INFO", x);
   96|       |#endif
   97|  3.84k|    if (i > 0)
   98|      0|        return;
   99|       |#ifdef REF_CHECK
  100|       |    if (i < 0) {
  101|       |        fprintf(stderr, "X509_INFO_free, bad reference count\n");
  102|       |        abort();
  103|       |    }
  104|       |#endif
  105|       |
  106|  3.84k|    if (x->x509 != NULL)
  107|  3.84k|        X509_free(x->x509);
  108|  3.84k|    if (x->crl != NULL)
  109|      0|        X509_CRL_free(x->crl);
  110|  3.84k|    if (x->x_pkey != NULL)
  111|      0|        X509_PKEY_free(x->x_pkey);
  112|  3.84k|    if (x->enc_data != NULL)
  113|      0|        OPENSSL_free(x->enc_data);
  114|  3.84k|    OPENSSL_free(x);
  115|  3.84k|}

x_name.c:x509_name_ex_new:
  141|  15.3k|{
  142|  15.3k|    X509_NAME *ret = NULL;
  143|  15.3k|    ret = OPENSSL_malloc(sizeof(X509_NAME));
  144|  15.3k|    if (!ret)
  145|      0|        goto memerr;
  146|  15.3k|    if ((ret->entries = sk_X509_NAME_ENTRY_new_null()) == NULL)
  147|      0|        goto memerr;
  148|  15.3k|    if ((ret->bytes = BUF_MEM_new()) == NULL)
  149|      0|        goto memerr;
  150|  15.3k|    ret->canon_enc = NULL;
  151|  15.3k|    ret->canon_enclen = 0;
  152|  15.3k|    ret->modified = 1;
  153|  15.3k|    *val = (ASN1_VALUE *)ret;
  154|  15.3k|    return 1;
  155|       |
  156|      0| memerr:
  157|      0|    ASN1err(ASN1_F_X509_NAME_EX_NEW, ERR_R_MALLOC_FAILURE);
  158|      0|    if (ret) {
  159|      0|        if (ret->entries)
  160|      0|            sk_X509_NAME_ENTRY_free(ret->entries);
  161|      0|        OPENSSL_free(ret);
  162|      0|    }
  163|      0|    return 0;
  164|  15.3k|}
x_name.c:x509_name_ex_free:
  167|  15.3k|{
  168|  15.3k|    X509_NAME *a;
  169|  15.3k|    if (!pval || !*pval)
  170|      0|        return;
  171|  15.3k|    a = (X509_NAME *)*pval;
  172|       |
  173|  15.3k|    BUF_MEM_free(a->bytes);
  174|  15.3k|    sk_X509_NAME_ENTRY_pop_free(a->entries, X509_NAME_ENTRY_free);
  175|  15.3k|    if (a->canon_enc)
  176|  7.68k|        OPENSSL_free(a->canon_enc);
  177|  15.3k|    OPENSSL_free(a);
  178|  15.3k|    *pval = NULL;
  179|  15.3k|}
x_name.c:x509_name_ex_d2i:
  195|  7.68k|{
  196|  7.68k|    const unsigned char *p = *in, *q;
  197|  7.68k|    union {
  198|  7.68k|        STACK_OF(STACK_OF_X509_NAME_ENTRY) *s;
  199|  7.68k|        ASN1_VALUE *a;
  200|  7.68k|    } intname = {
  201|  7.68k|        NULL
  202|  7.68k|    };
  203|  7.68k|    union {
  204|  7.68k|        X509_NAME *x;
  205|  7.68k|        ASN1_VALUE *a;
  206|  7.68k|    } nm = {
  207|  7.68k|        NULL
  208|  7.68k|    };
  209|  7.68k|    int i, j, ret;
  210|  7.68k|    STACK_OF(X509_NAME_ENTRY) *entries;
  211|  7.68k|    X509_NAME_ENTRY *entry;
  212|  7.68k|    if (len > X509_NAME_MAX)
  213|      0|        len = X509_NAME_MAX;
  214|  7.68k|    q = p;
  215|       |
  216|       |    /* Get internal representation of Name */
  217|  7.68k|    ret = ASN1_item_ex_d2i(&intname.a,
  218|  7.68k|                           &p, len, ASN1_ITEM_rptr(X509_NAME_INTERNAL),
  219|  7.68k|                           tag, aclass, opt, ctx);
  220|       |
  221|  7.68k|    if (ret <= 0)
  222|      0|        return ret;
  223|       |
  224|  7.68k|    if (*val)
  225|  7.68k|        x509_name_ex_free(val, NULL);
  226|  7.68k|    if (!x509_name_ex_new(&nm.a, NULL))
  227|      0|        goto err;
  228|       |    /* We've decoded it: now cache encoding */
  229|  7.68k|    if (!BUF_MEM_grow(nm.x->bytes, p - q))
  230|      0|        goto err;
  231|  7.68k|    memcpy(nm.x->bytes->data, q, p - q);
  232|       |
  233|       |    /* Convert internal representation to X509_NAME structure */
  234|  36.6k|    for (i = 0; i < sk_STACK_OF_X509_NAME_ENTRY_num(intname.s); i++) {
  235|  28.9k|        entries = sk_STACK_OF_X509_NAME_ENTRY_value(intname.s, i);
  236|  57.9k|        for (j = 0; j < sk_X509_NAME_ENTRY_num(entries); j++) {
  237|  28.9k|            entry = sk_X509_NAME_ENTRY_value(entries, j);
  238|  28.9k|            entry->set = i;
  239|  28.9k|            if (!sk_X509_NAME_ENTRY_push(nm.x->entries, entry))
  240|      0|                goto err;
  241|  28.9k|            sk_X509_NAME_ENTRY_set(entries, j, NULL);
  242|  28.9k|        }
  243|  28.9k|    }
  244|  7.68k|    ret = x509_name_canon(nm.x);
  245|  7.68k|    if (!ret)
  246|      0|        goto err;
  247|  7.68k|    sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
  248|  7.68k|                                         local_sk_X509_NAME_ENTRY_free);
  249|  7.68k|    nm.x->modified = 0;
  250|  7.68k|    *val = nm.a;
  251|  7.68k|    *in = p;
  252|  7.68k|    return ret;
  253|      0| err:
  254|      0|    if (nm.x != NULL)
  255|      0|        X509_NAME_free(nm.x);
  256|      0|    sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname.s,
  257|      0|                                         local_sk_X509_NAME_ENTRY_pop_free);
  258|      0|    ASN1err(ASN1_F_X509_NAME_EX_D2I, ERR_R_NESTED_ASN1_ERROR);
  259|      0|    return 0;
  260|  7.68k|}
x_name.c:x509_name_canon:
  353|  7.68k|{
  354|  7.68k|    unsigned char *p;
  355|  7.68k|    STACK_OF(STACK_OF_X509_NAME_ENTRY) *intname = NULL;
  356|  7.68k|    STACK_OF(X509_NAME_ENTRY) *entries = NULL;
  357|  7.68k|    X509_NAME_ENTRY *entry, *tmpentry = NULL;
  358|  7.68k|    int i, set = -1, ret = 0;
  359|       |
  360|  7.68k|    if (a->canon_enc) {
  361|      0|        OPENSSL_free(a->canon_enc);
  362|      0|        a->canon_enc = NULL;
  363|      0|    }
  364|       |    /* Special case: empty X509_NAME => null encoding */
  365|  7.68k|    if (sk_X509_NAME_ENTRY_num(a->entries) == 0) {
  366|      0|        a->canon_enclen = 0;
  367|      0|        return 1;
  368|      0|    }
  369|  7.68k|    intname = sk_STACK_OF_X509_NAME_ENTRY_new_null();
  370|  7.68k|    if (!intname)
  371|      0|        goto err;
  372|  36.6k|    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
  373|  28.9k|        entry = sk_X509_NAME_ENTRY_value(a->entries, i);
  374|  28.9k|        if (entry->set != set) {
  375|  28.9k|            entries = sk_X509_NAME_ENTRY_new_null();
  376|  28.9k|            if (!entries)
  377|      0|                goto err;
  378|  28.9k|            if (!sk_STACK_OF_X509_NAME_ENTRY_push(intname, entries)) {
  379|      0|                sk_X509_NAME_ENTRY_free(entries);
  380|      0|                goto err;
  381|      0|            }
  382|  28.9k|            set = entry->set;
  383|  28.9k|        }
  384|  28.9k|        tmpentry = X509_NAME_ENTRY_new();
  385|  28.9k|        if (!tmpentry)
  386|      0|            goto err;
  387|  28.9k|        tmpentry->object = OBJ_dup(entry->object);
  388|  28.9k|        if (!asn1_string_canon(tmpentry->value, entry->value))
  389|      0|            goto err;
  390|  28.9k|        if (!sk_X509_NAME_ENTRY_push(entries, tmpentry))
  391|      0|            goto err;
  392|  28.9k|        tmpentry = NULL;
  393|  28.9k|    }
  394|       |
  395|       |    /* Finally generate encoding */
  396|       |
  397|  7.68k|    a->canon_enclen = i2d_name_canon(intname, NULL);
  398|       |
  399|  7.68k|    p = OPENSSL_malloc(a->canon_enclen);
  400|       |
  401|  7.68k|    if (!p)
  402|      0|        goto err;
  403|       |
  404|  7.68k|    a->canon_enc = p;
  405|       |
  406|  7.68k|    i2d_name_canon(intname, &p);
  407|       |
  408|  7.68k|    ret = 1;
  409|       |
  410|  7.68k| err:
  411|       |
  412|  7.68k|    if (tmpentry)
  413|      0|        X509_NAME_ENTRY_free(tmpentry);
  414|  7.68k|    if (intname)
  415|  7.68k|        sk_STACK_OF_X509_NAME_ENTRY_pop_free(intname,
  416|  7.68k|                                             local_sk_X509_NAME_ENTRY_pop_free);
  417|  7.68k|    return ret;
  418|  7.68k|}
x_name.c:asn1_string_canon:
  428|  28.9k|{
  429|  28.9k|    unsigned char *to, *from;
  430|  28.9k|    int len, i;
  431|       |
  432|       |    /* If type not in bitmask just copy string across */
  433|  28.9k|    if (!(ASN1_tag2bit(in->type) & ASN1_MASK_CANON)) {
  434|      0|        if (!ASN1_STRING_copy(out, in))
  435|      0|            return 0;
  436|      0|        return 1;
  437|      0|    }
  438|       |
  439|  28.9k|    out->type = V_ASN1_UTF8STRING;
  440|  28.9k|    out->length = ASN1_STRING_to_UTF8(&out->data, in);
  441|  28.9k|    if (out->length == -1)
  442|      0|        return 0;
  443|       |
  444|  28.9k|    to = out->data;
  445|  28.9k|    from = to;
  446|       |
  447|  28.9k|    len = out->length;
  448|       |
  449|       |    /*
  450|       |     * Convert string in place to canonical form. Ultimately we may need to
  451|       |     * handle a wider range of characters but for now ignore anything with
  452|       |     * MSB set and rely on the isspace() and tolower() functions.
  453|       |     */
  454|       |
  455|       |    /* Ignore leading spaces */
  456|  28.9k|    while ((len > 0) && !(*from & 0x80) && isspace(*from)) {
  457|      0|        from++;
  458|      0|        len--;
  459|      0|    }
  460|       |
  461|  28.9k|    to = from + len - 1;
  462|       |
  463|       |    /* Ignore trailing spaces */
  464|  28.9k|    while ((len > 0) && !(*to & 0x80) && isspace(*to)) {
  465|      0|        to--;
  466|      0|        len--;
  467|      0|    }
  468|       |
  469|  28.9k|    to = out->data;
  470|       |
  471|  28.9k|    i = 0;
  472|   513k|    while (i < len) {
  473|       |        /* If MSB set just copy across */
  474|   484k|        if (*from & 0x80) {
  475|  1.32k|            *to++ = *from++;
  476|  1.32k|            i++;
  477|  1.32k|        }
  478|       |        /* Collapse multiple spaces */
  479|   482k|        else if (isspace(*from)) {
  480|       |            /* Copy one space across */
  481|  45.7k|            *to++ = ' ';
  482|       |            /*
  483|       |             * Ignore subsequent spaces. Note: don't need to check len here
  484|       |             * because we know the last character is a non-space so we can't
  485|       |             * overflow.
  486|       |             */
  487|  45.7k|            do {
  488|  45.7k|                from++;
  489|  45.7k|                i++;
  490|  45.7k|            }
  491|  45.7k|            while (!(*from & 0x80) && isspace(*from));
  492|   437k|        } else {
  493|   437k|            *to++ = tolower(*from);
  494|   437k|            from++;
  495|   437k|            i++;
  496|   437k|        }
  497|   484k|    }
  498|       |
  499|  28.9k|    out->length = to - out->data;
  500|       |
  501|  28.9k|    return 1;
  502|       |
  503|  28.9k|}
x_name.c:i2d_name_canon:
  507|  15.3k|{
  508|  15.3k|    int i, len, ltmp;
  509|  15.3k|    ASN1_VALUE *v;
  510|  15.3k|    STACK_OF(ASN1_VALUE) *intname = (STACK_OF(ASN1_VALUE) *)_intname;
  511|       |
  512|  15.3k|    len = 0;
  513|  73.3k|    for (i = 0; i < sk_ASN1_VALUE_num(intname); i++) {
  514|  57.9k|        v = sk_ASN1_VALUE_value(intname, i);
  515|  57.9k|        ltmp = ASN1_item_ex_i2d(&v, in,
  516|  57.9k|                                ASN1_ITEM_rptr(X509_NAME_ENTRIES), -1, -1);
  517|  57.9k|        if (ltmp < 0)
  518|      0|            return ltmp;
  519|  57.9k|        len += ltmp;
  520|  57.9k|    }
  521|  15.3k|    return len;
  522|  15.3k|}
x_name.c:local_sk_X509_NAME_ENTRY_free:
  182|  28.9k|{
  183|  28.9k|    sk_X509_NAME_ENTRY_free(ne);
  184|  28.9k|}
x_name.c:local_sk_X509_NAME_ENTRY_pop_free:
  187|  28.9k|{
  188|  28.9k|    sk_X509_NAME_ENTRY_pop_free(ne, X509_NAME_ENTRY_free);
  189|  28.9k|}

x_pubkey.c:pubkey_cb:
   74|  23.0k|{
   75|  23.0k|    if (operation == ASN1_OP_FREE_POST) {
   76|  3.84k|        X509_PUBKEY *pubkey = (X509_PUBKEY *)*pval;
   77|  3.84k|        EVP_PKEY_free(pubkey->pkey);
   78|  3.84k|    }
   79|  23.0k|    return 1;
   80|  23.0k|}

x_x509.c:x509_cb:
   86|  23.0k|{
   87|  23.0k|    X509 *ret = (X509 *)*pval;
   88|       |
   89|  23.0k|    switch (operation) {
   90|       |
   91|  3.84k|    case ASN1_OP_NEW_POST:
   92|  3.84k|        ret->valid = 0;
   93|  3.84k|        ret->name = NULL;
   94|  3.84k|        ret->ex_flags = 0;
   95|  3.84k|        ret->ex_pathlen = -1;
   96|  3.84k|        ret->skid = NULL;
   97|  3.84k|        ret->akid = NULL;
   98|       |#ifndef OPENSSL_NO_RFC3779
   99|       |        ret->rfc3779_addr = NULL;
  100|       |        ret->rfc3779_asid = NULL;
  101|       |#endif
  102|  3.84k|        ret->aux = NULL;
  103|  3.84k|        ret->crldp = NULL;
  104|  3.84k|        CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509, ret, &ret->ex_data);
  105|  3.84k|        break;
  106|       |
  107|  3.84k|    case ASN1_OP_D2I_POST:
  108|  3.84k|        if (ret->name != NULL)
  109|      0|            OPENSSL_free(ret->name);
  110|  3.84k|        ret->name = X509_NAME_oneline(ret->cert_info->subject, NULL, 0);
  111|  3.84k|        break;
  112|       |
  113|  3.84k|    case ASN1_OP_FREE_POST:
  114|  3.84k|        CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509, ret, &ret->ex_data);
  115|  3.84k|        X509_CERT_AUX_free(ret->aux);
  116|  3.84k|        ASN1_OCTET_STRING_free(ret->skid);
  117|  3.84k|        AUTHORITY_KEYID_free(ret->akid);
  118|  3.84k|        CRL_DIST_POINTS_free(ret->crldp);
  119|  3.84k|        policy_cache_free(ret->policy_cache);
  120|  3.84k|        GENERAL_NAMES_free(ret->altname);
  121|  3.84k|        NAME_CONSTRAINTS_free(ret->nc);
  122|       |#ifndef OPENSSL_NO_RFC3779
  123|       |        sk_IPAddressFamily_pop_free(ret->rfc3779_addr, IPAddressFamily_free);
  124|       |        ASIdentifiers_free(ret->rfc3779_asid);
  125|       |#endif
  126|       |
  127|  3.84k|        if (ret->name != NULL)
  128|  3.84k|            OPENSSL_free(ret->name);
  129|  3.84k|        break;
  130|       |
  131|  23.0k|    }
  132|       |
  133|  23.0k|    return 1;
  134|       |
  135|  23.0k|}

BIO_snprintf:
  839|    210|{
  840|    210|    va_list args;
  841|    210|    int ret;
  842|       |
  843|    210|    va_start(args, format);
  844|       |
  845|    210|    ret = BIO_vsnprintf(buf, n, format, args);
  846|       |
  847|    210|    va_end(args);
  848|    210|    return (ret);
  849|    210|}
BIO_vsnprintf:
  852|    210|{
  853|    210|    size_t retlen;
  854|    210|    int truncated;
  855|       |
  856|    210|    if(!_dopr(&buf, NULL, &n, &retlen, &truncated, format, args))
  857|      0|        return -1;
  858|       |
  859|    210|    if (truncated)
  860|       |        /*
  861|       |         * In case of truncation, return -1 like traditional snprintf.
  862|       |         * (Current drafts for ISO/IEC 9899 say snprintf should return the
  863|       |         * number of characters that would have been written, had the buffer
  864|       |         * been large enough.)
  865|       |         */
  866|      0|        return -1;
  867|    210|    else
  868|    210|        return (retlen <= INT_MAX) ? (int)retlen : -1;
  869|    210|}
b_print.c:_dopr:
  173|    210|{
  174|    210|    char ch;
  175|    210|    LLONG value;
  176|    210|    LDOUBLE fvalue;
  177|    210|    char *strvalue;
  178|    210|    int min;
  179|    210|    int max;
  180|    210|    int state;
  181|    210|    int flags;
  182|    210|    int cflags;
  183|    210|    size_t currlen;
  184|       |
  185|    210|    state = DP_S_DEFAULT;
  186|    210|    flags = currlen = cflags = min = 0;
  187|    210|    max = -1;
  188|    210|    ch = *format++;
  189|       |
  190|  3.21k|    while (state != DP_S_DONE) {
  191|  3.00k|        if (ch == '\0' || (buffer == NULL && currlen >= *maxlen))
  192|    210|            state = DP_S_DONE;
  193|       |
  194|  3.00k|        switch (state) {
  195|  1.23k|        case DP_S_DEFAULT:
  196|  1.23k|            if (ch == '%')
  197|    300|                state = DP_S_FLAGS;
  198|    930|            else
  199|    930|                if(!doapr_outch(sbuffer, buffer, &currlen, maxlen, ch))
  200|      0|                    return 0;
  201|  1.23k|            ch = *format++;
  202|  1.23k|            break;
  203|    330|        case DP_S_FLAGS:
  204|    330|            switch (ch) {
  205|      0|            case '-':
  206|      0|                flags |= DP_F_MINUS;
  207|      0|                ch = *format++;
  208|      0|                break;
  209|      0|            case '+':
  210|      0|                flags |= DP_F_PLUS;
  211|      0|                ch = *format++;
  212|      0|                break;
  213|      0|            case ' ':
  214|      0|                flags |= DP_F_SPACE;
  215|      0|                ch = *format++;
  216|      0|                break;
  217|      0|            case '#':
  218|      0|                flags |= DP_F_NUM;
  219|      0|                ch = *format++;
  220|      0|                break;
  221|     30|            case '0':
  222|     30|                flags |= DP_F_ZERO;
  223|     30|                ch = *format++;
  224|     30|                break;
  225|    300|            default:
  226|    300|                state = DP_S_MIN;
  227|    300|                break;
  228|    330|            }
  229|    330|            break;
  230|    330|        case DP_S_MIN:
  231|    330|            if (isdigit((unsigned char)ch)) {
  232|     30|                min = 10 * min + char_to_int(ch);
  233|     30|                ch = *format++;
  234|    300|            } else if (ch == '*') {
  235|      0|                min = va_arg(args, int);
  236|      0|                ch = *format++;
  237|      0|                state = DP_S_DOT;
  238|      0|            } else
  239|    300|                state = DP_S_DOT;
  240|    330|            break;
  241|    300|        case DP_S_DOT:
  242|    300|            if (ch == '.') {
  243|      0|                state = DP_S_MAX;
  244|      0|                ch = *format++;
  245|      0|            } else
  246|    300|                state = DP_S_MOD;
  247|    300|            break;
  248|      0|        case DP_S_MAX:
  249|      0|            if (isdigit((unsigned char)ch)) {
  250|      0|                if (max < 0)
  251|      0|                    max = 0;
  252|      0|                max = 10 * max + char_to_int(ch);
  253|      0|                ch = *format++;
  254|      0|            } else if (ch == '*') {
  255|      0|                max = va_arg(args, int);
  256|      0|                ch = *format++;
  257|      0|                state = DP_S_MOD;
  258|      0|            } else
  259|      0|                state = DP_S_MOD;
  260|      0|            break;
  261|    300|        case DP_S_MOD:
  262|    300|            switch (ch) {
  263|      0|            case 'h':
  264|      0|                cflags = DP_C_SHORT;
  265|      0|                ch = *format++;
  266|      0|                break;
  267|    210|            case 'l':
  268|    210|                if (*format == 'l') {
  269|      0|                    cflags = DP_C_LLONG;
  270|      0|                    format++;
  271|      0|                } else
  272|    210|                    cflags = DP_C_LONG;
  273|    210|                ch = *format++;
  274|    210|                break;
  275|      0|            case 'q':
  276|      0|                cflags = DP_C_LLONG;
  277|      0|                ch = *format++;
  278|      0|                break;
  279|      0|            case 'L':
  280|      0|                cflags = DP_C_LDOUBLE;
  281|      0|                ch = *format++;
  282|      0|                break;
  283|     90|            default:
  284|     90|                break;
  285|    300|            }
  286|    300|            state = DP_S_CONV;
  287|    300|            break;
  288|    300|        case DP_S_CONV:
  289|    300|            switch (ch) {
  290|      0|            case 'd':
  291|      0|            case 'i':
  292|      0|                switch (cflags) {
  293|      0|                case DP_C_SHORT:
  294|      0|                    value = (short int)va_arg(args, int);
  295|      0|                    break;
  296|      0|                case DP_C_LONG:
  297|      0|                    value = va_arg(args, long int);
  298|      0|                    break;
  299|      0|                case DP_C_LLONG:
  300|      0|                    value = va_arg(args, LLONG);
  301|      0|                    break;
  302|      0|                default:
  303|      0|                    value = va_arg(args, int);
  304|      0|                    break;
  305|      0|                }
  306|      0|                if (!fmtint(sbuffer, buffer, &currlen, maxlen, value, 10, min,
  307|      0|                            max, flags))
  308|      0|                    return 0;
  309|      0|                break;
  310|     30|            case 'X':
  311|     30|                flags |= DP_F_UP;
  312|       |                /* FALLTHROUGH */
  313|     30|            case 'x':
  314|     30|            case 'o':
  315|    210|            case 'u':
  316|    210|                flags |= DP_F_UNSIGNED;
  317|    210|                switch (cflags) {
  318|      0|                case DP_C_SHORT:
  319|      0|                    value = (unsigned short int)va_arg(args, unsigned int);
  320|      0|                    break;
  321|    210|                case DP_C_LONG:
  322|    210|                    value = (LLONG) va_arg(args, unsigned long int);
  323|    210|                    break;
  324|      0|                case DP_C_LLONG:
  325|      0|                    value = va_arg(args, unsigned LLONG);
  326|      0|                    break;
  327|      0|                default:
  328|      0|                    value = (LLONG) va_arg(args, unsigned int);
  329|      0|                    break;
  330|    210|                }
  331|    210|                if (!fmtint(sbuffer, buffer, &currlen, maxlen, value,
  332|    210|                            ch == 'o' ? 8 : (ch == 'u' ? 10 : 16),
  333|    210|                            min, max, flags))
  334|      0|                    return 0;
  335|    210|                break;
  336|    210|            case 'f':
  337|      0|                if (cflags == DP_C_LDOUBLE)
  338|      0|                    fvalue = va_arg(args, LDOUBLE);
  339|      0|                else
  340|      0|                    fvalue = va_arg(args, double);
  341|      0|                if (!fmtfp(sbuffer, buffer, &currlen, maxlen, fvalue, min, max,
  342|      0|                           flags))
  343|      0|                    return 0;
  344|      0|                break;
  345|      0|            case 'E':
  346|      0|                flags |= DP_F_UP;
  347|      0|            case 'e':
  348|      0|                if (cflags == DP_C_LDOUBLE)
  349|      0|                    fvalue = va_arg(args, LDOUBLE);
  350|      0|                else
  351|      0|                    fvalue = va_arg(args, double);
  352|      0|                break;
  353|      0|            case 'G':
  354|      0|                flags |= DP_F_UP;
  355|      0|            case 'g':
  356|      0|                if (cflags == DP_C_LDOUBLE)
  357|      0|                    fvalue = va_arg(args, LDOUBLE);
  358|      0|                else
  359|      0|                    fvalue = va_arg(args, double);
  360|      0|                break;
  361|      0|            case 'c':
  362|      0|                if(!doapr_outch(sbuffer, buffer, &currlen, maxlen,
  363|      0|                            va_arg(args, int)))
  364|      0|                    return 0;
  365|      0|                break;
  366|     90|            case 's':
  367|     90|                strvalue = va_arg(args, char *);
  368|     90|                if (max < 0) {
  369|     90|                    if (buffer)
  370|      0|                        max = INT_MAX;
  371|     90|                    else
  372|     90|                        max = *maxlen;
  373|     90|                }
  374|     90|                if (!fmtstr(sbuffer, buffer, &currlen, maxlen, strvalue,
  375|     90|                            flags, min, max))
  376|      0|                    return 0;
  377|     90|                break;
  378|     90|            case 'p':
  379|      0|                value = (long)va_arg(args, void *);
  380|      0|                if (!fmtint(sbuffer, buffer, &currlen, maxlen,
  381|      0|                            value, 16, min, max, flags | DP_F_NUM))
  382|      0|                    return 0;
  383|      0|                break;
  384|      0|            case 'n':          /* XXX */
  385|      0|                if (cflags == DP_C_SHORT) {
  386|      0|                    short int *num;
  387|      0|                    num = va_arg(args, short int *);
  388|      0|                    *num = currlen;
  389|      0|                } else if (cflags == DP_C_LONG) { /* XXX */
  390|      0|                    long int *num;
  391|      0|                    num = va_arg(args, long int *);
  392|      0|                    *num = (long int)currlen;
  393|      0|                } else if (cflags == DP_C_LLONG) { /* XXX */
  394|      0|                    LLONG *num;
  395|      0|                    num = va_arg(args, LLONG *);
  396|      0|                    *num = (LLONG) currlen;
  397|      0|                } else {
  398|      0|                    int *num;
  399|      0|                    num = va_arg(args, int *);
  400|      0|                    *num = currlen;
  401|      0|                }
  402|      0|                break;
  403|      0|            case '%':
  404|      0|                if(!doapr_outch(sbuffer, buffer, &currlen, maxlen, ch))
  405|      0|                    return 0;
  406|      0|                break;
  407|      0|            case 'w':
  408|       |                /* not supported yet, treat as next char */
  409|      0|                ch = *format++;
  410|      0|                break;
  411|      0|            default:
  412|       |                /* unknown, skip */
  413|      0|                break;
  414|    300|            }
  415|    300|            ch = *format++;
  416|    300|            state = DP_S_DEFAULT;
  417|    300|            flags = cflags = min = 0;
  418|    300|            max = -1;
  419|    300|            break;
  420|    210|        case DP_S_DONE:
  421|    210|            break;
  422|      0|        default:
  423|      0|            break;
  424|  3.00k|        }
  425|  3.00k|    }
  426|       |    /*
  427|       |     * We have to truncate if there is no dynamic buffer and we have filled the
  428|       |     * static buffer.
  429|       |     */
  430|    210|    if (buffer == NULL) {
  431|    210|        *truncated = (currlen > *maxlen - 1);
  432|    210|        if (*truncated)
  433|      0|            currlen = *maxlen - 1;
  434|    210|    }
  435|    210|    if(!doapr_outch(sbuffer, buffer, &currlen, maxlen, '\0'))
  436|      0|        return 0;
  437|    210|    *retlen = currlen - 1;
  438|    210|    return 1;
  439|    210|}
b_print.c:doapr_outch:
  748|  2.25k|{
  749|       |    /* If we haven't at least one buffer, someone has doe a big booboo */
  750|  2.25k|    assert(*sbuffer != NULL || buffer != NULL);
  751|       |
  752|       |    /* |currlen| must always be <= |*maxlen| */
  753|  2.25k|    assert(*currlen <= *maxlen);
  754|       |
  755|  2.25k|    if (buffer && *currlen == *maxlen) {
  756|      0|        if (*maxlen > INT_MAX - BUFFER_INC)
  757|      0|            return 0;
  758|       |
  759|      0|        *maxlen += BUFFER_INC;
  760|      0|        if (*buffer == NULL) {
  761|      0|            *buffer = OPENSSL_malloc(*maxlen);
  762|      0|            if (*buffer == NULL)
  763|      0|                return 0;
  764|      0|            if (*currlen > 0) {
  765|      0|                assert(*sbuffer != NULL);
  766|      0|                memcpy(*buffer, *sbuffer, *currlen);
  767|      0|            }
  768|      0|            *sbuffer = NULL;
  769|      0|        } else {
  770|      0|            char *tmpbuf;
  771|      0|            tmpbuf = OPENSSL_realloc(*buffer, *maxlen);
  772|      0|            if (tmpbuf == NULL)
  773|      0|                return 0;
  774|      0|            *buffer = tmpbuf;
  775|      0|        }
  776|      0|    }
  777|       |
  778|  2.25k|    if (*currlen < *maxlen) {
  779|  2.25k|        if (*sbuffer)
  780|  2.25k|            (*sbuffer)[(*currlen)++] = (char)c;
  781|      0|        else
  782|      0|            (*buffer)[(*currlen)++] = (char)c;
  783|  2.25k|    }
  784|       |
  785|  2.25k|    return 1;
  786|  2.25k|}
b_print.c:fmtint:
  489|    210|{
  490|    210|    int signvalue = 0;
  491|    210|    const char *prefix = "";
  492|    210|    unsigned LLONG uvalue;
  493|    210|    char convert[DECIMAL_SIZE(value) + 3];
  494|    210|    int place = 0;
  495|    210|    int spadlen = 0;
  496|    210|    int zpadlen = 0;
  497|    210|    int caps = 0;
  498|       |
  499|    210|    if (max < 0)
  500|    210|        max = 0;
  501|    210|    uvalue = value;
  502|    210|    if (!(flags & DP_F_UNSIGNED)) {
  503|      0|        if (value < 0) {
  504|      0|            signvalue = '-';
  505|      0|            uvalue = -(unsigned LLONG)value;
  506|      0|        } else if (flags & DP_F_PLUS)
  507|      0|            signvalue = '+';
  508|      0|        else if (flags & DP_F_SPACE)
  509|      0|            signvalue = ' ';
  510|      0|    }
  511|    210|    if (flags & DP_F_NUM) {
  512|      0|        if (base == 8)
  513|      0|            prefix = "0";
  514|      0|        if (base == 16)
  515|      0|            prefix = "0x";
  516|      0|    }
  517|    210|    if (flags & DP_F_UP)
  518|     30|        caps = 1;
  519|    240|    do {
  520|    240|        convert[place++] = (caps ? "0123456789ABCDEF" : "0123456789abcdef")
  521|    240|            [uvalue % (unsigned)base];
  522|    240|        uvalue = (uvalue / (unsigned)base);
  523|    240|    } while (uvalue && (place < (int)sizeof(convert)));
  524|    210|    if (place == sizeof(convert))
  525|      0|        place--;
  526|    210|    convert[place] = 0;
  527|       |
  528|    210|    zpadlen = max - place;
  529|    210|    spadlen =
  530|    210|        min - OSSL_MAX(max, place) - (signvalue ? 1 : 0) - strlen(prefix);
  531|    210|    if (zpadlen < 0)
  532|    210|        zpadlen = 0;
  533|    210|    if (spadlen < 0)
  534|    180|        spadlen = 0;
  535|    210|    if (flags & DP_F_ZERO) {
  536|     30|        zpadlen = OSSL_MAX(zpadlen, spadlen);
  537|     30|        spadlen = 0;
  538|     30|    }
  539|    210|    if (flags & DP_F_MINUS)
  540|      0|        spadlen = -spadlen;
  541|       |
  542|       |    /* spaces */
  543|    210|    while (spadlen > 0) {
  544|      0|        if(!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))
  545|      0|            return 0;
  546|      0|        --spadlen;
  547|      0|    }
  548|       |
  549|       |    /* sign */
  550|    210|    if (signvalue)
  551|      0|        if(!doapr_outch(sbuffer, buffer, currlen, maxlen, signvalue))
  552|      0|            return 0;
  553|       |
  554|       |    /* prefix */
  555|    210|    while (*prefix) {
  556|      0|        if(!doapr_outch(sbuffer, buffer, currlen, maxlen, *prefix))
  557|      0|            return 0;
  558|      0|        prefix++;
  559|      0|    }
  560|       |
  561|       |    /* zeros */
  562|    210|    if (zpadlen > 0) {
  563|    240|        while (zpadlen > 0) {
  564|    210|            if(!doapr_outch(sbuffer, buffer, currlen, maxlen, '0'))
  565|      0|                return 0;
  566|    210|            --zpadlen;
  567|    210|        }
  568|     30|    }
  569|       |    /* digits */
  570|    450|    while (place > 0) {
  571|    240|        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, convert[--place]))
  572|      0|            return 0;
  573|    240|    }
  574|       |
  575|       |    /* left justified spaces */
  576|    210|    while (spadlen < 0) {
  577|      0|        if (!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))
  578|      0|            return 0;
  579|      0|        ++spadlen;
  580|      0|    }
  581|    210|    return 1;
  582|    210|}
b_print.c:fmtstr:
  446|     90|{
  447|     90|    int padlen;
  448|     90|    size_t strln;
  449|     90|    int cnt = 0;
  450|       |
  451|     90|    if (value == 0)
  452|      0|        value = "<NULL>";
  453|       |
  454|     90|    strln = strlen(value);
  455|     90|    if (strln > INT_MAX)
  456|      0|        strln = INT_MAX;
  457|       |
  458|     90|    padlen = min - strln;
  459|     90|    if (min < 0 || padlen < 0)
  460|     90|        padlen = 0;
  461|     90|    if (flags & DP_F_MINUS)
  462|      0|        padlen = -padlen;
  463|       |
  464|     90|    while ((padlen > 0) && (cnt < max)) {
  465|      0|        if(!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))
  466|      0|            return 0;
  467|      0|        --padlen;
  468|      0|        ++cnt;
  469|      0|    }
  470|    750|    while (*value && (cnt < max)) {
  471|    660|        if(!doapr_outch(sbuffer, buffer, currlen, maxlen, *value++))
  472|      0|            return 0;
  473|    660|        ++cnt;
  474|    660|    }
  475|     90|    while ((padlen < 0) && (cnt < max)) {
  476|      0|        if(!doapr_outch(sbuffer, buffer, currlen, maxlen, ' '))
  477|      0|            return 0;
  478|      0|        ++padlen;
  479|      0|        ++cnt;
  480|      0|    }
  481|     90|    return 1;
  482|     90|}

ERR_load_BIO_strings:
  149|      1|{
  150|      1|#ifndef OPENSSL_NO_ERR
  151|       |
  152|      1|    if (ERR_func_error_string(BIO_str_functs[0].error) == NULL) {
  153|      1|        ERR_load_strings(0, BIO_str_functs);
  154|      1|        ERR_load_strings(0, BIO_str_reasons);
  155|      1|    }
  156|      1|#endif
  157|      1|}

BIO_new:
   67|     90|{
   68|     90|    BIO *ret = NULL;
   69|       |
   70|     90|    ret = (BIO *)OPENSSL_malloc(sizeof(BIO));
   71|     90|    if (ret == NULL) {
   72|      0|        BIOerr(BIO_F_BIO_NEW, ERR_R_MALLOC_FAILURE);
   73|      0|        return (NULL);
   74|      0|    }
   75|     90|    if (!BIO_set(ret, method)) {
   76|      0|        OPENSSL_free(ret);
   77|      0|        ret = NULL;
   78|      0|    }
   79|     90|    return (ret);
   80|     90|}
BIO_set:
   83|     90|{
   84|     90|    bio->method = method;
   85|     90|    bio->callback = NULL;
   86|     90|    bio->cb_arg = NULL;
   87|     90|    bio->init = 0;
   88|     90|    bio->shutdown = 1;
   89|     90|    bio->flags = 0;
   90|     90|    bio->retry_reason = 0;
   91|     90|    bio->num = 0;
   92|     90|    bio->ptr = NULL;
   93|     90|    bio->prev_bio = NULL;
   94|     90|    bio->next_bio = NULL;
   95|     90|    bio->references = 1;
   96|     90|    bio->num_read = 0L;
   97|     90|    bio->num_write = 0L;
   98|     90|    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
   99|     90|    if (method->create != NULL)
  100|     90|        if (!method->create(bio)) {
  101|      0|            CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, bio, &bio->ex_data);
  102|      0|            return (0);
  103|      0|        }
  104|     90|    return (1);
  105|     90|}
BIO_free:
  108|     90|{
  109|     90|    int i;
  110|       |
  111|     90|    if (a == NULL)
  112|      0|        return (0);
  113|       |
  114|     90|    i = CRYPTO_add(&a->references, -1, CRYPTO_LOCK_BIO);
  115|       |#ifdef REF_PRINT
  116|       |    REF_PRINT("BIO", a);
  117|       |#endif
  118|     90|    if (i > 0)
  119|      0|        return (1);
  120|       |#ifdef REF_CHECK
  121|       |    if (i < 0) {
  122|       |        fprintf(stderr, "BIO_free, bad reference count\n");
  123|       |        abort();
  124|       |    }
  125|       |#endif
  126|     90|    if ((a->callback != NULL) &&
  127|     90|        ((i = (int)a->callback(a, BIO_CB_FREE, NULL, 0, 0L, 1L)) <= 0))
  128|      0|        return (i);
  129|       |
  130|     90|    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_BIO, a, &a->ex_data);
  131|       |
  132|     90|    if ((a->method != NULL) && (a->method->destroy != NULL))
  133|     90|        a->method->destroy(a);
  134|     90|    OPENSSL_free(a);
  135|     90|    return (1);
  136|     90|}
BIO_clear_flags:
  144|    150|{
  145|    150|    b->flags &= ~flags;
  146|    150|}
BIO_read:
  191|     60|{
  192|     60|    int i;
  193|     60|    long (*cb) (BIO *, int, const char *, int, long, long);
  194|       |
  195|     60|    if ((b == NULL) || (b->method == NULL) || (b->method->bread == NULL)) {
  196|      0|        BIOerr(BIO_F_BIO_READ, BIO_R_UNSUPPORTED_METHOD);
  197|      0|        return (-2);
  198|      0|    }
  199|       |
  200|     60|    cb = b->callback;
  201|     60|    if ((cb != NULL) &&
  202|     60|        ((i = (int)cb(b, BIO_CB_READ, out, outl, 0L, 1L)) <= 0))
  203|      0|        return (i);
  204|       |
  205|     60|    if (!b->init) {
  206|      0|        BIOerr(BIO_F_BIO_READ, BIO_R_UNINITIALIZED);
  207|      0|        return (-2);
  208|      0|    }
  209|       |
  210|     60|    i = b->method->bread(b, out, outl);
  211|       |
  212|     60|    if (i > 0)
  213|      0|        b->num_read += (unsigned long)i;
  214|       |
  215|     60|    if (cb != NULL)
  216|      0|        i = (int)cb(b, BIO_CB_READ | BIO_CB_RETURN, out, outl, 0L, (long)i);
  217|     60|    return (i);
  218|     60|}
BIO_write:
  221|     60|{
  222|     60|    int i;
  223|     60|    long (*cb) (BIO *, int, const char *, int, long, long);
  224|       |
  225|     60|    if (b == NULL)
  226|      0|        return (0);
  227|       |
  228|     60|    cb = b->callback;
  229|     60|    if ((b->method == NULL) || (b->method->bwrite == NULL)) {
  230|      0|        BIOerr(BIO_F_BIO_WRITE, BIO_R_UNSUPPORTED_METHOD);
  231|      0|        return (-2);
  232|      0|    }
  233|       |
  234|     60|    if ((cb != NULL) &&
  235|     60|        ((i = (int)cb(b, BIO_CB_WRITE, in, inl, 0L, 1L)) <= 0))
  236|      0|        return (i);
  237|       |
  238|     60|    if (!b->init) {
  239|      0|        BIOerr(BIO_F_BIO_WRITE, BIO_R_UNINITIALIZED);
  240|      0|        return (-2);
  241|      0|    }
  242|       |
  243|     60|    i = b->method->bwrite(b, in, inl);
  244|       |
  245|     60|    if (i > 0)
  246|     60|        b->num_write += (unsigned long)i;
  247|       |
  248|     60|    if (cb != NULL)
  249|      0|        i = (int)cb(b, BIO_CB_WRITE | BIO_CB_RETURN, in, inl, 0L, (long)i);
  250|     60|    return (i);
  251|     60|}
BIO_gets:
  284|  98.2k|{
  285|  98.2k|    int i;
  286|  98.2k|    long (*cb) (BIO *, int, const char *, int, long, long);
  287|       |
  288|  98.2k|    if ((b == NULL) || (b->method == NULL) || (b->method->bgets == NULL)) {
  289|      0|        BIOerr(BIO_F_BIO_GETS, BIO_R_UNSUPPORTED_METHOD);
  290|      0|        return (-2);
  291|      0|    }
  292|       |
  293|  98.2k|    cb = b->callback;
  294|       |
  295|  98.2k|    if ((cb != NULL) && ((i = (int)cb(b, BIO_CB_GETS, in, inl, 0L, 1L)) <= 0))
  296|      0|        return (i);
  297|       |
  298|  98.2k|    if (!b->init) {
  299|      0|        BIOerr(BIO_F_BIO_GETS, BIO_R_UNINITIALIZED);
  300|      0|        return (-2);
  301|      0|    }
  302|       |
  303|  98.2k|    i = b->method->bgets(b, in, inl);
  304|       |
  305|  98.2k|    if (cb != NULL)
  306|      0|        i = (int)cb(b, BIO_CB_GETS | BIO_CB_RETURN, in, inl, 0L, (long)i);
  307|  98.2k|    return (i);
  308|  98.2k|}
BIO_int_ctrl:
  323|     30|{
  324|     30|    int i;
  325|       |
  326|     30|    i = iarg;
  327|     30|    return (BIO_ctrl(b, cmd, larg, (char *)&i));
  328|     30|}
BIO_ctrl:
  341|     90|{
  342|     90|    long ret;
  343|     90|    long (*cb) (BIO *, int, const char *, int, long, long);
  344|       |
  345|     90|    if (b == NULL)
  346|      0|        return (0);
  347|       |
  348|     90|    if ((b->method == NULL) || (b->method->ctrl == NULL)) {
  349|      0|        BIOerr(BIO_F_BIO_CTRL, BIO_R_UNSUPPORTED_METHOD);
  350|      0|        return (-2);
  351|      0|    }
  352|       |
  353|     90|    cb = b->callback;
  354|       |
  355|     90|    if ((cb != NULL) &&
  356|     90|        ((ret = cb(b, BIO_CB_CTRL, parg, cmd, larg, 1L)) <= 0))
  357|      0|        return (ret);
  358|       |
  359|     90|    ret = b->method->ctrl(b, cmd, larg, parg);
  360|       |
  361|     90|    if (cb != NULL)
  362|      0|        ret = cb(b, BIO_CB_CTRL | BIO_CB_RETURN, parg, cmd, larg, ret);
  363|     90|    return (ret);
  364|     90|}
BIO_free_all:
  501|     30|{
  502|     30|    BIO *b;
  503|     30|    int ref;
  504|       |
  505|     60|    while (bio != NULL) {
  506|     30|        b = bio;
  507|     30|        ref = b->references;
  508|     30|        bio = bio->next_bio;
  509|     30|        BIO_free(b);
  510|       |        /* Since ref count > 1, don't free anyone else. */
  511|     30|        if (ref > 1)
  512|      0|            break;
  513|     30|    }
  514|     30|}

BIO_new_file:
  170|     31|{
  171|     31|    BIO  *ret;
  172|     31|    FILE *file = file_fopen(filename, mode);
  173|       |
  174|     31|    if (file == NULL) {
  175|      1|        SYSerr(SYS_F_FOPEN, get_last_sys_error());
  176|      1|        ERR_add_error_data(5, "fopen('", filename, "','", mode, "')");
  177|      1|        if (errno == ENOENT
  178|      1|# ifdef ENXIO
  179|      1|            || errno == ENXIO
  180|      1|# endif
  181|      1|            )
  182|      1|            BIOerr(BIO_F_BIO_NEW_FILE, BIO_R_NO_SUCH_FILE);
  183|      0|        else
  184|      1|            BIOerr(BIO_F_BIO_NEW_FILE, ERR_R_SYS_LIB);
  185|      1|        return (NULL);
  186|      1|    }
  187|     30|    if ((ret = BIO_new(BIO_s_file())) == NULL) {
  188|      0|        fclose(file);
  189|      0|        return (NULL);
  190|      0|    }
  191|       |
  192|     30|    BIO_clear_flags(ret, BIO_FLAGS_UPLINK); /* we did fopen -> we disengage
  193|       |                                             * UPLINK */
  194|     30|    BIO_set_fp(ret, file, BIO_CLOSE);
  195|     30|    return (ret);
  196|     30|}
BIO_s_file:
  212|     30|{
  213|     30|    return (&methods_filep);
  214|     30|}
bss_file.c:file_fopen:
  119|     31|{
  120|     31|    FILE *file = NULL;
  121|       |
  122|       |#  if defined(_WIN32) && defined(CP_UTF8)
  123|       |    int sz, len_0 = (int)strlen(filename) + 1;
  124|       |    DWORD flags;
  125|       |
  126|       |    /*
  127|       |     * Basically there are three cases to cover: a) filename is
  128|       |     * pure ASCII string; b) actual UTF-8 encoded string and
  129|       |     * c) locale-ized string, i.e. one containing 8-bit
  130|       |     * characters that are meaningful in current system locale.
  131|       |     * If filename is pure ASCII or real UTF-8 encoded string,
  132|       |     * MultiByteToWideChar succeeds and _wfopen works. If
  133|       |     * filename is locale-ized string, chances are that
  134|       |     * MultiByteToWideChar fails reporting
  135|       |     * ERROR_NO_UNICODE_TRANSLATION, in which case we fall
  136|       |     * back to fopen...
  137|       |     */
  138|       |    if ((sz = MultiByteToWideChar(CP_UTF8, (flags = MB_ERR_INVALID_CHARS),
  139|       |                                  filename, len_0, NULL, 0)) > 0 ||
  140|       |        (GetLastError() == ERROR_INVALID_FLAGS &&
  141|       |         (sz = MultiByteToWideChar(CP_UTF8, (flags = 0),
  142|       |                                   filename, len_0, NULL, 0)) > 0)
  143|       |        ) {
  144|       |        WCHAR wmode[8];
  145|       |        WCHAR *wfilename = _alloca(sz * sizeof(WCHAR));
  146|       |
  147|       |        if (MultiByteToWideChar(CP_UTF8, flags,
  148|       |                                filename, len_0, wfilename, sz) &&
  149|       |            MultiByteToWideChar(CP_UTF8, 0, mode, strlen(mode) + 1,
  150|       |                                wmode, sizeof(wmode) / sizeof(wmode[0])) &&
  151|       |            (file = _wfopen(wfilename, wmode)) == NULL &&
  152|       |            (errno == ENOENT || errno == EBADF)
  153|       |            ) {
  154|       |            /*
  155|       |             * UTF-8 decode succeeded, but no file, filename
  156|       |             * could still have been locale-ized...
  157|       |             */
  158|       |            file = fopen(filename, mode);
  159|       |        }
  160|       |    } else if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION) {
  161|       |        file = fopen(filename, mode);
  162|       |    }
  163|       |#  else
  164|     31|    file = fopen(filename, mode);
  165|     31|#  endif
  166|     31|    return (file);
  167|     31|}
bss_file.c:file_gets:
  456|  98.2k|{
  457|  98.2k|    int ret = 0;
  458|       |
  459|  98.2k|    buf[0] = '\0';
  460|  98.2k|    if (bp->flags & BIO_FLAGS_UPLINK) {
  461|      0|        if (!UP_fgets(buf, size, bp->ptr))
  462|      0|            goto err;
  463|  98.2k|    } else {
  464|  98.2k|        if (!fgets(buf, size, (FILE *)bp->ptr))
  465|     30|            goto err;
  466|  98.2k|    }
  467|  98.1k|    if (buf[0] != '\0')
  468|  98.1k|        ret = strlen(buf);
  469|  98.2k| err:
  470|  98.2k|    return (ret);
  471|  98.1k|}
bss_file.c:file_ctrl:
  285|     30|{
  286|     30|    long ret = 1;
  287|     30|    FILE *fp = (FILE *)b->ptr;
  288|     30|    FILE **fpp;
  289|     30|    char p[4];
  290|     30|    int st;
  291|       |
  292|     30|    switch (cmd) {
  293|      0|    case BIO_C_FILE_SEEK:
  294|      0|    case BIO_CTRL_RESET:
  295|      0|        if (b->flags & BIO_FLAGS_UPLINK)
  296|      0|            ret = (long)UP_fseek(b->ptr, num, 0);
  297|      0|        else
  298|      0|            ret = (long)fseek(fp, num, 0);
  299|      0|        break;
  300|      0|    case BIO_CTRL_EOF:
  301|      0|        if (b->flags & BIO_FLAGS_UPLINK)
  302|      0|            ret = (long)UP_feof(fp);
  303|      0|        else
  304|      0|            ret = (long)feof(fp);
  305|      0|        break;
  306|      0|    case BIO_C_FILE_TELL:
  307|      0|    case BIO_CTRL_INFO:
  308|      0|        if (b->flags & BIO_FLAGS_UPLINK)
  309|      0|            ret = UP_ftell(b->ptr);
  310|      0|        else
  311|      0|            ret = ftell(fp);
  312|      0|        break;
  313|     30|    case BIO_C_SET_FILE_PTR:
  314|     30|        file_free(b);
  315|     30|        b->shutdown = (int)num & BIO_CLOSE;
  316|     30|        b->ptr = ptr;
  317|     30|        b->init = 1;
  318|       |#  if BIO_FLAGS_UPLINK!=0
  319|       |#   if defined(__MINGW32__) && defined(__MSVCRT__) && !defined(_IOB_ENTRIES)
  320|       |#    define _IOB_ENTRIES 20
  321|       |#   endif
  322|       |        /* Safety net to catch purely internal BIO_set_fp calls */
  323|       |#   if defined(_MSC_VER) && _MSC_VER>=1900
  324|       |        if (ptr == stdin || ptr == stdout || ptr == stderr)
  325|       |            BIO_clear_flags(b, BIO_FLAGS_UPLINK);
  326|       |#   elif defined(_IOB_ENTRIES)
  327|       |        if ((size_t)ptr >= (size_t)stdin &&
  328|       |            (size_t)ptr < (size_t)(stdin + _IOB_ENTRIES))
  329|       |            BIO_clear_flags(b, BIO_FLAGS_UPLINK);
  330|       |#   endif
  331|       |#  endif
  332|       |#  ifdef UP_fsetmod
  333|       |        if (b->flags & BIO_FLAGS_UPLINK)
  334|       |            UP_fsetmod(b->ptr, (char)((num & BIO_FP_TEXT) ? 't' : 'b'));
  335|       |        else
  336|       |#  endif
  337|     30|        {
  338|       |#  if defined(OPENSSL_SYS_WINDOWS)
  339|       |            int fd = _fileno((FILE *)ptr);
  340|       |            if (num & BIO_FP_TEXT)
  341|       |                _setmode(fd, _O_TEXT);
  342|       |            else
  343|       |                _setmode(fd, _O_BINARY);
  344|       |#  elif defined(OPENSSL_SYS_NETWARE) && defined(NETWARE_CLIB)
  345|       |            int fd = fileno((FILE *)ptr);
  346|       |            /* Under CLib there are differences in file modes */
  347|       |            if (num & BIO_FP_TEXT)
  348|       |                setmode(fd, O_TEXT);
  349|       |            else
  350|       |                setmode(fd, O_BINARY);
  351|       |#  elif defined(OPENSSL_SYS_MSDOS)
  352|       |            int fd = fileno((FILE *)ptr);
  353|       |            /* Set correct text/binary mode */
  354|       |            if (num & BIO_FP_TEXT)
  355|       |                _setmode(fd, _O_TEXT);
  356|       |            /* Dangerous to set stdin/stdout to raw (unless redirected) */
  357|       |            else {
  358|       |                if (fd == STDIN_FILENO || fd == STDOUT_FILENO) {
  359|       |                    if (isatty(fd) <= 0)
  360|       |                        _setmode(fd, _O_BINARY);
  361|       |                } else
  362|       |                    _setmode(fd, _O_BINARY);
  363|       |            }
  364|       |#  elif defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)
  365|       |            int fd = fileno((FILE *)ptr);
  366|       |            if (num & BIO_FP_TEXT)
  367|       |                setmode(fd, O_TEXT);
  368|       |            else
  369|       |                setmode(fd, O_BINARY);
  370|       |#  endif
  371|     30|        }
  372|     30|        break;
  373|      0|    case BIO_C_SET_FILENAME:
  374|      0|        file_free(b);
  375|      0|        b->shutdown = (int)num & BIO_CLOSE;
  376|      0|        if (num & BIO_FP_APPEND) {
  377|      0|            if (num & BIO_FP_READ)
  378|      0|                BUF_strlcpy(p, "a+", sizeof p);
  379|      0|            else
  380|      0|                BUF_strlcpy(p, "a", sizeof p);
  381|      0|        } else if ((num & BIO_FP_READ) && (num & BIO_FP_WRITE))
  382|      0|            BUF_strlcpy(p, "r+", sizeof p);
  383|      0|        else if (num & BIO_FP_WRITE)
  384|      0|            BUF_strlcpy(p, "w", sizeof p);
  385|      0|        else if (num & BIO_FP_READ)
  386|      0|            BUF_strlcpy(p, "r", sizeof p);
  387|      0|        else {
  388|      0|            BIOerr(BIO_F_FILE_CTRL, BIO_R_BAD_FOPEN_MODE);
  389|      0|            ret = 0;
  390|      0|            break;
  391|      0|        }
  392|       |#  if defined(OPENSSL_SYS_MSDOS) || defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_OS2) || defined(OPENSSL_SYS_WIN32_CYGWIN)
  393|       |        if (!(num & BIO_FP_TEXT))
  394|       |            strcat(p, "b");
  395|       |        else
  396|       |            strcat(p, "t");
  397|       |#  endif
  398|       |#  if defined(OPENSSL_SYS_NETWARE)
  399|       |        if (!(num & BIO_FP_TEXT))
  400|       |            strcat(p, "b");
  401|       |        else
  402|       |            strcat(p, "t");
  403|       |#  endif
  404|      0|        fp = file_fopen(ptr, p);
  405|      0|        if (fp == NULL) {
  406|      0|            SYSerr(SYS_F_FOPEN, get_last_sys_error());
  407|      0|            ERR_add_error_data(5, "fopen('", ptr, "','", p, "')");
  408|      0|            BIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);
  409|      0|            ret = 0;
  410|      0|            break;
  411|      0|        }
  412|      0|        b->ptr = fp;
  413|      0|        b->init = 1;
  414|      0|        BIO_clear_flags(b, BIO_FLAGS_UPLINK); /* we did fopen -> we disengage
  415|       |                                               * UPLINK */
  416|      0|        break;
  417|      0|    case BIO_C_GET_FILE_PTR:
  418|       |        /* the ptr parameter is actually a FILE ** in this case. */
  419|      0|        if (ptr != NULL) {
  420|      0|            fpp = (FILE **)ptr;
  421|      0|            *fpp = (FILE *)b->ptr;
  422|      0|        }
  423|      0|        break;
  424|      0|    case BIO_CTRL_GET_CLOSE:
  425|      0|        ret = (long)b->shutdown;
  426|      0|        break;
  427|      0|    case BIO_CTRL_SET_CLOSE:
  428|      0|        b->shutdown = (int)num;
  429|      0|        break;
  430|      0|    case BIO_CTRL_FLUSH:
  431|      0|        st = b->flags & BIO_FLAGS_UPLINK
  432|      0|                ? UP_fflush(b->ptr) : fflush((FILE *)b->ptr);
  433|      0|        if (st == EOF) {
  434|      0|            SYSerr(SYS_F_FFLUSH, get_last_sys_error());
  435|      0|            ERR_add_error_data(1, "fflush()");
  436|      0|            BIOerr(BIO_F_FILE_CTRL, ERR_R_SYS_LIB);
  437|      0|            ret = 0;
  438|      0|        }
  439|      0|        break;
  440|      0|    case BIO_CTRL_DUP:
  441|      0|        ret = 1;
  442|      0|        break;
  443|       |
  444|      0|    case BIO_CTRL_WPENDING:
  445|      0|    case BIO_CTRL_PENDING:
  446|      0|    case BIO_CTRL_PUSH:
  447|      0|    case BIO_CTRL_POP:
  448|      0|    default:
  449|      0|        ret = 0;
  450|      0|        break;
  451|     30|    }
  452|     30|    return (ret);
  453|     30|}
bss_file.c:file_new:
  217|     30|{
  218|     30|    bi->init = 0;
  219|     30|    bi->num = 0;
  220|     30|    bi->ptr = NULL;
  221|     30|    bi->flags = BIO_FLAGS_UPLINK; /* default to UPLINK */
  222|     30|    return (1);
  223|     30|}
bss_file.c:file_free:
  226|     60|{
  227|     60|    if (a == NULL)
  228|      0|        return (0);
  229|     60|    if (a->shutdown) {
  230|     60|        if ((a->init) && (a->ptr != NULL)) {
  231|     30|            if (a->flags & BIO_FLAGS_UPLINK)
  232|      0|                UP_fclose(a->ptr);
  233|     30|            else
  234|     30|                fclose(a->ptr);
  235|     30|            a->ptr = NULL;
  236|     30|            a->flags = BIO_FLAGS_UPLINK;
  237|     30|        }
  238|     60|        a->init = 0;
  239|     60|    }
  240|     60|    return (1);
  241|     60|}

BIO_s_mem:
   90|     30|{
   91|     30|    return (&mem_method);
   92|     30|}
bss_mem.c:mem_write:
  174|     30|{
  175|     30|    int ret = -1;
  176|     30|    int blen;
  177|     30|    BUF_MEM *bm;
  178|       |
  179|     30|    bm = (BUF_MEM *)b->ptr;
  180|     30|    if (in == NULL) {
  181|      0|        BIOerr(BIO_F_MEM_WRITE, BIO_R_NULL_PARAMETER);
  182|      0|        goto end;
  183|      0|    }
  184|       |
  185|     30|    if (b->flags & BIO_FLAGS_MEM_RDONLY) {
  186|      0|        BIOerr(BIO_F_MEM_WRITE, BIO_R_WRITE_TO_READ_ONLY_BIO);
  187|      0|        goto end;
  188|      0|    }
  189|       |
  190|     30|    BIO_clear_retry_flags(b);
  191|     30|    blen = bm->length;
  192|     30|    if (BUF_MEM_grow_clean(bm, blen + inl) != (blen + inl))
  193|      0|        goto end;
  194|     30|    memcpy(&(bm->data[blen]), in, inl);
  195|     30|    ret = inl;
  196|     30| end:
  197|     30|    return (ret);
  198|     30|}
bss_mem.c:mem_ctrl:
  201|     30|{
  202|     30|    long ret = 1;
  203|     30|    char **pptr;
  204|       |
  205|     30|    BUF_MEM *bm = (BUF_MEM *)b->ptr;
  206|       |
  207|     30|    switch (cmd) {
  208|      0|    case BIO_CTRL_RESET:
  209|      0|        if (bm->data != NULL) {
  210|       |            /* For read only case reset to the start again */
  211|      0|            if (b->flags & BIO_FLAGS_MEM_RDONLY) {
  212|      0|                bm->data -= bm->max - bm->length;
  213|      0|                bm->length = bm->max;
  214|      0|            } else {
  215|      0|                memset(bm->data, 0, bm->max);
  216|      0|                bm->length = 0;
  217|      0|            }
  218|      0|        }
  219|      0|        break;
  220|      0|    case BIO_CTRL_EOF:
  221|      0|        ret = (long)(bm->length == 0);
  222|      0|        break;
  223|      0|    case BIO_C_SET_BUF_MEM_EOF_RETURN:
  224|      0|        b->num = (int)num;
  225|      0|        break;
  226|      0|    case BIO_CTRL_INFO:
  227|      0|        ret = (long)bm->length;
  228|      0|        if (ptr != NULL) {
  229|      0|            pptr = (char **)ptr;
  230|      0|            *pptr = (char *)&(bm->data[0]);
  231|      0|        }
  232|      0|        break;
  233|      0|    case BIO_C_SET_BUF_MEM:
  234|      0|        mem_free(b);
  235|      0|        b->shutdown = (int)num;
  236|      0|        b->ptr = ptr;
  237|      0|        break;
  238|      0|    case BIO_C_GET_BUF_MEM_PTR:
  239|      0|        if (ptr != NULL) {
  240|      0|            pptr = (char **)ptr;
  241|      0|            *pptr = (char *)bm;
  242|      0|        }
  243|      0|        break;
  244|      0|    case BIO_CTRL_GET_CLOSE:
  245|      0|        ret = (long)b->shutdown;
  246|      0|        break;
  247|     30|    case BIO_CTRL_SET_CLOSE:
  248|     30|        b->shutdown = (int)num;
  249|     30|        break;
  250|       |
  251|      0|    case BIO_CTRL_WPENDING:
  252|      0|        ret = 0L;
  253|      0|        break;
  254|      0|    case BIO_CTRL_PENDING:
  255|      0|        ret = (long)bm->length;
  256|      0|        break;
  257|      0|    case BIO_CTRL_DUP:
  258|      0|    case BIO_CTRL_FLUSH:
  259|      0|        ret = 1;
  260|      0|        break;
  261|      0|    case BIO_CTRL_PUSH:
  262|      0|    case BIO_CTRL_POP:
  263|      0|    default:
  264|      0|        ret = 0;
  265|      0|        break;
  266|     30|    }
  267|     30|    return (ret);
  268|     30|}
bss_mem.c:mem_new:
  120|     30|{
  121|     30|    BUF_MEM *b;
  122|       |
  123|     30|    if ((b = BUF_MEM_new()) == NULL)
  124|      0|        return (0);
  125|     30|    bi->shutdown = 1;
  126|     30|    bi->init = 1;
  127|     30|    bi->num = -1;
  128|     30|    bi->ptr = (char *)b;
  129|     30|    return (1);
  130|     30|}
bss_mem.c:mem_free:
  133|     30|{
  134|     30|    if (a == NULL)
  135|      0|        return (0);
  136|     30|    if (a->shutdown) {
  137|     30|        if ((a->init) && (a->ptr != NULL)) {
  138|     30|            BUF_MEM *b;
  139|     30|            b = (BUF_MEM *)a->ptr;
  140|     30|            if (a->flags & BIO_FLAGS_MEM_RDONLY)
  141|      0|                b->data = NULL;
  142|     30|            BUF_MEM_free(b);
  143|     30|            a->ptr = NULL;
  144|     30|        }
  145|     30|    }
  146|     30|    return (1);
  147|     30|}

BIO_s_socket:
   96|     30|{
   97|     30|    return (&methods_sockp);
   98|     30|}
BIO_sock_should_retry:
  212|     60|{
  213|     60|    int err;
  214|       |
  215|     60|    if ((i == 0) || (i == -1)) {
  216|     60|        err = get_last_socket_error();
  217|       |
  218|       |# if defined(OPENSSL_SYS_WINDOWS) && 0/* more microsoft stupidity? perhaps
  219|       |                                       * not? Ben 4/1/99 */
  220|       |        if ((i == -1) && (err == 0))
  221|       |            return (1);
  222|       |# endif
  223|       |
  224|     60|        return (BIO_sock_non_fatal_error(err));
  225|     60|    }
  226|      0|    return (0);
  227|     60|}
BIO_sock_non_fatal_error:
  230|     60|{
  231|     60|    switch (err) {
  232|       |# if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_NETWARE)
  233|       |#  if defined(WSAEWOULDBLOCK)
  234|       |    case WSAEWOULDBLOCK:
  235|       |#  endif
  236|       |
  237|       |#  if 0                         /* This appears to always be an error */
  238|       |#   if defined(WSAENOTCONN)
  239|       |    case WSAENOTCONN:
  240|       |#   endif
  241|       |#  endif
  242|       |# endif
  243|       |
  244|      0|# ifdef EWOULDBLOCK
  245|       |#  ifdef WSAEWOULDBLOCK
  246|       |#   if WSAEWOULDBLOCK != EWOULDBLOCK
  247|       |    case EWOULDBLOCK:
  248|       |#   endif
  249|       |#  else
  250|      0|    case EWOULDBLOCK:
  251|      0|#  endif
  252|      0|# endif
  253|       |
  254|      0|# if defined(ENOTCONN)
  255|      0|    case ENOTCONN:
  256|      0|# endif
  257|       |
  258|      0|# ifdef EINTR
  259|      0|    case EINTR:
  260|      0|# endif
  261|       |
  262|      0|# ifdef EAGAIN
  263|       |#  if EWOULDBLOCK != EAGAIN
  264|       |    case EAGAIN:
  265|       |#  endif
  266|      0|# endif
  267|       |
  268|      0|# ifdef EPROTO
  269|      0|    case EPROTO:
  270|      0|# endif
  271|       |
  272|      0|# ifdef EINPROGRESS
  273|      0|    case EINPROGRESS:
  274|      0|# endif
  275|       |
  276|      0|# ifdef EALREADY
  277|      0|    case EALREADY:
  278|      0|# endif
  279|      0|        return (1);
  280|       |        /* break; */
  281|     60|    default:
  282|     60|        break;
  283|     60|    }
  284|     60|    return (0);
  285|     60|}
bss_sock.c:sock_write:
  151|     30|{
  152|     30|    int ret;
  153|       |
  154|     30|    clear_socket_error();
  155|     30|    ret = writesocket(b->num, in, inl);
  156|     30|    BIO_clear_retry_flags(b);
  157|     30|    if (ret <= 0) {
  158|      0|        if (BIO_sock_should_retry(ret))
  159|      0|            BIO_set_retry_write(b);
  160|      0|    }
  161|     30|    return (ret);
  162|     30|}
bss_sock.c:sock_read:
  135|     60|{
  136|     60|    int ret = 0;
  137|       |
  138|     60|    if (out != NULL) {
  139|     60|        clear_socket_error();
  140|     60|        ret = readsocket(b->num, out, outl);
  141|     60|        BIO_clear_retry_flags(b);
  142|     60|        if (ret <= 0) {
  143|     60|            if (BIO_sock_should_retry(ret))
  144|      0|                BIO_set_retry_read(b);
  145|     60|        }
  146|     60|    }
  147|     60|    return (ret);
  148|     60|}
bss_sock.c:sock_ctrl:
  165|     30|{
  166|     30|    long ret = 1;
  167|     30|    int *ip;
  168|       |
  169|     30|    switch (cmd) {
  170|     30|    case BIO_C_SET_FD:
  171|     30|        sock_free(b);
  172|     30|        b->num = *((int *)ptr);
  173|     30|        b->shutdown = (int)num;
  174|     30|        b->init = 1;
  175|     30|        break;
  176|      0|    case BIO_C_GET_FD:
  177|      0|        if (b->init) {
  178|      0|            ip = (int *)ptr;
  179|      0|            if (ip != NULL)
  180|      0|                *ip = b->num;
  181|      0|            ret = b->num;
  182|      0|        } else
  183|      0|            ret = -1;
  184|      0|        break;
  185|      0|    case BIO_CTRL_GET_CLOSE:
  186|      0|        ret = b->shutdown;
  187|      0|        break;
  188|      0|    case BIO_CTRL_SET_CLOSE:
  189|      0|        b->shutdown = (int)num;
  190|      0|        break;
  191|      0|    case BIO_CTRL_DUP:
  192|      0|    case BIO_CTRL_FLUSH:
  193|      0|        ret = 1;
  194|      0|        break;
  195|      0|    default:
  196|      0|        ret = 0;
  197|      0|        break;
  198|     30|    }
  199|     30|    return (ret);
  200|     30|}
bss_sock.c:sock_new:
  112|     30|{
  113|     30|    bi->init = 0;
  114|     30|    bi->num = 0;
  115|     30|    bi->ptr = NULL;
  116|     30|    bi->flags = 0;
  117|     30|    return (1);
  118|     30|}
bss_sock.c:sock_free:
  121|     60|{
  122|     60|    if (a == NULL)
  123|      0|        return (0);
  124|     60|    if (a->shutdown) {
  125|     30|        if (a->init) {
  126|      0|            SHUTDOWN2(a->num);
  127|      0|        }
  128|     30|        a->init = 0;
  129|     30|        a->flags = 0;
  130|     30|    }
  131|     60|    return (1);
  132|     60|}

ERR_load_BN_strings:
  146|      1|{
  147|      1|#ifndef OPENSSL_NO_ERR
  148|       |
  149|      1|    if (ERR_func_error_string(BN_str_functs[0].error) == NULL) {
  150|      1|        ERR_load_strings(0, BN_str_functs);
  151|      1|        ERR_load_strings(0, BN_str_reasons);
  152|      1|    }
  153|      1|#endif
  154|      1|}

BN_free:
  246|    480|{
  247|    480|    if (a == NULL)
  248|    480|        return;
  249|      0|    bn_check_top(a);
  250|      0|    if ((a->d != NULL) && !(BN_get_flags(a, BN_FLG_STATIC_DATA)))
  251|      0|        OPENSSL_free(a->d);
  252|      0|    if (a->flags & BN_FLG_MALLOCED)
  253|      0|        OPENSSL_free(a);
  254|      0|    else {
  255|      0|#ifndef OPENSSL_NO_DEPRECATED
  256|      0|        a->flags |= BN_FLG_FREE;
  257|      0|#endif
  258|      0|        a->d = NULL;
  259|      0|    }
  260|      0|}

ERR_load_BUF_strings:
   89|      1|{
   90|      1|#ifndef OPENSSL_NO_ERR
   91|       |
   92|      1|    if (ERR_func_error_string(BUF_str_functs[0].error) == NULL) {
   93|      1|        ERR_load_strings(0, BUF_str_functs);
   94|      1|        ERR_load_strings(0, BUF_str_reasons);
   95|      1|    }
   96|      1|#endif
   97|      1|}

BUF_strnlen:
   65|     35|{
   66|     35|    const char *p;
   67|       |
   68|    378|    for (p = str; maxlen-- != 0 && *p != '\0'; ++p) ;
   69|       |
   70|     35|    return p - str;
   71|     35|}
BUF_strdup:
   74|     35|{
   75|     35|    if (str == NULL)
   76|      0|        return NULL;
   77|     35|    return BUF_strndup(str, strlen(str));
   78|     35|}
BUF_strndup:
   81|     35|{
   82|     35|    char *ret;
   83|       |
   84|     35|    if (str == NULL)
   85|      0|        return NULL;
   86|       |
   87|     35|    siz = BUF_strnlen(str, siz);
   88|       |
   89|     35|    if (siz >= INT_MAX)
   90|      0|        return NULL;
   91|       |
   92|     35|    ret = OPENSSL_malloc(siz + 1);
   93|     35|    if (ret == NULL) {
   94|      0|        BUFerr(BUF_F_BUF_STRNDUP, ERR_R_MALLOC_FAILURE);
   95|      0|        return NULL;
   96|      0|    }
   97|       |
   98|     35|    memcpy(ret, str, siz);
   99|     35|    ret[siz] = '\0';
  100|       |
  101|     35|    return (ret);
  102|     35|}
BUF_strlcpy:
  120|    118|{
  121|    118|    size_t l = 0;
  122|    839|    for (; size > 1 && *src; size--) {
  123|    721|        *dst++ = *src++;
  124|    721|        l++;
  125|    721|    }
  126|    118|    if (size)
  127|    118|        *dst = '\0';
  128|    118|    return l + strlen(src);
  129|    118|}
BUF_strlcat:
  132|     23|{
  133|     23|    size_t l = 0;
  134|    435|    for (; size > 0 && *dst; size--, dst++)
  135|    412|        l++;
  136|     23|    return l + BUF_strlcpy(dst, src, size);
  137|     23|}

BUF_MEM_new:
   71|  30.8k|{
   72|  30.8k|    BUF_MEM *ret;
   73|       |
   74|  30.8k|    ret = OPENSSL_malloc(sizeof(BUF_MEM));
   75|  30.8k|    if (ret == NULL) {
   76|      0|        BUFerr(BUF_F_BUF_MEM_NEW, ERR_R_MALLOC_FAILURE);
   77|      0|        return (NULL);
   78|      0|    }
   79|  30.8k|    ret->length = 0;
   80|  30.8k|    ret->max = 0;
   81|  30.8k|    ret->data = NULL;
   82|  30.8k|    return (ret);
   83|  30.8k|}
BUF_MEM_free:
   86|  15.5k|{
   87|  15.5k|    if (a == NULL)
   88|      0|        return;
   89|       |
   90|  15.5k|    if (a->data != NULL) {
   91|  7.74k|        OPENSSL_cleanse(a->data, a->max);
   92|  7.74k|        OPENSSL_free(a->data);
   93|  7.74k|    }
   94|  15.5k|    OPENSSL_free(a);
   95|  15.5k|}
BUF_MEM_grow:
   98|   131k|{
   99|   131k|    char *ret;
  100|   131k|    size_t n;
  101|       |
  102|   131k|    if (str->length >= len) {
  103|  7.68k|        str->length = len;
  104|  7.68k|        return (len);
  105|  7.68k|    }
  106|   124k|    if (str->max >= len) {
  107|  84.9k|        memset(&str->data[str->length], 0, len - str->length);
  108|  84.9k|        str->length = len;
  109|  84.9k|        return (len);
  110|  84.9k|    }
  111|       |    /* This limit is sufficient to ensure (len+3)/3*4 < 2**31 */
  112|  39.3k|    if (len > LIMIT_BEFORE_EXPANSION) {
  113|      0|        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);
  114|      0|        return 0;
  115|      0|    }
  116|  39.3k|    n = (len + 3) / 3 * 4;
  117|  39.3k|    if (str->data == NULL)
  118|  23.0k|        ret = OPENSSL_malloc(n);
  119|  16.2k|    else
  120|  16.2k|        ret = OPENSSL_realloc(str->data, n);
  121|  39.3k|    if (ret == NULL) {
  122|      0|        BUFerr(BUF_F_BUF_MEM_GROW, ERR_R_MALLOC_FAILURE);
  123|      0|        len = 0;
  124|  39.3k|    } else {
  125|  39.3k|        str->data = ret;
  126|  39.3k|        str->max = n;
  127|  39.3k|        memset(&str->data[str->length], 0, len - str->length);
  128|  39.3k|        str->length = len;
  129|  39.3k|    }
  130|  39.3k|    return (len);
  131|  39.3k|}
BUF_MEM_grow_clean:
  134|     30|{
  135|     30|    char *ret;
  136|     30|    size_t n;
  137|       |
  138|     30|    if (str->length >= len) {
  139|      0|        memset(&str->data[len], 0, str->length - len);
  140|      0|        str->length = len;
  141|      0|        return (len);
  142|      0|    }
  143|     30|    if (str->max >= len) {
  144|      0|        memset(&str->data[str->length], 0, len - str->length);
  145|      0|        str->length = len;
  146|      0|        return (len);
  147|      0|    }
  148|       |    /* This limit is sufficient to ensure (len+3)/3*4 < 2**31 */
  149|     30|    if (len > LIMIT_BEFORE_EXPANSION) {
  150|      0|        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);
  151|      0|        return 0;
  152|      0|    }
  153|     30|    n = (len + 3) / 3 * 4;
  154|     30|    if (str->data == NULL)
  155|     30|        ret = OPENSSL_malloc(n);
  156|      0|    else
  157|      0|        ret = OPENSSL_realloc_clean(str->data, str->max, n);
  158|     30|    if (ret == NULL) {
  159|      0|        BUFerr(BUF_F_BUF_MEM_GROW_CLEAN, ERR_R_MALLOC_FAILURE);
  160|      0|        len = 0;
  161|     30|    } else {
  162|     30|        str->data = ret;
  163|     30|        str->max = n;
  164|     30|        memset(&str->data[str->length], 0, len - str->length);
  165|     30|        str->length = len;
  166|     30|    }
  167|     30|    return (len);
  168|     30|}

ERR_load_CMS_strings:
  301|      1|{
  302|      1|#ifndef OPENSSL_NO_ERR
  303|       |
  304|      1|    if (ERR_func_error_string(CMS_str_functs[0].error) == NULL) {
  305|      1|        ERR_load_strings(0, CMS_str_functs);
  306|      1|        ERR_load_strings(0, CMS_str_reasons);
  307|      1|    }
  308|      1|#endif
  309|      1|}

COMP_zlib:
  344|      1|{
  345|      1|    COMP_METHOD *meth = &zlib_method_nozlib;
  346|       |
  347|       |#ifdef ZLIB_SHARED
  348|       |    if (!zlib_loaded) {
  349|       |# if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
  350|       |        zlib_dso = DSO_load(NULL, "ZLIB1", NULL, 0);
  351|       |# else
  352|       |        zlib_dso = DSO_load(NULL, "z", NULL, 0);
  353|       |# endif
  354|       |        if (zlib_dso != NULL) {
  355|       |            p_compress = (compress_ft) DSO_bind_func(zlib_dso, "compress");
  356|       |            p_inflateEnd
  357|       |                = (inflateEnd_ft) DSO_bind_func(zlib_dso, "inflateEnd");
  358|       |            p_inflate = (inflate_ft) DSO_bind_func(zlib_dso, "inflate");
  359|       |            p_inflateInit_
  360|       |                = (inflateInit__ft) DSO_bind_func(zlib_dso, "inflateInit_");
  361|       |            p_deflateEnd
  362|       |                = (deflateEnd_ft) DSO_bind_func(zlib_dso, "deflateEnd");
  363|       |            p_deflate = (deflate_ft) DSO_bind_func(zlib_dso, "deflate");
  364|       |            p_deflateInit_
  365|       |                = (deflateInit__ft) DSO_bind_func(zlib_dso, "deflateInit_");
  366|       |            p_zError = (zError__ft) DSO_bind_func(zlib_dso, "zError");
  367|       |
  368|       |            if (p_compress && p_inflateEnd && p_inflate
  369|       |                && p_inflateInit_ && p_deflateEnd
  370|       |                && p_deflate && p_deflateInit_ && p_zError)
  371|       |                zlib_loaded++;
  372|       |        }
  373|       |    }
  374|       |#endif
  375|       |#ifdef ZLIB_SHARED
  376|       |    if (zlib_loaded)
  377|       |#endif
  378|       |#if defined(ZLIB) || defined(ZLIB_SHARED)
  379|       |    {
  380|       |        /*
  381|       |         * init zlib_stateful_ex_idx here so that in a multi-process
  382|       |         * application it's enough to intialize openssl before forking (idx
  383|       |         * will be inherited in all the children)
  384|       |         */
  385|       |        if (zlib_stateful_ex_idx == -1) {
  386|       |            CRYPTO_w_lock(CRYPTO_LOCK_COMP);
  387|       |            if (zlib_stateful_ex_idx == -1)
  388|       |                zlib_stateful_ex_idx =
  389|       |                    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,
  390|       |                                            0, NULL, NULL, NULL, NULL);
  391|       |            CRYPTO_w_unlock(CRYPTO_LOCK_COMP);
  392|       |            if (zlib_stateful_ex_idx == -1)
  393|       |                goto err;
  394|       |        }
  395|       |
  396|       |        meth = &zlib_stateful_method;
  397|       |    }
  398|       | err:
  399|       |#endif
  400|       |
  401|      1|    return (meth);
  402|      1|}

ERR_load_COMP_strings:
   90|      1|{
   91|      1|#ifndef OPENSSL_NO_ERR
   92|       |
   93|      1|    if (ERR_func_error_string(COMP_str_functs[0].error) == NULL) {
   94|      1|        ERR_load_strings(0, COMP_str_functs);
   95|      1|        ERR_load_strings(0, COMP_str_reasons);
   96|      1|    }
   97|      1|#endif
   98|      1|}

_CONF_free_data:
  223|      1|{
  224|      1|    if (conf == NULL || conf->data == NULL)
  225|      1|        return;
  226|       |
  227|      0|    lh_CONF_VALUE_down_load(conf->data) = 0; /* evil thing to make * sure the
  228|       |                                              * 'OPENSSL_free()' works as *
  229|       |                                              * expected */
  230|      0|    lh_CONF_VALUE_doall_arg(conf->data,
  231|      0|                            LHASH_DOALL_ARG_FN(value_free_hash),
  232|      0|                            LHASH_OF(CONF_VALUE), conf->data);
  233|       |
  234|       |    /*
  235|       |     * We now have only 'section' entries in the hash table. Due to problems
  236|       |     * with
  237|       |     */
  238|       |
  239|      0|    lh_CONF_VALUE_doall(conf->data, LHASH_DOALL_FN(value_free_stack));
  240|      0|    lh_CONF_VALUE_free(conf->data);
  241|      0|}

NCONF_default:
  126|      1|{
  127|      1|    return &default_method;
  128|      1|}
conf_def.c:def_create:
  136|      1|{
  137|      1|    CONF *ret;
  138|       |
  139|      1|    ret = OPENSSL_malloc(sizeof(CONF) + sizeof(unsigned short *));
  140|      1|    if (ret)
  141|      1|        if (meth->init(ret) == 0) {
  142|      0|            OPENSSL_free(ret);
  143|      0|            ret = NULL;
  144|      0|        }
  145|      1|    return ret;
  146|      1|}
conf_def.c:def_init_default:
  149|      1|{
  150|      1|    if (conf == NULL)
  151|      0|        return 0;
  152|       |
  153|      1|    conf->meth = &default_method;
  154|      1|    conf->meth_data = CONF_type_default;
  155|      1|    conf->data = NULL;
  156|       |
  157|      1|    return 1;
  158|      1|}
conf_def.c:def_destroy:
  173|      1|{
  174|      1|    if (def_destroy_data(conf)) {
  175|      1|        OPENSSL_free(conf);
  176|      1|        return 1;
  177|      1|    }
  178|      0|    return 0;
  179|      1|}
conf_def.c:def_destroy_data:
  182|      1|{
  183|      1|    if (conf == NULL)
  184|      0|        return 0;
  185|      1|    _CONF_free_data(conf);
  186|      1|    return 1;
  187|      1|}
conf_def.c:def_load:
  190|      1|{
  191|      1|    int ret;
  192|      1|    BIO *in = NULL;
  193|       |
  194|       |#ifdef OPENSSL_SYS_VMS
  195|       |    in = BIO_new_file(name, "r");
  196|       |#else
  197|      1|    in = BIO_new_file(name, "rb");
  198|      1|#endif
  199|      1|    if (in == NULL) {
  200|      1|        if (ERR_GET_REASON(ERR_peek_last_error()) == BIO_R_NO_SUCH_FILE)
  201|      1|            CONFerr(CONF_F_DEF_LOAD, CONF_R_NO_SUCH_FILE);
  202|      0|        else
  203|      1|            CONFerr(CONF_F_DEF_LOAD, ERR_R_SYS_LIB);
  204|      1|        return 0;
  205|      1|    }
  206|       |
  207|      0|    ret = def_load_bio(conf, in, line);
  208|      0|    BIO_free(in);
  209|       |
  210|      0|    return ret;
  211|      1|}

ERR_load_CONF_strings:
  127|      1|{
  128|      1|#ifndef OPENSSL_NO_ERR
  129|       |
  130|      1|    if (ERR_func_error_string(CONF_str_functs[0].error) == NULL) {
  131|      1|        ERR_load_strings(0, CONF_str_functs);
  132|      1|        ERR_load_strings(0, CONF_str_reasons);
  133|      1|    }
  134|      1|#endif
  135|      1|}

NCONF_new:
  229|      1|{
  230|      1|    CONF *ret;
  231|       |
  232|      1|    if (meth == NULL)
  233|      1|        meth = NCONF_default();
  234|       |
  235|      1|    ret = meth->create(meth);
  236|      1|    if (ret == NULL) {
  237|      0|        CONFerr(CONF_F_NCONF_NEW, ERR_R_MALLOC_FAILURE);
  238|      0|        return (NULL);
  239|      0|    }
  240|       |
  241|      1|    return ret;
  242|      1|}
NCONF_free:
  245|      1|{
  246|      1|    if (conf == NULL)
  247|      0|        return;
  248|      1|    conf->meth->destroy(conf);
  249|      1|}
NCONF_load:
  259|      1|{
  260|      1|    if (conf == NULL) {
  261|      0|        CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF);
  262|      0|        return 0;
  263|      0|    }
  264|       |
  265|      1|    return conf->meth->load(conf, file, eline);
  266|      1|}

OPENSSL_load_builtin_modules:
   74|      1|{
   75|       |    /* Add builtin modules here */
   76|      1|    ASN1_add_oid_module();
   77|      1|#ifndef OPENSSL_NO_ENGINE
   78|      1|    ENGINE_add_conf_module();
   79|      1|#endif
   80|      1|    EVP_add_alg_module();
   81|      1|}

CONF_modules_load_file:
  164|      1|{
  165|      1|    char *file = NULL;
  166|      1|    CONF *conf = NULL;
  167|      1|    int ret = 0;
  168|      1|    conf = NCONF_new(NULL);
  169|      1|    if (!conf)
  170|      0|        goto err;
  171|       |
  172|      1|    if (filename == NULL) {
  173|      1|        file = CONF_get1_default_config_file();
  174|      1|        if (!file)
  175|      0|            goto err;
  176|      1|    } else
  177|      0|        file = (char *)filename;
  178|       |
  179|      1|    if (NCONF_load(conf, file, NULL) <= 0) {
  180|      1|        if ((flags & CONF_MFLAGS_IGNORE_MISSING_FILE) &&
  181|      1|            (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) {
  182|      1|            ERR_clear_error();
  183|      1|            ret = 1;
  184|      1|        }
  185|      1|        goto err;
  186|      1|    }
  187|       |
  188|      0|    ret = CONF_modules_load(conf, appname, flags);
  189|       |
  190|      1| err:
  191|      1|    if (filename == NULL)
  192|      1|        OPENSSL_free(file);
  193|      1|    NCONF_free(conf);
  194|       |
  195|      1|    return ret;
  196|      0|}
CONF_module_add:
  466|      3|{
  467|      3|    if (module_add(NULL, name, ifunc, ffunc))
  468|      3|        return 1;
  469|      0|    else
  470|      0|        return 0;
  471|      3|}
CONF_get1_default_config_file:
  529|      1|{
  530|      1|    char *file;
  531|      1|    int len;
  532|       |
  533|      1|    file = getenv("OPENSSL_CONF");
  534|      1|    if (file)
  535|      0|        return BUF_strdup(file);
  536|       |
  537|      1|    len = strlen(X509_get_default_cert_area());
  538|      1|#ifndef OPENSSL_SYS_VMS
  539|      1|    len++;
  540|      1|#endif
  541|      1|    len += strlen(OPENSSL_CONF);
  542|       |
  543|      1|    file = OPENSSL_malloc(len + 1);
  544|       |
  545|      1|    if (!file)
  546|      0|        return NULL;
  547|      1|    BUF_strlcpy(file, X509_get_default_cert_area(), len + 1);
  548|      1|#ifndef OPENSSL_SYS_VMS
  549|      1|    BUF_strlcat(file, "/", len + 1);
  550|      1|#endif
  551|      1|    BUF_strlcat(file, OPENSSL_CONF, len + 1);
  552|       |
  553|      1|    return file;
  554|      1|}
conf_mod.c:module_add:
  279|      3|{
  280|      3|    CONF_MODULE *tmod = NULL;
  281|      3|    if (supported_modules == NULL)
  282|      1|        supported_modules = sk_CONF_MODULE_new_null();
  283|      3|    if (supported_modules == NULL)
  284|      0|        return NULL;
  285|      3|    tmod = OPENSSL_malloc(sizeof(CONF_MODULE));
  286|      3|    if (tmod == NULL)
  287|      0|        return NULL;
  288|       |
  289|      3|    tmod->dso = dso;
  290|      3|    tmod->name = BUF_strdup(name);
  291|      3|    if (tmod->name == NULL) {
  292|      0|        OPENSSL_free(tmod);
  293|      0|        return NULL;
  294|      0|    }
  295|      3|    tmod->init = ifunc;
  296|      3|    tmod->finish = ffunc;
  297|      3|    tmod->links = 0;
  298|       |
  299|      3|    if (!sk_CONF_MODULE_push(supported_modules, tmod)) {
  300|      0|        OPENSSL_free(tmod);
  301|      0|        return NULL;
  302|      0|    }
  303|       |
  304|      3|    return tmod;
  305|      3|}

ERR_load_CRYPTO_strings:
   96|      1|{
   97|      1|#ifndef OPENSSL_NO_ERR
   98|       |
   99|      1|    if (ERR_func_error_string(CRYPTO_str_functs[0].error) == NULL) {
  100|      1|        ERR_load_strings(0, CRYPTO_str_functs);
  101|      1|        ERR_load_strings(0, CRYPTO_str_reasons);
  102|      1|    }
  103|      1|#endif
  104|      1|}

CRYPTO_THREADID_set_pointer:
  436|  31.0k|{
  437|  31.0k|    unsigned char *dest = (void *)&id->val;
  438|  31.0k|    unsigned int accum = 0;
  439|  31.0k|    unsigned char dnum = sizeof(id->val);
  440|       |
  441|  31.0k|    memset(id, 0, sizeof(*id));
  442|  31.0k|    id->ptr = ptr;
  443|  31.0k|    if (sizeof(id->val) >= sizeof(id->ptr)) {
  444|       |        /*
  445|       |         * 'ptr' can be embedded in 'val' without loss of uniqueness
  446|       |         */
  447|  31.0k|        id->val = (unsigned long)id->ptr;
  448|  31.0k|        return;
  449|  31.0k|    }
  450|       |    /*
  451|       |     * hash ptr ==> val. Each byte of 'val' gets the mod-256 total of a
  452|       |     * linear function over the bytes in 'ptr', the co-efficients of which
  453|       |     * are a sequence of low-primes (hash_coeffs is an 8-element cycle) - the
  454|       |     * starting prime for the sequence varies for each byte of 'val' (unique
  455|       |     * polynomials unless pointers are >64-bit). For added spice, the totals
  456|       |     * accumulate rather than restarting from zero, and the index of the
  457|       |     * 'val' byte is added each time (position dependence). If I was a
  458|       |     * black-belt, I'd scan big-endian pointers in reverse to give low-order
  459|       |     * bits more play, but this isn't crypto and I'd prefer nobody mistake it
  460|       |     * as such. Plus I'm lazy.
  461|       |     */
  462|      0|    while (dnum--) {
  463|      0|        const unsigned char *src = (void *)&id->ptr;
  464|      0|        unsigned char snum = sizeof(id->ptr);
  465|      0|        while (snum--)
  466|      0|            accum += *(src++) * hash_coeffs[(snum + dnum) & 7];
  467|      0|        accum += dnum;
  468|      0|        *(dest++) = accum & 255;
  469|      0|    }
  470|      0|}
CRYPTO_THREADID_current:
  492|  31.0k|{
  493|  31.0k|    if (threadid_callback) {
  494|      0|        threadid_callback(id);
  495|      0|        return;
  496|      0|    }
  497|  31.0k|#ifndef OPENSSL_NO_DEPRECATED
  498|       |    /* If the deprecated callback was set, fall back to that */
  499|  31.0k|    if (id_callback) {
  500|      0|        CRYPTO_THREADID_set_numeric(id, id_callback());
  501|      0|        return;
  502|      0|    }
  503|  31.0k|#endif
  504|       |    /* Else pick a backup */
  505|       |#ifdef OPENSSL_SYS_WIN16
  506|       |    CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentTask());
  507|       |#elif defined(OPENSSL_SYS_WIN32)
  508|       |    CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentThreadId());
  509|       |#elif defined(OPENSSL_SYS_BEOS)
  510|       |    CRYPTO_THREADID_set_numeric(id, (unsigned long)find_thread(NULL));
  511|       |#else
  512|       |    /* For everything else, default to using the address of 'errno' */
  513|  31.0k|    CRYPTO_THREADID_set_pointer(id, (void *)&errno);
  514|  31.0k|#endif
  515|  31.0k|}
CRYPTO_THREADID_cmp:
  518|  20.1k|{
  519|  20.1k|    return memcmp(a, b, sizeof(*a));
  520|  20.1k|}
CRYPTO_THREADID_cpy:
  523|  23.8k|{
  524|  23.8k|    memcpy(dest, src, sizeof(*src));
  525|  23.8k|}
CRYPTO_THREADID_hash:
  528|  23.2k|{
  529|  23.2k|    return id->val;
  530|  23.2k|}
CRYPTO_lock:
  565|   357k|{
  566|       |#ifdef LOCK_DEBUG
  567|       |    {
  568|       |        CRYPTO_THREADID id;
  569|       |        char *rw_text, *operation_text;
  570|       |
  571|       |        if (mode & CRYPTO_LOCK)
  572|       |            operation_text = "lock  ";
  573|       |        else if (mode & CRYPTO_UNLOCK)
  574|       |            operation_text = "unlock";
  575|       |        else
  576|       |            operation_text = "ERROR ";
  577|       |
  578|       |        if (mode & CRYPTO_READ)
  579|       |            rw_text = "r";
  580|       |        else if (mode & CRYPTO_WRITE)
  581|       |            rw_text = "w";
  582|       |        else
  583|       |            rw_text = "ERROR";
  584|       |
  585|       |        CRYPTO_THREADID_current(&id);
  586|       |        fprintf(stderr, "lock:%08lx:(%s)%s %-18s %s:%d\n",
  587|       |                CRYPTO_THREADID_hash(&id), rw_text, operation_text,
  588|       |                CRYPTO_get_lock_name(type), file, line);
  589|       |    }
  590|       |#endif
  591|   357k|    if (type < 0) {
  592|      0|        if (dynlock_lock_callback != NULL) {
  593|      0|            struct CRYPTO_dynlock_value *pointer
  594|      0|                = CRYPTO_get_dynlock_value(type);
  595|       |
  596|      0|            OPENSSL_assert(pointer != NULL);
  597|       |
  598|      0|            dynlock_lock_callback(mode, pointer, file, line);
  599|       |
  600|      0|            CRYPTO_destroy_dynlockid(type);
  601|      0|        }
  602|   357k|    } else if (locking_callback != NULL)
  603|      0|        locking_callback(mode, type, file, line);
  604|   357k|}
CRYPTO_add_lock:
  608|  38.9k|{
  609|  38.9k|    int ret = 0;
  610|       |
  611|  38.9k|    if (add_lock_callback != NULL) {
  612|       |#ifdef LOCK_DEBUG
  613|       |        int before = *pointer;
  614|       |#endif
  615|       |
  616|      0|        ret = add_lock_callback(pointer, amount, type, file, line);
  617|       |#ifdef LOCK_DEBUG
  618|       |        {
  619|       |            CRYPTO_THREADID id;
  620|       |            CRYPTO_THREADID_current(&id);
  621|       |            fprintf(stderr, "ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
  622|       |                    CRYPTO_THREADID_hash(&id), before, amount, ret,
  623|       |                    CRYPTO_get_lock_name(type), file, line);
  624|       |        }
  625|       |#endif
  626|  38.9k|    } else {
  627|  38.9k|        CRYPTO_lock(CRYPTO_LOCK | CRYPTO_WRITE, type, file, line);
  628|       |
  629|  38.9k|        ret = *pointer + amount;
  630|       |#ifdef LOCK_DEBUG
  631|       |        {
  632|       |            CRYPTO_THREADID id;
  633|       |            CRYPTO_THREADID_current(&id);
  634|       |            fprintf(stderr, "ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
  635|       |                    CRYPTO_THREADID_hash(&id),
  636|       |                    *pointer, amount, ret,
  637|       |                    CRYPTO_get_lock_name(type), file, line);
  638|       |        }
  639|       |#endif
  640|  38.9k|        *pointer = ret;
  641|  38.9k|        CRYPTO_lock(CRYPTO_UNLOCK | CRYPTO_WRITE, type, file, line);
  642|  38.9k|    }
  643|  38.9k|    return (ret);
  644|  38.9k|}
OPENSSL_cpuid_setup:
  687|      4|{
  688|      4|    static int trigger = 0;
  689|      4|    IA32CAP OPENSSL_ia32_cpuid(unsigned int *);
  690|      4|    IA32CAP vec;
  691|      4|    char *env;
  692|       |
  693|      4|    if (trigger)
  694|      2|        return;
  695|       |
  696|      2|    trigger = 1;
  697|      2|    if ((env = getenv("OPENSSL_ia32cap"))) {
  698|      0|        int off = (env[0] == '~') ? 1 : 0;
  699|       |#  if defined(_WIN32)
  700|       |        if (!sscanf(env + off, "%I64i", &vec))
  701|       |            vec = strtoul(env + off, NULL, 0);
  702|       |#  else
  703|      0|        if (!sscanf(env + off, "%lli", (long long *)&vec))
  704|      0|            vec = strtoul(env + off, NULL, 0);
  705|      0|#  endif
  706|      0|        if (off)
  707|      0|            vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P) & ~vec;
  708|      0|        else if (env[0] == ':')
  709|      0|            vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);
  710|       |
  711|      0|        OPENSSL_ia32cap_P[2] = 0;
  712|      0|        if ((env = strchr(env, ':'))) {
  713|      0|            unsigned int vecx;
  714|      0|            env++;
  715|      0|            off = (env[0] == '~') ? 1 : 0;
  716|      0|            vecx = strtoul(env + off, NULL, 0);
  717|      0|            if (off)
  718|      0|                OPENSSL_ia32cap_P[2] &= ~vecx;
  719|      0|            else
  720|      0|                OPENSSL_ia32cap_P[2] = vecx;
  721|      0|        }
  722|      0|    } else
  723|      2|        vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);
  724|       |
  725|       |    /*
  726|       |     * |(1<<10) sets a reserved bit to signal that variable
  727|       |     * was initialized already... This is to avoid interference
  728|       |     * with cpuid snippets in ELF .init segment.
  729|       |     */
  730|      2|    OPENSSL_ia32cap_P[0] = (unsigned int)vec | (1 << 10);
  731|      2|    OPENSSL_ia32cap_P[1] = (unsigned int)(vec >> 32);
  732|      2|}

ERR_load_DH_strings:
  118|      1|{
  119|      1|#ifndef OPENSSL_NO_ERR
  120|       |
  121|      1|    if (ERR_func_error_string(DH_str_functs[0].error) == NULL) {
  122|      1|        ERR_load_strings(0, DH_str_functs);
  123|      1|        ERR_load_strings(0, DH_str_reasons);
  124|      1|    }
  125|      1|#endif
  126|      1|}

DH_OpenSSL:
  124|      7|{
  125|      7|    return &dh_ossl;
  126|      7|}

ERR_load_DSA_strings:
  125|      1|{
  126|      1|#ifndef OPENSSL_NO_ERR
  127|       |
  128|      1|    if (ERR_func_error_string(DSA_str_functs[0].error) == NULL) {
  129|      1|        ERR_load_strings(0, DSA_str_functs);
  130|      1|        ERR_load_strings(0, DSA_str_reasons);
  131|      1|    }
  132|      1|#endif
  133|      1|}

DSA_get_default_method:
   87|      1|{
   88|      1|    if (!default_DSA_method) {
   89|       |#ifdef OPENSSL_FIPS
   90|       |        if (FIPS_mode())
   91|       |            return FIPS_dsa_openssl();
   92|       |        else
   93|       |            return DSA_OpenSSL();
   94|       |#else
   95|      1|        default_DSA_method = DSA_OpenSSL();
   96|      1|#endif
   97|      1|    }
   98|      1|    return default_DSA_method;
   99|      1|}

DSA_OpenSSL:
  129|      5|{
  130|      5|    return &openssl_dsa_meth;
  131|      5|}

DSO_METHOD_dlfcn:
  135|      1|{
  136|      1|    return (&dso_meth_dlfcn);
  137|      1|}
dso_dlfcn.c:dlfcn_load:
  171|      4|{
  172|      4|    void *ptr = NULL;
  173|       |    /* See applicable comments in dso_dl.c */
  174|      4|    char *filename = DSO_convert_filename(dso, NULL);
  175|      4|    int flags = DLOPEN_FLAG;
  176|       |
  177|      4|    if (filename == NULL) {
  178|      0|        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);
  179|      0|        goto err;
  180|      0|    }
  181|      4|# ifdef RTLD_GLOBAL
  182|      4|    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)
  183|      0|        flags |= RTLD_GLOBAL;
  184|      4|# endif
  185|      4|    ptr = dlopen(filename, flags);
  186|      4|    if (ptr == NULL) {
  187|      4|        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);
  188|      4|        ERR_add_error_data(4, "filename(", filename, "): ", dlerror());
  189|      4|        goto err;
  190|      4|    }
  191|      0|    if (!sk_void_push(dso->meth_data, (char *)ptr)) {
  192|      0|        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);
  193|      0|        goto err;
  194|      0|    }
  195|       |    /* Success */
  196|      0|    dso->loaded_filename = filename;
  197|      0|    return (1);
  198|      4| err:
  199|       |    /* Cleanup! */
  200|      4|    if (filename != NULL)
  201|      4|        OPENSSL_free(filename);
  202|      4|    if (ptr != NULL)
  203|      0|        dlclose(ptr);
  204|      4|    return (0);
  205|      0|}
dso_dlfcn.c:dlfcn_unload:
  208|      4|{
  209|      4|    void *ptr;
  210|      4|    if (dso == NULL) {
  211|      0|        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);
  212|      0|        return (0);
  213|      0|    }
  214|      4|    if (sk_void_num(dso->meth_data) < 1)
  215|      4|        return (1);
  216|      0|    ptr = sk_void_pop(dso->meth_data);
  217|      0|    if (ptr == NULL) {
  218|      0|        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);
  219|       |        /*
  220|       |         * Should push the value back onto the stack in case of a retry.
  221|       |         */
  222|      0|        sk_void_push(dso->meth_data, ptr);
  223|      0|        return (0);
  224|      0|    }
  225|       |    /* For now I'm not aware of any errors associated with dlclose() */
  226|      0|    dlclose(ptr);
  227|      0|    return (1);
  228|      0|}
dso_dlfcn.c:dlfcn_name_converter:
  355|      4|{
  356|      4|    char *translated;
  357|      4|    int len, rsize, transform;
  358|       |
  359|      4|    len = strlen(filename);
  360|      4|    rsize = len + 1;
  361|      4|    transform = (strstr(filename, "/") == NULL);
  362|      4|    if (transform) {
  363|       |        /* We will convert this to "%s.so" or "lib%s.so" etc */
  364|      4|        rsize += DSO_extlen;    /* The length of ".so" */
  365|      4|        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
  366|      4|            rsize += 3;         /* The length of "lib" */
  367|      4|    }
  368|      4|    translated = OPENSSL_malloc(rsize);
  369|      4|    if (translated == NULL) {
  370|      0|        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);
  371|      0|        return (NULL);
  372|      0|    }
  373|      4|    if (transform) {
  374|      4|        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
  375|      4|            sprintf(translated, "lib%s" DSO_ext, filename);
  376|      0|        else
  377|      0|            sprintf(translated, "%s" DSO_ext, filename);
  378|      4|    } else
  379|      0|        sprintf(translated, "%s", filename);
  380|      4|    return (translated);
  381|      4|}

ERR_load_DSO_strings:
  150|      1|{
  151|      1|#ifndef OPENSSL_NO_ERR
  152|       |
  153|      1|    if (ERR_func_error_string(DSO_str_functs[0].error) == NULL) {
  154|      1|        ERR_load_strings(0, DSO_str_functs);
  155|      1|        ERR_load_strings(0, DSO_str_reasons);
  156|      1|    }
  157|      1|#endif
  158|      1|}

DSO_new_method:
   96|      4|{
   97|      4|    DSO *ret;
   98|       |
   99|      4|    if (default_DSO_meth == NULL)
  100|       |        /*
  101|       |         * We default to DSO_METH_openssl() which in turn defaults to
  102|       |         * stealing the "best available" method. Will fallback to
  103|       |         * DSO_METH_null() in the worst case.
  104|       |         */
  105|      1|        default_DSO_meth = DSO_METHOD_openssl();
  106|      4|    ret = (DSO *)OPENSSL_malloc(sizeof(DSO));
  107|      4|    if (ret == NULL) {
  108|      0|        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);
  109|      0|        return (NULL);
  110|      0|    }
  111|      4|    memset(ret, 0, sizeof(DSO));
  112|      4|    ret->meth_data = sk_void_new_null();
  113|      4|    if (ret->meth_data == NULL) {
  114|       |        /* sk_new doesn't generate any errors so we do */
  115|      0|        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);
  116|      0|        OPENSSL_free(ret);
  117|      0|        return (NULL);
  118|      0|    }
  119|      4|    if (meth == NULL)
  120|      4|        ret->meth = default_DSO_meth;
  121|      0|    else
  122|      0|        ret->meth = meth;
  123|      4|    ret->references = 1;
  124|      4|    if ((ret->meth->init != NULL) && !ret->meth->init(ret)) {
  125|      0|        sk_void_free(ret->meth_data);
  126|      0|        OPENSSL_free(ret);
  127|      0|        ret = NULL;
  128|      0|    }
  129|      4|    return (ret);
  130|      4|}
DSO_free:
  133|      4|{
  134|      4|    int i;
  135|       |
  136|      4|    if (dso == NULL) {
  137|      0|        DSOerr(DSO_F_DSO_FREE, ERR_R_PASSED_NULL_PARAMETER);
  138|      0|        return (0);
  139|      0|    }
  140|       |
  141|      4|    i = CRYPTO_add(&dso->references, -1, CRYPTO_LOCK_DSO);
  142|       |#ifdef REF_PRINT
  143|       |    REF_PRINT("DSO", dso);
  144|       |#endif
  145|      4|    if (i > 0)
  146|      0|        return (1);
  147|       |#ifdef REF_CHECK
  148|       |    if (i < 0) {
  149|       |        fprintf(stderr, "DSO_free, bad reference count\n");
  150|       |        abort();
  151|       |    }
  152|       |#endif
  153|       |
  154|      4|    if ((dso->meth->dso_unload != NULL) && !dso->meth->dso_unload(dso)) {
  155|      0|        DSOerr(DSO_F_DSO_FREE, DSO_R_UNLOAD_FAILED);
  156|      0|        return (0);
  157|      0|    }
  158|       |
  159|      4|    if ((dso->meth->finish != NULL) && !dso->meth->finish(dso)) {
  160|      0|        DSOerr(DSO_F_DSO_FREE, DSO_R_FINISH_FAILED);
  161|      0|        return (0);
  162|      0|    }
  163|       |
  164|      4|    sk_void_free(dso->meth_data);
  165|      4|    if (dso->filename != NULL)
  166|      4|        OPENSSL_free(dso->filename);
  167|      4|    if (dso->loaded_filename != NULL)
  168|      0|        OPENSSL_free(dso->loaded_filename);
  169|       |
  170|      4|    OPENSSL_free(dso);
  171|      4|    return (1);
  172|      4|}
DSO_flags:
  175|      8|{
  176|      8|    return ((dso == NULL) ? 0 : dso->flags);
  177|      8|}
DSO_load:
  191|      4|{
  192|      4|    DSO *ret;
  193|      4|    int allocated = 0;
  194|       |
  195|      4|    if (dso == NULL) {
  196|      4|        ret = DSO_new_method(meth);
  197|      4|        if (ret == NULL) {
  198|      0|            DSOerr(DSO_F_DSO_LOAD, ERR_R_MALLOC_FAILURE);
  199|      0|            goto err;
  200|      0|        }
  201|      4|        allocated = 1;
  202|       |        /* Pass the provided flags to the new DSO object */
  203|      4|        if (DSO_ctrl(ret, DSO_CTRL_SET_FLAGS, flags, NULL) < 0) {
  204|      0|            DSOerr(DSO_F_DSO_LOAD, DSO_R_CTRL_FAILED);
  205|      0|            goto err;
  206|      0|        }
  207|      4|    } else
  208|      0|        ret = dso;
  209|       |    /* Don't load if we're currently already loaded */
  210|      4|    if (ret->filename != NULL) {
  211|      0|        DSOerr(DSO_F_DSO_LOAD, DSO_R_DSO_ALREADY_LOADED);
  212|      0|        goto err;
  213|      0|    }
  214|       |    /*
  215|       |     * filename can only be NULL if we were passed a dso that already has one
  216|       |     * set.
  217|       |     */
  218|      4|    if (filename != NULL)
  219|      4|        if (!DSO_set_filename(ret, filename)) {
  220|      0|            DSOerr(DSO_F_DSO_LOAD, DSO_R_SET_FILENAME_FAILED);
  221|      0|            goto err;
  222|      0|        }
  223|      4|    filename = ret->filename;
  224|      4|    if (filename == NULL) {
  225|      0|        DSOerr(DSO_F_DSO_LOAD, DSO_R_NO_FILENAME);
  226|      0|        goto err;
  227|      0|    }
  228|      4|    if (ret->meth->dso_load == NULL) {
  229|      0|        DSOerr(DSO_F_DSO_LOAD, DSO_R_UNSUPPORTED);
  230|      0|        goto err;
  231|      0|    }
  232|      4|    if (!ret->meth->dso_load(ret)) {
  233|      4|        DSOerr(DSO_F_DSO_LOAD, DSO_R_LOAD_FAILED);
  234|      4|        goto err;
  235|      4|    }
  236|       |    /* Load succeeded */
  237|      0|    return (ret);
  238|      4| err:
  239|      4|    if (allocated)
  240|      4|        DSO_free(ret);
  241|      4|    return (NULL);
  242|      4|}
DSO_ctrl:
  294|      4|{
  295|      4|    if (dso == NULL) {
  296|      0|        DSOerr(DSO_F_DSO_CTRL, ERR_R_PASSED_NULL_PARAMETER);
  297|      0|        return (-1);
  298|      0|    }
  299|       |    /*
  300|       |     * We should intercept certain generic commands and only pass control to
  301|       |     * the method-specific ctrl() function if it's something we don't handle.
  302|       |     */
  303|      4|    switch (cmd) {
  304|      0|    case DSO_CTRL_GET_FLAGS:
  305|      0|        return dso->flags;
  306|      4|    case DSO_CTRL_SET_FLAGS:
  307|      4|        dso->flags = (int)larg;
  308|      4|        return (0);
  309|      0|    case DSO_CTRL_OR_FLAGS:
  310|      0|        dso->flags |= (int)larg;
  311|      0|        return (0);
  312|      0|    default:
  313|      0|        break;
  314|      4|    }
  315|      0|    if ((dso->meth == NULL) || (dso->meth->dso_ctrl == NULL)) {
  316|      0|        DSOerr(DSO_F_DSO_CTRL, DSO_R_UNSUPPORTED);
  317|      0|        return (-1);
  318|      0|    }
  319|      0|    return (dso->meth->dso_ctrl(dso, cmd, larg, parg));
  320|      0|}
DSO_set_filename:
  345|      4|{
  346|      4|    char *copied;
  347|       |
  348|      4|    if ((dso == NULL) || (filename == NULL)) {
  349|      0|        DSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_PASSED_NULL_PARAMETER);
  350|      0|        return (0);
  351|      0|    }
  352|      4|    if (dso->loaded_filename) {
  353|      0|        DSOerr(DSO_F_DSO_SET_FILENAME, DSO_R_DSO_ALREADY_LOADED);
  354|      0|        return (0);
  355|      0|    }
  356|       |    /* We'll duplicate filename */
  357|      4|    copied = OPENSSL_malloc(strlen(filename) + 1);
  358|      4|    if (copied == NULL) {
  359|      0|        DSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_MALLOC_FAILURE);
  360|      0|        return (0);
  361|      0|    }
  362|      4|    BUF_strlcpy(copied, filename, strlen(filename) + 1);
  363|      4|    if (dso->filename)
  364|      0|        OPENSSL_free(dso->filename);
  365|      4|    dso->filename = copied;
  366|      4|    return (1);
  367|      4|}
DSO_convert_filename:
  387|      4|{
  388|      4|    char *result = NULL;
  389|       |
  390|      4|    if (dso == NULL) {
  391|      0|        DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_PASSED_NULL_PARAMETER);
  392|      0|        return (NULL);
  393|      0|    }
  394|      4|    if (filename == NULL)
  395|      4|        filename = dso->filename;
  396|      4|    if (filename == NULL) {
  397|      0|        DSOerr(DSO_F_DSO_CONVERT_FILENAME, DSO_R_NO_FILENAME);
  398|      0|        return (NULL);
  399|      0|    }
  400|      4|    if ((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0) {
  401|      4|        if (dso->name_converter != NULL)
  402|      0|            result = dso->name_converter(dso, filename);
  403|      4|        else if (dso->meth->dso_name_converter != NULL)
  404|      4|            result = dso->meth->dso_name_converter(dso, filename);
  405|      4|    }
  406|      4|    if (result == NULL) {
  407|      0|        result = OPENSSL_malloc(strlen(filename) + 1);
  408|      0|        if (result == NULL) {
  409|      0|            DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_MALLOC_FAILURE);
  410|      0|            return (NULL);
  411|      0|        }
  412|      0|        BUF_strlcpy(result, filename, strlen(filename) + 1);
  413|      0|    }
  414|      4|    return (result);
  415|      4|}

DSO_METHOD_openssl:
   67|      1|{
   68|       |#ifdef DEF_DSO_METHOD
   69|       |    return (DEF_DSO_METHOD());
   70|       |#elif defined(DSO_DLFCN)
   71|      1|    return (DSO_METHOD_dlfcn());
   72|       |#elif defined(DSO_DL)
   73|       |    return (DSO_METHOD_dl());
   74|       |#elif defined(DSO_WIN32)
   75|       |    return (DSO_METHOD_win32());
   76|       |#elif defined(DSO_VMS)
   77|       |    return (DSO_METHOD_vms());
   78|       |#elif defined(DSO_BEOS)
   79|       |    return (DSO_METHOD_beos());
   80|       |#else
   81|       |    return (DSO_METHOD_null());
   82|       |#endif
   83|      1|}

ERR_load_EC_strings:
  324|      1|{
  325|      1|#ifndef OPENSSL_NO_ERR
  326|       |
  327|      1|    if (ERR_func_error_string(EC_str_functs[0].error) == NULL) {
  328|      1|        ERR_load_strings(0, EC_str_functs);
  329|      1|        ERR_load_strings(0, EC_str_reasons);
  330|      1|    }
  331|      1|#endif
  332|      1|}

ERR_load_ECDH_strings:
   90|      1|{
   91|      1|#ifndef OPENSSL_NO_ERR
   92|       |
   93|      1|    if (ERR_func_error_string(ECDH_str_functs[0].error) == NULL) {
   94|      1|        ERR_load_strings(0, ECDH_str_functs);
   95|      1|        ERR_load_strings(0, ECDH_str_reasons);
   96|      1|    }
   97|      1|#endif
   98|      1|}

ERR_load_ECDSA_strings:
   99|      1|{
  100|      1|#ifndef OPENSSL_NO_ERR
  101|       |
  102|      1|    if (ERR_func_error_string(ECDSA_str_functs[0].error) == NULL) {
  103|      1|        ERR_load_strings(0, ECDSA_str_functs);
  104|      1|        ERR_load_strings(0, ECDSA_str_reasons);
  105|      1|    }
  106|      1|#endif
  107|      1|}

eng_table.c:engine_pile_LHASH_HASH:
  105|  8.38k|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|  8.38k|                const o_type *a = arg; \
  107|  8.38k|                return name##_hash(a); }
eng_table.c:engine_pile_LHASH_COMP:
  114|     29|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|     29|                const o_type *a = arg1;             \
  116|     29|                const o_type *b = arg2; \
  117|     29|                return name##_cmp(a,b); }

ENGINE_load_builtin_engines:
   64|      1|{
   65|       |    /* Some ENGINEs need this */
   66|      1|    OPENSSL_cpuid_setup();
   67|       |#if 0
   68|       |    /*
   69|       |     * There's no longer any need for an "openssl" ENGINE unless, one day, it
   70|       |     * is the *only* way for standard builtin implementations to be be
   71|       |     * accessed (ie. it would be possible to statically link binaries with
   72|       |     * *no* builtin implementations).
   73|       |     */
   74|       |    ENGINE_load_openssl();
   75|       |#endif
   76|       |#if !defined(OPENSSL_NO_HW) && (defined(__OpenBSD__) || defined(__FreeBSD__) || defined(HAVE_CRYPTODEV))
   77|       |    ENGINE_load_cryptodev();
   78|       |#endif
   79|      1|#ifndef OPENSSL_NO_RDRAND
   80|      1|    ENGINE_load_rdrand();
   81|      1|#endif
   82|      1|    ENGINE_load_dynamic();
   83|      1|#ifndef OPENSSL_NO_STATIC_ENGINE
   84|      1|# ifndef OPENSSL_NO_HW
   85|      1|#  ifndef OPENSSL_NO_HW_4758_CCA
   86|      1|    ENGINE_load_4758cca();
   87|      1|#  endif
   88|      1|#  ifndef OPENSSL_NO_HW_AEP
   89|      1|    ENGINE_load_aep();
   90|      1|#  endif
   91|      1|#  ifndef OPENSSL_NO_HW_ATALLA
   92|      1|    ENGINE_load_atalla();
   93|      1|#  endif
   94|      1|#  ifndef OPENSSL_NO_HW_CSWIFT
   95|      1|    ENGINE_load_cswift();
   96|      1|#  endif
   97|      1|#  ifndef OPENSSL_NO_HW_NCIPHER
   98|      1|    ENGINE_load_chil();
   99|      1|#  endif
  100|      1|#  ifndef OPENSSL_NO_HW_NURON
  101|      1|    ENGINE_load_nuron();
  102|      1|#  endif
  103|      1|#  ifndef OPENSSL_NO_HW_SUREWARE
  104|      1|    ENGINE_load_sureware();
  105|      1|#  endif
  106|      1|#  ifndef OPENSSL_NO_HW_UBSEC
  107|      1|    ENGINE_load_ubsec();
  108|      1|#  endif
  109|      1|#  ifndef OPENSSL_NO_HW_PADLOCK
  110|      1|    ENGINE_load_padlock();
  111|      1|#  endif
  112|      1|# endif
  113|      1|# ifndef OPENSSL_NO_GOST
  114|      1|    ENGINE_load_gost();
  115|      1|# endif
  116|       |# ifndef OPENSSL_NO_GMP
  117|       |    ENGINE_load_gmp();
  118|       |# endif
  119|       |# if defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_NO_CAPIENG)
  120|       |    ENGINE_load_capi();
  121|       |# endif
  122|      1|#endif
  123|      1|    ENGINE_register_all_complete();
  124|      1|}

ENGINE_add_conf_module:
  239|      1|{
  240|      1|    CONF_module_add("engines",
  241|      1|                    int_engine_module_init, int_engine_module_finish);
  242|      1|}

ENGINE_load_dynamic:
  312|      1|{
  313|      1|    ENGINE *toadd = engine_dynamic();
  314|      1|    if (!toadd)
  315|      0|        return;
  316|      1|    ENGINE_add(toadd);
  317|       |    /*
  318|       |     * If the "add" worked, it gets a structural reference. So either way, we
  319|       |     * release our just-created reference.
  320|       |     */
  321|      1|    ENGINE_free(toadd);
  322|       |    /*
  323|       |     * If the "add" didn't work, it was probably a conflict because it was
  324|       |     * already added (eg. someone calling ENGINE_load_blah then calling
  325|       |     * ENGINE_load_builtin_engines() perhaps).
  326|       |     */
  327|      1|    ERR_clear_error();
  328|      1|}
eng_dyn.c:engine_dynamic:
  294|      1|{
  295|      1|    ENGINE *ret = ENGINE_new();
  296|      1|    if (!ret)
  297|      0|        return NULL;
  298|      1|    if (!ENGINE_set_id(ret, engine_dynamic_id) ||
  299|      1|        !ENGINE_set_name(ret, engine_dynamic_name) ||
  300|      1|        !ENGINE_set_init_function(ret, dynamic_init) ||
  301|      1|        !ENGINE_set_finish_function(ret, dynamic_finish) ||
  302|      1|        !ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||
  303|      1|        !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||
  304|      1|        !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) {
  305|      0|        ENGINE_free(ret);
  306|      0|        return NULL;
  307|      0|    }
  308|      1|    return ret;
  309|      1|}

ERR_load_ENGINE_strings:
  173|      1|{
  174|      1|#ifndef OPENSSL_NO_ERR
  175|       |
  176|      1|    if (ERR_func_error_string(ENGINE_str_functs[0].error) == NULL) {
  177|      1|        ERR_load_strings(0, ENGINE_str_functs);
  178|      1|        ERR_load_strings(0, ENGINE_str_reasons);
  179|      1|    }
  180|      1|#endif
  181|      1|}

ENGINE_register_complete:
  150|     10|{
  151|     10|    ENGINE_register_ciphers(e);
  152|     10|    ENGINE_register_digests(e);
  153|     10|#ifndef OPENSSL_NO_RSA
  154|     10|    ENGINE_register_RSA(e);
  155|     10|#endif
  156|     10|#ifndef OPENSSL_NO_DSA
  157|     10|    ENGINE_register_DSA(e);
  158|     10|#endif
  159|     10|#ifndef OPENSSL_NO_DH
  160|     10|    ENGINE_register_DH(e);
  161|     10|#endif
  162|     10|#ifndef OPENSSL_NO_ECDH
  163|     10|    ENGINE_register_ECDH(e);
  164|     10|#endif
  165|     10|#ifndef OPENSSL_NO_ECDSA
  166|     10|    ENGINE_register_ECDSA(e);
  167|     10|#endif
  168|     10|    ENGINE_register_RAND(e);
  169|     10|    ENGINE_register_pkey_meths(e);
  170|     10|    return 1;
  171|     10|}
ENGINE_register_all_complete:
  174|      1|{
  175|      1|    ENGINE *e;
  176|       |
  177|     12|    for (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))
  178|     11|        if (!(e->flags & ENGINE_FLAGS_NO_REGISTER_ALL))
  179|     10|            ENGINE_register_complete(e);
  180|      1|    return 1;
  181|      1|}

engine_unlocked_init:
   63|      4|{
   64|      4|    int to_return = 1;
   65|       |
   66|      4|    if ((e->funct_ref == 0) && e->init)
   67|       |        /*
   68|       |         * This is the first functional reference and the engine requires
   69|       |         * initialisation so we do it now.
   70|       |         */
   71|      4|        to_return = e->init(e);
   72|      4|    if (to_return) {
   73|       |        /*
   74|       |         * OK, we return a functional reference which is also a structural
   75|       |         * reference.
   76|       |         */
   77|      0|        e->struct_ref++;
   78|      0|        e->funct_ref++;
   79|      0|        engine_ref_debug(e, 0, 1)
   80|      0|            engine_ref_debug(e, 1, 1)
   81|      0|    }
   82|      4|    return to_return;
   83|      4|}

ENGINE_new:
   66|     11|{
   67|     11|    ENGINE *ret;
   68|       |
   69|     11|    ret = (ENGINE *)OPENSSL_malloc(sizeof(ENGINE));
   70|     11|    if (ret == NULL) {
   71|      0|        ENGINEerr(ENGINE_F_ENGINE_NEW, ERR_R_MALLOC_FAILURE);
   72|      0|        return NULL;
   73|      0|    }
   74|     11|    memset(ret, 0, sizeof(ENGINE));
   75|     11|    ret->struct_ref = 1;
   76|     11|    engine_ref_debug(ret, 0, 1)
   77|     11|        CRYPTO_new_ex_data(CRYPTO_EX_INDEX_ENGINE, ret, &ret->ex_data);
   78|     11|    return ret;
   79|     11|}
engine_free_util:
  108|     22|{
  109|     22|    int i;
  110|       |
  111|     22|    if (e == NULL) {
  112|      0|        ENGINEerr(ENGINE_F_ENGINE_FREE_UTIL, ERR_R_PASSED_NULL_PARAMETER);
  113|      0|        return 0;
  114|      0|    }
  115|     22|    if (locked)
  116|     22|        i = CRYPTO_add(&e->struct_ref, -1, CRYPTO_LOCK_ENGINE);
  117|      0|    else
  118|      0|        i = --e->struct_ref;
  119|     22|    engine_ref_debug(e, 0, -1)
  120|     22|        if (i > 0)
  121|     22|        return 1;
  122|       |#ifdef REF_CHECK
  123|       |    if (i < 0) {
  124|       |        fprintf(stderr, "ENGINE_free, bad structural reference count\n");
  125|       |        abort();
  126|       |    }
  127|       |#endif
  128|       |    /* Free up any dynamically allocated public key methods */
  129|      0|    engine_pkey_meths_free(e);
  130|      0|    engine_pkey_asn1_meths_free(e);
  131|       |    /*
  132|       |     * Give the ENGINE a chance to do any structural cleanup corresponding to
  133|       |     * allocation it did in its constructor (eg. unload error strings)
  134|       |     */
  135|      0|    if (e->destroy)
  136|      0|        e->destroy(e);
  137|      0|    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_ENGINE, e, &e->ex_data);
  138|      0|    OPENSSL_free(e);
  139|      0|    return 1;
  140|     22|}
ENGINE_free:
  143|     22|{
  144|     22|    return engine_free_util(e, 1);
  145|     22|}
engine_cleanup_add_first:
  176|      7|{
  177|      7|    ENGINE_CLEANUP_ITEM *item;
  178|      7|    if (!int_cleanup_check(1))
  179|      0|        return;
  180|      7|    item = int_cleanup_item(cb);
  181|      7|    if (item)
  182|      7|        sk_ENGINE_CLEANUP_ITEM_insert(cleanup_stack, item, 0);
  183|      7|}
engine_cleanup_add_last:
  186|      1|{
  187|      1|    ENGINE_CLEANUP_ITEM *item;
  188|      1|    if (!int_cleanup_check(1))
  189|      0|        return;
  190|      1|    item = int_cleanup_item(cb);
  191|      1|    if (item)
  192|      1|        sk_ENGINE_CLEANUP_ITEM_push(cleanup_stack, item);
  193|      1|}
ENGINE_set_id:
  242|     11|{
  243|     11|    if (id == NULL) {
  244|      0|        ENGINEerr(ENGINE_F_ENGINE_SET_ID, ERR_R_PASSED_NULL_PARAMETER);
  245|      0|        return 0;
  246|      0|    }
  247|     11|    e->id = id;
  248|     11|    return 1;
  249|     11|}
ENGINE_set_name:
  252|     11|{
  253|     11|    if (name == NULL) {
  254|      0|        ENGINEerr(ENGINE_F_ENGINE_SET_NAME, ERR_R_PASSED_NULL_PARAMETER);
  255|      0|        return 0;
  256|      0|    }
  257|     11|    e->name = name;
  258|     11|    return 1;
  259|     11|}
ENGINE_set_destroy_function:
  262|      9|{
  263|      9|    e->destroy = destroy_f;
  264|      9|    return 1;
  265|      9|}
ENGINE_set_init_function:
  268|     11|{
  269|     11|    e->init = init_f;
  270|     11|    return 1;
  271|     11|}
ENGINE_set_finish_function:
  274|     10|{
  275|     10|    e->finish = finish_f;
  276|     10|    return 1;
  277|     10|}
ENGINE_set_ctrl_function:
  280|     10|{
  281|     10|    e->ctrl = ctrl_f;
  282|     10|    return 1;
  283|     10|}
ENGINE_set_flags:
  286|      2|{
  287|      2|    e->flags = flags;
  288|      2|    return 1;
  289|      2|}
ENGINE_set_cmd_defns:
  292|      9|{
  293|      9|    e->cmd_defns = defns;
  294|      9|    return 1;
  295|      9|}
eng_lib.c:int_cleanup_check:
  157|      8|{
  158|      8|    if (cleanup_stack)
  159|      7|        return 1;
  160|      1|    if (!create)
  161|      0|        return 0;
  162|      1|    cleanup_stack = sk_ENGINE_CLEANUP_ITEM_new_null();
  163|      1|    return (cleanup_stack ? 1 : 0);
  164|      1|}
eng_lib.c:int_cleanup_item:
  167|      8|{
  168|      8|    ENGINE_CLEANUP_ITEM *item = OPENSSL_malloc(sizeof(ENGINE_CLEANUP_ITEM));
  169|      8|    if (!item)
  170|      0|        return NULL;
  171|      8|    item->cb = cb;
  172|      8|    return item;
  173|      8|}

ENGINE_get_first:
  185|      1|{
  186|      1|    ENGINE *ret;
  187|       |
  188|      1|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  189|      1|    ret = engine_list_head;
  190|      1|    if (ret) {
  191|      1|        ret->struct_ref++;
  192|      1|        engine_ref_debug(ret, 0, 1)
  193|      1|    }
  194|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  195|      1|    return ret;
  196|      1|}
ENGINE_get_next:
  214|     11|{
  215|     11|    ENGINE *ret = NULL;
  216|     11|    if (e == NULL) {
  217|      0|        ENGINEerr(ENGINE_F_ENGINE_GET_NEXT, ERR_R_PASSED_NULL_PARAMETER);
  218|      0|        return 0;
  219|      0|    }
  220|     11|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  221|     11|    ret = e->next;
  222|     11|    if (ret) {
  223|       |        /* Return a valid structural refernce to the next ENGINE */
  224|     10|        ret->struct_ref++;
  225|     10|        engine_ref_debug(ret, 0, 1)
  226|     10|    }
  227|     11|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  228|       |    /* Release the structural reference to the previous ENGINE */
  229|     11|    ENGINE_free(e);
  230|     11|    return ret;
  231|     11|}
ENGINE_add:
  255|     11|{
  256|     11|    int to_return = 1;
  257|     11|    if (e == NULL) {
  258|      0|        ENGINEerr(ENGINE_F_ENGINE_ADD, ERR_R_PASSED_NULL_PARAMETER);
  259|      0|        return 0;
  260|      0|    }
  261|     11|    if ((e->id == NULL) || (e->name == NULL)) {
  262|      0|        ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_ID_OR_NAME_MISSING);
  263|      0|        return 0;
  264|      0|    }
  265|     11|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  266|     11|    if (!engine_list_add(e)) {
  267|      0|        ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
  268|      0|        to_return = 0;
  269|      0|    }
  270|     11|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  271|     11|    return to_return;
  272|     11|}
eng_list.c:engine_list_add:
  103|     11|{
  104|     11|    int conflict = 0;
  105|     11|    ENGINE *iterator = NULL;
  106|       |
  107|     11|    if (e == NULL) {
  108|      0|        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER);
  109|      0|        return 0;
  110|      0|    }
  111|     11|    iterator = engine_list_head;
  112|     66|    while (iterator && !conflict) {
  113|     55|        conflict = (strcmp(iterator->id, e->id) == 0);
  114|     55|        iterator = iterator->next;
  115|     55|    }
  116|     11|    if (conflict) {
  117|      0|        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID);
  118|      0|        return 0;
  119|      0|    }
  120|     11|    if (engine_list_head == NULL) {
  121|       |        /* We are adding to an empty list. */
  122|      1|        if (engine_list_tail) {
  123|      0|            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
  124|      0|            return 0;
  125|      0|        }
  126|      1|        engine_list_head = e;
  127|      1|        e->prev = NULL;
  128|       |        /*
  129|       |         * The first time the list allocates, we should register the cleanup.
  130|       |         */
  131|      1|        engine_cleanup_add_last(engine_list_cleanup);
  132|     10|    } else {
  133|       |        /* We are adding to the tail of an existing list. */
  134|     10|        if ((engine_list_tail == NULL) || (engine_list_tail->next != NULL)) {
  135|      0|            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
  136|      0|            return 0;
  137|      0|        }
  138|     10|        engine_list_tail->next = e;
  139|     10|        e->prev = engine_list_tail;
  140|     10|    }
  141|       |    /*
  142|       |     * Having the engine in the list assumes a structural reference.
  143|       |     */
  144|     11|    e->struct_ref++;
  145|     11|    engine_ref_debug(e, 0, 1)
  146|       |        /* However it came to be, e is the last item in the list. */
  147|     11|        engine_list_tail = e;
  148|     11|    e->next = NULL;
  149|     11|    return 1;
  150|     11|}

ENGINE_set_load_privkey_function:
   62|      3|{
   63|      3|    e->load_privkey = loadpriv_f;
   64|      3|    return 1;
   65|      3|}
ENGINE_set_load_pubkey_function:
   68|      3|{
   69|      3|    e->load_pubkey = loadpub_f;
   70|      3|    return 1;
   71|      3|}

ENGINE_load_rdrand:
  133|      1|{
  134|      1|    extern unsigned int OPENSSL_ia32cap_P[];
  135|       |
  136|      1|    if (OPENSSL_ia32cap_P[1] & (1 << (62 - 32))) {
  137|      1|        ENGINE *toadd = ENGINE_rdrand();
  138|      1|        if (!toadd)
  139|      0|            return;
  140|      1|        ENGINE_add(toadd);
  141|      1|        ENGINE_free(toadd);
  142|      1|        ERR_clear_error();
  143|      1|    }
  144|      1|}
eng_rdrand.c:ENGINE_rdrand:
  121|      1|{
  122|      1|    ENGINE *ret = ENGINE_new();
  123|      1|    if (!ret)
  124|      0|        return NULL;
  125|      1|    if (!bind_helper(ret)) {
  126|      0|        ENGINE_free(ret);
  127|      0|        return NULL;
  128|      0|    }
  129|      1|    return ret;
  130|      1|}
eng_rdrand.c:bind_helper:
  109|      1|{
  110|      1|    if (!ENGINE_set_id(e, engine_e_rdrand_id) ||
  111|      1|        !ENGINE_set_name(e, engine_e_rdrand_name) ||
  112|      1|        !ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL) ||
  113|      1|        !ENGINE_set_init_function(e, rdrand_init) ||
  114|      1|        !ENGINE_set_RAND(e, &rdrand_meth))
  115|      0|        return 0;
  116|       |
  117|      1|    return 1;
  118|      1|}

engine_table_register:
  135|     31|{
  136|     31|    int ret = 0, added = 0;
  137|     31|    ENGINE_PILE tmplate, *fnd;
  138|     31|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  139|     31|    if (!(*table))
  140|      7|        added = 1;
  141|     31|    if (!int_table_check(table, 1))
  142|      0|        goto end;
  143|     31|    if (added)
  144|       |        /* The cleanup callback needs to be added */
  145|      7|        engine_cleanup_add_first(cleanup);
  146|     70|    while (num_nids--) {
  147|     39|        tmplate.nid = *nids;
  148|     39|        fnd = lh_ENGINE_PILE_retrieve(&(*table)->piles, &tmplate);
  149|     39|        if (!fnd) {
  150|     11|            fnd = OPENSSL_malloc(sizeof(ENGINE_PILE));
  151|     11|            if (!fnd)
  152|      0|                goto end;
  153|     11|            fnd->uptodate = 1;
  154|     11|            fnd->nid = *nids;
  155|     11|            fnd->sk = sk_ENGINE_new_null();
  156|     11|            if (!fnd->sk) {
  157|      0|                OPENSSL_free(fnd);
  158|      0|                goto end;
  159|      0|            }
  160|     11|            fnd->funct = NULL;
  161|     11|            (void)lh_ENGINE_PILE_insert(&(*table)->piles, fnd);
  162|     11|        }
  163|       |        /* A registration shouldn't add duplciate entries */
  164|     39|        (void)sk_ENGINE_delete_ptr(fnd->sk, e);
  165|       |        /*
  166|       |         * if 'setdefault', this ENGINE goes to the head of the list
  167|       |         */
  168|     39|        if (!sk_ENGINE_push(fnd->sk, e))
  169|      0|            goto end;
  170|       |        /* "touch" this ENGINE_PILE */
  171|     39|        fnd->uptodate = 0;
  172|     39|        if (setdefault) {
  173|      0|            if (!engine_unlocked_init(e)) {
  174|      0|                ENGINEerr(ENGINE_F_ENGINE_TABLE_REGISTER,
  175|      0|                          ENGINE_R_INIT_FAILED);
  176|      0|                goto end;
  177|      0|            }
  178|      0|            if (fnd->funct)
  179|      0|                engine_unlocked_finish(fnd->funct, 0);
  180|      0|            fnd->funct = e;
  181|      0|            fnd->uptodate = 1;
  182|      0|        }
  183|     39|        nids++;
  184|     39|    }
  185|     31|    ret = 1;
  186|     31| end:
  187|     31|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  188|     31|    return ret;
  189|     31|}
engine_table_select:
  246|  8.33k|{
  247|  8.33k|    ENGINE *ret = NULL;
  248|  8.33k|    ENGINE_PILE tmplate, *fnd = NULL;
  249|  8.33k|    int initres, loop = 0;
  250|       |
  251|  8.33k|    if (!(*table)) {
  252|       |#ifdef ENGINE_TABLE_DEBUG
  253|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, nothing "
  254|       |                "registered!\n", f, l, nid);
  255|       |#endif
  256|      0|        return NULL;
  257|      0|    }
  258|  8.33k|    ERR_set_mark();
  259|  8.33k|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  260|       |    /*
  261|       |     * Check again inside the lock otherwise we could race against cleanup
  262|       |     * operations. But don't worry about a fprintf(stderr).
  263|       |     */
  264|  8.33k|    if (!int_table_check(table, 0))
  265|      0|        goto end;
  266|  8.33k|    tmplate.nid = nid;
  267|  8.33k|    fnd = lh_ENGINE_PILE_retrieve(&(*table)->piles, &tmplate);
  268|  8.33k|    if (!fnd)
  269|  8.33k|        goto end;
  270|      1|    if (fnd->funct && engine_unlocked_init(fnd->funct)) {
  271|       |#ifdef ENGINE_TABLE_DEBUG
  272|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, using "
  273|       |                "ENGINE '%s' cached\n", f, l, nid, fnd->funct->id);
  274|       |#endif
  275|      0|        ret = fnd->funct;
  276|      0|        goto end;
  277|      0|    }
  278|      1|    if (fnd->uptodate) {
  279|      0|        ret = fnd->funct;
  280|      0|        goto end;
  281|      0|    }
  282|      5| trynext:
  283|      5|    ret = sk_ENGINE_value(fnd->sk, loop++);
  284|      5|    if (!ret) {
  285|       |#ifdef ENGINE_TABLE_DEBUG
  286|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, no "
  287|       |                "registered implementations would initialise\n", f, l, nid);
  288|       |#endif
  289|      1|        goto end;
  290|      1|    }
  291|       |    /* Try to initialise the ENGINE? */
  292|      4|    if ((ret->funct_ref > 0) || !(table_flags & ENGINE_TABLE_FLAG_NOINIT))
  293|      4|        initres = engine_unlocked_init(ret);
  294|      0|    else
  295|      0|        initres = 0;
  296|      4|    if (initres) {
  297|       |        /* Update 'funct' */
  298|      0|        if ((fnd->funct != ret) && engine_unlocked_init(ret)) {
  299|       |            /* If there was a previous default we release it. */
  300|      0|            if (fnd->funct)
  301|      0|                engine_unlocked_finish(fnd->funct, 0);
  302|      0|            fnd->funct = ret;
  303|       |#ifdef ENGINE_TABLE_DEBUG
  304|       |            fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, "
  305|       |                    "setting default to '%s'\n", f, l, nid, ret->id);
  306|       |#endif
  307|      0|        }
  308|       |#ifdef ENGINE_TABLE_DEBUG
  309|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, using "
  310|       |                "newly initialised '%s'\n", f, l, nid, ret->id);
  311|       |#endif
  312|      0|        goto end;
  313|      0|    }
  314|      4|    goto trynext;
  315|  8.33k| end:
  316|       |    /*
  317|       |     * If it failed, it is unlikely to succeed again until some future
  318|       |     * registrations have taken place. In all cases, we cache.
  319|       |     */
  320|  8.33k|    if (fnd)
  321|      1|        fnd->uptodate = 1;
  322|       |#ifdef ENGINE_TABLE_DEBUG
  323|       |    if (ret)
  324|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, caching "
  325|       |                "ENGINE '%s'\n", f, l, nid, ret->id);
  326|       |    else
  327|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, caching "
  328|       |                "'no matching ENGINE'\n", f, l, nid);
  329|       |#endif
  330|  8.33k|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  331|       |    /*
  332|       |     * Whatever happened, any failed init()s are not failures in this
  333|       |     * context, so clear our error state.
  334|       |     */
  335|  8.33k|    ERR_pop_to_mark();
  336|  8.33k|    return ret;
  337|      4|}
engine_table_doall:
  350|    121|{
  351|    121|    ENGINE_PILE_DOALL dall;
  352|    121|    dall.cb = cb;
  353|    121|    dall.arg = arg;
  354|    121|    if (table)
  355|    121|        lh_ENGINE_PILE_doall_arg(&table->piles,
  356|    121|                                 LHASH_DOALL_ARG_FN(int_cb),
  357|    121|                                 ENGINE_PILE_DOALL, &dall);
  358|    121|}
eng_table.c:int_table_check:
  115|  8.36k|{
  116|  8.36k|    LHASH_OF(ENGINE_PILE) *lh;
  117|       |
  118|  8.36k|    if (*t)
  119|  8.35k|        return 1;
  120|      7|    if (!create)
  121|      0|        return 0;
  122|      7|    if ((lh = lh_ENGINE_PILE_new()) == NULL)
  123|      0|        return 0;
  124|      7|    *t = (ENGINE_TABLE *)lh;
  125|      7|    return 1;
  126|      7|}
eng_table.c:engine_pile_hash:
  102|  8.38k|{
  103|  8.38k|    return c->nid;
  104|  8.38k|}
eng_table.c:engine_pile_cmp:
  107|     29|{
  108|     29|    return a->nid - b->nid;
  109|     29|}

ENGINE_set_pkey_asn1_meths:
  147|      1|{
  148|      1|    e->pkey_asn1_meths = f;
  149|      1|    return 1;
  150|      1|}
ENGINE_pkey_asn1_find_str:
  230|    121|{
  231|    121|    ENGINE_FIND_STR fstr;
  232|    121|    fstr.e = NULL;
  233|    121|    fstr.ameth = NULL;
  234|    121|    fstr.str = str;
  235|    121|    fstr.len = len;
  236|    121|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  237|    121|    engine_table_doall(pkey_asn1_meth_table, look_str_cb, &fstr);
  238|       |    /* If found obtain a structural reference to engine */
  239|    121|    if (fstr.e) {
  240|      0|        fstr.e->struct_ref++;
  241|      0|        engine_ref_debug(fstr.e, 0, 1)
  242|      0|    }
  243|    121|    *pe = fstr.e;
  244|    121|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  245|    121|    return fstr.ameth;
  246|    121|}

ENGINE_register_ciphers:
   77|     11|{
   78|     11|    if (e->ciphers) {
   79|      2|        const int *nids;
   80|      2|        int num_nids = e->ciphers(e, NULL, &nids, 0);
   81|      2|        if (num_nids > 0)
   82|      2|            return engine_table_register(&cipher_table,
   83|      2|                                         engine_unregister_all_ciphers, e,
   84|      2|                                         nids, num_nids, 0);
   85|      2|    }
   86|      9|    return 1;
   87|     11|}
ENGINE_set_ciphers:
  140|      1|{
  141|      1|    e->ciphers = f;
  142|      1|    return 1;
  143|      1|}

ENGINE_register_DH:
   78|     10|{
   79|     10|    if (e->dh_meth)
   80|      7|        return engine_table_register(&dh_table,
   81|      7|                                     engine_unregister_all_DH, e, &dummy_nid,
   82|      7|                                     1, 0);
   83|      3|    return 1;
   84|     10|}
ENGINE_set_DH:
  121|      7|{
  122|      7|    e->dh_meth = dh_meth;
  123|      7|    return 1;
  124|      7|}

ENGINE_register_digests:
   77|     11|{
   78|     11|    if (e->digests) {
   79|      2|        const int *nids;
   80|      2|        int num_nids = e->digests(e, NULL, &nids, 0);
   81|      2|        if (num_nids > 0)
   82|      2|            return engine_table_register(&digest_table,
   83|      2|                                         engine_unregister_all_digests, e,
   84|      2|                                         nids, num_nids, 0);
   85|      2|    }
   86|      9|    return 1;
   87|     11|}
ENGINE_get_digest_engine:
  116|  8.33k|{
  117|  8.33k|    return engine_table_select(&digest_table, nid);
  118|  8.33k|}
ENGINE_set_digests:
  140|      1|{
  141|      1|    e->digests = f;
  142|      1|    return 1;
  143|      1|}

ENGINE_register_DSA:
   78|     10|{
   79|     10|    if (e->dsa_meth)
   80|      6|        return engine_table_register(&dsa_table,
   81|      6|                                     engine_unregister_all_DSA, e, &dummy_nid,
   82|      6|                                     1, 0);
   83|      4|    return 1;
   84|     10|}
ENGINE_set_DSA:
  121|      6|{
  122|      6|    e->dsa_meth = dsa_meth;
  123|      6|    return 1;
  124|      6|}

ENGINE_register_ECDH:
   93|     10|{
   94|     10|    if (e->ecdh_meth)
   95|      0|        return engine_table_register(&ecdh_table,
   96|      0|                                     engine_unregister_all_ECDH, e,
   97|      0|                                     &dummy_nid, 1, 0);
   98|     10|    return 1;
   99|     10|}

ENGINE_register_ECDSA:
   78|     10|{
   79|     10|    if (e->ecdsa_meth)
   80|      0|        return engine_table_register(&ecdsa_table,
   81|      0|                                     engine_unregister_all_ECDSA, e,
   82|      0|                                     &dummy_nid, 1, 0);
   83|     10|    return 1;
   84|     10|}

ENGINE_register_pkey_meths:
   78|     11|{
   79|     11|    if (e->pkey_meths) {
   80|      2|        const int *nids;
   81|      2|        int num_nids = e->pkey_meths(e, NULL, &nids, 0);
   82|      2|        if (num_nids > 0)
   83|      2|            return engine_table_register(&pkey_meth_table,
   84|      2|                                         engine_unregister_all_pkey_meths, e,
   85|      2|                                         nids, num_nids, 0);
   86|      2|    }
   87|      9|    return 1;
   88|     11|}
ENGINE_set_pkey_meths:
  142|      1|{
  143|      1|    e->pkey_meths = f;
  144|      1|    return 1;
  145|      1|}

ENGINE_register_RAND:
   78|     10|{
   79|     10|    if (e->rand_meth)
   80|      4|        return engine_table_register(&rand_table,
   81|      4|                                     engine_unregister_all_RAND, e,
   82|      4|                                     &dummy_nid, 1, 0);
   83|      6|    return 1;
   84|     10|}
ENGINE_get_default_RAND:
  109|      1|{
  110|      1|    return engine_table_select(&rand_table, dummy_nid);
  111|      1|}
ENGINE_set_RAND:
  121|      5|{
  122|      5|    e->rand_meth = rand_meth;
  123|      5|    return 1;
  124|      5|}

ENGINE_register_RSA:
   78|     10|{
   79|     10|    if (e->rsa_meth)
   80|      8|        return engine_table_register(&rsa_table,
   81|      8|                                     engine_unregister_all_RSA, e, &dummy_nid,
   82|      8|                                     1, 0);
   83|      2|    return 1;
   84|     10|}
ENGINE_set_RSA:
  121|      8|{
  122|      8|    e->rsa_meth = rsa_meth;
  123|      8|    return 1;
  124|      8|}

err.c:err_string_data_LHASH_HASH:
  105|  19.2k|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|  19.2k|                const o_type *a = arg; \
  107|  19.2k|                return name##_hash(a); }
err.c:err_string_data_LHASH_COMP:
  114|  17.2k|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|  17.2k|                const o_type *a = arg1;             \
  116|  17.2k|                const o_type *b = arg2; \
  117|  17.2k|                return name##_cmp(a,b); }
err.c:err_state_LHASH_HASH:
  105|  23.2k|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|  23.2k|                const o_type *a = arg; \
  107|  23.2k|                return name##_hash(a); }
err.c:err_state_LHASH_COMP:
  114|  20.1k|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|  20.1k|                const o_type *a = arg1;             \
  116|  20.1k|                const o_type *b = arg2; \
  117|  20.1k|                return name##_cmp(a,b); }

ERR_load_ERR_strings:
  659|     81|{
  660|     81|    err_fns_check();
  661|     81|#ifndef OPENSSL_NO_ERR
  662|     81|    err_load_strings(0, ERR_str_libraries);
  663|     81|    err_load_strings(0, ERR_str_reasons);
  664|     81|    err_load_strings(ERR_LIB_SYS, ERR_str_functs);
  665|     81|    build_SYS_str_reasons();
  666|     81|    err_load_strings(ERR_LIB_SYS, SYS_str_reasons);
  667|     81|#endif
  668|     81|}
ERR_load_strings:
  681|     80|{
  682|     80|    ERR_load_ERR_strings();
  683|     80|    err_load_strings(lib, str);
  684|     80|}
ERR_put_error:
  705|    107|{
  706|    107|    ERR_STATE *es;
  707|       |
  708|       |#ifdef _OSD_POSIX
  709|       |    /*
  710|       |     * In the BS2000-OSD POSIX subsystem, the compiler generates path names
  711|       |     * in the form "*POSIX(/etc/passwd)". This dirty hack strips them to
  712|       |     * something sensible. @@@ We shouldn't modify a const string, though.
  713|       |     */
  714|       |    if (strncmp(file, "*POSIX(", sizeof("*POSIX(") - 1) == 0) {
  715|       |        char *end;
  716|       |
  717|       |        /* Skip the "*POSIX(" prefix */
  718|       |        file += sizeof("*POSIX(") - 1;
  719|       |        end = &file[strlen(file) - 1];
  720|       |        if (*end == ')')
  721|       |            *end = '\0';
  722|       |        /* Optional: use the basename of the path only. */
  723|       |        if ((end = strrchr(file, '/')) != NULL)
  724|       |            file = &end[1];
  725|       |    }
  726|       |#endif
  727|    107|    es = ERR_get_state();
  728|    107|    if (es == NULL)
  729|      0|        return;
  730|       |
  731|    107|    es->top = (es->top + 1) % ERR_NUM_ERRORS;
  732|    107|    if (es->top == es->bottom)
  733|      0|        es->bottom = (es->bottom + 1) % ERR_NUM_ERRORS;
  734|    107|    es->err_flags[es->top] = 0;
  735|    107|    es->err_buffer[es->top] = ERR_PACK(lib, func, reason);
  736|    107|    es->err_file[es->top] = file;
  737|    107|    es->err_line[es->top] = line;
  738|    107|    err_clear_data(es, es->top);
  739|    107|}
ERR_clear_error:
  742|    132|{
  743|    132|    int i;
  744|    132|    ERR_STATE *es;
  745|       |
  746|    132|    es = ERR_get_state();
  747|    132|    if (es == NULL)
  748|      0|        return;
  749|       |
  750|  2.24k|    for (i = 0; i < ERR_NUM_ERRORS; i++) {
  751|  2.11k|        err_clear(es, i);
  752|  2.11k|    }
  753|    132|    es->top = es->bottom = 0;
  754|    132|}
ERR_get_error:
  757|     30|{
  758|     30|    return (get_error_values(1, 0, NULL, NULL, NULL, NULL));
  759|     30|}
ERR_peek_error:
  773|     30|{
  774|     30|    return (get_error_values(0, 0, NULL, NULL, NULL, NULL));
  775|     30|}
ERR_peek_last_error:
  789|     32|{
  790|     32|    return (get_error_values(0, 1, NULL, NULL, NULL, NULL));
  791|     32|}
ERR_error_string_n:
  873|     30|{
  874|     30|    char lsbuf[64], fsbuf[64], rsbuf[64];
  875|     30|    const char *ls, *fs, *rs;
  876|     30|    unsigned long l, f, r;
  877|       |
  878|     30|    if (len == 0)
  879|      0|        return;
  880|       |
  881|     30|    l = ERR_GET_LIB(e);
  882|     30|    f = ERR_GET_FUNC(e);
  883|     30|    r = ERR_GET_REASON(e);
  884|       |
  885|     30|    ls = ERR_lib_error_string(e);
  886|     30|    fs = ERR_func_error_string(e);
  887|     30|    rs = ERR_reason_error_string(e);
  888|       |
  889|     30|    if (ls == NULL)
  890|     30|        BIO_snprintf(lsbuf, sizeof(lsbuf), "lib(%lu)", l);
  891|     30|    if (fs == NULL)
  892|     30|        BIO_snprintf(fsbuf, sizeof(fsbuf), "func(%lu)", f);
  893|     30|    if (rs == NULL)
  894|     30|        BIO_snprintf(rsbuf, sizeof(rsbuf), "reason(%lu)", r);
  895|       |
  896|     30|    BIO_snprintf(buf, len, "error:%08lX:%s:%s:%s", e, ls ? ls : lsbuf,
  897|     30|                 fs ? fs : fsbuf, rs ? rs : rsbuf);
  898|     30|    if (strlen(buf) == len - 1) {
  899|       |        /*
  900|       |         * output may be truncated; make sure we always have 5
  901|       |         * colon-separated fields, i.e. 4 colons ...
  902|       |         */
  903|      0|#define NUM_COLONS 4
  904|      0|        if (len > NUM_COLONS) { /* ... if possible */
  905|      0|            int i;
  906|      0|            char *s = buf;
  907|       |
  908|      0|            for (i = 0; i < NUM_COLONS; i++) {
  909|      0|                char *colon = strchr(s, ':');
  910|      0|                if (colon == NULL || colon > &buf[len - 1] - NUM_COLONS + i) {
  911|       |                    /*
  912|       |                     * set colon no. i at last possible position (buf[len-1]
  913|       |                     * is the terminating 0)
  914|       |                     */
  915|      0|                    colon = &buf[len - 1] - NUM_COLONS + i;
  916|      0|                    *colon = ':';
  917|      0|                }
  918|      0|                s = colon + 1;
  919|      0|            }
  920|      0|        }
  921|      0|    }
  922|     30|}
ERR_lib_error_string:
  959|     30|{
  960|     30|    ERR_STRING_DATA d, *p;
  961|     30|    unsigned long l;
  962|       |
  963|     30|    err_fns_check();
  964|     30|    l = ERR_GET_LIB(e);
  965|     30|    d.error = ERR_PACK(l, 0, 0);
  966|     30|    p = ERRFN(err_get_item) (&d);
  967|     30|    return ((p == NULL) ? NULL : p->string);
  968|     30|}
ERR_func_error_string:
  971|     58|{
  972|     58|    ERR_STRING_DATA d, *p;
  973|     58|    unsigned long l, f;
  974|       |
  975|     58|    err_fns_check();
  976|     58|    l = ERR_GET_LIB(e);
  977|     58|    f = ERR_GET_FUNC(e);
  978|     58|    d.error = ERR_PACK(l, f, 0);
  979|     58|    p = ERRFN(err_get_item) (&d);
  980|     58|    return ((p == NULL) ? NULL : p->string);
  981|     58|}
ERR_reason_error_string:
  984|     30|{
  985|     30|    ERR_STRING_DATA d, *p = NULL;
  986|     30|    unsigned long l, r;
  987|       |
  988|     30|    err_fns_check();
  989|     30|    l = ERR_GET_LIB(e);
  990|     30|    r = ERR_GET_REASON(e);
  991|     30|    d.error = ERR_PACK(l, 0, r);
  992|     30|    p = ERRFN(err_get_item) (&d);
  993|     30|    if (!p) {
  994|     30|        d.error = ERR_PACK(0, 0, r);
  995|     30|        p = ERRFN(err_get_item) (&d);
  996|     30|    }
  997|     30|    return ((p == NULL) ? NULL : p->string);
  998|     30|}
ERR_remove_thread_state:
 1001|  6.25k|{
 1002|  6.25k|    ERR_STATE tmp;
 1003|       |
 1004|  6.25k|    if (id)
 1005|      0|        CRYPTO_THREADID_cpy(&tmp.tid, id);
 1006|  6.25k|    else
 1007|  6.25k|        CRYPTO_THREADID_current(&tmp.tid);
 1008|  6.25k|    err_fns_check();
 1009|       |    /*
 1010|       |     * thread_del_item automatically destroys the LHASH if the number of
 1011|       |     * items reaches zero.
 1012|       |     */
 1013|  6.25k|    ERRFN(thread_del_item) (&tmp);
 1014|  6.25k|}
ERR_get_state:
 1024|  17.0k|{
 1025|  17.0k|    ERR_STATE *ret, tmp, *tmpp = NULL;
 1026|  17.0k|    int i;
 1027|  17.0k|    CRYPTO_THREADID tid;
 1028|       |
 1029|  17.0k|    err_fns_check();
 1030|  17.0k|    CRYPTO_THREADID_current(&tid);
 1031|  17.0k|    CRYPTO_THREADID_cpy(&tmp.tid, &tid);
 1032|  17.0k|    ret = ERRFN(thread_get_item) (&tmp);
 1033|       |
 1034|       |    /* ret == the error state, if NULL, make a new one */
 1035|  17.0k|    if (ret == NULL) {
 1036|  3.11k|        ret = (ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));
 1037|  3.11k|        if (ret == NULL)
 1038|      0|            return NULL;
 1039|  3.11k|        CRYPTO_THREADID_cpy(&ret->tid, &tid);
 1040|  3.11k|        ret->top = 0;
 1041|  3.11k|        ret->bottom = 0;
 1042|  52.8k|        for (i = 0; i < ERR_NUM_ERRORS; i++) {
 1043|  49.7k|            ret->err_data[i] = NULL;
 1044|  49.7k|            ret->err_data_flags[i] = 0;
 1045|  49.7k|        }
 1046|  3.11k|        tmpp = ERRFN(thread_set_item) (ret);
 1047|       |        /* To check if insertion failed, do a get. */
 1048|  3.11k|        if (ERRFN(thread_get_item) (ret) != ret) {
 1049|      0|            ERR_STATE_free(ret); /* could not insert it */
 1050|      0|            return NULL;
 1051|      0|        }
 1052|       |        /*
 1053|       |         * If a race occured in this function and we came second, tmpp is the
 1054|       |         * first one that we just replaced.
 1055|       |         */
 1056|  3.11k|        if (tmpp)
 1057|      0|            ERR_STATE_free(tmpp);
 1058|  3.11k|    }
 1059|  17.0k|    return ret;
 1060|  17.0k|}
ERR_get_next_error_library:
 1063|      9|{
 1064|      9|    err_fns_check();
 1065|      9|    return ERRFN(get_next_lib) ();
 1066|      9|}
ERR_set_error_data:
 1069|      5|{
 1070|      5|    ERR_STATE *es;
 1071|      5|    int i;
 1072|       |
 1073|      5|    es = ERR_get_state();
 1074|      5|    if (es == NULL)
 1075|      0|        return;
 1076|       |
 1077|      5|    i = es->top;
 1078|       |
 1079|      5|    err_clear_data(es, i);
 1080|      5|    es->err_data[i] = data;
 1081|      5|    es->err_data_flags[i] = flags;
 1082|      5|}
ERR_add_error_data:
 1085|      5|{
 1086|      5|    va_list args;
 1087|      5|    va_start(args, num);
 1088|      5|    ERR_add_error_vdata(num, args);
 1089|      5|    va_end(args);
 1090|      5|}
ERR_add_error_vdata:
 1093|      5|{
 1094|      5|    int i, n, s;
 1095|      5|    char *str, *p, *a;
 1096|       |
 1097|      5|    s = 80;
 1098|      5|    str = OPENSSL_malloc(s + 1);
 1099|      5|    if (str == NULL)
 1100|      0|        return;
 1101|      5|    str[0] = '\0';
 1102|       |
 1103|      5|    n = 0;
 1104|     26|    for (i = 0; i < num; i++) {
 1105|     21|        a = va_arg(args, char *);
 1106|       |        /* ignore NULLs, thanks to Bob Beck <beck@obtuse.com> */
 1107|     21|        if (a != NULL) {
 1108|     21|            n += strlen(a);
 1109|     21|            if (n > s) {
 1110|      4|                s = n + 20;
 1111|      4|                p = OPENSSL_realloc(str, s + 1);
 1112|      4|                if (p == NULL) {
 1113|      0|                    OPENSSL_free(str);
 1114|      0|                    return;
 1115|      0|                } else
 1116|      4|                    str = p;
 1117|      4|            }
 1118|     21|            BUF_strlcat(str, a, (size_t)s + 1);
 1119|     21|        }
 1120|     21|    }
 1121|      5|    ERR_set_error_data(str, ERR_TXT_MALLOCED | ERR_TXT_STRING);
 1122|      5|}
ERR_set_mark:
 1125|  8.33k|{
 1126|  8.33k|    ERR_STATE *es;
 1127|       |
 1128|  8.33k|    es = ERR_get_state();
 1129|  8.33k|    if (es == NULL)
 1130|      0|        return 0;
 1131|       |
 1132|  8.33k|    if (es->bottom == es->top)
 1133|  8.33k|        return 0;
 1134|      0|    es->err_flags[es->top] |= ERR_FLAG_MARK;
 1135|      0|    return 1;
 1136|  8.33k|}
ERR_pop_to_mark:
 1139|  8.33k|{
 1140|  8.33k|    ERR_STATE *es;
 1141|       |
 1142|  8.33k|    es = ERR_get_state();
 1143|  8.33k|    if (es == NULL)
 1144|      0|        return 0;
 1145|       |
 1146|  8.34k|    while (es->bottom != es->top
 1147|  8.34k|           && (es->err_flags[es->top] & ERR_FLAG_MARK) == 0) {
 1148|     12|        err_clear(es, es->top);
 1149|     12|        es->top -= 1;
 1150|     12|        if (es->top == -1)
 1151|      0|            es->top = ERR_NUM_ERRORS - 1;
 1152|     12|    }
 1153|       |
 1154|  8.33k|    if (es->bottom == es->top)
 1155|  8.33k|        return 0;
 1156|      0|    es->err_flags[es->top] &= ~ERR_FLAG_MARK;
 1157|      0|    return 1;
 1158|  8.33k|}
err.c:err_fns_check:
  292|  72.1k|{
  293|  72.1k|    if (err_fns)
  294|  72.1k|        return;
  295|       |
  296|      1|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  297|      1|    if (!err_fns)
  298|      1|        err_fns = &err_defaults;
  299|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  300|      1|}
err.c:int_err_get:
  358|  19.2k|{
  359|  19.2k|    LHASH_OF(ERR_STRING_DATA) *ret = NULL;
  360|       |
  361|  19.2k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  362|  19.2k|    if (!int_error_hash && create) {
  363|      1|        CRYPTO_push_info("int_err_get (err.c)");
  364|      1|        int_error_hash = lh_ERR_STRING_DATA_new();
  365|      1|        CRYPTO_pop_info();
  366|      1|    }
  367|  19.2k|    if (int_error_hash)
  368|  19.2k|        ret = int_error_hash;
  369|  19.2k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  370|       |
  371|  19.2k|    return ret;
  372|  19.2k|}
err.c:err_string_data_hash:
  339|  19.2k|{
  340|  19.2k|    unsigned long ret, l;
  341|       |
  342|  19.2k|    l = a->error;
  343|  19.2k|    ret = l ^ ERR_GET_LIB(l) ^ ERR_GET_FUNC(l);
  344|  19.2k|    return (ret ^ ret % 19 * 13);
  345|  19.2k|}
err.c:err_string_data_cmp:
  351|  17.2k|{
  352|  17.2k|    return (int)(a->error - b->error);
  353|  17.2k|}
err.c:int_err_get_item:
  385|    148|{
  386|    148|    ERR_STRING_DATA *p;
  387|    148|    LHASH_OF(ERR_STRING_DATA) *hash;
  388|       |
  389|    148|    err_fns_check();
  390|    148|    hash = ERRFN(err_get) (0);
  391|    148|    if (!hash)
  392|      0|        return NULL;
  393|       |
  394|    148|    CRYPTO_r_lock(CRYPTO_LOCK_ERR);
  395|    148|    p = lh_ERR_STRING_DATA_retrieve(hash, d);
  396|    148|    CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  397|       |
  398|    148|    return p;
  399|    148|}
err.c:int_err_set_item:
  402|  19.0k|{
  403|  19.0k|    ERR_STRING_DATA *p;
  404|  19.0k|    LHASH_OF(ERR_STRING_DATA) *hash;
  405|       |
  406|  19.0k|    err_fns_check();
  407|  19.0k|    hash = ERRFN(err_get) (1);
  408|  19.0k|    if (!hash)
  409|      0|        return NULL;
  410|       |
  411|  19.0k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  412|  19.0k|    p = lh_ERR_STRING_DATA_insert(hash, d);
  413|  19.0k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  414|       |
  415|  19.0k|    return p;
  416|  19.0k|}
err.c:int_thread_get:
  450|  29.4k|{
  451|  29.4k|    LHASH_OF(ERR_STATE) *ret = NULL;
  452|       |
  453|  29.4k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  454|  29.4k|    if (!int_thread_hash && create) {
  455|  3.11k|        CRYPTO_push_info("int_thread_get (err.c)");
  456|  3.11k|        int_thread_hash = lh_ERR_STATE_new();
  457|  3.11k|        CRYPTO_pop_info();
  458|  3.11k|    }
  459|  29.4k|    if (int_thread_hash) {
  460|  23.2k|        int_thread_hash_references++;
  461|  23.2k|        ret = int_thread_hash;
  462|  23.2k|    }
  463|  29.4k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  464|  29.4k|    return ret;
  465|  29.4k|}
err.c:err_state_hash:
  436|  23.2k|{
  437|  23.2k|    return CRYPTO_THREADID_hash(&a->tid) * 13;
  438|  23.2k|}
err.c:err_state_cmp:
  443|  20.1k|{
  444|  20.1k|    return CRYPTO_THREADID_cmp(&a->tid, &b->tid);
  445|  20.1k|}
err.c:int_thread_release:
  468|  23.2k|{
  469|  23.2k|    int i;
  470|       |
  471|  23.2k|    if (hash == NULL || *hash == NULL)
  472|      0|        return;
  473|       |
  474|  23.2k|    i = CRYPTO_add(&int_thread_hash_references, -1, CRYPTO_LOCK_ERR);
  475|       |
  476|       |#ifdef REF_PRINT
  477|       |    fprintf(stderr, "%4d:%s\n", int_thread_hash_references, "ERR");
  478|       |#endif
  479|  23.2k|    if (i > 0)
  480|      0|        return;
  481|       |#ifdef REF_CHECK
  482|       |    if (i < 0) {
  483|       |        fprintf(stderr, "int_thread_release, bad reference count\n");
  484|       |        abort();                /* ok */
  485|       |    }
  486|       |#endif
  487|  23.2k|    *hash = NULL;
  488|  23.2k|}
err.c:int_thread_get_item:
  491|  20.1k|{
  492|  20.1k|    ERR_STATE *p;
  493|  20.1k|    LHASH_OF(ERR_STATE) *hash;
  494|       |
  495|  20.1k|    err_fns_check();
  496|  20.1k|    hash = ERRFN(thread_get) (0);
  497|  20.1k|    if (!hash)
  498|  3.11k|        return NULL;
  499|       |
  500|  17.0k|    CRYPTO_r_lock(CRYPTO_LOCK_ERR);
  501|  17.0k|    p = lh_ERR_STATE_retrieve(hash, d);
  502|  17.0k|    CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  503|       |
  504|  17.0k|    ERRFN(thread_release) (&hash);
  505|  17.0k|    return p;
  506|  20.1k|}
err.c:int_thread_set_item:
  509|  3.11k|{
  510|  3.11k|    ERR_STATE *p;
  511|  3.11k|    LHASH_OF(ERR_STATE) *hash;
  512|       |
  513|  3.11k|    err_fns_check();
  514|  3.11k|    hash = ERRFN(thread_get) (1);
  515|  3.11k|    if (!hash)
  516|      0|        return NULL;
  517|       |
  518|  3.11k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  519|  3.11k|    p = lh_ERR_STATE_insert(hash, d);
  520|  3.11k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  521|       |
  522|  3.11k|    ERRFN(thread_release) (&hash);
  523|  3.11k|    return p;
  524|  3.11k|}
err.c:int_thread_del_item:
  527|  6.25k|{
  528|  6.25k|    ERR_STATE *p;
  529|  6.25k|    LHASH_OF(ERR_STATE) *hash;
  530|       |
  531|  6.25k|    err_fns_check();
  532|  6.25k|    hash = ERRFN(thread_get) (0);
  533|  6.25k|    if (!hash)
  534|  3.14k|        return;
  535|       |
  536|  3.10k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  537|  3.10k|    p = lh_ERR_STATE_delete(hash, d);
  538|       |    /* make sure we don't leak memory */
  539|  3.10k|    if (int_thread_hash_references == 1
  540|  3.10k|        && int_thread_hash && lh_ERR_STATE_num_items(int_thread_hash) == 0) {
  541|  3.10k|        lh_ERR_STATE_free(int_thread_hash);
  542|  3.10k|        int_thread_hash = NULL;
  543|  3.10k|    }
  544|  3.10k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  545|       |
  546|  3.10k|    ERRFN(thread_release) (&hash);
  547|  3.10k|    if (p)
  548|  3.10k|        ERR_STATE_free(p);
  549|  3.10k|}
err.c:int_err_get_next_lib:
  552|      9|{
  553|      9|    int ret;
  554|       |
  555|      9|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  556|      9|    ret = int_err_library_number++;
  557|      9|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  558|       |
  559|      9|    return ret;
  560|      9|}
err.c:build_SYS_str_reasons:
  578|     81|{
  579|       |    /* OPENSSL_malloc cannot be used here, use static storage instead */
  580|     81|    static char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];
  581|     81|    int i;
  582|     81|    static int init = 1;
  583|       |
  584|     81|    CRYPTO_r_lock(CRYPTO_LOCK_ERR);
  585|     81|    if (!init) {
  586|     80|        CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  587|     80|        return;
  588|     80|    }
  589|       |
  590|      1|    CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  591|      1|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  592|      1|    if (!init) {
  593|      0|        CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  594|      0|        return;
  595|      0|    }
  596|       |
  597|    128|    for (i = 1; i <= NUM_SYS_STR_REASONS; i++) {
  598|    127|        ERR_STRING_DATA *str = &SYS_str_reasons[i - 1];
  599|       |
  600|    127|        str->error = (unsigned long)i;
  601|    127|        if (str->string == NULL) {
  602|    127|            char (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);
  603|    127|            char *src = strerror(i);
  604|    127|            if (src != NULL) {
  605|    127|                strncpy(*dest, src, sizeof *dest);
  606|    127|                (*dest)[sizeof *dest - 1] = '\0';
  607|    127|                str->string = *dest;
  608|    127|            }
  609|    127|        }
  610|    127|        if (str->string == NULL)
  611|      0|            str->string = "unknown";
  612|    127|    }
  613|       |
  614|       |    /*
  615|       |     * Now we still have SYS_str_reasons[NUM_SYS_STR_REASONS] = {0, NULL}, as
  616|       |     * required by ERR_load_strings.
  617|       |     */
  618|       |
  619|      1|    init = 0;
  620|       |
  621|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  622|      1|}
err.c:err_load_strings:
  671|    404|{
  672|  19.4k|    while (str->error) {
  673|  19.0k|        if (lib)
  674|  11.4k|            str->error |= ERR_PACK(lib, 0, 0);
  675|  19.0k|        ERRFN(err_set_item) (str);
  676|  19.0k|        str++;
  677|  19.0k|    }
  678|    404|}
err.c:get_error_values:
  807|     92|{
  808|     92|    int i = 0;
  809|     92|    ERR_STATE *es;
  810|     92|    unsigned long ret;
  811|       |
  812|     92|    es = ERR_get_state();
  813|     92|    if (es == NULL)
  814|      0|        return 0;
  815|       |
  816|     92|    if (inc && top) {
  817|      0|        if (file)
  818|      0|            *file = "";
  819|      0|        if (line)
  820|      0|            *line = 0;
  821|      0|        if (data)
  822|      0|            *data = "";
  823|      0|        if (flags)
  824|      0|            *flags = 0;
  825|       |
  826|      0|        return ERR_R_INTERNAL_ERROR;
  827|      0|    }
  828|       |
  829|     92|    if (es->bottom == es->top)
  830|     60|        return 0;
  831|     32|    if (top)
  832|     32|        i = es->top;            /* last error */
  833|      0|    else
  834|      0|        i = (es->bottom + 1) % ERR_NUM_ERRORS; /* first error */
  835|       |
  836|     32|    ret = es->err_buffer[i];
  837|     32|    if (inc) {
  838|      0|        es->bottom = i;
  839|      0|        es->err_buffer[i] = 0;
  840|      0|    }
  841|       |
  842|     32|    if ((file != NULL) && (line != NULL)) {
  843|      0|        if (es->err_file[i] == NULL) {
  844|      0|            *file = "NA";
  845|      0|            if (line != NULL)
  846|      0|                *line = 0;
  847|      0|        } else {
  848|      0|            *file = es->err_file[i];
  849|      0|            if (line != NULL)
  850|      0|                *line = es->err_line[i];
  851|      0|        }
  852|      0|    }
  853|       |
  854|     32|    if (data == NULL) {
  855|     32|        if (inc) {
  856|      0|            err_clear_data(es, i);
  857|      0|        }
  858|     32|    } else {
  859|      0|        if (es->err_data[i] == NULL) {
  860|      0|            *data = "";
  861|      0|            if (flags != NULL)
  862|      0|                *flags = 0;
  863|      0|        } else {
  864|      0|            *data = es->err_data[i];
  865|      0|            if (flags != NULL)
  866|      0|                *flags = es->err_data_flags[i];
  867|      0|        }
  868|      0|    }
  869|     32|    return ret;
  870|     92|}
err.c:ERR_STATE_free:
  646|  3.10k|{
  647|  3.10k|    int i;
  648|       |
  649|  3.10k|    if (s == NULL)
  650|      0|        return;
  651|       |
  652|  52.8k|    for (i = 0; i < ERR_NUM_ERRORS; i++) {
  653|  49.7k|        err_clear_data(s, i);
  654|  49.7k|    }
  655|  3.10k|    OPENSSL_free(s);
  656|  3.10k|}

ERR_load_crypto_strings:
  112|      1|{
  113|      1|#ifndef OPENSSL_NO_ERR
  114|      1|    ERR_load_ERR_strings();     /* include error strings for SYSerr */
  115|      1|    ERR_load_BN_strings();
  116|      1|# ifndef OPENSSL_NO_RSA
  117|      1|    ERR_load_RSA_strings();
  118|      1|# endif
  119|      1|# ifndef OPENSSL_NO_DH
  120|      1|    ERR_load_DH_strings();
  121|      1|# endif
  122|      1|    ERR_load_EVP_strings();
  123|      1|    ERR_load_BUF_strings();
  124|      1|    ERR_load_OBJ_strings();
  125|      1|    ERR_load_PEM_strings();
  126|      1|# ifndef OPENSSL_NO_DSA
  127|      1|    ERR_load_DSA_strings();
  128|      1|# endif
  129|      1|    ERR_load_X509_strings();
  130|      1|    ERR_load_ASN1_strings();
  131|      1|    ERR_load_CONF_strings();
  132|      1|    ERR_load_CRYPTO_strings();
  133|      1|# ifndef OPENSSL_NO_COMP
  134|      1|    ERR_load_COMP_strings();
  135|      1|# endif
  136|      1|# ifndef OPENSSL_NO_EC
  137|      1|    ERR_load_EC_strings();
  138|      1|# endif
  139|      1|# ifndef OPENSSL_NO_ECDSA
  140|      1|    ERR_load_ECDSA_strings();
  141|      1|# endif
  142|      1|# ifndef OPENSSL_NO_ECDH
  143|      1|    ERR_load_ECDH_strings();
  144|      1|# endif
  145|       |    /* skip ERR_load_SSL_strings() because it is not in this library */
  146|      1|    ERR_load_BIO_strings();
  147|      1|    ERR_load_PKCS7_strings();
  148|      1|    ERR_load_X509V3_strings();
  149|      1|    ERR_load_PKCS12_strings();
  150|      1|    ERR_load_RAND_strings();
  151|      1|    ERR_load_DSO_strings();
  152|      1|    ERR_load_TS_strings();
  153|      1|# ifndef OPENSSL_NO_ENGINE
  154|      1|    ERR_load_ENGINE_strings();
  155|      1|# endif
  156|      1|    ERR_load_OCSP_strings();
  157|      1|    ERR_load_UI_strings();
  158|       |# ifdef OPENSSL_FIPS
  159|       |    ERR_load_FIPS_strings();
  160|       |# endif
  161|      1|# ifndef OPENSSL_NO_CMS
  162|      1|    ERR_load_CMS_strings();
  163|      1|# endif
  164|       |# ifndef OPENSSL_NO_JPAKE
  165|       |    ERR_load_JPAKE_strings();
  166|       |# endif
  167|      1|#endif
  168|      1|}

EVP_des_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_cfb1:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_cfb8:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cfb1:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cfb8:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_cfb128:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }

OPENSSL_add_all_algorithms_noconf:
   76|      1|{
   77|       |    /*
   78|       |     * For the moment OPENSSL_cpuid_setup does something
   79|       |     * only on IA-32, but we reserve the option for all
   80|       |     * platforms...
   81|       |     */
   82|      1|    OPENSSL_cpuid_setup();
   83|      1|    OpenSSL_add_all_ciphers();
   84|      1|    OpenSSL_add_all_digests();
   85|      1|}

OpenSSL_add_all_ciphers:
   66|      1|{
   67|       |
   68|      1|#ifndef OPENSSL_NO_DES
   69|      1|    EVP_add_cipher(EVP_des_cfb());
   70|      1|    EVP_add_cipher(EVP_des_cfb1());
   71|      1|    EVP_add_cipher(EVP_des_cfb8());
   72|      1|    EVP_add_cipher(EVP_des_ede_cfb());
   73|      1|    EVP_add_cipher(EVP_des_ede3_cfb());
   74|      1|    EVP_add_cipher(EVP_des_ede3_cfb1());
   75|      1|    EVP_add_cipher(EVP_des_ede3_cfb8());
   76|       |
   77|      1|    EVP_add_cipher(EVP_des_ofb());
   78|      1|    EVP_add_cipher(EVP_des_ede_ofb());
   79|      1|    EVP_add_cipher(EVP_des_ede3_ofb());
   80|       |
   81|      1|    EVP_add_cipher(EVP_desx_cbc());
   82|      1|    EVP_add_cipher_alias(SN_desx_cbc, "DESX");
   83|      1|    EVP_add_cipher_alias(SN_desx_cbc, "desx");
   84|       |
   85|      1|    EVP_add_cipher(EVP_des_cbc());
   86|      1|    EVP_add_cipher_alias(SN_des_cbc, "DES");
   87|      1|    EVP_add_cipher_alias(SN_des_cbc, "des");
   88|      1|    EVP_add_cipher(EVP_des_ede_cbc());
   89|      1|    EVP_add_cipher(EVP_des_ede3_cbc());
   90|      1|    EVP_add_cipher_alias(SN_des_ede3_cbc, "DES3");
   91|      1|    EVP_add_cipher_alias(SN_des_ede3_cbc, "des3");
   92|       |
   93|      1|    EVP_add_cipher(EVP_des_ecb());
   94|      1|    EVP_add_cipher(EVP_des_ede());
   95|      1|    EVP_add_cipher(EVP_des_ede3());
   96|      1|    EVP_add_cipher(EVP_des_ede3_wrap());
   97|      1|#endif
   98|       |
   99|      1|#ifndef OPENSSL_NO_RC4
  100|      1|    EVP_add_cipher(EVP_rc4());
  101|      1|    EVP_add_cipher(EVP_rc4_40());
  102|      1|# ifndef OPENSSL_NO_MD5
  103|      1|    EVP_add_cipher(EVP_rc4_hmac_md5());
  104|      1|# endif
  105|      1|#endif
  106|       |
  107|      1|#ifndef OPENSSL_NO_IDEA
  108|      1|    EVP_add_cipher(EVP_idea_ecb());
  109|      1|    EVP_add_cipher(EVP_idea_cfb());
  110|      1|    EVP_add_cipher(EVP_idea_ofb());
  111|      1|    EVP_add_cipher(EVP_idea_cbc());
  112|      1|    EVP_add_cipher_alias(SN_idea_cbc, "IDEA");
  113|      1|    EVP_add_cipher_alias(SN_idea_cbc, "idea");
  114|      1|#endif
  115|       |
  116|      1|#ifndef OPENSSL_NO_SEED
  117|      1|    EVP_add_cipher(EVP_seed_ecb());
  118|      1|    EVP_add_cipher(EVP_seed_cfb());
  119|      1|    EVP_add_cipher(EVP_seed_ofb());
  120|      1|    EVP_add_cipher(EVP_seed_cbc());
  121|      1|    EVP_add_cipher_alias(SN_seed_cbc, "SEED");
  122|      1|    EVP_add_cipher_alias(SN_seed_cbc, "seed");
  123|      1|#endif
  124|       |
  125|      1|#ifndef OPENSSL_NO_RC2
  126|      1|    EVP_add_cipher(EVP_rc2_ecb());
  127|      1|    EVP_add_cipher(EVP_rc2_cfb());
  128|      1|    EVP_add_cipher(EVP_rc2_ofb());
  129|      1|    EVP_add_cipher(EVP_rc2_cbc());
  130|      1|    EVP_add_cipher(EVP_rc2_40_cbc());
  131|      1|    EVP_add_cipher(EVP_rc2_64_cbc());
  132|      1|    EVP_add_cipher_alias(SN_rc2_cbc, "RC2");
  133|      1|    EVP_add_cipher_alias(SN_rc2_cbc, "rc2");
  134|      1|#endif
  135|       |
  136|      1|#ifndef OPENSSL_NO_BF
  137|      1|    EVP_add_cipher(EVP_bf_ecb());
  138|      1|    EVP_add_cipher(EVP_bf_cfb());
  139|      1|    EVP_add_cipher(EVP_bf_ofb());
  140|      1|    EVP_add_cipher(EVP_bf_cbc());
  141|      1|    EVP_add_cipher_alias(SN_bf_cbc, "BF");
  142|      1|    EVP_add_cipher_alias(SN_bf_cbc, "bf");
  143|      1|    EVP_add_cipher_alias(SN_bf_cbc, "blowfish");
  144|      1|#endif
  145|       |
  146|      1|#ifndef OPENSSL_NO_CAST
  147|      1|    EVP_add_cipher(EVP_cast5_ecb());
  148|      1|    EVP_add_cipher(EVP_cast5_cfb());
  149|      1|    EVP_add_cipher(EVP_cast5_ofb());
  150|      1|    EVP_add_cipher(EVP_cast5_cbc());
  151|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "CAST");
  152|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "cast");
  153|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "CAST-cbc");
  154|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "cast-cbc");
  155|      1|#endif
  156|       |
  157|      1|#ifndef OPENSSL_NO_RC5
  158|      1|    EVP_add_cipher(EVP_rc5_32_12_16_ecb());
  159|      1|    EVP_add_cipher(EVP_rc5_32_12_16_cfb());
  160|      1|    EVP_add_cipher(EVP_rc5_32_12_16_ofb());
  161|      1|    EVP_add_cipher(EVP_rc5_32_12_16_cbc());
  162|      1|    EVP_add_cipher_alias(SN_rc5_cbc, "rc5");
  163|      1|    EVP_add_cipher_alias(SN_rc5_cbc, "RC5");
  164|      1|#endif
  165|       |
  166|      1|#ifndef OPENSSL_NO_AES
  167|      1|    EVP_add_cipher(EVP_aes_128_ecb());
  168|      1|    EVP_add_cipher(EVP_aes_128_cbc());
  169|      1|    EVP_add_cipher(EVP_aes_128_cfb());
  170|      1|    EVP_add_cipher(EVP_aes_128_cfb1());
  171|      1|    EVP_add_cipher(EVP_aes_128_cfb8());
  172|      1|    EVP_add_cipher(EVP_aes_128_ofb());
  173|      1|    EVP_add_cipher(EVP_aes_128_ctr());
  174|      1|    EVP_add_cipher(EVP_aes_128_gcm());
  175|      1|    EVP_add_cipher(EVP_aes_128_xts());
  176|      1|    EVP_add_cipher(EVP_aes_128_ccm());
  177|      1|    EVP_add_cipher(EVP_aes_128_wrap());
  178|      1|    EVP_add_cipher_alias(SN_aes_128_cbc, "AES128");
  179|      1|    EVP_add_cipher_alias(SN_aes_128_cbc, "aes128");
  180|      1|    EVP_add_cipher(EVP_aes_192_ecb());
  181|      1|    EVP_add_cipher(EVP_aes_192_cbc());
  182|      1|    EVP_add_cipher(EVP_aes_192_cfb());
  183|      1|    EVP_add_cipher(EVP_aes_192_cfb1());
  184|      1|    EVP_add_cipher(EVP_aes_192_cfb8());
  185|      1|    EVP_add_cipher(EVP_aes_192_ofb());
  186|      1|    EVP_add_cipher(EVP_aes_192_ctr());
  187|      1|    EVP_add_cipher(EVP_aes_192_gcm());
  188|      1|    EVP_add_cipher(EVP_aes_192_ccm());
  189|      1|    EVP_add_cipher(EVP_aes_192_wrap());
  190|      1|    EVP_add_cipher_alias(SN_aes_192_cbc, "AES192");
  191|      1|    EVP_add_cipher_alias(SN_aes_192_cbc, "aes192");
  192|      1|    EVP_add_cipher(EVP_aes_256_ecb());
  193|      1|    EVP_add_cipher(EVP_aes_256_cbc());
  194|      1|    EVP_add_cipher(EVP_aes_256_cfb());
  195|      1|    EVP_add_cipher(EVP_aes_256_cfb1());
  196|      1|    EVP_add_cipher(EVP_aes_256_cfb8());
  197|      1|    EVP_add_cipher(EVP_aes_256_ofb());
  198|      1|    EVP_add_cipher(EVP_aes_256_ctr());
  199|      1|    EVP_add_cipher(EVP_aes_256_gcm());
  200|      1|    EVP_add_cipher(EVP_aes_256_xts());
  201|      1|    EVP_add_cipher(EVP_aes_256_ccm());
  202|      1|    EVP_add_cipher(EVP_aes_256_wrap());
  203|      1|    EVP_add_cipher_alias(SN_aes_256_cbc, "AES256");
  204|      1|    EVP_add_cipher_alias(SN_aes_256_cbc, "aes256");
  205|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
  206|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
  207|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
  208|      1|# endif
  209|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA256)
  210|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha256());
  211|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha256());
  212|      1|# endif
  213|      1|#endif
  214|       |
  215|      1|#ifndef OPENSSL_NO_CAMELLIA
  216|      1|    EVP_add_cipher(EVP_camellia_128_ecb());
  217|      1|    EVP_add_cipher(EVP_camellia_128_cbc());
  218|      1|    EVP_add_cipher(EVP_camellia_128_cfb());
  219|      1|    EVP_add_cipher(EVP_camellia_128_cfb1());
  220|      1|    EVP_add_cipher(EVP_camellia_128_cfb8());
  221|      1|    EVP_add_cipher(EVP_camellia_128_ofb());
  222|      1|    EVP_add_cipher_alias(SN_camellia_128_cbc, "CAMELLIA128");
  223|      1|    EVP_add_cipher_alias(SN_camellia_128_cbc, "camellia128");
  224|      1|    EVP_add_cipher(EVP_camellia_192_ecb());
  225|      1|    EVP_add_cipher(EVP_camellia_192_cbc());
  226|      1|    EVP_add_cipher(EVP_camellia_192_cfb());
  227|      1|    EVP_add_cipher(EVP_camellia_192_cfb1());
  228|      1|    EVP_add_cipher(EVP_camellia_192_cfb8());
  229|      1|    EVP_add_cipher(EVP_camellia_192_ofb());
  230|      1|    EVP_add_cipher_alias(SN_camellia_192_cbc, "CAMELLIA192");
  231|      1|    EVP_add_cipher_alias(SN_camellia_192_cbc, "camellia192");
  232|      1|    EVP_add_cipher(EVP_camellia_256_ecb());
  233|      1|    EVP_add_cipher(EVP_camellia_256_cbc());
  234|      1|    EVP_add_cipher(EVP_camellia_256_cfb());
  235|      1|    EVP_add_cipher(EVP_camellia_256_cfb1());
  236|      1|    EVP_add_cipher(EVP_camellia_256_cfb8());
  237|      1|    EVP_add_cipher(EVP_camellia_256_ofb());
  238|      1|    EVP_add_cipher_alias(SN_camellia_256_cbc, "CAMELLIA256");
  239|      1|    EVP_add_cipher_alias(SN_camellia_256_cbc, "camellia256");
  240|      1|#endif
  241|      1|}

OpenSSL_add_all_digests:
   66|      1|{
   67|      1|#ifndef OPENSSL_NO_MD4
   68|      1|    EVP_add_digest(EVP_md4());
   69|      1|#endif
   70|      1|#ifndef OPENSSL_NO_MD5
   71|      1|    EVP_add_digest(EVP_md5());
   72|      1|    EVP_add_digest_alias(SN_md5, "ssl2-md5");
   73|      1|    EVP_add_digest_alias(SN_md5, "ssl3-md5");
   74|      1|#endif
   75|      1|#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA0)
   76|      1|    EVP_add_digest(EVP_sha());
   77|      1|# ifndef OPENSSL_NO_DSA
   78|      1|    EVP_add_digest(EVP_dss());
   79|      1|# endif
   80|      1|#endif
   81|      1|#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
   82|      1|    EVP_add_digest(EVP_sha1());
   83|      1|    EVP_add_digest_alias(SN_sha1, "ssl3-sha1");
   84|      1|    EVP_add_digest_alias(SN_sha1WithRSAEncryption, SN_sha1WithRSA);
   85|      1|# ifndef OPENSSL_NO_DSA
   86|      1|    EVP_add_digest(EVP_dss1());
   87|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, SN_dsaWithSHA1_2);
   88|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "DSS1");
   89|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "dss1");
   90|      1|# endif
   91|      1|# ifndef OPENSSL_NO_ECDSA
   92|      1|    EVP_add_digest(EVP_ecdsa());
   93|      1|# endif
   94|      1|#endif
   95|      1|#if !defined(OPENSSL_NO_MDC2) && !defined(OPENSSL_NO_DES)
   96|      1|    EVP_add_digest(EVP_mdc2());
   97|      1|#endif
   98|      1|#ifndef OPENSSL_NO_RIPEMD
   99|      1|    EVP_add_digest(EVP_ripemd160());
  100|      1|    EVP_add_digest_alias(SN_ripemd160, "ripemd");
  101|      1|    EVP_add_digest_alias(SN_ripemd160, "rmd160");
  102|      1|#endif
  103|      1|#ifndef OPENSSL_NO_SHA256
  104|      1|    EVP_add_digest(EVP_sha224());
  105|      1|    EVP_add_digest(EVP_sha256());
  106|      1|#endif
  107|      1|#ifndef OPENSSL_NO_SHA512
  108|      1|    EVP_add_digest(EVP_sha384());
  109|      1|    EVP_add_digest(EVP_sha512());
  110|      1|#endif
  111|      1|#ifndef OPENSSL_NO_WHIRLPOOL
  112|      1|    EVP_add_digest(EVP_whirlpool());
  113|      1|#endif
  114|      1|}

EVP_MD_CTX_init:
  126|  4.18k|{
  127|  4.18k|    memset(ctx, '\0', sizeof *ctx);
  128|  4.18k|}
EVP_MD_CTX_create:
  131|    108|{
  132|    108|    EVP_MD_CTX *ctx = OPENSSL_malloc(sizeof *ctx);
  133|       |
  134|    108|    if (ctx)
  135|    108|        EVP_MD_CTX_init(ctx);
  136|       |
  137|    108|    return ctx;
  138|    108|}
EVP_DigestInit_ex:
  147|  8.33k|{
  148|  8.33k|    EVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);
  149|       |#ifdef OPENSSL_FIPS
  150|       |    /* If FIPS mode switch to approved implementation if possible */
  151|       |    if (FIPS_mode()) {
  152|       |        const EVP_MD *fipsmd;
  153|       |        if (type) {
  154|       |            fipsmd = evp_get_fips_md(type);
  155|       |            if (fipsmd)
  156|       |                type = fipsmd;
  157|       |        }
  158|       |    }
  159|       |#endif
  160|  8.33k|#ifndef OPENSSL_NO_ENGINE
  161|       |    /*
  162|       |     * Whether it's nice or not, "Inits" can be used on "Final"'d contexts so
  163|       |     * this context may already have an ENGINE! Try to avoid releasing the
  164|       |     * previous handle, re-querying for an ENGINE, and having a
  165|       |     * reinitialisation, when it may all be unecessary.
  166|       |     */
  167|  8.33k|    if (ctx->engine && ctx->digest && (!type ||
  168|      0|                                       (type
  169|      0|                                        && (type->type ==
  170|      0|                                            ctx->digest->type))))
  171|      0|        goto skip_to_init;
  172|  8.33k|    if (type) {
  173|       |        /*
  174|       |         * Ensure an ENGINE left lying around from last time is cleared (the
  175|       |         * previous check attempted to avoid this if the same ENGINE and
  176|       |         * EVP_MD could be used).
  177|       |         */
  178|  8.33k|        if (ctx->engine)
  179|      0|            ENGINE_finish(ctx->engine);
  180|  8.33k|        if (impl) {
  181|      0|            if (!ENGINE_init(impl)) {
  182|      0|                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
  183|      0|                return 0;
  184|      0|            }
  185|      0|        } else
  186|       |            /* Ask if an ENGINE is reserved for this job */
  187|  8.33k|            impl = ENGINE_get_digest_engine(type->type);
  188|  8.33k|        if (impl) {
  189|       |            /* There's an ENGINE for this job ... (apparently) */
  190|      0|            const EVP_MD *d = ENGINE_get_digest(impl, type->type);
  191|      0|            if (!d) {
  192|       |                /* Same comment from evp_enc.c */
  193|      0|                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
  194|      0|                ENGINE_finish(impl);
  195|      0|                return 0;
  196|      0|            }
  197|       |            /* We'll use the ENGINE's private digest definition */
  198|      0|            type = d;
  199|       |            /*
  200|       |             * Store the ENGINE functional reference so we know 'type' came
  201|       |             * from an ENGINE and we need to release it when done.
  202|       |             */
  203|      0|            ctx->engine = impl;
  204|      0|        } else
  205|  8.33k|            ctx->engine = NULL;
  206|  8.33k|    } else {
  207|      0|        if (!ctx->digest) {
  208|      0|            EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET);
  209|      0|            return 0;
  210|      0|        }
  211|      0|        type = ctx->digest;
  212|      0|    }
  213|  8.33k|#endif
  214|  8.33k|    if (ctx->digest != type) {
  215|  4.18k|        if (ctx->digest && ctx->digest->ctx_size) {
  216|      0|            OPENSSL_free(ctx->md_data);
  217|      0|            ctx->md_data = NULL;
  218|      0|        }
  219|  4.18k|        ctx->digest = type;
  220|  4.18k|        if (!(ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) && type->ctx_size) {
  221|  4.18k|            ctx->update = type->update;
  222|  4.18k|            ctx->md_data = OPENSSL_malloc(type->ctx_size);
  223|  4.18k|            if (ctx->md_data == NULL) {
  224|      0|                EVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE);
  225|      0|                return 0;
  226|      0|            }
  227|  4.18k|        }
  228|  4.18k|    }
  229|  8.33k|#ifndef OPENSSL_NO_ENGINE
  230|  8.33k| skip_to_init:
  231|  8.33k|#endif
  232|  8.33k|    if (ctx->pctx) {
  233|      0|        int r;
  234|      0|        r = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_TYPE_SIG,
  235|      0|                              EVP_PKEY_CTRL_DIGESTINIT, 0, ctx);
  236|      0|        if (r <= 0 && (r != -2))
  237|      0|            return 0;
  238|      0|    }
  239|  8.33k|    if (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT)
  240|      0|        return 1;
  241|       |#ifdef OPENSSL_FIPS
  242|       |    if (FIPS_mode()) {
  243|       |        if (FIPS_digestinit(ctx, type))
  244|       |            return 1;
  245|       |        OPENSSL_free(ctx->md_data);
  246|       |        ctx->md_data = NULL;
  247|       |        return 0;
  248|       |    }
  249|       |#endif
  250|  8.33k|    return ctx->digest->init(ctx);
  251|  8.33k|}
EVP_DigestUpdate:
  254|  38.8k|{
  255|       |#ifdef OPENSSL_FIPS
  256|       |    if (FIPS_mode())
  257|       |        return FIPS_digestupdate(ctx, data, count);
  258|       |#endif
  259|  38.8k|    return ctx->update(ctx, data, count);
  260|  38.8k|}
EVP_DigestFinal_ex:
  273|  8.33k|{
  274|  8.33k|    int ret;
  275|       |#ifdef OPENSSL_FIPS
  276|       |    if (FIPS_mode())
  277|       |        return FIPS_digestfinal(ctx, md, size);
  278|       |#endif
  279|       |
  280|  8.33k|    OPENSSL_assert(ctx->digest->md_size <= EVP_MAX_MD_SIZE);
  281|  8.33k|    ret = ctx->digest->final(ctx, md);
  282|  8.33k|    if (size != NULL)
  283|      0|        *size = ctx->digest->md_size;
  284|  8.33k|    if (ctx->digest->cleanup) {
  285|      0|        ctx->digest->cleanup(ctx);
  286|      0|        EVP_MD_CTX_set_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);
  287|      0|    }
  288|  8.33k|    OPENSSL_cleanse(ctx->md_data, ctx->digest->ctx_size);
  289|  8.33k|    return ret;
  290|  8.33k|}
EVP_MD_CTX_destroy:
  368|    108|{
  369|    108|    if (ctx) {
  370|    108|        EVP_MD_CTX_cleanup(ctx);
  371|    108|        OPENSSL_free(ctx);
  372|    108|    }
  373|    108|}
EVP_MD_CTX_cleanup:
  377|  4.18k|{
  378|  4.18k|#ifndef OPENSSL_FIPS
  379|       |    /*
  380|       |     * Don't assume ctx->md_data was cleaned in EVP_Digest_Final, because
  381|       |     * sometimes only copies of the context are ever finalised.
  382|       |     */
  383|  4.18k|    if (ctx->digest && ctx->digest->cleanup
  384|  4.18k|        && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_CLEANED))
  385|      0|        ctx->digest->cleanup(ctx);
  386|  4.18k|    if (ctx->digest && ctx->digest->ctx_size && ctx->md_data
  387|  4.18k|        && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_REUSE)) {
  388|  4.18k|        OPENSSL_cleanse(ctx->md_data, ctx->digest->ctx_size);
  389|  4.18k|        OPENSSL_free(ctx->md_data);
  390|  4.18k|    }
  391|  4.18k|#endif
  392|  4.18k|    if (ctx->pctx)
  393|      0|        EVP_PKEY_CTX_free(ctx->pctx);
  394|  4.18k|#ifndef OPENSSL_NO_ENGINE
  395|  4.18k|    if (ctx->engine)
  396|       |        /*
  397|       |         * The EVP_MD we used belongs to an ENGINE, release the functional
  398|       |         * reference we held for this reason.
  399|       |         */
  400|      0|        ENGINE_finish(ctx->engine);
  401|  4.18k|#endif
  402|       |#ifdef OPENSSL_FIPS
  403|       |    FIPS_md_ctx_cleanup(ctx);
  404|       |#endif
  405|  4.18k|    memset(ctx, '\0', sizeof *ctx);
  406|       |
  407|  4.18k|    return 1;
  408|  4.18k|}

EVP_aes_128_cbc:
  459|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ecb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ofb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_cfb128:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_cfb1:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_cfb8:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ctr:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cbc:
  459|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ecb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ofb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cfb128:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cfb1:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cfb8:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ctr:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cbc:
  459|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ecb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ofb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cfb128:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cfb1:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cfb8:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ctr:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_gcm:
  481|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_gcm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_gcm:
  481|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_xts:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_xts:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ccm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ccm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ccm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_wrap:
 2001|      1|{
 2002|      1|    return &aes_128_wrap;
 2003|      1|}
EVP_aes_192_wrap:
 2015|      1|{
 2016|      1|    return &aes_192_wrap;
 2017|      1|}
EVP_aes_256_wrap:
 2029|      1|{
 2030|      1|    return &aes_256_wrap;
 2031|      1|}

EVP_aes_128_cbc_hmac_sha1:
  994|      2|{
  995|      2|    return (OPENSSL_ia32cap_P[1] & AESNI_CAPABLE ?
  996|      2|            &aesni_128_cbc_hmac_sha1_cipher : NULL);
  997|      2|}
EVP_aes_256_cbc_hmac_sha1:
 1000|      2|{
 1001|      2|    return (OPENSSL_ia32cap_P[1] & AESNI_CAPABLE ?
 1002|      2|            &aesni_256_cbc_hmac_sha1_cipher : NULL);
 1003|      2|}

EVP_aes_128_cbc_hmac_sha256:
  973|      2|{
  974|      2|    return ((OPENSSL_ia32cap_P[1] & AESNI_CAPABLE) &&
  975|      2|            aesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?
  976|      0|            &aesni_128_cbc_hmac_sha256_cipher : NULL);
  977|      2|}
EVP_aes_256_cbc_hmac_sha256:
  980|      2|{
  981|      2|    return ((OPENSSL_ia32cap_P[1] & AESNI_CAPABLE) &&
  982|      2|            aesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?
  983|      0|            &aesni_256_cbc_hmac_sha256_cipher : NULL);
  984|      2|}

EVP_camellia_128_cbc:
  240|      2|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      2|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_ecb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_ofb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_cfb128:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_cfb1:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_cfb8:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cbc:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_ecb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_ofb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cfb128:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cfb1:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cfb8:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cbc:
  240|      2|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      2|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_ecb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_ofb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cfb128:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cfb1:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cfb8:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }

EVP_des_ede:
  378|      1|{
  379|      1|    return &des_ede_ecb;
  380|      1|}
EVP_des_ede3:
  383|      1|{
  384|      1|    return &des_ede3_ecb;
  385|      1|}
EVP_des_ede3_wrap:
  492|      1|{
  493|      1|    return &des3_wrap;
  494|      1|}

EVP_rc2_64_cbc:
  123|      1|{
  124|      1|    return (&r2_64_cbc_cipher);
  125|      1|}
EVP_rc2_40_cbc:
  128|      2|{
  129|      2|    return (&r2_40_cbc_cipher);
  130|      2|}

EVP_rc4:
  111|      2|{
  112|      2|    return (&r4_cipher);
  113|      2|}
EVP_rc4_40:
  116|      1|{
  117|      1|    return (&r4_40_cipher);
  118|      1|}

EVP_rc4_hmac_md5:
  309|      2|{
  310|      2|    return (&r4_hmac_md5_cipher);
  311|      2|}

EVP_desx_cbc:
   97|      1|{
   98|      1|    return (&d_xcbc_cipher);
   99|      1|}

EVP_DecodeInit:
  243|  3.84k|{
  244|       |    /* Only ctx->num is used during decoding. */
  245|  3.84k|    ctx->num = 0;
  246|  3.84k|    ctx->length = 0;
  247|  3.84k|    ctx->line_num = 0;
  248|  3.84k|    ctx->expect_nl = 0;
  249|  3.84k|}
EVP_DecodeUpdate:
  273|  3.84k|{
  274|  3.84k|    int seof = 0, eof = 0, rv = -1, ret = 0, i, v, tmp, n, decoded_len;
  275|  3.84k|    unsigned char *d;
  276|       |
  277|  3.84k|    n = ctx->num;
  278|  3.84k|    d = ctx->enc_data;
  279|       |
  280|  3.84k|    if (n > 0 && d[n - 1] == '=') {
  281|      0|        eof++;
  282|      0|        if (n > 1 && d[n - 2] == '=')
  283|      0|            eof++;
  284|      0|    }
  285|       |
  286|       |     /* Legacy behaviour: an empty input chunk signals end of input. */
  287|  3.84k|    if (inl == 0) {
  288|      0|        rv = 0;
  289|      0|        goto end;
  290|      0|    }
  291|       |
  292|  5.76M|    for (i = 0; i < inl; i++) {
  293|  5.76M|        tmp = *(in++);
  294|  5.76M|        v = conv_ascii2bin(tmp);
  295|  5.76M|        if (v == B64_ERROR) {
  296|      0|            rv = -1;
  297|      0|            goto end;
  298|      0|        }
  299|       |
  300|  5.76M|        if (tmp == '=') {
  301|  3.27k|            eof++;
  302|  5.76M|        } else if (eof > 0 && B64_BASE64(v)) {
  303|       |            /* More data after padding. */
  304|      0|            rv = -1;
  305|      0|            goto end;
  306|      0|        }
  307|       |
  308|  5.76M|        if (eof > 2) {
  309|      0|            rv = -1;
  310|      0|            goto end;
  311|      0|        }
  312|       |
  313|  5.76M|        if (v == B64_EOF) {
  314|      0|            seof = 1;
  315|      0|            goto tail;
  316|      0|        }
  317|       |
  318|       |        /* Only save valid base64 characters. */
  319|  5.76M|        if (B64_BASE64(v)) {
  320|  5.67M|            if (n >= 64) {
  321|       |                /*
  322|       |                 * We increment n once per loop, and empty the buffer as soon as
  323|       |                 * we reach 64 characters, so this can only happen if someone's
  324|       |                 * manually messed with the ctx. Refuse to write any more data.
  325|       |                 */
  326|      0|                rv = -1;
  327|      0|                goto end;
  328|      0|            }
  329|  5.67M|            OPENSSL_assert(n < (int)sizeof(ctx->enc_data));
  330|  5.67M|            d[n++] = tmp;
  331|  5.67M|        }
  332|       |
  333|  5.76M|        if (n == 64) {
  334|  86.9k|            decoded_len = EVP_DecodeBlock(out, d, n);
  335|  86.9k|            n = 0;
  336|  86.9k|            if (decoded_len < 0 || eof > decoded_len) {
  337|      0|                rv = -1;
  338|      0|                goto end;
  339|      0|            }
  340|  86.9k|            ret += decoded_len - eof;
  341|  86.9k|            out += decoded_len - eof;
  342|  86.9k|        }
  343|  5.76M|    }
  344|       |
  345|       |    /*
  346|       |     * Legacy behaviour: if the current line is a full base64-block (i.e., has
  347|       |     * 0 mod 4 base64 characters), it is processed immediately. We keep this
  348|       |     * behaviour as applications may not be calling EVP_DecodeFinal properly.
  349|       |     */
  350|  3.84k|tail:
  351|  3.84k|    if (n > 0) {
  352|  3.60k|        if ((n & 3) == 0) {
  353|  3.60k|            decoded_len = EVP_DecodeBlock(out, d, n);
  354|  3.60k|            n = 0;
  355|  3.60k|            if (decoded_len < 0 || eof > decoded_len) {
  356|      0|                rv = -1;
  357|      0|                goto end;
  358|      0|            }
  359|  3.60k|            ret += (decoded_len - eof);
  360|  3.60k|        } else if (seof) {
  361|       |            /* EOF in the middle of a base64 block. */
  362|      0|            rv = -1;
  363|      0|            goto end;
  364|      0|        }
  365|  3.60k|    }
  366|       |
  367|  3.84k|    rv = seof || (n == 0 && eof) ? 0 : 1;
  368|  3.84k|end:
  369|       |    /* Legacy behaviour. This should probably rather be zeroed on error. */
  370|  3.84k|    *outl = ret;
  371|  3.84k|    ctx->num = n;
  372|  3.84k|    return (rv);
  373|  3.84k|}
EVP_DecodeBlock:
  376|  90.5k|{
  377|  90.5k|    int i, ret = 0, a, b, c, d;
  378|  90.5k|    unsigned long l;
  379|       |
  380|       |    /* trim white space from the start of the line. */
  381|  90.5k|    while ((conv_ascii2bin(*f) == B64_WS) && (n > 0)) {
  382|      0|        f++;
  383|      0|        n--;
  384|      0|    }
  385|       |
  386|       |    /*
  387|       |     * strip off stuff at the end of the line ascii2bin values B64_WS,
  388|       |     * B64_EOLN, B64_EOLN and B64_EOF
  389|       |     */
  390|  90.5k|    while ((n > 3) && (B64_NOT_BASE64(conv_ascii2bin(f[n - 1]))))
  391|      0|        n--;
  392|       |
  393|  90.5k|    if (n % 4 != 0)
  394|      0|        return (-1);
  395|       |
  396|  1.50M|    for (i = 0; i < n; i += 4) {
  397|  1.41M|        a = conv_ascii2bin(*(f++));
  398|  1.41M|        b = conv_ascii2bin(*(f++));
  399|  1.41M|        c = conv_ascii2bin(*(f++));
  400|  1.41M|        d = conv_ascii2bin(*(f++));
  401|  1.41M|        if ((a & 0x80) || (b & 0x80) || (c & 0x80) || (d & 0x80))
  402|      0|            return (-1);
  403|  1.41M|        l = ((((unsigned long)a) << 18L) |
  404|  1.41M|             (((unsigned long)b) << 12L) |
  405|  1.41M|             (((unsigned long)c) << 6L) | (((unsigned long)d)));
  406|  1.41M|        *(t++) = (unsigned char)(l >> 16L) & 0xff;
  407|  1.41M|        *(t++) = (unsigned char)(l >> 8L) & 0xff;
  408|  1.41M|        *(t++) = (unsigned char)(l) & 0xff;
  409|  1.41M|        ret += 3;
  410|  1.41M|    }
  411|  90.5k|    return (ret);
  412|  90.5k|}
EVP_DecodeFinal:
  415|  3.84k|{
  416|  3.84k|    int i;
  417|       |
  418|  3.84k|    *outl = 0;
  419|  3.84k|    if (ctx->num != 0) {
  420|      0|        i = EVP_DecodeBlock(out, ctx->enc_data, ctx->num);
  421|      0|        if (i < 0)
  422|      0|            return (-1);
  423|      0|        ctx->num = 0;
  424|      0|        *outl = i;
  425|      0|        return (1);
  426|      0|    } else
  427|  3.84k|        return (1);
  428|  3.84k|}
encode.c:conv_ascii2bin:
  129|  11.6M|{
  130|  11.6M|    if (a & 0x80)
  131|      0|        return B64_ERROR;
  132|  11.6M|    return data_ascii2bin[a];
  133|  11.6M|}

EVP_add_alg_module:
  116|      1|{
  117|      1|    CONF_module_add("alg_section", alg_module_init, 0);
  118|      1|}

ERR_load_EVP_strings:
  247|      1|{
  248|      1|#ifndef OPENSSL_NO_ERR
  249|       |
  250|      1|    if (ERR_func_error_string(EVP_str_functs[0].error) == NULL) {
  251|      1|        ERR_load_strings(0, EVP_str_functs);
  252|      1|        ERR_load_strings(0, EVP_str_reasons);
  253|      1|    }
  254|      1|#endif
  255|      1|}

EVP_MD_size:
  311|      5|{
  312|      5|    if (!md) {
  313|      0|        EVPerr(EVP_F_EVP_MD_SIZE, EVP_R_MESSAGE_DIGEST_IS_NULL);
  314|      0|        return -1;
  315|      0|    }
  316|      5|    return md->md_size;
  317|      5|}
EVP_MD_CTX_clear_flags:
  369|  8.33k|{
  370|  8.33k|    ctx->flags &= ~flags;
  371|  8.33k|}
EVP_MD_CTX_test_flags:
  374|  4.18k|{
  375|  4.18k|    return (ctx->flags & flags);
  376|  4.18k|}

EVP_dss:
  101|      1|{
  102|      1|    return (&dsa_md);
  103|      1|}

EVP_dss1:
  102|      2|{
  103|      2|    return (&dss1_md);
  104|      2|}

EVP_ecdsa:
  151|      2|{
  152|      2|    return (&ecdsa_md);
  153|      2|}

EVP_md4:
  105|      1|{
  106|      1|    return (&md4_md);
  107|      1|}

EVP_md5:
  104|      2|{
  105|      2|    return (&md5_md);
  106|      2|}

EVP_mdc2:
  105|      1|{
  106|      1|    return (&mdc2_md);
  107|      1|}

EVP_ripemd160:
  104|      1|{
  105|      1|    return (&ripemd160_md);
  106|      1|}

EVP_sha:
  103|      1|{
  104|      1|    return (&sha_md);
  105|      1|}

EVP_sha1:
  102|  8.46k|{
  103|  8.46k|    return (&sha1_md);
  104|  8.46k|}
EVP_sha224:
  149|      2|{
  150|      2|    return (&sha224_md);
  151|      2|}
EVP_sha256:
  169|    110|{
  170|    110|    return (&sha256_md);
  171|    110|}
EVP_sha384:
  212|      2|{
  213|      2|    return (&sha384_md);
  214|      2|}
EVP_sha512:
  232|      2|{
  233|      2|    return (&sha512_md);
  234|      2|}
m_sha1.c:init:
   72|  8.22k|{
   73|  8.22k|    return SHA1_Init(ctx->md_data);
   74|  8.22k|}
m_sha1.c:update:
   77|  32.9k|{
   78|  32.9k|    return SHA1_Update(ctx->md_data, data, count);
   79|  32.9k|}
m_sha1.c:final:
   82|  8.22k|{
   83|  8.22k|    return SHA1_Final(md, ctx->md_data);
   84|  8.22k|}
m_sha1.c:update256:
  124|  5.86k|{
  125|  5.86k|    return SHA256_Update(ctx->md_data, data, count);
  126|  5.86k|}
m_sha1.c:final256:
  129|    108|{
  130|    108|    return SHA256_Final(md, ctx->md_data);
  131|    108|}
m_sha1.c:init256:
  114|    108|{
  115|    108|    return SHA256_Init(ctx->md_data);
  116|    108|}

EVP_whirlpool:
   45|      1|{
   46|      1|    return (&whirlpool_md);
   47|      1|}

EVP_add_cipher:
   66|    122|{
   67|    122|    int r;
   68|       |
   69|    122|    if (c == NULL)
   70|      4|        return 0;
   71|       |
   72|    118|    OPENSSL_init();
   73|       |
   74|    118|    r = OBJ_NAME_add(OBJ_nid2sn(c->nid), OBJ_NAME_TYPE_CIPHER_METH,
   75|    118|                     (const char *)c);
   76|    118|    if (r == 0)
   77|      0|        return (0);
   78|    118|    check_defer(c->nid);
   79|    118|    r = OBJ_NAME_add(OBJ_nid2ln(c->nid), OBJ_NAME_TYPE_CIPHER_METH,
   80|    118|                     (const char *)c);
   81|    118|    return (r);
   82|    118|}
EVP_add_digest:
   85|     24|{
   86|     24|    int r;
   87|     24|    const char *name;
   88|     24|    OPENSSL_init();
   89|       |
   90|     24|    name = OBJ_nid2sn(md->type);
   91|     24|    r = OBJ_NAME_add(name, OBJ_NAME_TYPE_MD_METH, (const char *)md);
   92|     24|    if (r == 0)
   93|      0|        return (0);
   94|     24|    check_defer(md->type);
   95|     24|    r = OBJ_NAME_add(OBJ_nid2ln(md->type), OBJ_NAME_TYPE_MD_METH,
   96|     24|                     (const char *)md);
   97|     24|    if (r == 0)
   98|      0|        return (0);
   99|       |
  100|     24|    if (md->pkey_type && md->type != md->pkey_type) {
  101|     18|        r = OBJ_NAME_add(OBJ_nid2sn(md->pkey_type),
  102|     18|                         OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);
  103|     18|        if (r == 0)
  104|      0|            return (0);
  105|     18|        check_defer(md->pkey_type);
  106|     18|        r = OBJ_NAME_add(OBJ_nid2ln(md->pkey_type),
  107|     18|                         OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);
  108|     18|    }
  109|     24|    return (r);
  110|     24|}
EVP_get_cipherbyname:
  113|     13|{
  114|     13|    const EVP_CIPHER *cp;
  115|       |
  116|     13|    cp = (const EVP_CIPHER *)OBJ_NAME_get(name, OBJ_NAME_TYPE_CIPHER_METH);
  117|     13|    return (cp);
  118|     13|}
EVP_get_digestbyname:
  121|     96|{
  122|     96|    const EVP_MD *cp;
  123|       |
  124|     96|    cp = (const EVP_MD *)OBJ_NAME_get(name, OBJ_NAME_TYPE_MD_METH);
  125|     96|    return (cp);
  126|     96|}

EVP_PKEY_free:
  385|  3.84k|{
  386|  3.84k|    int i;
  387|       |
  388|  3.84k|    if (x == NULL)
  389|  3.84k|        return;
  390|       |
  391|      0|    i = CRYPTO_add(&x->references, -1, CRYPTO_LOCK_EVP_PKEY);
  392|       |#ifdef REF_PRINT
  393|       |    REF_PRINT("EVP_PKEY", x);
  394|       |#endif
  395|      0|    if (i > 0)
  396|      0|        return;
  397|       |#ifdef REF_CHECK
  398|       |    if (i < 0) {
  399|       |        fprintf(stderr, "EVP_PKEY_free, bad reference count\n");
  400|       |        abort();
  401|       |    }
  402|       |#endif
  403|      0|    EVP_PKEY_free_it(x);
  404|      0|    if (x->attributes)
  405|      0|        sk_X509_ATTRIBUTE_pop_free(x->attributes, X509_ATTRIBUTE_free);
  406|      0|    OPENSSL_free(x);
  407|      0|}

EVP_PKEY_meth_new:
  201|      3|{
  202|      3|    EVP_PKEY_METHOD *pmeth;
  203|       |
  204|      3|    pmeth = OPENSSL_malloc(sizeof(EVP_PKEY_METHOD));
  205|      3|    if (!pmeth)
  206|      0|        return NULL;
  207|       |
  208|      3|    memset(pmeth, 0, sizeof(EVP_PKEY_METHOD));
  209|       |
  210|      3|    pmeth->pkey_id = id;
  211|      3|    pmeth->flags = flags | EVP_PKEY_FLAG_DYNAMIC;
  212|      3|    return pmeth;
  213|      3|}
EVP_PKEY_meth_set_init:
  450|      3|{
  451|      3|    pmeth->init = init;
  452|      3|}
EVP_PKEY_meth_set_copy:
  457|      3|{
  458|      3|    pmeth->copy = copy;
  459|      3|}
EVP_PKEY_meth_set_cleanup:
  463|      3|{
  464|      3|    pmeth->cleanup = cleanup;
  465|      3|}
EVP_PKEY_meth_set_paramgen:
  471|      2|{
  472|      2|    pmeth->paramgen_init = paramgen_init;
  473|      2|    pmeth->paramgen = paramgen;
  474|      2|}
EVP_PKEY_meth_set_keygen:
  480|      3|{
  481|      3|    pmeth->keygen_init = keygen_init;
  482|      3|    pmeth->keygen = keygen;
  483|      3|}
EVP_PKEY_meth_set_sign:
  491|      2|{
  492|      2|    pmeth->sign_init = sign_init;
  493|      2|    pmeth->sign = sign;
  494|      2|}
EVP_PKEY_meth_set_verify:
  503|      2|{
  504|      2|    pmeth->verify_init = verify_init;
  505|      2|    pmeth->verify = verify;
  506|      2|}
EVP_PKEY_meth_set_signctx:
  531|      1|{
  532|      1|    pmeth->signctx_init = signctx_init;
  533|      1|    pmeth->signctx = signctx;
  534|      1|}
EVP_PKEY_meth_set_encrypt:
  555|      2|{
  556|      2|    pmeth->encrypt_init = encrypt_init;
  557|      2|    pmeth->encrypt = encryptfn;
  558|      2|}
EVP_PKEY_meth_set_decrypt:
  567|      2|{
  568|      2|    pmeth->decrypt_init = decrypt_init;
  569|      2|    pmeth->decrypt = decrypt;
  570|      2|}
EVP_PKEY_meth_set_derive:
  577|      2|{
  578|      2|    pmeth->derive_init = derive_init;
  579|      2|    pmeth->derive = derive;
  580|      2|}
EVP_PKEY_meth_set_ctrl:
  588|      3|{
  589|      3|    pmeth->ctrl = ctrl;
  590|      3|    pmeth->ctrl_str = ctrl_str;
  591|      3|}

CRYPTO_get_ex_new_index:
  581|      5|{
  582|      5|    int ret = -1;
  583|       |
  584|      5|    IMPL_CHECK
  585|      5|        ret = EX_IMPL(get_new_index) (class_index,
  586|      5|                                      argl, argp, new_func, dup_func,
  587|      5|                                      free_func);
  588|      5|    return ret;
  589|      5|}
CRYPTO_new_ex_data:
  596|  4.06k|{
  597|  4.06k|    IMPL_CHECK return EX_IMPL(new_ex_data) (class_index, obj, ad);
  598|  4.06k|}
CRYPTO_free_ex_data:
  615|  4.05k|{
  616|  4.05k|    IMPL_CHECK EX_IMPL(free_ex_data) (class_index, obj, ad);
  617|  4.05k|}
CRYPTO_set_ex_data:
  624|    360|{
  625|    360|    int i;
  626|       |
  627|    360|    if (ad->sk == NULL) {
  628|     30|        if ((ad->sk = sk_void_new_null()) == NULL) {
  629|      0|            CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);
  630|      0|            return (0);
  631|      0|        }
  632|     30|    }
  633|    360|    i = sk_void_num(ad->sk);
  634|       |
  635|    480|    while (i <= idx) {
  636|    120|        if (!sk_void_push(ad->sk, NULL)) {
  637|      0|            CRYPTOerr(CRYPTO_F_CRYPTO_SET_EX_DATA, ERR_R_MALLOC_FAILURE);
  638|      0|            return (0);
  639|      0|        }
  640|    120|        i++;
  641|    120|    }
  642|    360|    sk_void_set(ad->sk, idx, val);
  643|    360|    return (1);
  644|    360|}
ex_data.c:impl_check:
  200|      1|{
  201|      1|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  202|      1|    if (!impl)
  203|      1|        impl = &impl_default;
  204|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  205|      1|}
ex_data.c:ex_data_check:
  276|      1|{
  277|      1|    int toret = 1;
  278|      1|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  279|      1|    if (!ex_data && (ex_data = lh_EX_CLASS_ITEM_new()) == NULL)
  280|      0|        toret = 0;
  281|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  282|      1|    return toret;
  283|      1|}
ex_data.c:ex_class_item_hash:
  258|  8.13k|{
  259|  8.13k|    return a->class_index;
  260|  8.13k|}
ex_data.c:ex_class_item_cmp:
  265|  8.11k|{
  266|  8.11k|    return a->class_index - b->class_index;
  267|  8.11k|}
ex_data.c:int_get_new_index:
  407|      5|{
  408|      5|    EX_CLASS_ITEM *item = def_get_class(class_index);
  409|      5|    if (!item)
  410|      0|        return -1;
  411|      5|    return def_add_index(item, argl, argp, new_func, dup_func, free_func);
  412|      5|}
ex_data.c:def_get_class:
  314|  8.11k|{
  315|  8.11k|    EX_CLASS_ITEM d, *p, *gen;
  316|  8.11k|    EX_DATA_CHECK(return NULL;)
  317|  8.11k|        d.class_index = class_index;
  318|  8.11k|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  319|  8.11k|    p = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);
  320|  8.11k|    if (!p) {
  321|      8|        gen = OPENSSL_malloc(sizeof(EX_CLASS_ITEM));
  322|      8|        if (gen) {
  323|      8|            gen->class_index = class_index;
  324|      8|            gen->meth_num = 0;
  325|      8|            gen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();
  326|      8|            if (!gen->meth)
  327|      0|                OPENSSL_free(gen);
  328|      8|            else {
  329|       |                /*
  330|       |                 * Because we're inside the ex_data lock, the return value
  331|       |                 * from the insert will be NULL
  332|       |                 */
  333|      8|                (void)lh_EX_CLASS_ITEM_insert(ex_data, gen);
  334|      8|                p = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);
  335|      8|                if (p != gen) {
  336|      0|                    sk_CRYPTO_EX_DATA_FUNCS_free(gen->meth);
  337|      0|                    OPENSSL_free(gen);
  338|      0|                }
  339|      8|            }
  340|      8|        }
  341|      8|    }
  342|  8.11k|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  343|  8.11k|    if (!p)
  344|  8.11k|        CRYPTOerr(CRYPTO_F_DEF_GET_CLASS, ERR_R_MALLOC_FAILURE);
  345|  8.11k|    return p;
  346|  8.11k|}
ex_data.c:def_add_index:
  355|      5|{
  356|      5|    int toret = -1;
  357|      5|    CRYPTO_EX_DATA_FUNCS *a =
  358|      5|        (CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(sizeof(CRYPTO_EX_DATA_FUNCS));
  359|      5|    if (!a) {
  360|      0|        CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);
  361|      0|        return -1;
  362|      0|    }
  363|      5|    a->argl = argl;
  364|      5|    a->argp = argp;
  365|      5|    a->new_func = new_func;
  366|      5|    a->dup_func = dup_func;
  367|      5|    a->free_func = free_func;
  368|      5|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  369|     10|    while (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num) {
  370|      5|        if (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL)) {
  371|      0|            CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);
  372|      0|            OPENSSL_free(a);
  373|      0|            goto err;
  374|      0|        }
  375|      5|    }
  376|      5|    toret = item->meth_num++;
  377|      5|    (void)sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);
  378|      5| err:
  379|      5|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  380|      5|    return toret;
  381|      5|}
ex_data.c:int_new_ex_data:
  421|  4.06k|{
  422|  4.06k|    int mx, i;
  423|  4.06k|    void *ptr;
  424|  4.06k|    CRYPTO_EX_DATA_FUNCS **storage = NULL;
  425|  4.06k|    EX_CLASS_ITEM *item = def_get_class(class_index);
  426|  4.06k|    if (!item)
  427|       |        /* error is already set */
  428|      0|        return 0;
  429|  4.06k|    ad->sk = NULL;
  430|  4.06k|    CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
  431|  4.06k|    mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
  432|  4.06k|    if (mx > 0) {
  433|     30|        storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));
  434|     30|        if (!storage)
  435|      0|            goto skip;
  436|    150|        for (i = 0; i < mx; i++)
  437|    120|            storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);
  438|     30|    }
  439|  4.06k| skip:
  440|  4.06k|    CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
  441|  4.06k|    if ((mx > 0) && !storage) {
  442|      0|        CRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA, ERR_R_MALLOC_FAILURE);
  443|      0|        return 0;
  444|      0|    }
  445|  4.18k|    for (i = 0; i < mx; i++) {
  446|    120|        if (storage[i] && storage[i]->new_func) {
  447|      0|            ptr = CRYPTO_get_ex_data(ad, i);
  448|      0|            storage[i]->new_func(obj, ptr, ad, i,
  449|      0|                                 storage[i]->argl, storage[i]->argp);
  450|      0|        }
  451|    120|    }
  452|  4.06k|    if (storage)
  453|     30|        OPENSSL_free(storage);
  454|  4.06k|    return 1;
  455|  4.06k|}
ex_data.c:int_free_ex_data:
  511|  4.05k|{
  512|  4.05k|    int mx, i;
  513|  4.05k|    EX_CLASS_ITEM *item;
  514|  4.05k|    void *ptr;
  515|  4.05k|    CRYPTO_EX_DATA_FUNCS *f;
  516|  4.05k|    CRYPTO_EX_DATA_FUNCS **storage = NULL;
  517|  4.05k|    if (ex_data == NULL)
  518|      0|        goto err;
  519|  4.05k|    if ((item = def_get_class(class_index)) == NULL)
  520|      0|        goto err;
  521|  4.05k|    CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
  522|  4.05k|    mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
  523|  4.05k|    if (mx > 0) {
  524|     30|        storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));
  525|     30|        if (!storage)
  526|      0|            goto skip;
  527|    150|        for (i = 0; i < mx; i++)
  528|    120|            storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);
  529|     30|    }
  530|  4.05k| skip:
  531|  4.05k|    CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
  532|  4.17k|    for (i = 0; i < mx; i++) {
  533|    120|        if (storage != NULL)
  534|    120|            f = storage[i];
  535|      0|        else {
  536|      0|            CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
  537|      0|            f = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);
  538|      0|            CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
  539|      0|        }
  540|    120|        if (f != NULL && f->free_func != NULL) {
  541|      0|            ptr = CRYPTO_get_ex_data(ad, i);
  542|      0|            f->free_func(obj, ptr, ad, i, f->argl, f->argp);
  543|      0|        }
  544|    120|    }
  545|  4.05k|    OPENSSL_free(storage);
  546|  4.05k| err:
  547|  4.05k|    sk_void_free(ad->sk);
  548|  4.05k|    ad->sk = NULL;
  549|  4.05k|}

lh_new:
  134|  3.15k|{
  135|  3.15k|    _LHASH *ret;
  136|  3.15k|    int i;
  137|       |
  138|  3.15k|    if ((ret = OPENSSL_malloc(sizeof(_LHASH))) == NULL)
  139|      0|        goto err0;
  140|  3.15k|    if ((ret->b = OPENSSL_malloc(sizeof(LHASH_NODE *) * MIN_NODES)) == NULL)
  141|      0|        goto err1;
  142|  53.5k|    for (i = 0; i < MIN_NODES; i++)
  143|  50.4k|        ret->b[i] = NULL;
  144|  3.15k|    ret->comp = ((c == NULL) ? (LHASH_COMP_FN_TYPE)strcmp : c);
  145|  3.15k|    ret->hash = ((h == NULL) ? (LHASH_HASH_FN_TYPE)lh_strhash : h);
  146|  3.15k|    ret->num_nodes = MIN_NODES / 2;
  147|  3.15k|    ret->num_alloc_nodes = MIN_NODES;
  148|  3.15k|    ret->p = 0;
  149|  3.15k|    ret->pmax = MIN_NODES / 2;
  150|  3.15k|    ret->up_load = UP_LOAD;
  151|  3.15k|    ret->down_load = DOWN_LOAD;
  152|  3.15k|    ret->num_items = 0;
  153|       |
  154|  3.15k|    ret->num_expands = 0;
  155|  3.15k|    ret->num_expand_reallocs = 0;
  156|  3.15k|    ret->num_contracts = 0;
  157|  3.15k|    ret->num_contract_reallocs = 0;
  158|  3.15k|    ret->num_hash_calls = 0;
  159|  3.15k|    ret->num_comp_calls = 0;
  160|  3.15k|    ret->num_insert = 0;
  161|  3.15k|    ret->num_replace = 0;
  162|  3.15k|    ret->num_delete = 0;
  163|  3.15k|    ret->num_no_delete = 0;
  164|  3.15k|    ret->num_retrieve = 0;
  165|  3.15k|    ret->num_retrieve_miss = 0;
  166|  3.15k|    ret->num_hash_comps = 0;
  167|       |
  168|  3.15k|    ret->error = 0;
  169|  3.15k|    return (ret);
  170|      0| err1:
  171|      0|    OPENSSL_free(ret);
  172|      0| err0:
  173|      0|    return (NULL);
  174|      0|}
lh_free:
  177|  3.13k|{
  178|  3.13k|    unsigned int i;
  179|  3.13k|    LHASH_NODE *n, *nn;
  180|       |
  181|  3.13k|    if (lh == NULL)
  182|      0|        return;
  183|       |
  184|  28.2k|    for (i = 0; i < lh->num_nodes; i++) {
  185|  25.1k|        n = lh->b[i];
  186|  25.1k|        while (n != NULL) {
  187|      0|            nn = n->next;
  188|      0|            OPENSSL_free(n);
  189|      0|            n = nn;
  190|      0|        }
  191|  25.1k|    }
  192|  3.13k|    OPENSSL_free(lh->b);
  193|  3.13k|    OPENSSL_free(lh);
  194|  3.13k|}
lh_insert:
  197|  22.5k|{
  198|  22.5k|    unsigned long hash;
  199|  22.5k|    LHASH_NODE *nn, **rn;
  200|  22.5k|    void *ret;
  201|       |
  202|  22.5k|    lh->error = 0;
  203|  22.5k|    if (lh->up_load <= (lh->num_items * LH_LOAD_MULT / lh->num_nodes)
  204|  22.5k|            && !expand(lh))
  205|      0|        return NULL;
  206|       |
  207|  22.5k|    rn = getrn(lh, data, &hash);
  208|       |
  209|  22.5k|    if (*rn == NULL) {
  210|  6.33k|        if ((nn = (LHASH_NODE *)OPENSSL_malloc(sizeof(LHASH_NODE))) == NULL) {
  211|      0|            lh->error++;
  212|      0|            return (NULL);
  213|      0|        }
  214|  6.33k|        nn->data = data;
  215|  6.33k|        nn->next = NULL;
  216|  6.33k|#ifndef OPENSSL_NO_HASH_COMP
  217|  6.33k|        nn->hash = hash;
  218|  6.33k|#endif
  219|  6.33k|        *rn = nn;
  220|  6.33k|        ret = NULL;
  221|  6.33k|        lh->num_insert++;
  222|  6.33k|        lh->num_items++;
  223|  16.2k|    } else {                    /* replace same key */
  224|       |
  225|  16.2k|        ret = (*rn)->data;
  226|  16.2k|        (*rn)->data = data;
  227|  16.2k|        lh->num_replace++;
  228|  16.2k|    }
  229|  22.5k|    return (ret);
  230|  22.5k|}
lh_delete:
  233|  3.10k|{
  234|  3.10k|    unsigned long hash;
  235|  3.10k|    LHASH_NODE *nn, **rn;
  236|  3.10k|    void *ret;
  237|       |
  238|  3.10k|    lh->error = 0;
  239|  3.10k|    rn = getrn(lh, data, &hash);
  240|       |
  241|  3.10k|    if (*rn == NULL) {
  242|      0|        lh->num_no_delete++;
  243|      0|        return (NULL);
  244|  3.10k|    } else {
  245|  3.10k|        nn = *rn;
  246|  3.10k|        *rn = nn->next;
  247|  3.10k|        ret = nn->data;
  248|  3.10k|        OPENSSL_free(nn);
  249|  3.10k|        lh->num_delete++;
  250|  3.10k|    }
  251|       |
  252|  3.10k|    lh->num_items--;
  253|  3.10k|    if ((lh->num_nodes > MIN_NODES) &&
  254|  3.10k|        (lh->down_load >= (lh->num_items * LH_LOAD_MULT / lh->num_nodes)))
  255|      0|        contract(lh);
  256|       |
  257|  3.10k|    return (ret);
  258|  3.10k|}
lh_retrieve:
  261|  33.8k|{
  262|  33.8k|    unsigned long hash;
  263|  33.8k|    LHASH_NODE **rn;
  264|  33.8k|    void *ret;
  265|       |
  266|  33.8k|    lh->error = 0;
  267|  33.8k|    rn = getrn(lh, data, &hash);
  268|       |
  269|  33.8k|    if (*rn == NULL) {
  270|  8.49k|        lh->num_retrieve_miss++;
  271|  8.49k|        return (NULL);
  272|  25.3k|    } else {
  273|  25.3k|        ret = (*rn)->data;
  274|  25.3k|        lh->num_retrieve++;
  275|  25.3k|    }
  276|  25.3k|    return (ret);
  277|  33.8k|}
lh_doall_arg:
  318|     30|{
  319|     30|    doall_util_fn(lh, 1, (LHASH_DOALL_FN_TYPE)0, func, arg);
  320|     30|}
lh_strhash:
  447|    568|{
  448|    568|    unsigned long ret = 0;
  449|    568|    long n;
  450|    568|    unsigned long v;
  451|    568|    int r;
  452|       |
  453|    568|    if ((c == NULL) || (*c == '\0'))
  454|      0|        return (ret);
  455|       |/*-
  456|       |    unsigned char b[16];
  457|       |    MD5(c,strlen(c),b);
  458|       |    return(b[0]|(b[1]<<8)|(b[2]<<16)|(b[3]<<24));
  459|       |*/
  460|       |
  461|    568|    n = 0x100;
  462|  5.62k|    while (*c) {
  463|  5.05k|        v = n | (*c);
  464|  5.05k|        n += 0x100;
  465|  5.05k|        r = (int)((v >> 2) ^ v) & 0x0f;
  466|  5.05k|        ret = (ret << r) | (ret >> (32 - r));
  467|  5.05k|        ret &= 0xFFFFFFFFL;
  468|  5.05k|        ret ^= v * v;
  469|  5.05k|        c++;
  470|  5.05k|    }
  471|    568|    return ((ret >> 16) ^ ret);
  472|    568|}
lh_num_items:
  475|  3.10k|{
  476|  3.10k|    return lh ? lh->num_items : 0;
  477|  3.10k|}
lhash.c:doall_util_fn:
  281|     30|{
  282|     30|    int i;
  283|     30|    LHASH_NODE *a, *n;
  284|       |
  285|     30|    if (lh == NULL)
  286|      0|        return;
  287|       |
  288|       |    /*
  289|       |     * reverse the order so we search from 'top to bottom' We were having
  290|       |     * memory leaks otherwise
  291|       |     */
  292|    270|    for (i = lh->num_nodes - 1; i >= 0; i--) {
  293|    240|        a = lh->b[i];
  294|    240|        while (a != NULL) {
  295|       |            /*
  296|       |             * 28/05/91 - eay - n added so items can be deleted via lh_doall
  297|       |             */
  298|       |            /*
  299|       |             * 22/05/08 - ben - eh? since a is not passed, this should not be
  300|       |             * needed
  301|       |             */
  302|      0|            n = a->next;
  303|      0|            if (use_arg)
  304|      0|                func_arg(a->data, arg);
  305|      0|            else
  306|      0|                func(a->data);
  307|      0|            a = n;
  308|      0|        }
  309|    240|    }
  310|     30|}
lhash.c:expand:
  323|  1.58k|{
  324|  1.58k|    LHASH_NODE **n, **n1, **n2, *np;
  325|  1.58k|    unsigned int p, pmax, nni, j;
  326|  1.58k|    unsigned long hash;
  327|       |
  328|  1.58k|    nni = lh->num_alloc_nodes;
  329|  1.58k|    p = lh->p;
  330|  1.58k|    pmax = lh->pmax;
  331|  1.58k|    if (p + 1 >= pmax) {
  332|     11|        j = nni * 2;
  333|     11|        n = OPENSSL_realloc(lh->b, (int)(sizeof(LHASH_NODE *) * j));
  334|     11|        if (n == NULL) {
  335|      0|            lh->error++;
  336|      0|            return 0;
  337|      0|        }
  338|     11|        lh->b = n;
  339|     11|        memset(n + nni, 0, sizeof(*n) * (j - nni));
  340|     11|        lh->pmax = nni;
  341|     11|        lh->num_alloc_nodes = j;
  342|     11|        lh->num_expand_reallocs++;
  343|     11|        lh->p = 0;
  344|  1.57k|    } else {
  345|  1.57k|        lh->p++;
  346|  1.57k|    }
  347|       |
  348|  1.58k|    lh->num_nodes++;
  349|  1.58k|    lh->num_expands++;
  350|  1.58k|    n1 = &(lh->b[p]);
  351|  1.58k|    n2 = &(lh->b[p + pmax]);
  352|  1.58k|    *n2 = NULL;
  353|       |
  354|  7.20k|    for (np = *n1; np != NULL;) {
  355|  5.61k|#ifndef OPENSSL_NO_HASH_COMP
  356|  5.61k|        hash = np->hash;
  357|       |#else
  358|       |        hash = lh->hash(np->data);
  359|       |        lh->num_hash_calls++;
  360|       |#endif
  361|  5.61k|        if ((hash % nni) != p) { /* move it */
  362|    558|            *n1 = (*n1)->next;
  363|    558|            np->next = *n2;
  364|    558|            *n2 = np;
  365|    558|        } else
  366|  5.05k|            n1 = &((*n1)->next);
  367|  5.61k|        np = *n1;
  368|  5.61k|    }
  369|       |
  370|  1.58k|    return 1;
  371|  1.58k|}
lhash.c:getrn:
  410|  59.5k|{
  411|  59.5k|    LHASH_NODE **ret, *n1;
  412|  59.5k|    unsigned long hash, nn;
  413|  59.5k|    LHASH_COMP_FN_TYPE cf;
  414|       |
  415|  59.5k|    hash = (*(lh->hash)) (data);
  416|  59.5k|    lh->num_hash_calls++;
  417|  59.5k|    *rhash = hash;
  418|       |
  419|  59.5k|    nn = hash % lh->pmax;
  420|  59.5k|    if (nn < lh->p)
  421|  11.7k|        nn = hash % lh->num_alloc_nodes;
  422|       |
  423|  59.5k|    cf = lh->comp;
  424|  59.5k|    ret = &(lh->b[(int)nn]);
  425|  94.0k|    for (n1 = *ret; n1 != NULL; n1 = n1->next) {
  426|  79.2k|#ifndef OPENSSL_NO_HASH_COMP
  427|  79.2k|        lh->num_hash_comps++;
  428|  79.2k|        if (n1->hash != hash) {
  429|  33.4k|            ret = &(n1->next);
  430|  33.4k|            continue;
  431|  33.4k|        }
  432|  45.7k|#endif
  433|  45.7k|        lh->num_comp_calls++;
  434|  45.7k|        if (cf(n1->data, data) == 0)
  435|  44.6k|            break;
  436|  1.06k|        ret = &(n1->next);
  437|  1.06k|    }
  438|  59.5k|    return (ret);
  439|  59.5k|}

MD5_Update:
  303|  3.90k|{
  304|  3.90k|    const unsigned char *data = data_;
  305|  3.90k|    unsigned char *p;
  306|  3.90k|    HASH_LONG l;
  307|  3.90k|    size_t n;
  308|       |
  309|  3.90k|    if (len == 0)
  310|      3|        return 1;
  311|       |
  312|  3.89k|    l = (c->Nl + (((HASH_LONG) len) << 3)) & 0xffffffffUL;
  313|       |    /*
  314|       |     * 95-05-24 eay Fixed a bug with the overflow handling, thanks to Wei Dai
  315|       |     * <weidai@eskimo.com> for pointing it out.
  316|       |     */
  317|  3.89k|    if (l < c->Nl)              /* overflow */
  318|      0|        c->Nh++;
  319|  3.89k|    c->Nh += (HASH_LONG) (len >> 29); /* might cause compiler warning on
  320|       |                                       * 16-bit */
  321|  3.89k|    c->Nl = l;
  322|       |
  323|  3.89k|    n = c->num;
  324|  3.89k|    if (n != 0) {
  325|  3.65k|        p = (unsigned char *)c->data;
  326|       |
  327|  3.65k|        if (len >= HASH_CBLOCK || len + n >= HASH_CBLOCK) {
  328|     59|            memcpy(p + n, data, HASH_CBLOCK - n);
  329|     59|            HASH_BLOCK_DATA_ORDER(c, p, 1);
  330|     59|            n = HASH_CBLOCK - n;
  331|     59|            data += n;
  332|     59|            len -= n;
  333|     59|            c->num = 0;
  334|       |            /*
  335|       |             * We use memset rather than OPENSSL_cleanse() here deliberately.
  336|       |             * Using OPENSSL_cleanse() here could be a performance issue. It
  337|       |             * will get properly cleansed on finalisation so this isn't a
  338|       |             * security problem.
  339|       |             */
  340|     59|            memset(p, 0, HASH_CBLOCK); /* keep it zeroed */
  341|  3.59k|        } else {
  342|  3.59k|            memcpy(p + n, data, len);
  343|  3.59k|            c->num += (unsigned int)len;
  344|  3.59k|            return 1;
  345|  3.59k|        }
  346|  3.65k|    }
  347|       |
  348|    302|    n = len / HASH_CBLOCK;
  349|    302|    if (n > 0) {
  350|     61|        HASH_BLOCK_DATA_ORDER(c, data, n);
  351|     61|        n *= HASH_CBLOCK;
  352|     61|        data += n;
  353|     61|        len -= n;
  354|     61|    }
  355|       |
  356|    302|    if (len != 0) {
  357|    243|        p = (unsigned char *)c->data;
  358|    243|        c->num = (unsigned int)len;
  359|    243|        memcpy(p, data, len);
  360|    243|    }
  361|    302|    return 1;
  362|  3.89k|}
MD5_Final:
  370|    199|{
  371|    199|    unsigned char *p = (unsigned char *)c->data;
  372|    199|    size_t n = c->num;
  373|       |
  374|    199|    p[n] = 0x80;                /* there is always room for one */
  375|    199|    n++;
  376|       |
  377|    199|    if (n > (HASH_CBLOCK - 8)) {
  378|      7|        memset(p + n, 0, HASH_CBLOCK - n);
  379|      7|        n = 0;
  380|      7|        HASH_BLOCK_DATA_ORDER(c, p, 1);
  381|      7|    }
  382|    199|    memset(p + n, 0, HASH_CBLOCK - 8 - n);
  383|       |
  384|    199|    p += HASH_CBLOCK - 8;
  385|       |#if   defined(DATA_ORDER_IS_BIG_ENDIAN)
  386|       |    (void)HOST_l2c(c->Nh, p);
  387|       |    (void)HOST_l2c(c->Nl, p);
  388|       |#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)
  389|    199|    (void)HOST_l2c(c->Nl, p);
  390|    199|    (void)HOST_l2c(c->Nh, p);
  391|    199|#endif
  392|    199|    p -= HASH_CBLOCK;
  393|    199|    HASH_BLOCK_DATA_ORDER(c, p, 1);
  394|    199|    c->num = 0;
  395|    199|    OPENSSL_cleanse(p, HASH_CBLOCK);
  396|       |
  397|       |#ifndef HASH_MAKE_STRING
  398|       |# error "HASH_MAKE_STRING must be defined!"
  399|       |#else
  400|    199|    HASH_MAKE_STRING(c, md);
  401|    199|#endif
  402|       |
  403|    199|    return 1;
  404|    199|}

MD5_Init:
   76|    199|{
   77|    199|    memset(c, 0, sizeof(*c));
   78|    199|    c->A = INIT_DATA_A;
   79|    199|    c->B = INIT_DATA_B;
   80|    199|    c->C = INIT_DATA_C;
   81|    199|    c->D = INIT_DATA_D;
   82|    199|    return 1;
   83|    199|}

CRYPTO_malloc:
  333|   761k|{
  334|   761k|    void *ret = NULL;
  335|       |
  336|   761k|    if (num <= 0)
  337|      0|        return NULL;
  338|       |
  339|   761k|    if (allow_customize)
  340|      1|        allow_customize = 0;
  341|   761k|    if (malloc_debug_func != NULL) {
  342|      0|        if (allow_customize_debug)
  343|      0|            allow_customize_debug = 0;
  344|      0|        malloc_debug_func(NULL, num, file, line, 0);
  345|      0|    }
  346|   761k|    ret = malloc_ex_func(num, file, line);
  347|       |#ifdef LEVITTE_DEBUG_MEM
  348|       |    fprintf(stderr, "LEVITTE_DEBUG_MEM:         > 0x%p (%d)\n", ret, num);
  349|       |#endif
  350|   761k|    if (malloc_debug_func != NULL)
  351|      0|        malloc_debug_func(ret, num, file, line, 1);
  352|       |
  353|   761k|    return ret;
  354|   761k|}
CRYPTO_realloc:
  368|  30.2k|{
  369|  30.2k|    void *ret = NULL;
  370|       |
  371|  30.2k|    if (str == NULL)
  372|      0|        return CRYPTO_malloc(num, file, line);
  373|       |
  374|  30.2k|    if (num <= 0)
  375|      0|        return NULL;
  376|       |
  377|  30.2k|    if (realloc_debug_func != NULL)
  378|      0|        realloc_debug_func(str, NULL, num, file, line, 0);
  379|  30.2k|    ret = realloc_ex_func(str, num, file, line);
  380|       |#ifdef LEVITTE_DEBUG_MEM
  381|       |    fprintf(stderr, "LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n", str,
  382|       |            ret, num);
  383|       |#endif
  384|  30.2k|    if (realloc_debug_func != NULL)
  385|      0|        realloc_debug_func(str, ret, num, file, line, 1);
  386|       |
  387|  30.2k|    return ret;
  388|  30.2k|}
CRYPTO_free:
  428|   762k|{
  429|   762k|    if (free_debug_func != NULL)
  430|      0|        free_debug_func(str, 0);
  431|       |#ifdef LEVITTE_DEBUG_MEM
  432|       |    fprintf(stderr, "LEVITTE_DEBUG_MEM:         < 0x%p\n", str);
  433|       |#endif
  434|   762k|    free_func(str);
  435|   762k|    if (free_debug_func != NULL)
  436|      0|        free_debug_func(NULL, 1);
  437|   762k|}
mem.c:default_malloc_ex:
   78|   761k|{
   79|   761k|    return malloc_func(num);
   80|   761k|}
mem.c:default_realloc_ex:
   96|  30.2k|{
   97|  30.2k|    return realloc_func(str, num);
   98|  30.2k|}

CRYPTO_mem_ctrl:
  209|      4|{
  210|      4|    int ret = mh_mode;
  211|       |
  212|      4|    CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
  213|      4|    switch (mode) {
  214|       |        /*
  215|       |         * for applications (not to be called while multiple threads use the
  216|       |         * library):
  217|       |         */
  218|      0|    case CRYPTO_MEM_CHECK_ON:  /* aka MemCheck_start() */
  219|      0|        mh_mode = CRYPTO_MEM_CHECK_ON | CRYPTO_MEM_CHECK_ENABLE;
  220|      0|        num_disable = 0;
  221|      0|        break;
  222|      0|    case CRYPTO_MEM_CHECK_OFF: /* aka MemCheck_stop() */
  223|      0|        mh_mode = 0;
  224|      0|        num_disable = 0;        /* should be true *before* MemCheck_stop is
  225|       |                                 * used, or there'll be a lot of confusion */
  226|      0|        break;
  227|       |
  228|       |        /* switch off temporarily (for library-internal use): */
  229|      2|    case CRYPTO_MEM_CHECK_DISABLE: /* aka MemCheck_off() */
  230|      2|        if (mh_mode & CRYPTO_MEM_CHECK_ON) {
  231|      0|            CRYPTO_THREADID cur;
  232|      0|            CRYPTO_THREADID_current(&cur);
  233|       |            /* see if we don't have the MALLOC2 lock already */
  234|      0|            if (!num_disable
  235|      0|                || CRYPTO_THREADID_cmp(&disabling_threadid, &cur)) {
  236|       |                /*
  237|       |                 * Long-time lock CRYPTO_LOCK_MALLOC2 must not be claimed
  238|       |                 * while we're holding CRYPTO_LOCK_MALLOC, or we'll deadlock
  239|       |                 * if somebody else holds CRYPTO_LOCK_MALLOC2 (and cannot
  240|       |                 * release it because we block entry to this function). Give
  241|       |                 * them a chance, first, and then claim the locks in
  242|       |                 * appropriate order (long-time lock first).
  243|       |                 */
  244|      0|                CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
  245|       |                /*
  246|       |                 * Note that after we have waited for CRYPTO_LOCK_MALLOC2 and
  247|       |                 * CRYPTO_LOCK_MALLOC, we'll still be in the right "case" and
  248|       |                 * "if" branch because MemCheck_start and MemCheck_stop may
  249|       |                 * never be used while there are multiple OpenSSL threads.
  250|       |                 */
  251|      0|                CRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);
  252|      0|                CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
  253|      0|                mh_mode &= ~CRYPTO_MEM_CHECK_ENABLE;
  254|      0|                CRYPTO_THREADID_cpy(&disabling_threadid, &cur);
  255|      0|            }
  256|      0|            num_disable++;
  257|      0|        }
  258|      2|        break;
  259|      2|    case CRYPTO_MEM_CHECK_ENABLE: /* aka MemCheck_on() */
  260|      2|        if (mh_mode & CRYPTO_MEM_CHECK_ON) {
  261|      0|            if (num_disable) {  /* always true, or something is going wrong */
  262|      0|                num_disable--;
  263|      0|                if (num_disable == 0) {
  264|      0|                    mh_mode |= CRYPTO_MEM_CHECK_ENABLE;
  265|      0|                    CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
  266|      0|                }
  267|      0|            }
  268|      0|        }
  269|      2|        break;
  270|       |
  271|      0|    default:
  272|      0|        break;
  273|      4|    }
  274|      4|    CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
  275|      4|    return (ret);
  276|      4|}
CRYPTO_is_mem_check_on:
  279|  6.22k|{
  280|  6.22k|    int ret = 0;
  281|       |
  282|  6.22k|    if (mh_mode & CRYPTO_MEM_CHECK_ON) {
  283|      0|        CRYPTO_THREADID cur;
  284|      0|        CRYPTO_THREADID_current(&cur);
  285|      0|        CRYPTO_r_lock(CRYPTO_LOCK_MALLOC);
  286|       |
  287|      0|        ret = (mh_mode & CRYPTO_MEM_CHECK_ENABLE)
  288|      0|            || CRYPTO_THREADID_cmp(&disabling_threadid, &cur);
  289|       |
  290|      0|        CRYPTO_r_unlock(CRYPTO_LOCK_MALLOC);
  291|      0|    }
  292|  6.22k|    return (ret);
  293|  6.22k|}
CRYPTO_push_info_:
  390|  3.11k|{
  391|  3.11k|    APP_INFO *ami, *amim;
  392|  3.11k|    int ret = 0;
  393|       |
  394|  3.11k|    if (is_MemCheck_on()) {
  395|      0|        MemCheck_off();         /* obtain MALLOC2 lock */
  396|       |
  397|      0|        if ((ami = (APP_INFO *)OPENSSL_malloc(sizeof(APP_INFO))) == NULL) {
  398|      0|            ret = 0;
  399|      0|            goto err;
  400|      0|        }
  401|      0|        if (amih == NULL) {
  402|      0|            if ((amih = lh_APP_INFO_new()) == NULL) {
  403|      0|                OPENSSL_free(ami);
  404|      0|                ret = 0;
  405|      0|                goto err;
  406|      0|            }
  407|      0|        }
  408|       |
  409|      0|        CRYPTO_THREADID_current(&ami->threadid);
  410|      0|        ami->file = file;
  411|      0|        ami->line = line;
  412|      0|        ami->info = info;
  413|      0|        ami->references = 1;
  414|      0|        ami->next = NULL;
  415|       |
  416|      0|        if ((amim = lh_APP_INFO_insert(amih, ami)) != NULL) {
  417|       |#ifdef LEVITTE_DEBUG_MEM
  418|       |            if (CRYPTO_THREADID_cmp(&ami->threadid, &amim->threadid)) {
  419|       |                fprintf(stderr,
  420|       |                        "CRYPTO_push_info(): previous info has other thread ID (%lu) than the current thread (%lu)!!!!\n",
  421|       |                        CRYPTO_THREADID_hash(&amim->threadid),
  422|       |                        CRYPTO_THREADID_hash(&ami->threadid));
  423|       |                abort();
  424|       |            }
  425|       |#endif
  426|      0|            ami->next = amim;
  427|      0|        }
  428|      0| err:
  429|      0|        MemCheck_on();          /* release MALLOC2 lock */
  430|      0|    }
  431|       |
  432|  3.11k|    return (ret);
  433|  3.11k|}
CRYPTO_pop_info:
  436|  3.11k|{
  437|  3.11k|    int ret = 0;
  438|       |
  439|  3.11k|    if (is_MemCheck_on()) {     /* _must_ be true, or something went severely
  440|       |                                 * wrong */
  441|      0|        MemCheck_off();         /* obtain MALLOC2 lock */
  442|       |
  443|      0|        ret = (pop_info() != NULL);
  444|       |
  445|      0|        MemCheck_on();          /* release MALLOC2 lock */
  446|      0|    }
  447|  3.11k|    return (ret);
  448|  3.11k|}

OPENSSL_init:
   69|    142|{
   70|    142|    static int done = 0;
   71|    142|    if (done)
   72|    141|        return;
   73|      1|    done = 1;
   74|       |#ifdef OPENSSL_FIPS
   75|       |    FIPS_set_locking_callbacks(CRYPTO_lock, CRYPTO_add_lock);
   76|       |# ifndef OPENSSL_NO_DEPRECATED
   77|       |    FIPS_crypto_set_id_callback(CRYPTO_thread_id);
   78|       |# endif
   79|       |    FIPS_set_error_callbacks(ERR_put_error, ERR_add_error_vdata);
   80|       |    FIPS_set_malloc_callbacks(CRYPTO_malloc, CRYPTO_free);
   81|       |    RAND_init_fips();
   82|       |#endif
   83|       |#if 0
   84|       |    fprintf(stderr, "Called OPENSSL_init\n");
   85|       |#endif
   86|      1|}

o_names.c:obj_name_LHASH_HASH:
  105|    568|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|    568|                const o_type *a = arg; \
  107|    568|                return name##_hash(a); }
o_names.c:obj_name_LHASH_COMP:
  114|    277|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|    277|                const o_type *a = arg1;             \
  116|    277|                const o_type *b = arg2; \
  117|    277|                return name##_cmp(a,b); }

obj_dat.c:OBJ_bsearch_obj:
 1070|  14.5k|      { \
 1071|  14.5k|      return (type2 *)OBJ_bsearch_(key, base, num, sizeof(type2), \
 1072|  14.5k|                                        nm##_cmp_BSEARCH_CMP_FN); \
 1073|  14.5k|      } \
obj_dat.c:obj_cmp_BSEARCH_CMP_FN:
 1064|   133k|      { \
 1065|   133k|      type1 const *a = a_; \
 1066|   133k|      type2 const *b = b_; \
 1067|   133k|      return nm##_cmp(a,b); \
 1068|   133k|      } \

OBJ_NAME_init:
   57|      1|{
   58|      1|    if (names_lh != NULL)
   59|      0|        return (1);
   60|      1|    MemCheck_off();
   61|      1|    names_lh = lh_OBJ_NAME_new();
   62|      1|    MemCheck_on();
   63|      1|    return (names_lh != NULL);
   64|      1|}
OBJ_NAME_get:
  151|    109|{
  152|    109|    OBJ_NAME on, *ret;
  153|    109|    int num = 0, alias;
  154|       |
  155|    109|    if (name == NULL)
  156|      0|        return (NULL);
  157|    109|    if ((names_lh == NULL) && !OBJ_NAME_init())
  158|      0|        return (NULL);
  159|       |
  160|    109|    alias = type & OBJ_NAME_ALIAS;
  161|    109|    type &= ~OBJ_NAME_ALIAS;
  162|       |
  163|    109|    on.name = name;
  164|    109|    on.type = type;
  165|       |
  166|    199|    for (;;) {
  167|    199|        ret = lh_OBJ_NAME_retrieve(names_lh, &on);
  168|    199|        if (ret == NULL)
  169|      0|            return (NULL);
  170|    199|        if ((ret->alias) && !alias) {
  171|     90|            if (++num > 10)
  172|      0|                return (NULL);
  173|     90|            on.name = ret->data;
  174|    109|        } else {
  175|    109|            return (ret->data);
  176|    109|        }
  177|    199|    }
  178|    109|}
OBJ_NAME_add:
  181|    369|{
  182|    369|    OBJ_NAME *onp, *ret;
  183|    369|    int alias;
  184|       |
  185|    369|    if ((names_lh == NULL) && !OBJ_NAME_init())
  186|      0|        return (0);
  187|       |
  188|    369|    alias = type & OBJ_NAME_ALIAS;
  189|    369|    type &= ~OBJ_NAME_ALIAS;
  190|       |
  191|    369|    onp = (OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));
  192|    369|    if (onp == NULL) {
  193|       |        /* ERROR */
  194|      0|        return 0;
  195|      0|    }
  196|       |
  197|    369|    onp->name = name;
  198|    369|    onp->alias = alias;
  199|    369|    onp->type = type;
  200|    369|    onp->data = data;
  201|       |
  202|    369|    ret = lh_OBJ_NAME_insert(names_lh, onp);
  203|    369|    if (ret != NULL) {
  204|       |        /* free things */
  205|     78|        if ((name_funcs_stack != NULL)
  206|     78|            && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type)) {
  207|       |            /*
  208|       |             * XXX: I'm not sure I understand why the free function should
  209|       |             * get three arguments... -- Richard Levitte
  210|       |             */
  211|      0|            sk_NAME_FUNCS_value(name_funcs_stack,
  212|      0|                                ret->type)->free_func(ret->name, ret->type,
  213|      0|                                                      ret->data);
  214|      0|        }
  215|     78|        OPENSSL_free(ret);
  216|    291|    } else {
  217|    291|        if (lh_OBJ_NAME_error(names_lh)) {
  218|       |            /* ERROR */
  219|      0|            OPENSSL_free(onp);
  220|      0|            return 0;
  221|      0|        }
  222|    291|    }
  223|    369|    return 1;
  224|    369|}
o_names.c:obj_name_hash:
  134|    568|{
  135|    568|    unsigned long ret;
  136|    568|    const OBJ_NAME *a = (const OBJ_NAME *)a_void;
  137|       |
  138|    568|    if ((name_funcs_stack != NULL)
  139|    568|        && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {
  140|      0|        ret =
  141|      0|            sk_NAME_FUNCS_value(name_funcs_stack,
  142|      0|                                a->type)->hash_func(a->name);
  143|    568|    } else {
  144|    568|        ret = lh_strhash(a->name);
  145|    568|    }
  146|    568|    ret ^= a->type;
  147|    568|    return (ret);
  148|    568|}
o_names.c:obj_name_cmp:
  115|    277|{
  116|    277|    int ret;
  117|    277|    const OBJ_NAME *a = (const OBJ_NAME *)a_void;
  118|    277|    const OBJ_NAME *b = (const OBJ_NAME *)b_void;
  119|       |
  120|    277|    ret = a->type - b->type;
  121|    277|    if (ret == 0) {
  122|    277|        if ((name_funcs_stack != NULL)
  123|    277|            && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {
  124|      0|            ret = sk_NAME_FUNCS_value(name_funcs_stack,
  125|      0|                                      a->type)->cmp_func(a->name, b->name);
  126|      0|        } else
  127|    277|            ret = strcmp(a->name, b->name);
  128|    277|    }
  129|    277|    return (ret);
  130|    277|}

check_defer:
  229|    160|{
  230|    160|    if (!obj_cleanup_defer && nid >= NUM_NID)
  231|      0|        obj_cleanup_defer = 1;
  232|    160|}
OBJ_nid2obj:
  314|  83.2k|{
  315|  83.2k|    ADDED_OBJ ad, *adp;
  316|  83.2k|    ASN1_OBJECT ob;
  317|       |
  318|  83.2k|    if ((n >= 0) && (n < NUM_NID)) {
  319|  83.2k|        if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
  320|      0|            OBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);
  321|      0|            return (NULL);
  322|      0|        }
  323|  83.2k|        return ((ASN1_OBJECT *)&(nid_objs[n]));
  324|  83.2k|    } else if (added == NULL)
  325|      0|        return (NULL);
  326|      0|    else {
  327|      0|        ad.type = ADDED_NID;
  328|      0|        ad.obj = &ob;
  329|      0|        ob.nid = n;
  330|      0|        adp = lh_ADDED_OBJ_retrieve(added, &ad);
  331|      0|        if (adp != NULL)
  332|      0|            return (adp->obj);
  333|      0|        else {
  334|      0|            OBJerr(OBJ_F_OBJ_NID2OBJ, OBJ_R_UNKNOWN_NID);
  335|      0|            return (NULL);
  336|      0|        }
  337|      0|    }
  338|  83.2k|}
OBJ_nid2sn:
  341|  14.6k|{
  342|  14.6k|    ADDED_OBJ ad, *adp;
  343|  14.6k|    ASN1_OBJECT ob;
  344|       |
  345|  14.6k|    if ((n >= 0) && (n < NUM_NID)) {
  346|  14.6k|        if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
  347|      0|            OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
  348|      0|            return (NULL);
  349|      0|        }
  350|  14.6k|        return (nid_objs[n].sn);
  351|  14.6k|    } else if (added == NULL)
  352|      0|        return (NULL);
  353|      0|    else {
  354|      0|        ad.type = ADDED_NID;
  355|      0|        ad.obj = &ob;
  356|      0|        ob.nid = n;
  357|      0|        adp = lh_ADDED_OBJ_retrieve(added, &ad);
  358|      0|        if (adp != NULL)
  359|      0|            return (adp->obj->sn);
  360|      0|        else {
  361|      0|            OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
  362|      0|            return (NULL);
  363|      0|        }
  364|      0|    }
  365|  14.6k|}
OBJ_nid2ln:
  368|    160|{
  369|    160|    ADDED_OBJ ad, *adp;
  370|    160|    ASN1_OBJECT ob;
  371|       |
  372|    160|    if ((n >= 0) && (n < NUM_NID)) {
  373|    160|        if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
  374|      0|            OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
  375|      0|            return (NULL);
  376|      0|        }
  377|    160|        return (nid_objs[n].ln);
  378|    160|    } else if (added == NULL)
  379|      0|        return (NULL);
  380|      0|    else {
  381|      0|        ad.type = ADDED_NID;
  382|      0|        ad.obj = &ob;
  383|      0|        ob.nid = n;
  384|      0|        adp = lh_ADDED_OBJ_retrieve(added, &ad);
  385|      0|        if (adp != NULL)
  386|      0|            return (adp->obj->ln);
  387|      0|        else {
  388|      0|            OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
  389|      0|            return (NULL);
  390|      0|        }
  391|      0|    }
  392|    160|}
OBJ_obj2nid:
  411|  14.5k|{
  412|  14.5k|    const unsigned int *op;
  413|  14.5k|    ADDED_OBJ ad, *adp;
  414|       |
  415|  14.5k|    if (a == NULL)
  416|      0|        return (NID_undef);
  417|  14.5k|    if (a->nid != 0)
  418|      0|        return (a->nid);
  419|       |
  420|  14.5k|    if (a->length == 0)
  421|      0|        return NID_undef;
  422|       |
  423|  14.5k|    if (added != NULL) {
  424|      0|        ad.type = ADDED_DATA;
  425|      0|        ad.obj = (ASN1_OBJECT *)a; /* XXX: ugly but harmless */
  426|      0|        adp = lh_ADDED_OBJ_retrieve(added, &ad);
  427|      0|        if (adp != NULL)
  428|      0|            return (adp->obj->nid);
  429|      0|    }
  430|  14.5k|    op = OBJ_bsearch_obj(&a, obj_objs, NUM_OBJ);
  431|  14.5k|    if (op == NULL)
  432|     60|        return (NID_undef);
  433|  14.4k|    return (nid_objs[*op].nid);
  434|  14.5k|}
OBJ_obj2txt:
  486|     30|{
  487|     30|    int i, n = 0, len, nid, first, use_bn;
  488|     30|    BIGNUM *bl;
  489|     30|    unsigned long l;
  490|     30|    const unsigned char *p;
  491|     30|    char tbuf[DECIMAL_SIZE(i) + DECIMAL_SIZE(l) + 2];
  492|       |
  493|       |    /* Ensure that, at every state, |buf| is NUL-terminated. */
  494|     30|    if (buf && buf_len > 0)
  495|     30|        buf[0] = '\0';
  496|       |
  497|     30|    if ((a == NULL) || (a->data == NULL))
  498|      0|        return (0);
  499|       |
  500|     30|    if (!no_name && (nid = OBJ_obj2nid(a)) != NID_undef) {
  501|      0|        const char *s;
  502|      0|        s = OBJ_nid2ln(nid);
  503|      0|        if (s == NULL)
  504|      0|            s = OBJ_nid2sn(nid);
  505|      0|        if (s) {
  506|      0|            if (buf)
  507|      0|                BUF_strlcpy(buf, s, buf_len);
  508|      0|            n = strlen(s);
  509|      0|            return n;
  510|      0|        }
  511|      0|    }
  512|       |
  513|     30|    len = a->length;
  514|     30|    p = a->data;
  515|       |
  516|     30|    first = 1;
  517|     30|    bl = NULL;
  518|       |
  519|    120|    while (len > 0) {
  520|     90|        l = 0;
  521|     90|        use_bn = 0;
  522|     90|        for (;;) {
  523|     90|            unsigned char c = *p++;
  524|     90|            len--;
  525|     90|            if ((len == 0) && (c & 0x80))
  526|      0|                goto err;
  527|     90|            if (use_bn) {
  528|      0|                if (!BN_add_word(bl, c & 0x7f))
  529|      0|                    goto err;
  530|      0|            } else
  531|     90|                l |= c & 0x7f;
  532|     90|            if (!(c & 0x80))
  533|     90|                break;
  534|      0|            if (!use_bn && (l > (ULONG_MAX >> 7L))) {
  535|      0|                if (!bl && !(bl = BN_new()))
  536|      0|                    goto err;
  537|      0|                if (!BN_set_word(bl, l))
  538|      0|                    goto err;
  539|      0|                use_bn = 1;
  540|      0|            }
  541|      0|            if (use_bn) {
  542|      0|                if (!BN_lshift(bl, bl, 7))
  543|      0|                    goto err;
  544|      0|            } else
  545|      0|                l <<= 7L;
  546|      0|        }
  547|       |
  548|     90|        if (first) {
  549|     30|            first = 0;
  550|     30|            if (l >= 80) {
  551|     30|                i = 2;
  552|     30|                if (use_bn) {
  553|      0|                    if (!BN_sub_word(bl, 80))
  554|      0|                        goto err;
  555|      0|                } else
  556|     30|                    l -= 80;
  557|     30|            } else {
  558|      0|                i = (int)(l / 40);
  559|      0|                l -= (long)(i * 40);
  560|      0|            }
  561|     30|            if (buf && (buf_len > 1)) {
  562|     30|                *buf++ = i + '0';
  563|     30|                *buf = '\0';
  564|     30|                buf_len--;
  565|     30|            }
  566|     30|            n++;
  567|     30|        }
  568|       |
  569|     90|        if (use_bn) {
  570|      0|            char *bndec;
  571|      0|            bndec = BN_bn2dec(bl);
  572|      0|            if (!bndec)
  573|      0|                goto err;
  574|      0|            i = strlen(bndec);
  575|      0|            if (buf) {
  576|      0|                if (buf_len > 1) {
  577|      0|                    *buf++ = '.';
  578|      0|                    *buf = '\0';
  579|      0|                    buf_len--;
  580|      0|                }
  581|      0|                BUF_strlcpy(buf, bndec, buf_len);
  582|      0|                if (i > buf_len) {
  583|      0|                    buf += buf_len;
  584|      0|                    buf_len = 0;
  585|      0|                } else {
  586|      0|                    buf += i;
  587|      0|                    buf_len -= i;
  588|      0|                }
  589|      0|            }
  590|      0|            n++;
  591|      0|            n += i;
  592|      0|            OPENSSL_free(bndec);
  593|     90|        } else {
  594|     90|            BIO_snprintf(tbuf, sizeof tbuf, ".%lu", l);
  595|     90|            i = strlen(tbuf);
  596|     90|            if (buf && (buf_len > 0)) {
  597|     90|                BUF_strlcpy(buf, tbuf, buf_len);
  598|     90|                if (i > buf_len) {
  599|      0|                    buf += buf_len;
  600|      0|                    buf_len = 0;
  601|     90|                } else {
  602|     90|                    buf += i;
  603|     90|                    buf_len -= i;
  604|     90|                }
  605|     90|            }
  606|     90|            n += i;
  607|     90|            l = 0;
  608|     90|        }
  609|     90|    }
  610|       |
  611|     30|    if (bl)
  612|      0|        BN_free(bl);
  613|     30|    return n;
  614|       |
  615|      0| err:
  616|      0|    if (bl)
  617|      0|        BN_free(bl);
  618|      0|    return -1;
  619|     30|}
OBJ_bsearch_:
  675|  14.5k|{
  676|  14.5k|    return OBJ_bsearch_ex_(key, base, num, size, cmp, 0);
  677|  14.5k|}
OBJ_bsearch_ex_:
  683|  18.3k|{
  684|  18.3k|    const char *base = base_;
  685|  18.3k|    int l, h, i = 0, c = 0;
  686|  18.3k|    const char *p = NULL;
  687|       |
  688|  18.3k|    if (num == 0)
  689|     30|        return (NULL);
  690|  18.3k|    l = 0;
  691|  18.3k|    h = num;
  692|   158k|    while (l < h) {
  693|   154k|        i = (l + h) / 2;
  694|   154k|        p = &(base[i * size]);
  695|   154k|        c = (*cmp) (key, p);
  696|   154k|        if (c < 0)
  697|  96.9k|            h = i;
  698|  57.8k|        else if (c > 0)
  699|  43.4k|            l = i + 1;
  700|  14.4k|        else
  701|  14.4k|            break;
  702|   154k|    }
  703|       |#ifdef CHARSET_EBCDIC
  704|       |    /*
  705|       |     * THIS IS A KLUDGE - Because the *_obj is sorted in ASCII order, and I
  706|       |     * don't have perl (yet), we revert to a *LINEAR* search when the object
  707|       |     * wasn't found in the binary search.
  708|       |     */
  709|       |    if (c != 0) {
  710|       |        for (i = 0; i < num; ++i) {
  711|       |            p = &(base[i * size]);
  712|       |            c = (*cmp) (key, p);
  713|       |            if (c == 0 || (c < 0 && (flags & OBJ_BSEARCH_VALUE_ON_NOMATCH)))
  714|       |                return p;
  715|       |        }
  716|       |    }
  717|       |#endif
  718|  18.3k|    if (c != 0 && !(flags & OBJ_BSEARCH_VALUE_ON_NOMATCH))
  719|  3.87k|        p = NULL;
  720|  14.4k|    else if (c == 0 && (flags & OBJ_BSEARCH_FIRST_VALUE_ON_MATCH)) {
  721|      0|        while (i > 0 && (*cmp) (key, &(base[(i - 1) * size])) == 0)
  722|      0|            i--;
  723|      0|        p = &(base[i * size]);
  724|      0|    }
  725|  18.3k|    return (p);
  726|  18.3k|}
obj_dat.c:obj_cmp:
  395|   133k|{
  396|   133k|    int j;
  397|   133k|    const ASN1_OBJECT *a = *ap;
  398|   133k|    const ASN1_OBJECT *b = &nid_objs[*bp];
  399|       |
  400|   133k|    j = (a->length - b->length);
  401|   133k|    if (j)
  402|  50.7k|        return (j);
  403|  82.4k|    if (a->length == 0)
  404|      0|        return 0;
  405|  82.4k|    return (memcmp(a->data, b->data, a->length));
  406|  82.4k|}

ERR_load_OBJ_strings:
   92|      1|{
   93|      1|#ifndef OPENSSL_NO_ERR
   94|       |
   95|      1|    if (ERR_func_error_string(OBJ_str_functs[0].error) == NULL) {
   96|      1|        ERR_load_strings(0, OBJ_str_functs);
   97|      1|        ERR_load_strings(0, OBJ_str_reasons);
   98|      1|    }
   99|      1|#endif
  100|      1|}

OBJ_dup:
   66|  28.9k|{
   67|  28.9k|    ASN1_OBJECT *r;
   68|  28.9k|    int i;
   69|  28.9k|    char *ln = NULL, *sn = NULL;
   70|  28.9k|    unsigned char *data = NULL;
   71|       |
   72|  28.9k|    if (o == NULL)
   73|      0|        return (NULL);
   74|  28.9k|    if (!(o->flags & ASN1_OBJECT_FLAG_DYNAMIC))
   75|      0|        return ((ASN1_OBJECT *)o); /* XXX: ugh! Why? What kind of duplication
   76|       |                                    * is this??? */
   77|       |
   78|  28.9k|    r = ASN1_OBJECT_new();
   79|  28.9k|    if (r == NULL) {
   80|      0|        OBJerr(OBJ_F_OBJ_DUP, ERR_R_ASN1_LIB);
   81|      0|        return (NULL);
   82|      0|    }
   83|  28.9k|    data = OPENSSL_malloc(o->length);
   84|  28.9k|    if (data == NULL)
   85|      0|        goto err;
   86|  28.9k|    if (o->data != NULL)
   87|  28.9k|        memcpy(data, o->data, o->length);
   88|       |    /* once data attached to object it remains const */
   89|  28.9k|    r->data = data;
   90|  28.9k|    r->length = o->length;
   91|  28.9k|    r->nid = o->nid;
   92|  28.9k|    r->ln = r->sn = NULL;
   93|  28.9k|    if (o->ln != NULL) {
   94|      0|        i = strlen(o->ln) + 1;
   95|      0|        ln = OPENSSL_malloc(i);
   96|      0|        if (ln == NULL)
   97|      0|            goto err;
   98|      0|        memcpy(ln, o->ln, i);
   99|      0|        r->ln = ln;
  100|      0|    }
  101|       |
  102|  28.9k|    if (o->sn != NULL) {
  103|      0|        i = strlen(o->sn) + 1;
  104|      0|        sn = OPENSSL_malloc(i);
  105|      0|        if (sn == NULL)
  106|      0|            goto err;
  107|      0|        memcpy(sn, o->sn, i);
  108|      0|        r->sn = sn;
  109|      0|    }
  110|  28.9k|    r->flags = o->flags | (ASN1_OBJECT_FLAG_DYNAMIC |
  111|  28.9k|                           ASN1_OBJECT_FLAG_DYNAMIC_STRINGS |
  112|  28.9k|                           ASN1_OBJECT_FLAG_DYNAMIC_DATA);
  113|  28.9k|    return (r);
  114|      0| err:
  115|      0|    OBJerr(OBJ_F_OBJ_DUP, ERR_R_MALLOC_FAILURE);
  116|      0|    if (ln != NULL)
  117|      0|        OPENSSL_free(ln);
  118|      0|    if (sn != NULL)
  119|      0|        OPENSSL_free(sn);
  120|      0|    if (data != NULL)
  121|      0|        OPENSSL_free(data);
  122|      0|    if (r != NULL)
  123|      0|        OPENSSL_free(r);
  124|      0|    return (NULL);
  125|  28.9k|}

ERR_load_OCSP_strings:
  141|      1|{
  142|      1|#ifndef OPENSSL_NO_ERR
  143|       |
  144|      1|    if (ERR_func_error_string(OCSP_str_functs[0].error) == NULL) {
  145|      1|        ERR_load_strings(0, OCSP_str_functs);
  146|      1|        ERR_load_strings(0, OCSP_str_reasons);
  147|      1|    }
  148|      1|#endif
  149|      1|}

ERR_load_PEM_strings:
  161|      1|{
  162|      1|#ifndef OPENSSL_NO_ERR
  163|       |
  164|      1|    if (ERR_func_error_string(PEM_str_functs[0].error) == NULL) {
  165|      1|        ERR_load_strings(0, PEM_str_functs);
  166|      1|        ERR_load_strings(0, PEM_str_reasons);
  167|      1|    }
  168|      1|#endif
  169|      1|}

PEM_X509_INFO_read_bio:
   93|     30|{
   94|     30|    X509_INFO *xi = NULL;
   95|     30|    char *name = NULL, *header = NULL;
   96|     30|    void *pp;
   97|     30|    unsigned char *data = NULL;
   98|     30|    const unsigned char *p;
   99|     30|    long len, error = 0;
  100|     30|    int ok = 0;
  101|     30|    STACK_OF(X509_INFO) *ret = NULL;
  102|     30|    unsigned int i, raw, ptype;
  103|     30|    d2i_of_void *d2i = 0;
  104|       |
  105|     30|    if (sk == NULL) {
  106|     30|        if ((ret = sk_X509_INFO_new_null()) == NULL) {
  107|      0|            PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_MALLOC_FAILURE);
  108|      0|            goto err;
  109|      0|        }
  110|     30|    } else
  111|      0|        ret = sk;
  112|       |
  113|     30|    if ((xi = X509_INFO_new()) == NULL)
  114|      0|        goto err;
  115|  3.87k|    for (;;) {
  116|  3.87k|        raw = 0;
  117|  3.87k|        ptype = 0;
  118|  3.87k|        i = PEM_read_bio(bp, &name, &header, &data, &len);
  119|  3.87k|        if (i == 0) {
  120|     30|            error = ERR_GET_REASON(ERR_peek_last_error());
  121|     30|            if (error == PEM_R_NO_START_LINE) {
  122|     30|                ERR_clear_error();
  123|     30|                break;
  124|     30|            }
  125|      0|            goto err;
  126|     30|        }
  127|  7.65k| start:
  128|  7.65k|        if ((strcmp(name, PEM_STRING_X509) == 0) ||
  129|  7.65k|            (strcmp(name, PEM_STRING_X509_OLD) == 0)) {
  130|  7.65k|            d2i = (D2I_OF(void)) d2i_X509;
  131|  7.65k|            if (xi->x509 != NULL) {
  132|  3.81k|                if (!sk_X509_INFO_push(ret, xi))
  133|      0|                    goto err;
  134|  3.81k|                if ((xi = X509_INFO_new()) == NULL)
  135|      0|                    goto err;
  136|  3.81k|                goto start;
  137|  3.81k|            }
  138|  3.84k|            pp = &(xi->x509);
  139|  3.84k|        } else if ((strcmp(name, PEM_STRING_X509_TRUSTED) == 0)) {
  140|      0|            d2i = (D2I_OF(void)) d2i_X509_AUX;
  141|      0|            if (xi->x509 != NULL) {
  142|      0|                if (!sk_X509_INFO_push(ret, xi))
  143|      0|                    goto err;
  144|      0|                if ((xi = X509_INFO_new()) == NULL)
  145|      0|                    goto err;
  146|      0|                goto start;
  147|      0|            }
  148|      0|            pp = &(xi->x509);
  149|      0|        } else if (strcmp(name, PEM_STRING_X509_CRL) == 0) {
  150|      0|            d2i = (D2I_OF(void)) d2i_X509_CRL;
  151|      0|            if (xi->crl != NULL) {
  152|      0|                if (!sk_X509_INFO_push(ret, xi))
  153|      0|                    goto err;
  154|      0|                if ((xi = X509_INFO_new()) == NULL)
  155|      0|                    goto err;
  156|      0|                goto start;
  157|      0|            }
  158|      0|            pp = &(xi->crl);
  159|      0|        } else
  160|      0|#ifndef OPENSSL_NO_RSA
  161|      0|        if (strcmp(name, PEM_STRING_RSA) == 0) {
  162|      0|            d2i = (D2I_OF(void)) d2i_RSAPrivateKey;
  163|      0|            if (xi->x_pkey != NULL) {
  164|      0|                if (!sk_X509_INFO_push(ret, xi))
  165|      0|                    goto err;
  166|      0|                if ((xi = X509_INFO_new()) == NULL)
  167|      0|                    goto err;
  168|      0|                goto start;
  169|      0|            }
  170|       |
  171|      0|            xi->enc_data = NULL;
  172|      0|            xi->enc_len = 0;
  173|       |
  174|      0|            xi->x_pkey = X509_PKEY_new();
  175|      0|            if (xi->x_pkey == NULL)
  176|      0|                goto err;
  177|      0|            ptype = EVP_PKEY_RSA;
  178|      0|            pp = &xi->x_pkey->dec_pkey;
  179|      0|            if ((int)strlen(header) > 10) /* assume encrypted */
  180|      0|                raw = 1;
  181|      0|        } else
  182|      0|#endif
  183|      0|#ifndef OPENSSL_NO_DSA
  184|      0|        if (strcmp(name, PEM_STRING_DSA) == 0) {
  185|      0|            d2i = (D2I_OF(void)) d2i_DSAPrivateKey;
  186|      0|            if (xi->x_pkey != NULL) {
  187|      0|                if (!sk_X509_INFO_push(ret, xi))
  188|      0|                    goto err;
  189|      0|                if ((xi = X509_INFO_new()) == NULL)
  190|      0|                    goto err;
  191|      0|                goto start;
  192|      0|            }
  193|       |
  194|      0|            xi->enc_data = NULL;
  195|      0|            xi->enc_len = 0;
  196|       |
  197|      0|            xi->x_pkey = X509_PKEY_new();
  198|      0|            if (xi->x_pkey == NULL)
  199|      0|                goto err;
  200|      0|            ptype = EVP_PKEY_DSA;
  201|      0|            pp = &xi->x_pkey->dec_pkey;
  202|      0|            if ((int)strlen(header) > 10) /* assume encrypted */
  203|      0|                raw = 1;
  204|      0|        } else
  205|      0|#endif
  206|      0|#ifndef OPENSSL_NO_EC
  207|      0|        if (strcmp(name, PEM_STRING_ECPRIVATEKEY) == 0) {
  208|      0|            d2i = (D2I_OF(void)) d2i_ECPrivateKey;
  209|      0|            if (xi->x_pkey != NULL) {
  210|      0|                if (!sk_X509_INFO_push(ret, xi))
  211|      0|                    goto err;
  212|      0|                if ((xi = X509_INFO_new()) == NULL)
  213|      0|                    goto err;
  214|      0|                goto start;
  215|      0|            }
  216|       |
  217|      0|            xi->enc_data = NULL;
  218|      0|            xi->enc_len = 0;
  219|       |
  220|      0|            xi->x_pkey = X509_PKEY_new();
  221|      0|            if (xi->x_pkey == NULL)
  222|      0|                goto err;
  223|      0|            ptype = EVP_PKEY_EC;
  224|      0|            pp = &xi->x_pkey->dec_pkey;
  225|      0|            if ((int)strlen(header) > 10) /* assume encrypted */
  226|      0|                raw = 1;
  227|      0|        } else
  228|      0|#endif
  229|      0|        {
  230|      0|            d2i = NULL;
  231|      0|            pp = NULL;
  232|      0|        }
  233|       |
  234|  3.84k|        if (d2i != NULL) {
  235|  3.84k|            if (!raw) {
  236|  3.84k|                EVP_CIPHER_INFO cipher;
  237|       |
  238|  3.84k|                if (!PEM_get_EVP_CIPHER_INFO(header, &cipher))
  239|      0|                    goto err;
  240|  3.84k|                if (!PEM_do_header(&cipher, data, &len, cb, u))
  241|      0|                    goto err;
  242|  3.84k|                p = data;
  243|  3.84k|                if (ptype) {
  244|      0|                    if (!d2i_PrivateKey(ptype, pp, &p, len)) {
  245|      0|                        PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
  246|      0|                        goto err;
  247|      0|                    }
  248|  3.84k|                } else if (d2i(pp, &p, len) == NULL) {
  249|      0|                    PEMerr(PEM_F_PEM_X509_INFO_READ_BIO, ERR_R_ASN1_LIB);
  250|      0|                    goto err;
  251|      0|                }
  252|  3.84k|            } else {            /* encrypted RSA data */
  253|      0|                if (!PEM_get_EVP_CIPHER_INFO(header, &xi->enc_cipher))
  254|      0|                    goto err;
  255|      0|                xi->enc_data = (char *)data;
  256|      0|                xi->enc_len = (int)len;
  257|      0|                data = NULL;
  258|      0|            }
  259|  3.84k|        } else {
  260|       |            /* unknown */
  261|      0|        }
  262|  3.84k|        if (name != NULL)
  263|  3.84k|            OPENSSL_free(name);
  264|  3.84k|        if (header != NULL)
  265|  3.84k|            OPENSSL_free(header);
  266|  3.84k|        if (data != NULL)
  267|  3.84k|            OPENSSL_free(data);
  268|  3.84k|        name = NULL;
  269|  3.84k|        header = NULL;
  270|  3.84k|        data = NULL;
  271|  3.84k|    }
  272|       |
  273|       |    /*
  274|       |     * if the last one hasn't been pushed yet and there is anything in it
  275|       |     * then add it to the stack ...
  276|       |     */
  277|     30|    if ((xi->x509 != NULL) || (xi->crl != NULL) ||
  278|     30|        (xi->x_pkey != NULL) || (xi->enc_data != NULL)) {
  279|     30|        if (!sk_X509_INFO_push(ret, xi))
  280|      0|            goto err;
  281|     30|        xi = NULL;
  282|     30|    }
  283|     30|    ok = 1;
  284|     30| err:
  285|     30|    if (xi != NULL)
  286|      0|        X509_INFO_free(xi);
  287|     30|    if (!ok) {
  288|      0|        for (i = 0; ((int)i) < sk_X509_INFO_num(ret); i++) {
  289|      0|            xi = sk_X509_INFO_value(ret, i);
  290|      0|            X509_INFO_free(xi);
  291|      0|        }
  292|      0|        if (ret != sk)
  293|      0|            sk_X509_INFO_free(ret);
  294|      0|        ret = NULL;
  295|      0|    }
  296|       |
  297|     30|    if (name != NULL)
  298|      0|        OPENSSL_free(name);
  299|     30|    if (header != NULL)
  300|      0|        OPENSSL_free(header);
  301|     30|    if (data != NULL)
  302|      0|        OPENSSL_free(data);
  303|     30|    return (ret);
  304|     30|}

PEM_do_header:
  447|  3.84k|{
  448|  3.84k|    int i = 0, j, o, klen;
  449|  3.84k|    long len;
  450|  3.84k|    EVP_CIPHER_CTX ctx;
  451|  3.84k|    unsigned char key[EVP_MAX_KEY_LENGTH];
  452|  3.84k|    char buf[PEM_BUFSIZE];
  453|       |
  454|  3.84k|    len = *plen;
  455|       |
  456|  3.84k|    if (cipher->cipher == NULL)
  457|  3.84k|        return (1);
  458|      0|    if (callback == NULL)
  459|      0|        klen = PEM_def_callback(buf, PEM_BUFSIZE, 0, u);
  460|      0|    else
  461|      0|        klen = callback(buf, PEM_BUFSIZE, 0, u);
  462|      0|    if (klen <= 0) {
  463|      0|        PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_PASSWORD_READ);
  464|      0|        return (0);
  465|      0|    }
  466|       |#ifdef CHARSET_EBCDIC
  467|       |    /* Convert the pass phrase from EBCDIC */
  468|       |    ebcdic2ascii(buf, buf, klen);
  469|       |#endif
  470|       |
  471|      0|    if (!EVP_BytesToKey(cipher->cipher, EVP_md5(), &(cipher->iv[0]),
  472|      0|                        (unsigned char *)buf, klen, 1, key, NULL))
  473|      0|        return 0;
  474|       |
  475|      0|    j = (int)len;
  476|      0|    EVP_CIPHER_CTX_init(&ctx);
  477|      0|    o = EVP_DecryptInit_ex(&ctx, cipher->cipher, NULL, key, &(cipher->iv[0]));
  478|      0|    if (o)
  479|      0|        o = EVP_DecryptUpdate(&ctx, data, &i, data, j);
  480|      0|    if (o)
  481|      0|        o = EVP_DecryptFinal_ex(&ctx, &(data[i]), &j);
  482|      0|    EVP_CIPHER_CTX_cleanup(&ctx);
  483|      0|    OPENSSL_cleanse((char *)buf, sizeof(buf));
  484|      0|    OPENSSL_cleanse((char *)key, sizeof(key));
  485|      0|    if (o)
  486|      0|        j += i;
  487|      0|    else {
  488|      0|        PEMerr(PEM_F_PEM_DO_HEADER, PEM_R_BAD_DECRYPT);
  489|      0|        return (0);
  490|      0|    }
  491|      0|    *plen = j;
  492|      0|    return (1);
  493|      0|}
PEM_get_EVP_CIPHER_INFO:
  496|  3.84k|{
  497|  3.84k|    const EVP_CIPHER *enc = NULL;
  498|  3.84k|    char *p, c;
  499|  3.84k|    char **header_pp = &header;
  500|       |
  501|  3.84k|    cipher->cipher = NULL;
  502|  3.84k|    if ((header == NULL) || (*header == '\0') || (*header == '\n'))
  503|  3.84k|        return (1);
  504|      0|    if (strncmp(header, "Proc-Type: ", 11) != 0) {
  505|      0|        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_PROC_TYPE);
  506|      0|        return (0);
  507|      0|    }
  508|      0|    header += 11;
  509|      0|    if (*header != '4')
  510|      0|        return (0);
  511|      0|    header++;
  512|      0|    if (*header != ',')
  513|      0|        return (0);
  514|      0|    header++;
  515|      0|    if (strncmp(header, "ENCRYPTED", 9) != 0) {
  516|      0|        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_ENCRYPTED);
  517|      0|        return (0);
  518|      0|    }
  519|      0|    for (; (*header != '\n') && (*header != '\0'); header++) ;
  520|      0|    if (*header == '\0') {
  521|      0|        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_SHORT_HEADER);
  522|      0|        return (0);
  523|      0|    }
  524|      0|    header++;
  525|      0|    if (strncmp(header, "DEK-Info: ", 10) != 0) {
  526|      0|        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_NOT_DEK_INFO);
  527|      0|        return (0);
  528|      0|    }
  529|      0|    header += 10;
  530|       |
  531|      0|    p = header;
  532|      0|    for (;;) {
  533|      0|        c = *header;
  534|      0|#ifndef CHARSET_EBCDIC
  535|      0|        if (!(((c >= 'A') && (c <= 'Z')) || (c == '-') ||
  536|      0|              ((c >= '0') && (c <= '9'))))
  537|      0|            break;
  538|       |#else
  539|       |        if (!(isupper((unsigned char)c) || (c == '-')
  540|       |            || isdigit((unsigned char)c)))
  541|       |            break;
  542|       |#endif
  543|      0|        header++;
  544|      0|    }
  545|      0|    *header = '\0';
  546|      0|    cipher->cipher = enc = EVP_get_cipherbyname(p);
  547|      0|    *header = c;
  548|      0|    header++;
  549|       |
  550|      0|    if (enc == NULL) {
  551|      0|        PEMerr(PEM_F_PEM_GET_EVP_CIPHER_INFO, PEM_R_UNSUPPORTED_ENCRYPTION);
  552|      0|        return (0);
  553|      0|    }
  554|      0|    if (!load_iv(header_pp, &(cipher->iv[0]), enc->iv_len))
  555|      0|        return (0);
  556|       |
  557|      0|    return (1);
  558|      0|}
PEM_read_bio:
  684|  3.87k|{
  685|  3.87k|    EVP_ENCODE_CTX ctx;
  686|  3.87k|    int end = 0, i, k, bl = 0, hl = 0, nohead = 0;
  687|  3.87k|    char buf[256];
  688|  3.87k|    BUF_MEM *nameB;
  689|  3.87k|    BUF_MEM *headerB;
  690|  3.87k|    BUF_MEM *dataB, *tmpB;
  691|       |
  692|  3.87k|    nameB = BUF_MEM_new();
  693|  3.87k|    headerB = BUF_MEM_new();
  694|  3.87k|    dataB = BUF_MEM_new();
  695|  3.87k|    if ((nameB == NULL) || (headerB == NULL) || (dataB == NULL)) {
  696|      0|        BUF_MEM_free(nameB);
  697|      0|        BUF_MEM_free(headerB);
  698|      0|        BUF_MEM_free(dataB);
  699|      0|        PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
  700|      0|        return (0);
  701|      0|    }
  702|       |
  703|  3.87k|    buf[254] = '\0';
  704|  3.87k|    for (;;) {
  705|  3.87k|        i = BIO_gets(bp, buf, 254);
  706|       |
  707|  3.87k|        if (i <= 0) {
  708|     30|            PEMerr(PEM_F_PEM_READ_BIO, PEM_R_NO_START_LINE);
  709|     30|            goto err;
  710|     30|        }
  711|       |
  712|  11.5k|        while ((i >= 0) && (buf[i] <= ' '))
  713|  7.68k|            i--;
  714|  3.84k|        buf[++i] = '\n';
  715|  3.84k|        buf[++i] = '\0';
  716|       |
  717|  3.84k|        if (strncmp(buf, "-----BEGIN ", 11) == 0) {
  718|  3.84k|            i = strlen(&(buf[11]));
  719|       |
  720|  3.84k|            if (strncmp(&(buf[11 + i - 6]), "-----\n", 6) != 0)
  721|      0|                continue;
  722|  3.84k|            if (!BUF_MEM_grow(nameB, i + 9)) {
  723|      0|                PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
  724|      0|                goto err;
  725|      0|            }
  726|  3.84k|            memcpy(nameB->data, &(buf[11]), i - 6);
  727|  3.84k|            nameB->data[i - 6] = '\0';
  728|  3.84k|            break;
  729|  3.84k|        }
  730|  3.84k|    }
  731|  3.84k|    hl = 0;
  732|  3.84k|    if (!BUF_MEM_grow(headerB, 256)) {
  733|      0|        PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
  734|      0|        goto err;
  735|      0|    }
  736|  3.84k|    headerB->data[0] = '\0';
  737|  94.3k|    for (;;) {
  738|  94.3k|        i = BIO_gets(bp, buf, 254);
  739|  94.3k|        if (i <= 0)
  740|      0|            break;
  741|       |
  742|   283k|        while ((i >= 0) && (buf[i] <= ' '))
  743|   188k|            i--;
  744|  94.3k|        buf[++i] = '\n';
  745|  94.3k|        buf[++i] = '\0';
  746|       |
  747|  94.3k|        if (buf[0] == '\n')
  748|      0|            break;
  749|  94.3k|        if (!BUF_MEM_grow(headerB, hl + i + 9)) {
  750|      0|            PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
  751|      0|            goto err;
  752|      0|        }
  753|  94.3k|        if (strncmp(buf, "-----END ", 9) == 0) {
  754|  3.84k|            nohead = 1;
  755|  3.84k|            break;
  756|  3.84k|        }
  757|  90.5k|        memcpy(&(headerB->data[hl]), buf, i);
  758|  90.5k|        headerB->data[hl + i] = '\0';
  759|  90.5k|        hl += i;
  760|  90.5k|    }
  761|       |
  762|  3.84k|    bl = 0;
  763|  3.84k|    if (!BUF_MEM_grow(dataB, 1024)) {
  764|      0|        PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
  765|      0|        goto err;
  766|      0|    }
  767|  3.84k|    dataB->data[0] = '\0';
  768|  3.84k|    if (!nohead) {
  769|      0|        for (;;) {
  770|      0|            i = BIO_gets(bp, buf, 254);
  771|      0|            if (i <= 0)
  772|      0|                break;
  773|       |
  774|      0|            while ((i >= 0) && (buf[i] <= ' '))
  775|      0|                i--;
  776|      0|            buf[++i] = '\n';
  777|      0|            buf[++i] = '\0';
  778|       |
  779|      0|            if (i != 65)
  780|      0|                end = 1;
  781|      0|            if (strncmp(buf, "-----END ", 9) == 0)
  782|      0|                break;
  783|      0|            if (i > 65)
  784|      0|                break;
  785|      0|            if (!BUF_MEM_grow_clean(dataB, i + bl + 9)) {
  786|      0|                PEMerr(PEM_F_PEM_READ_BIO, ERR_R_MALLOC_FAILURE);
  787|      0|                goto err;
  788|      0|            }
  789|      0|            memcpy(&(dataB->data[bl]), buf, i);
  790|      0|            dataB->data[bl + i] = '\0';
  791|      0|            bl += i;
  792|      0|            if (end) {
  793|      0|                buf[0] = '\0';
  794|      0|                i = BIO_gets(bp, buf, 254);
  795|      0|                if (i <= 0)
  796|      0|                    break;
  797|       |
  798|      0|                while ((i >= 0) && (buf[i] <= ' '))
  799|      0|                    i--;
  800|      0|                buf[++i] = '\n';
  801|      0|                buf[++i] = '\0';
  802|       |
  803|      0|                break;
  804|      0|            }
  805|      0|        }
  806|  3.84k|    } else {
  807|  3.84k|        tmpB = headerB;
  808|  3.84k|        headerB = dataB;
  809|  3.84k|        dataB = tmpB;
  810|  3.84k|        bl = hl;
  811|  3.84k|    }
  812|  3.84k|    i = strlen(nameB->data);
  813|  3.84k|    if ((strncmp(buf, "-----END ", 9) != 0) ||
  814|  3.84k|        (strncmp(nameB->data, &(buf[9]), i) != 0) ||
  815|  3.84k|        (strncmp(&(buf[9 + i]), "-----\n", 6) != 0)) {
  816|      0|        PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_END_LINE);
  817|      0|        goto err;
  818|      0|    }
  819|       |
  820|  3.84k|    EVP_DecodeInit(&ctx);
  821|  3.84k|    i = EVP_DecodeUpdate(&ctx,
  822|  3.84k|                         (unsigned char *)dataB->data, &bl,
  823|  3.84k|                         (unsigned char *)dataB->data, bl);
  824|  3.84k|    if (i < 0) {
  825|      0|        PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
  826|      0|        goto err;
  827|      0|    }
  828|  3.84k|    i = EVP_DecodeFinal(&ctx, (unsigned char *)&(dataB->data[bl]), &k);
  829|  3.84k|    if (i < 0) {
  830|      0|        PEMerr(PEM_F_PEM_READ_BIO, PEM_R_BAD_BASE64_DECODE);
  831|      0|        goto err;
  832|      0|    }
  833|  3.84k|    bl += k;
  834|       |
  835|  3.84k|    if (bl == 0)
  836|      0|        goto err;
  837|  3.84k|    *name = nameB->data;
  838|  3.84k|    *header = headerB->data;
  839|  3.84k|    *data = (unsigned char *)dataB->data;
  840|  3.84k|    *len = bl;
  841|  3.84k|    OPENSSL_free(nameB);
  842|  3.84k|    OPENSSL_free(headerB);
  843|  3.84k|    OPENSSL_free(dataB);
  844|  3.84k|    return (1);
  845|     30| err:
  846|     30|    BUF_MEM_free(nameB);
  847|     30|    BUF_MEM_free(headerB);
  848|     30|    BUF_MEM_free(dataB);
  849|     30|    return (0);
  850|  3.84k|}

ERR_load_PKCS12_strings:
  141|      1|{
  142|      1|#ifndef OPENSSL_NO_ERR
  143|       |
  144|      1|    if (ERR_func_error_string(PKCS12_str_functs[0].error) == NULL) {
  145|      1|        ERR_load_strings(0, PKCS12_str_functs);
  146|      1|        ERR_load_strings(0, PKCS12_str_reasons);
  147|      1|    }
  148|      1|#endif
  149|      1|}

ERR_load_PKCS7_strings:
  199|      1|{
  200|      1|#ifndef OPENSSL_NO_ERR
  201|       |
  202|      1|    if (ERR_func_error_string(PKCS7_str_functs[0].error) == NULL) {
  203|      1|        ERR_load_strings(0, PKCS7_str_functs);
  204|      1|        ERR_load_strings(0, PKCS7_str_reasons);
  205|      1|    }
  206|      1|#endif
  207|      1|}

RAND_SSLeay:
  177|      1|{
  178|      1|    return (&rand_ssleay_meth);
  179|      1|}
ssleay_rand_bytes:
  344|  3.96k|{
  345|  3.96k|    static volatile int stirred_pool = 0;
  346|  3.96k|    int i, j, k;
  347|  3.96k|    size_t num_ceil, st_idx, st_num;
  348|  3.96k|    int ok;
  349|  3.96k|    long md_c[2];
  350|  3.96k|    unsigned char local_md[MD_DIGEST_LENGTH];
  351|  3.96k|    EVP_MD_CTX m;
  352|  3.96k|#ifndef GETPID_IS_MEANINGLESS
  353|  3.96k|    pid_t curr_pid = getpid();
  354|  3.96k|#endif
  355|  3.96k|    int do_stir_pool = 0;
  356|       |
  357|       |#ifdef PREDICT
  358|       |    if (rand_predictable) {
  359|       |        static unsigned char val = 0;
  360|       |
  361|       |        for (i = 0; i < num; i++)
  362|       |            buf[i] = val++;
  363|       |        return (1);
  364|       |    }
  365|       |#endif
  366|       |
  367|  3.96k|    if (num <= 0)
  368|      0|        return 1;
  369|       |
  370|  3.96k|    EVP_MD_CTX_init(&m);
  371|       |    /* round upwards to multiple of MD_DIGEST_LENGTH/2 */
  372|  3.96k|    num_ceil =
  373|  3.96k|        (1 + (num - 1) / (MD_DIGEST_LENGTH / 2)) * (MD_DIGEST_LENGTH / 2);
  374|       |
  375|       |    /*
  376|       |     * (Based on the rand(3) manpage:)
  377|       |     *
  378|       |     * For each group of 10 bytes (or less), we do the following:
  379|       |     *
  380|       |     * Input into the hash function the local 'md' (which is initialized from
  381|       |     * the global 'md' before any bytes are generated), the bytes that are to
  382|       |     * be overwritten by the random bytes, and bytes from the 'state'
  383|       |     * (incrementing looping index). From this digest output (which is kept
  384|       |     * in 'md'), the top (up to) 10 bytes are returned to the caller and the
  385|       |     * bottom 10 bytes are xored into the 'state'.
  386|       |     *
  387|       |     * Finally, after we have finished 'num' random bytes for the
  388|       |     * caller, 'count' (which is incremented) and the local and global 'md'
  389|       |     * are fed into the hash function and the results are kept in the
  390|       |     * global 'md'.
  391|       |     */
  392|  3.96k|    if (lock)
  393|  3.96k|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  394|       |
  395|       |    /* prevent ssleay_rand_bytes() from trying to obtain the lock again */
  396|  3.96k|    CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
  397|  3.96k|    CRYPTO_THREADID_current(&locking_threadid);
  398|  3.96k|    CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
  399|  3.96k|    crypto_lock_rand = 1;
  400|       |
  401|  3.96k|    if (!initialized) {
  402|      0|        RAND_poll();
  403|      0|        initialized = 1;
  404|      0|    }
  405|       |
  406|  3.96k|    if (!stirred_pool)
  407|      1|        do_stir_pool = 1;
  408|       |
  409|  3.96k|    ok = (entropy >= ENTROPY_NEEDED);
  410|  3.96k|    if (!ok) {
  411|       |        /*
  412|       |         * If the PRNG state is not yet unpredictable, then seeing the PRNG
  413|       |         * output may help attackers to determine the new state; thus we have
  414|       |         * to decrease the entropy estimate. Once we've had enough initial
  415|       |         * seeding we don't bother to adjust the entropy count, though,
  416|       |         * because we're not ambitious to provide *information-theoretic*
  417|       |         * randomness. NOTE: This approach fails if the program forks before
  418|       |         * we have enough entropy. Entropy should be collected in a separate
  419|       |         * input pool and be transferred to the output pool only when the
  420|       |         * entropy limit has been reached.
  421|       |         */
  422|      0|        entropy -= num;
  423|      0|        if (entropy < 0)
  424|      0|            entropy = 0;
  425|      0|    }
  426|       |
  427|  3.96k|    if (do_stir_pool) {
  428|       |        /*
  429|       |         * In the output function only half of 'md' remains secret, so we
  430|       |         * better make sure that the required entropy gets 'evenly
  431|       |         * distributed' through 'state', our randomness pool. The input
  432|       |         * function (ssleay_rand_add) chains all of 'md', which makes it more
  433|       |         * suitable for this purpose.
  434|       |         */
  435|       |
  436|      1|        int n = STATE_SIZE;     /* so that the complete pool gets accessed */
  437|     53|        while (n > 0) {
  438|       |#if MD_DIGEST_LENGTH > 20
  439|       |# error "Please adjust DUMMY_SEED."
  440|       |#endif
  441|     52|#define DUMMY_SEED "...................." /* at least MD_DIGEST_LENGTH */
  442|       |            /*
  443|       |             * Note that the seed does not matter, it's just that
  444|       |             * ssleay_rand_add expects to have something to hash.
  445|       |             */
  446|     52|            ssleay_rand_add(DUMMY_SEED, MD_DIGEST_LENGTH, 0.0);
  447|     52|            n -= MD_DIGEST_LENGTH;
  448|     52|        }
  449|      1|        if (ok)
  450|      1|            stirred_pool = 1;
  451|      1|    }
  452|       |
  453|  3.96k|    st_idx = state_index;
  454|  3.96k|    st_num = state_num;
  455|  3.96k|    md_c[0] = md_count[0];
  456|  3.96k|    md_c[1] = md_count[1];
  457|  3.96k|    memcpy(local_md, md, sizeof md);
  458|       |
  459|  3.96k|    state_index += num_ceil;
  460|  3.96k|    if (state_index > state_num)
  461|     41|        state_index %= state_num;
  462|       |
  463|       |    /*
  464|       |     * state[st_idx], ..., state[(st_idx + num_ceil - 1) % st_num] are now
  465|       |     * ours (but other threads may use them too)
  466|       |     */
  467|       |
  468|  3.96k|    md_count[0] += 1;
  469|       |
  470|       |    /* before unlocking, we must clear 'crypto_lock_rand' */
  471|  3.96k|    crypto_lock_rand = 0;
  472|  3.96k|    if (lock)
  473|  3.96k|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  474|       |
  475|  8.10k|    while (num > 0) {
  476|       |        /* num_ceil -= MD_DIGEST_LENGTH/2 */
  477|  4.14k|        j = (num >= MD_DIGEST_LENGTH / 2) ? MD_DIGEST_LENGTH / 2 : num;
  478|  4.14k|        num -= j;
  479|  4.14k|        if (!MD_Init(&m))
  480|      0|           goto err;
  481|  4.14k|#ifndef GETPID_IS_MEANINGLESS
  482|  4.14k|        if (curr_pid) {         /* just in the first iteration to save time */
  483|  3.96k|            if (!MD_Update(&m, (unsigned char *)&curr_pid, sizeof curr_pid))
  484|      0|                goto err;
  485|  3.96k|            curr_pid = 0;
  486|  3.96k|        }
  487|  4.14k|#endif
  488|  4.14k|        if (!MD_Update(&m, local_md, MD_DIGEST_LENGTH) ||
  489|  4.14k|            !MD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c)))
  490|      0|            goto err;
  491|       |
  492|  4.14k|#ifndef PURIFY                  /* purify complains */
  493|       |        /*
  494|       |         * The following line uses the supplied buffer as a small source of
  495|       |         * entropy: since this buffer is often uninitialised it may cause
  496|       |         * programs such as purify or valgrind to complain. So for those
  497|       |         * builds it is not used: the removal of such a small source of
  498|       |         * entropy has negligible impact on security.
  499|       |         */
  500|  4.14k|        if (!MD_Update(&m, buf, j))
  501|      0|            goto err;
  502|  4.14k|#endif
  503|       |
  504|  4.14k|        k = (st_idx + MD_DIGEST_LENGTH / 2) - st_num;
  505|  4.14k|        if (k > 0) {
  506|     41|            if (!MD_Update(&m, &(state[st_idx]), MD_DIGEST_LENGTH / 2 - k) ||
  507|     41|                !MD_Update(&m, &(state[0]), k))
  508|      0|                goto err;
  509|  4.10k|        } else {
  510|  4.10k|            if (!MD_Update(&m, &(state[st_idx]), MD_DIGEST_LENGTH / 2))
  511|      0|                goto err;
  512|  4.10k|        }
  513|  4.14k|        if (!MD_Final(&m, local_md))
  514|      0|            goto err;
  515|       |
  516|  45.5k|        for (i = 0; i < MD_DIGEST_LENGTH / 2; i++) {
  517|       |            /* may compete with other threads */
  518|  41.4k|            state[st_idx++] ^= local_md[i];
  519|  41.4k|            if (st_idx >= st_num)
  520|     46|                st_idx = 0;
  521|  41.4k|            if (i < j)
  522|  17.7k|                *(buf++) = local_md[i + MD_DIGEST_LENGTH / 2];
  523|  41.4k|        }
  524|  4.14k|    }
  525|       |
  526|  3.96k|    if (!MD_Init(&m) ||
  527|  3.96k|        !MD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c)) ||
  528|  3.96k|        !MD_Update(&m, local_md, MD_DIGEST_LENGTH))
  529|      0|        goto err;
  530|  3.96k|    if (lock)
  531|  3.96k|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  532|  3.96k|    if (!MD_Update(&m, md, MD_DIGEST_LENGTH) ||
  533|  3.96k|        !MD_Final(&m, md)) {
  534|      0|        if (lock)
  535|      0|            CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  536|      0|        goto err;
  537|      0|    }
  538|  3.96k|    if (lock)
  539|  3.96k|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  540|       |
  541|  3.96k|    EVP_MD_CTX_cleanup(&m);
  542|  3.96k|    if (ok)
  543|  3.96k|        return (1);
  544|      0|    else if (pseudo)
  545|      0|        return 0;
  546|      0|    else {
  547|      0|        RANDerr(RAND_F_SSLEAY_RAND_BYTES, RAND_R_PRNG_NOT_SEEDED);
  548|      0|        ERR_add_error_data(1, "You need to read the OpenSSL FAQ, "
  549|      0|                           "http://www.openssl.org/support/faq.html");
  550|      0|        return (0);
  551|      0|    }
  552|       |
  553|      0| err:
  554|      0|    EVP_MD_CTX_cleanup(&m);
  555|      0|    return (0);
  556|  3.96k|}
md_rand.c:ssleay_rand_add:
  194|    116|{
  195|    116|    int i, j, k, st_idx;
  196|    116|    long md_c[2];
  197|    116|    unsigned char local_md[MD_DIGEST_LENGTH];
  198|    116|    EVP_MD_CTX m;
  199|    116|    int do_not_lock;
  200|       |
  201|    116|    if (!num)
  202|      0|        return;
  203|       |
  204|       |    /*
  205|       |     * (Based on the rand(3) manpage)
  206|       |     *
  207|       |     * The input is chopped up into units of 20 bytes (or less for
  208|       |     * the last block).  Each of these blocks is run through the hash
  209|       |     * function as follows:  The data passed to the hash function
  210|       |     * is the current 'md', the same number of bytes from the 'state'
  211|       |     * (the location determined by in incremented looping index) as
  212|       |     * the current 'block', the new key data 'block', and 'count'
  213|       |     * (which is incremented after each use).
  214|       |     * The result of this is kept in 'md' and also xored into the
  215|       |     * 'state' at the same locations that were used as input into the
  216|       |     * hash function.
  217|       |     */
  218|       |
  219|       |    /* check if we already have the lock */
  220|    116|    if (crypto_lock_rand) {
  221|     56|        CRYPTO_THREADID cur;
  222|     56|        CRYPTO_THREADID_current(&cur);
  223|     56|        CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
  224|     56|        do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
  225|     56|        CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
  226|     56|    } else
  227|     60|        do_not_lock = 0;
  228|       |
  229|    116|    if (!do_not_lock)
  230|     60|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  231|    116|    st_idx = state_index;
  232|       |
  233|       |    /*
  234|       |     * use our own copies of the counters so that even if a concurrent thread
  235|       |     * seeds with exactly the same data and uses the same subarray there's
  236|       |     * _some_ difference
  237|       |     */
  238|    116|    md_c[0] = md_count[0];
  239|    116|    md_c[1] = md_count[1];
  240|       |
  241|    116|    memcpy(local_md, md, sizeof md);
  242|       |
  243|       |    /* state_index <= state_num <= STATE_SIZE */
  244|    116|    state_index += num;
  245|    116|    if (state_index >= STATE_SIZE) {
  246|      1|        state_index %= STATE_SIZE;
  247|      1|        state_num = STATE_SIZE;
  248|    115|    } else if (state_num < STATE_SIZE) {
  249|     52|        if (state_index > state_num)
  250|     52|            state_num = state_index;
  251|     52|    }
  252|       |    /* state_index <= state_num <= STATE_SIZE */
  253|       |
  254|       |    /*
  255|       |     * state[st_idx], ..., state[(st_idx + num - 1) % STATE_SIZE] are what we
  256|       |     * will use now, but other threads may use them as well
  257|       |     */
  258|       |
  259|    116|    md_count[1] += (num / MD_DIGEST_LENGTH) + (num % MD_DIGEST_LENGTH > 0);
  260|       |
  261|    116|    if (!do_not_lock)
  262|     60|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  263|       |
  264|    116|    EVP_MD_CTX_init(&m);
  265|    233|    for (i = 0; i < num; i += MD_DIGEST_LENGTH) {
  266|    117|        j = (num - i);
  267|    117|        j = (j > MD_DIGEST_LENGTH) ? MD_DIGEST_LENGTH : j;
  268|       |
  269|    117|        if (!MD_Init(&m) ||
  270|    117|            !MD_Update(&m, local_md, MD_DIGEST_LENGTH))
  271|      0|            goto err;
  272|    117|        k = (st_idx + j) - STATE_SIZE;
  273|    117|        if (k > 0) {
  274|      1|            if (!MD_Update(&m, &(state[st_idx]), j - k) ||
  275|      1|                !MD_Update(&m, &(state[0]), k))
  276|      0|                goto err;
  277|      1|        } else
  278|    116|            if (!MD_Update(&m, &(state[st_idx]), j))
  279|      0|                goto err;
  280|       |
  281|       |        /* DO NOT REMOVE THE FOLLOWING CALL TO MD_Update()! */
  282|    117|        if (!MD_Update(&m, buf, j))
  283|      0|            goto err;
  284|       |        /*
  285|       |         * We know that line may cause programs such as purify and valgrind
  286|       |         * to complain about use of uninitialized data.  The problem is not,
  287|       |         * it's with the caller.  Removing that line will make sure you get
  288|       |         * really bad randomness and thereby other problems such as very
  289|       |         * insecure keys.
  290|       |         */
  291|       |
  292|    117|        if (!MD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c)) ||
  293|    117|            !MD_Final(&m, local_md))
  294|      0|            goto err;
  295|    117|        md_c[1]++;
  296|       |
  297|    117|        buf = (const char *)buf + j;
  298|       |
  299|  1.69k|        for (k = 0; k < j; k++) {
  300|       |            /*
  301|       |             * Parallel threads may interfere with this, but always each byte
  302|       |             * of the new state is the XOR of some previous value of its and
  303|       |             * local_md (itermediate values may be lost). Alway using locking
  304|       |             * could hurt performance more than necessary given that
  305|       |             * conflicts occur only when the total seeding is longer than the
  306|       |             * random state.
  307|       |             */
  308|  1.57k|            state[st_idx++] ^= local_md[k];
  309|  1.57k|            if (st_idx >= STATE_SIZE)
  310|      1|                st_idx = 0;
  311|  1.57k|        }
  312|    117|    }
  313|       |
  314|    116|    if (!do_not_lock)
  315|     60|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  316|       |    /*
  317|       |     * Don't just copy back local_md into md -- this could mean that other
  318|       |     * thread's seeding remains without effect (except for the incremented
  319|       |     * counter).  By XORing it we keep at least as much entropy as fits into
  320|       |     * md.
  321|       |     */
  322|  2.43k|    for (k = 0; k < (int)sizeof(md); k++) {
  323|  2.32k|        md[k] ^= local_md[k];
  324|  2.32k|    }
  325|    116|    if (entropy < ENTROPY_NEEDED) /* stop counting when we have enough */
  326|      1|        entropy += add;
  327|    116|    if (!do_not_lock)
  328|     60|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  329|       |
  330|       |#if !defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32)
  331|       |    assert(md_c[1] == md_count[1]);
  332|       |#endif
  333|       |
  334|    116| err:
  335|    116|    EVP_MD_CTX_cleanup(&m);
  336|    116|}
md_rand.c:ssleay_rand_nopseudo_bytes:
  559|  3.96k|{
  560|  3.96k|    return ssleay_rand_bytes(buf, num, 0, 1);
  561|  3.96k|}
md_rand.c:ssleay_rand_status:
  572|  3.73k|{
  573|  3.73k|    CRYPTO_THREADID cur;
  574|  3.73k|    int ret;
  575|  3.73k|    int do_not_lock;
  576|       |
  577|  3.73k|    CRYPTO_THREADID_current(&cur);
  578|       |    /*
  579|       |     * check if we already have the lock (could happen if a RAND_poll()
  580|       |     * implementation calls RAND_status())
  581|       |     */
  582|  3.73k|    if (crypto_lock_rand) {
  583|      0|        CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
  584|      0|        do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
  585|      0|        CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
  586|      0|    } else
  587|  3.73k|        do_not_lock = 0;
  588|       |
  589|  3.73k|    if (!do_not_lock) {
  590|  3.73k|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  591|       |
  592|       |        /*
  593|       |         * prevent ssleay_rand_bytes() from trying to obtain the lock again
  594|       |         */
  595|  3.73k|        CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
  596|  3.73k|        CRYPTO_THREADID_cpy(&locking_threadid, &cur);
  597|  3.73k|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
  598|  3.73k|        crypto_lock_rand = 1;
  599|  3.73k|    }
  600|       |
  601|  3.73k|    if (!initialized) {
  602|      1|        RAND_poll();
  603|      1|        initialized = 1;
  604|      1|    }
  605|       |
  606|  3.73k|    ret = entropy >= ENTROPY_NEEDED;
  607|       |
  608|  3.73k|    if (!do_not_lock) {
  609|       |        /* before unlocking, we must clear 'crypto_lock_rand' */
  610|  3.73k|        crypto_lock_rand = 0;
  611|       |
  612|  3.73k|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  613|  3.73k|    }
  614|       |
  615|  3.73k|    return ret;
  616|  3.73k|}

ERR_load_RAND_strings:
   92|      1|{
   93|      1|#ifndef OPENSSL_NO_ERR
   94|       |
   95|      1|    if (ERR_func_error_string(RAND_str_functs[0].error) == NULL) {
   96|      1|        ERR_load_strings(0, RAND_str_functs);
   97|      1|        ERR_load_strings(0, RAND_str_reasons);
   98|      1|    }
   99|      1|#endif
  100|      1|}

RAND_get_rand_method:
   93|  7.76k|{
   94|  7.76k|    if (!default_RAND_meth) {
   95|      1|#ifndef OPENSSL_NO_ENGINE
   96|      1|        ENGINE *e = ENGINE_get_default_RAND();
   97|      1|        if (e) {
   98|      0|            default_RAND_meth = ENGINE_get_RAND(e);
   99|      0|            if (!default_RAND_meth) {
  100|      0|                ENGINE_finish(e);
  101|      0|                e = NULL;
  102|      0|            }
  103|      0|        }
  104|      1|        if (e)
  105|      0|            funct_ref = e;
  106|      1|        else
  107|      1|#endif
  108|      1|            default_RAND_meth = RAND_SSLeay();
  109|      1|    }
  110|  7.76k|    return default_RAND_meth;
  111|  7.76k|}
RAND_add:
  149|     64|{
  150|     64|    const RAND_METHOD *meth = RAND_get_rand_method();
  151|     64|    if (meth && meth->add)
  152|     64|        meth->add(buf, num, entropy);
  153|     64|}
RAND_bytes:
  156|  3.96k|{
  157|  3.96k|    const RAND_METHOD *meth = RAND_get_rand_method();
  158|  3.96k|    if (meth && meth->bytes)
  159|  3.96k|        return meth->bytes(buf, num);
  160|      0|    return (-1);
  161|  3.96k|}
RAND_status:
  172|  3.73k|{
  173|  3.73k|    const RAND_METHOD *meth = RAND_get_rand_method();
  174|  3.73k|    if (meth && meth->status)
  175|  3.73k|        return meth->status();
  176|      0|    return 0;
  177|  3.73k|}

RAND_poll:
  244|      1|{
  245|      1|    unsigned long l;
  246|      1|    pid_t curr_pid = getpid();
  247|      1|#  if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
  248|      1|    unsigned char tmpbuf[ENTROPY_NEEDED];
  249|      1|    int n = 0;
  250|      1|#  endif
  251|      1|#  ifdef DEVRANDOM
  252|      1|    static const char *randomfiles[] = { DEVRANDOM };
  253|      1|    struct stat randomstats[sizeof(randomfiles) / sizeof(randomfiles[0])];
  254|      1|    int fd;
  255|      1|    unsigned int i;
  256|      1|#  endif
  257|      1|#  ifdef DEVRANDOM_EGD
  258|      1|    static const char *egdsockets[] = { DEVRANDOM_EGD, NULL };
  259|      1|    const char **egdsocket = NULL;
  260|      1|#  endif
  261|       |
  262|      1|#  ifdef DEVRANDOM
  263|      1|    memset(randomstats, 0, sizeof(randomstats));
  264|       |    /*
  265|       |     * Use a random entropy pool device. Linux, FreeBSD and OpenBSD have
  266|       |     * this. Use /dev/urandom if you can as /dev/random may block if it runs
  267|       |     * out of random entries.
  268|       |     */
  269|       |
  270|      2|    for (i = 0; (i < sizeof(randomfiles) / sizeof(randomfiles[0])) &&
  271|      2|         (n < ENTROPY_NEEDED); i++) {
  272|      1|        if ((fd = open(randomfiles[i], O_RDONLY
  273|      1|#   ifdef O_NONBLOCK
  274|      1|                       | O_NONBLOCK
  275|      1|#   endif
  276|       |#   ifdef O_BINARY
  277|       |                       | O_BINARY
  278|       |#   endif
  279|      1|#   ifdef O_NOCTTY              /* If it happens to be a TTY (god forbid), do
  280|       |                                 * not make it our controlling tty */
  281|      1|                       | O_NOCTTY
  282|      1|#   endif
  283|      1|             )) >= 0) {
  284|      1|            int usec = 10 * 1000; /* spend 10ms on each file */
  285|      1|            int r;
  286|      1|            unsigned int j;
  287|      1|            struct stat *st = &randomstats[i];
  288|       |
  289|       |            /*
  290|       |             * Avoid using same input... Used to be O_NOFOLLOW above, but
  291|       |             * it's not universally appropriate...
  292|       |             */
  293|      1|            if (fstat(fd, st) != 0) {
  294|      0|                close(fd);
  295|      0|                continue;
  296|      0|            }
  297|      1|            for (j = 0; j < i; j++) {
  298|      0|                if (randomstats[j].st_ino == st->st_ino &&
  299|      0|                    randomstats[j].st_dev == st->st_dev)
  300|      0|                    break;
  301|      0|            }
  302|      1|            if (j < i) {
  303|      0|                close(fd);
  304|      0|                continue;
  305|      0|            }
  306|       |
  307|      1|            do {
  308|      1|                int try_read = 0;
  309|       |
  310|       |#   if defined(OPENSSL_SYS_BEOS_R5)
  311|       |                /*
  312|       |                 * select() is broken in BeOS R5, so we simply try to read
  313|       |                 * something and snooze if we couldn't
  314|       |                 */
  315|       |                try_read = 1;
  316|       |
  317|       |#   elif defined(OPENSSL_SYS_LINUX)
  318|       |                /* use poll() */
  319|      1|                struct pollfd pset;
  320|       |
  321|      1|                pset.fd = fd;
  322|      1|                pset.events = POLLIN;
  323|      1|                pset.revents = 0;
  324|       |
  325|      1|                if (poll(&pset, 1, usec / 1000) < 0)
  326|      0|                    usec = 0;
  327|      1|                else
  328|      1|                    try_read = (pset.revents & POLLIN) != 0;
  329|       |
  330|       |#   else
  331|       |                /* use select() */
  332|       |                fd_set fset;
  333|       |                struct timeval t;
  334|       |
  335|       |                t.tv_sec = 0;
  336|       |                t.tv_usec = usec;
  337|       |
  338|       |                if (FD_SETSIZE > 0 && (unsigned)fd >= FD_SETSIZE) {
  339|       |                    /*
  340|       |                     * can't use select, so just try to read once anyway
  341|       |                     */
  342|       |                    try_read = 1;
  343|       |                } else {
  344|       |                    FD_ZERO(&fset);
  345|       |                    FD_SET(fd, &fset);
  346|       |
  347|       |                    if (select(fd + 1, &fset, NULL, NULL, &t) >= 0) {
  348|       |                        usec = t.tv_usec;
  349|       |                        if (FD_ISSET(fd, &fset))
  350|       |                            try_read = 1;
  351|       |                    } else
  352|       |                        usec = 0;
  353|       |                }
  354|       |#   endif
  355|       |
  356|      1|                if (try_read) {
  357|      1|                    r = read(fd, (unsigned char *)tmpbuf + n,
  358|      1|                             ENTROPY_NEEDED - n);
  359|      1|                    if (r > 0)
  360|      1|                        n += r;
  361|       |#   if defined(OPENSSL_SYS_BEOS_R5)
  362|       |                    if (r == 0)
  363|       |                        snooze(t.tv_usec);
  364|       |#   endif
  365|      1|                } else
  366|      0|                    r = -1;
  367|       |
  368|       |                /*
  369|       |                 * Some Unixen will update t in select(), some won't.  For
  370|       |                 * those who won't, or if we didn't use select() in the first
  371|       |                 * place, give up here, otherwise, we will do this once again
  372|       |                 * for the remaining time.
  373|       |                 */
  374|      1|                if (usec == 10 * 1000)
  375|      1|                    usec = 0;
  376|      1|            }
  377|      1|            while ((r > 0 ||
  378|      1|                    (errno == EINTR || errno == EAGAIN)) && usec != 0
  379|      1|                   && n < ENTROPY_NEEDED);
  380|       |
  381|      1|            close(fd);
  382|      1|        }
  383|      1|    }
  384|      1|#  endif                        /* defined(DEVRANDOM) */
  385|       |
  386|      1|#  ifdef DEVRANDOM_EGD
  387|       |    /*
  388|       |     * Use an EGD socket to read entropy from an EGD or PRNGD entropy
  389|       |     * collecting daemon.
  390|       |     */
  391|       |
  392|      1|    for (egdsocket = egdsockets; *egdsocket && n < ENTROPY_NEEDED;
  393|      1|         egdsocket++) {
  394|      0|        int r;
  395|       |
  396|      0|        r = RAND_query_egd_bytes(*egdsocket, (unsigned char *)tmpbuf + n,
  397|      0|                                 ENTROPY_NEEDED - n);
  398|      0|        if (r > 0)
  399|      0|            n += r;
  400|      0|    }
  401|      1|#  endif                        /* defined(DEVRANDOM_EGD) */
  402|       |
  403|      1|#  if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
  404|      1|    if (n > 0) {
  405|      1|        RAND_add(tmpbuf, sizeof tmpbuf, (double)n);
  406|      1|        OPENSSL_cleanse(tmpbuf, n);
  407|      1|    }
  408|      1|#  endif
  409|       |
  410|       |    /* put in some default random data, we need more than just this */
  411|      1|    l = curr_pid;
  412|      1|    RAND_add(&l, sizeof(l), 0.0);
  413|      1|    l = getuid();
  414|      1|    RAND_add(&l, sizeof(l), 0.0);
  415|       |
  416|      1|    l = time(NULL);
  417|      1|    RAND_add(&l, sizeof(l), 0.0);
  418|       |
  419|       |#  if defined(OPENSSL_SYS_BEOS)
  420|       |    {
  421|       |        system_info sysInfo;
  422|       |        get_system_info(&sysInfo);
  423|       |        RAND_add(&sysInfo, sizeof(sysInfo), 0);
  424|       |    }
  425|       |#  endif
  426|       |
  427|      1|#  if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
  428|      1|    return 1;
  429|       |#  else
  430|       |    return 0;
  431|       |#  endif
  432|      1|}

RSA_PKCS1_SSLeay:
  151|      7|{
  152|      7|    return (&rsa_pkcs1_eay_meth);
  153|      7|}

ERR_load_RSA_strings:
  239|      1|{
  240|      1|#ifndef OPENSSL_NO_ERR
  241|       |
  242|      1|    if (ERR_func_error_string(RSA_str_functs[0].error) == NULL) {
  243|      1|        ERR_load_strings(0, RSA_str_functs);
  244|      1|        ERR_load_strings(0, RSA_str_reasons);
  245|      1|    }
  246|      1|#endif
  247|      1|}

SHA1_Update:
  303|  32.9k|{
  304|  32.9k|    const unsigned char *data = data_;
  305|  32.9k|    unsigned char *p;
  306|  32.9k|    HASH_LONG l;
  307|  32.9k|    size_t n;
  308|       |
  309|  32.9k|    if (len == 0)
  310|      5|        return 1;
  311|       |
  312|  32.9k|    l = (c->Nl + (((HASH_LONG) len) << 3)) & 0xffffffffUL;
  313|       |    /*
  314|       |     * 95-05-24 eay Fixed a bug with the overflow handling, thanks to Wei Dai
  315|       |     * <weidai@eskimo.com> for pointing it out.
  316|       |     */
  317|  32.9k|    if (l < c->Nl)              /* overflow */
  318|      0|        c->Nh++;
  319|  32.9k|    c->Nh += (HASH_LONG) (len >> 29); /* might cause compiler warning on
  320|       |                                       * 16-bit */
  321|  32.9k|    c->Nl = l;
  322|       |
  323|  32.9k|    n = c->num;
  324|  32.9k|    if (n != 0) {
  325|  24.7k|        p = (unsigned char *)c->data;
  326|       |
  327|  24.7k|        if (len >= HASH_CBLOCK || len + n >= HASH_CBLOCK) {
  328|     53|            memcpy(p + n, data, HASH_CBLOCK - n);
  329|     53|            HASH_BLOCK_DATA_ORDER(c, p, 1);
  330|     53|            n = HASH_CBLOCK - n;
  331|     53|            data += n;
  332|     53|            len -= n;
  333|     53|            c->num = 0;
  334|       |            /*
  335|       |             * We use memset rather than OPENSSL_cleanse() here deliberately.
  336|       |             * Using OPENSSL_cleanse() here could be a performance issue. It
  337|       |             * will get properly cleansed on finalisation so this isn't a
  338|       |             * security problem.
  339|       |             */
  340|     53|            memset(p, 0, HASH_CBLOCK); /* keep it zeroed */
  341|  24.6k|        } else {
  342|  24.6k|            memcpy(p + n, data, len);
  343|  24.6k|            c->num += (unsigned int)len;
  344|  24.6k|            return 1;
  345|  24.6k|        }
  346|  24.7k|    }
  347|       |
  348|  8.27k|    n = len / HASH_CBLOCK;
  349|  8.27k|    if (n > 0) {
  350|      0|        HASH_BLOCK_DATA_ORDER(c, data, n);
  351|      0|        n *= HASH_CBLOCK;
  352|      0|        data += n;
  353|      0|        len -= n;
  354|      0|    }
  355|       |
  356|  8.27k|    if (len != 0) {
  357|  8.27k|        p = (unsigned char *)c->data;
  358|  8.27k|        c->num = (unsigned int)len;
  359|  8.27k|        memcpy(p, data, len);
  360|  8.27k|    }
  361|  8.27k|    return 1;
  362|  32.9k|}
SHA1_Final:
  370|  8.22k|{
  371|  8.22k|    unsigned char *p = (unsigned char *)c->data;
  372|  8.22k|    size_t n = c->num;
  373|       |
  374|  8.22k|    p[n] = 0x80;                /* there is always room for one */
  375|  8.22k|    n++;
  376|       |
  377|  8.22k|    if (n > (HASH_CBLOCK - 8)) {
  378|  4.14k|        memset(p + n, 0, HASH_CBLOCK - n);
  379|  4.14k|        n = 0;
  380|  4.14k|        HASH_BLOCK_DATA_ORDER(c, p, 1);
  381|  4.14k|    }
  382|  8.22k|    memset(p + n, 0, HASH_CBLOCK - 8 - n);
  383|       |
  384|  8.22k|    p += HASH_CBLOCK - 8;
  385|  8.22k|#if   defined(DATA_ORDER_IS_BIG_ENDIAN)
  386|  8.22k|    (void)HOST_l2c(c->Nh, p);
  387|  8.22k|    (void)HOST_l2c(c->Nl, p);
  388|       |#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)
  389|       |    (void)HOST_l2c(c->Nl, p);
  390|       |    (void)HOST_l2c(c->Nh, p);
  391|       |#endif
  392|  8.22k|    p -= HASH_CBLOCK;
  393|  8.22k|    HASH_BLOCK_DATA_ORDER(c, p, 1);
  394|  8.22k|    c->num = 0;
  395|  8.22k|    OPENSSL_cleanse(p, HASH_CBLOCK);
  396|       |
  397|       |#ifndef HASH_MAKE_STRING
  398|       |# error "HASH_MAKE_STRING must be defined!"
  399|       |#else
  400|  8.22k|    HASH_MAKE_STRING(c, md);
  401|  8.22k|#endif
  402|       |
  403|  8.22k|    return 1;
  404|  8.22k|}
SHA256_Update:
  303|  5.86k|{
  304|  5.86k|    const unsigned char *data = data_;
  305|  5.86k|    unsigned char *p;
  306|  5.86k|    HASH_LONG l;
  307|  5.86k|    size_t n;
  308|       |
  309|  5.86k|    if (len == 0)
  310|      9|        return 1;
  311|       |
  312|  5.85k|    l = (c->Nl + (((HASH_LONG) len) << 3)) & 0xffffffffUL;
  313|       |    /*
  314|       |     * 95-05-24 eay Fixed a bug with the overflow handling, thanks to Wei Dai
  315|       |     * <weidai@eskimo.com> for pointing it out.
  316|       |     */
  317|  5.85k|    if (l < c->Nl)              /* overflow */
  318|      0|        c->Nh++;
  319|  5.85k|    c->Nh += (HASH_LONG) (len >> 29); /* might cause compiler warning on
  320|       |                                       * 16-bit */
  321|  5.85k|    c->Nl = l;
  322|       |
  323|  5.85k|    n = c->num;
  324|  5.85k|    if (n != 0) {
  325|  5.67k|        p = (unsigned char *)c->data;
  326|       |
  327|  5.67k|        if (len >= HASH_CBLOCK || len + n >= HASH_CBLOCK) {
  328|     90|            memcpy(p + n, data, HASH_CBLOCK - n);
  329|     90|            HASH_BLOCK_DATA_ORDER(c, p, 1);
  330|     90|            n = HASH_CBLOCK - n;
  331|     90|            data += n;
  332|     90|            len -= n;
  333|     90|            c->num = 0;
  334|       |            /*
  335|       |             * We use memset rather than OPENSSL_cleanse() here deliberately.
  336|       |             * Using OPENSSL_cleanse() here could be a performance issue. It
  337|       |             * will get properly cleansed on finalisation so this isn't a
  338|       |             * security problem.
  339|       |             */
  340|     90|            memset(p, 0, HASH_CBLOCK); /* keep it zeroed */
  341|  5.58k|        } else {
  342|  5.58k|            memcpy(p + n, data, len);
  343|  5.58k|            c->num += (unsigned int)len;
  344|  5.58k|            return 1;
  345|  5.58k|        }
  346|  5.67k|    }
  347|       |
  348|    279|    n = len / HASH_CBLOCK;
  349|    279|    if (n > 0) {
  350|     18|        HASH_BLOCK_DATA_ORDER(c, data, n);
  351|     18|        n *= HASH_CBLOCK;
  352|     18|        data += n;
  353|     18|        len -= n;
  354|     18|    }
  355|       |
  356|    279|    if (len != 0) {
  357|    189|        p = (unsigned char *)c->data;
  358|    189|        c->num = (unsigned int)len;
  359|    189|        memcpy(p, data, len);
  360|    189|    }
  361|    279|    return 1;
  362|  5.85k|}
SHA256_Final:
  370|    108|{
  371|    108|    unsigned char *p = (unsigned char *)c->data;
  372|    108|    size_t n = c->num;
  373|       |
  374|    108|    p[n] = 0x80;                /* there is always room for one */
  375|    108|    n++;
  376|       |
  377|    108|    if (n > (HASH_CBLOCK - 8)) {
  378|      9|        memset(p + n, 0, HASH_CBLOCK - n);
  379|      9|        n = 0;
  380|      9|        HASH_BLOCK_DATA_ORDER(c, p, 1);
  381|      9|    }
  382|    108|    memset(p + n, 0, HASH_CBLOCK - 8 - n);
  383|       |
  384|    108|    p += HASH_CBLOCK - 8;
  385|    108|#if   defined(DATA_ORDER_IS_BIG_ENDIAN)
  386|    108|    (void)HOST_l2c(c->Nh, p);
  387|    108|    (void)HOST_l2c(c->Nl, p);
  388|       |#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)
  389|       |    (void)HOST_l2c(c->Nl, p);
  390|       |    (void)HOST_l2c(c->Nh, p);
  391|       |#endif
  392|    108|    p -= HASH_CBLOCK;
  393|    108|    HASH_BLOCK_DATA_ORDER(c, p, 1);
  394|    108|    c->num = 0;
  395|    108|    OPENSSL_cleanse(p, HASH_CBLOCK);
  396|       |
  397|       |#ifndef HASH_MAKE_STRING
  398|       |# error "HASH_MAKE_STRING must be defined!"
  399|       |#else
  400|    108|    HASH_MAKE_STRING(c, md);
  401|    108|#endif
  402|       |
  403|    108|    return 1;
  404|    108|}

SHA256_Init:
   35|    108|{
   36|    108|    memset(c, 0, sizeof(*c));
   37|    108|    c->h[0] = 0x6a09e667UL;
   38|    108|    c->h[1] = 0xbb67ae85UL;
   39|    108|    c->h[2] = 0x3c6ef372UL;
   40|    108|    c->h[3] = 0xa54ff53aUL;
   41|    108|    c->h[4] = 0x510e527fUL;
   42|    108|    c->h[5] = 0x9b05688cUL;
   43|    108|    c->h[6] = 0x1f83d9abUL;
   44|    108|    c->h[7] = 0x5be0cd19UL;
   45|    108|    c->md_len = SHA256_DIGEST_LENGTH;
   46|    108|    return 1;
   47|    108|}

SHA1_Init:
  130|  8.22k|{
  131|  8.22k|    memset(c, 0, sizeof(*c));
  132|  8.22k|    c->h0 = INIT_DATA_h0;
  133|  8.22k|    c->h1 = INIT_DATA_h1;
  134|  8.22k|    c->h2 = INIT_DATA_h2;
  135|  8.22k|    c->h3 = INIT_DATA_h3;
  136|  8.22k|    c->h4 = INIT_DATA_h4;
  137|  8.22k|    return 1;
  138|  8.22k|}

sk_set_cmp_func:
   82|     60| (const void *, const void *) {
   83|     60|    int (*old) (const void *, const void *) = sk->comp;
   84|       |
   85|     60|    if (sk->comp != c)
   86|     60|        sk->sorted = 0;
   87|     60|    sk->comp = c;
   88|       |
   89|     60|    return old;
   90|     60|}
sk_dup:
   93|     60|{
   94|     60|    _STACK *ret;
   95|     60|    char **s;
   96|       |
   97|     60|    if ((ret = sk_new(sk->comp)) == NULL)
   98|      0|        goto err;
   99|     60|    s = (char **)OPENSSL_realloc((char *)ret->data,
  100|     60|                                 (unsigned int)sizeof(char *) *
  101|     60|                                 sk->num_alloc);
  102|     60|    if (s == NULL)
  103|      0|        goto err;
  104|     60|    ret->data = s;
  105|       |
  106|     60|    ret->num = sk->num;
  107|     60|    memcpy(ret->data, sk->data, sizeof(char *) * sk->num);
  108|     60|    ret->sorted = sk->sorted;
  109|     60|    ret->num_alloc = sk->num_alloc;
  110|     60|    ret->comp = sk->comp;
  111|     60|    return (ret);
  112|      0| err:
  113|      0|    if (ret)
  114|      0|        sk_free(ret);
  115|      0|    return (NULL);
  116|     60|}
sk_new_null:
  153|  92.7k|{
  154|  92.7k|    return sk_new((int (*)(const void *, const void *))0);
  155|  92.7k|}
sk_new:
  158|  92.8k|{
  159|  92.8k|    _STACK *ret;
  160|  92.8k|    int i;
  161|       |
  162|  92.8k|    if ((ret = OPENSSL_malloc(sizeof(_STACK))) == NULL)
  163|      0|        goto err;
  164|  92.8k|    if ((ret->data = OPENSSL_malloc(sizeof(char *) * MIN_NODES)) == NULL)
  165|      0|        goto err;
  166|   464k|    for (i = 0; i < MIN_NODES; i++)
  167|   371k|        ret->data[i] = NULL;
  168|  92.8k|    ret->comp = c;
  169|  92.8k|    ret->num_alloc = MIN_NODES;
  170|  92.8k|    ret->num = 0;
  171|  92.8k|    ret->sorted = 0;
  172|  92.8k|    return (ret);
  173|      0| err:
  174|      0|    if (ret)
  175|      0|        OPENSSL_free(ret);
  176|      0|    return (NULL);
  177|  92.8k|}
sk_insert:
  180|   172k|{
  181|   172k|    char **s;
  182|       |
  183|   172k|    if (st == NULL)
  184|      0|        return 0;
  185|   172k|    if (st->num_alloc <= st->num + 1) {
  186|  13.8k|        s = OPENSSL_realloc((char *)st->data,
  187|  13.8k|                            (unsigned int)sizeof(char *) * st->num_alloc * 2);
  188|  13.8k|        if (s == NULL)
  189|      0|            return (0);
  190|  13.8k|        st->data = s;
  191|  13.8k|        st->num_alloc *= 2;
  192|  13.8k|    }
  193|   172k|    if ((loc >= (int)st->num) || (loc < 0))
  194|   172k|        st->data[st->num] = data;
  195|      7|    else {
  196|      7|        int i;
  197|      7|        char **f, **t;
  198|       |
  199|      7|        f = st->data;
  200|      7|        t = &(st->data[1]);
  201|     42|        for (i = st->num; i >= loc; i--)
  202|     35|            t[i] = f[i];
  203|       |
  204|       |#ifdef undef                    /* no memmove on sunos :-( */
  205|       |        memmove(&(st->data[loc + 1]),
  206|       |                &(st->data[loc]), sizeof(char *) * (st->num - loc));
  207|       |#endif
  208|      7|        st->data[loc] = data;
  209|      7|    }
  210|   172k|    st->num++;
  211|   172k|    st->sorted = 0;
  212|   172k|    return (st->num);
  213|   172k|}
sk_delete_ptr:
  216|     39|{
  217|     39|    int i;
  218|       |
  219|    109|    for (i = 0; i < st->num; i++)
  220|     77|        if (st->data[i] == p)
  221|      7|            return (sk_delete(st, i));
  222|     32|    return (NULL);
  223|     39|}
sk_delete:
  226|      7|{
  227|      7|    char *ret;
  228|      7|    int i, j;
  229|       |
  230|      7|    if (!st || (loc < 0) || (loc >= st->num))
  231|      0|        return NULL;
  232|       |
  233|      7|    ret = st->data[loc];
  234|      7|    if (loc != st->num - 1) {
  235|      0|        j = st->num - 1;
  236|      0|        for (i = loc; i < j; i++)
  237|      0|            st->data[i] = st->data[i + 1];
  238|       |        /*
  239|       |         * In theory memcpy is not safe for this memcpy( &(st->data[loc]),
  240|       |         * &(st->data[loc+1]), sizeof(char *)*(st->num-loc-1));
  241|       |         */
  242|      0|    }
  243|      7|    st->num--;
  244|      7|    return (ret);
  245|      7|}
sk_find:
  272|  3.84k|{
  273|  3.84k|    return internal_find(st, data, OBJ_BSEARCH_FIRST_VALUE_ON_MATCH);
  274|  3.84k|}
sk_push:
  282|   172k|{
  283|   172k|    return (sk_insert(st, data, st->num));
  284|   172k|}
sk_pop_free:
  320|  59.7k|{
  321|  59.7k|    int i;
  322|       |
  323|  59.7k|    if (st == NULL)
  324|      0|        return;
  325|   183k|    for (i = 0; i < st->num; i++)
  326|   123k|        if (st->data[i] != NULL)
  327|   123k|            func(st->data[i]);
  328|  59.7k|    sk_free(st);
  329|  59.7k|}
sk_free:
  332|   104k|{
  333|   104k|    if (st == NULL)
  334|  11.7k|        return;
  335|  92.7k|    if (st->data != NULL)
  336|  92.7k|        OPENSSL_free(st->data);
  337|  92.7k|    OPENSSL_free(st);
  338|  92.7k|}
sk_num:
  341|   474k|{
  342|   474k|    if (st == NULL)
  343|  7.68k|        return -1;
  344|   466k|    return st->num;
  345|   474k|}
sk_value:
  348|   266k|{
  349|   266k|    if (!st || (i < 0) || (i >= st->num))
  350|      1|        return NULL;
  351|   266k|    return st->data[i];
  352|   266k|}
sk_set:
  355|  29.3k|{
  356|  29.3k|    if (!st || (i < 0) || (i >= st->num))
  357|      0|        return NULL;
  358|  29.3k|    return (st->data[i] = value);
  359|  29.3k|}
sk_sort:
  362|  3.90k|{
  363|  3.90k|    if (st && !st->sorted && st->comp != NULL) {
  364|  3.90k|        int (*comp_func) (const void *, const void *);
  365|       |
  366|       |        /*
  367|       |         * same comment as in sk_find ... previously st->comp was declared as
  368|       |         * a (void*,void*) callback type, but this made the population of the
  369|       |         * callback pointer illogical - our callbacks compare type** with
  370|       |         * type**, so we leave the casting until absolutely necessary (ie.
  371|       |         * "now").
  372|       |         */
  373|  3.90k|        comp_func = (int (*)(const void *, const void *))(st->comp);
  374|  3.90k|        qsort(st->data, st->num, sizeof(char *), comp_func);
  375|  3.90k|        st->sorted = 1;
  376|  3.90k|    }
  377|  3.90k|}
stack.c:internal_find:
  248|  3.84k|{
  249|  3.84k|    const void *const *r;
  250|  3.84k|    int i;
  251|       |
  252|  3.84k|    if (st == NULL)
  253|      0|        return -1;
  254|       |
  255|  3.84k|    if (st->comp == NULL) {
  256|      0|        for (i = 0; i < st->num; i++)
  257|      0|            if (st->data[i] == data)
  258|      0|                return (i);
  259|      0|        return (-1);
  260|      0|    }
  261|  3.84k|    sk_sort(st);
  262|  3.84k|    if (data == NULL)
  263|      0|        return (-1);
  264|  3.84k|    r = OBJ_bsearch_ex_(&data, st->data, st->num, sizeof(void *), st->comp,
  265|  3.84k|                        ret_val_options);
  266|  3.84k|    if (r == NULL)
  267|  3.84k|        return (-1);
  268|      0|    return (int)((char **)r - st->data);
  269|  3.84k|}

ERR_load_TS_strings:
  180|      1|{
  181|      1|#ifndef OPENSSL_NO_ERR
  182|       |
  183|      1|    if (ERR_func_error_string(TS_str_functs[0].error) == NULL) {
  184|      1|        ERR_load_strings(0, TS_str_functs);
  185|      1|        ERR_load_strings(0, TS_str_reasons);
  186|      1|    }
  187|      1|#endif
  188|      1|}

ERR_load_UI_strings:
  103|      1|{
  104|      1|#ifndef OPENSSL_NO_ERR
  105|       |
  106|      1|    if (ERR_func_error_string(UI_str_functs[0].error) == NULL) {
  107|      1|        ERR_load_strings(0, UI_str_functs);
  108|      1|        ERR_load_strings(0, UI_str_reasons);
  109|      1|    }
  110|      1|#endif
  111|      1|}

X509_LOOKUP_file:
   87|     30|{
   88|     30|    return (&x509_file_lookup);
   89|     30|}
X509_load_cert_crl_file:
  244|     30|{
  245|     30|    STACK_OF(X509_INFO) *inf;
  246|     30|    X509_INFO *itmp;
  247|     30|    BIO *in;
  248|     30|    int i, count = 0;
  249|     30|    if (type != X509_FILETYPE_PEM)
  250|      0|        return X509_load_cert_file(ctx, file, type);
  251|     30|    in = BIO_new_file(file, "r");
  252|     30|    if (!in) {
  253|      0|        X509err(X509_F_X509_LOAD_CERT_CRL_FILE, ERR_R_SYS_LIB);
  254|      0|        return 0;
  255|      0|    }
  256|     30|    inf = PEM_X509_INFO_read_bio(in, NULL, NULL, "");
  257|     30|    BIO_free(in);
  258|     30|    if (!inf) {
  259|      0|        X509err(X509_F_X509_LOAD_CERT_CRL_FILE, ERR_R_PEM_LIB);
  260|      0|        return 0;
  261|      0|    }
  262|  3.87k|    for (i = 0; i < sk_X509_INFO_num(inf); i++) {
  263|  3.84k|        itmp = sk_X509_INFO_value(inf, i);
  264|  3.84k|        if (itmp->x509) {
  265|  3.84k|            X509_STORE_add_cert(ctx->store_ctx, itmp->x509);
  266|  3.84k|            count++;
  267|  3.84k|        }
  268|  3.84k|        if (itmp->crl) {
  269|      0|            X509_STORE_add_crl(ctx->store_ctx, itmp->crl);
  270|      0|            count++;
  271|      0|        }
  272|  3.84k|    }
  273|     30|    sk_X509_INFO_pop_free(inf, X509_INFO_free);
  274|     30|    return count;
  275|     30|}
by_file.c:by_file_ctrl:
   93|     30|{
   94|     30|    int ok = 0;
   95|     30|    const char *file;
   96|       |
   97|     30|    switch (cmd) {
   98|     30|    case X509_L_FILE_LOAD:
   99|     30|        if (argl == X509_FILETYPE_DEFAULT) {
  100|      0|            file = getenv(X509_get_default_cert_file_env());
  101|      0|            if (file)
  102|      0|                ok = (X509_load_cert_crl_file(ctx, file,
  103|      0|                                              X509_FILETYPE_PEM) != 0);
  104|       |
  105|      0|            else
  106|      0|                ok = (X509_load_cert_crl_file
  107|      0|                      (ctx, X509_get_default_cert_file(),
  108|      0|                       X509_FILETYPE_PEM) != 0);
  109|       |
  110|      0|            if (!ok) {
  111|      0|                X509err(X509_F_BY_FILE_CTRL, X509_R_LOADING_DEFAULTS);
  112|      0|            }
  113|     30|        } else {
  114|     30|            if (argl == X509_FILETYPE_PEM)
  115|     30|                ok = (X509_load_cert_crl_file(ctx, argp,
  116|     30|                                              X509_FILETYPE_PEM) != 0);
  117|      0|            else
  118|      0|                ok = (X509_load_cert_file(ctx, argp, (int)argl) != 0);
  119|     30|        }
  120|     30|        break;
  121|     30|    }
  122|     30|    return (ok);
  123|     30|}

X509_subject_name_cmp:
  116|   767k|{
  117|   767k|    return (X509_NAME_cmp(a->cert_info->subject, b->cert_info->subject));
  118|   767k|}
X509_NAME_cmp:
  203|   767k|{
  204|   767k|    int ret;
  205|       |
  206|       |    /* Ensure canonical encoding is present and up to date */
  207|       |
  208|   767k|    if (!a->canon_enc || a->modified) {
  209|      0|        ret = i2d_X509_NAME((X509_NAME *)a, NULL);
  210|      0|        if (ret < 0)
  211|      0|            return -2;
  212|      0|    }
  213|       |
  214|   767k|    if (!b->canon_enc || b->modified) {
  215|      0|        ret = i2d_X509_NAME((X509_NAME *)b, NULL);
  216|      0|        if (ret < 0)
  217|      0|            return -2;
  218|      0|    }
  219|       |
  220|   767k|    ret = a->canon_enclen - b->canon_enclen;
  221|       |
  222|   767k|    if (ret)
  223|   645k|        return ret;
  224|       |
  225|   122k|    return memcmp(a->canon_enc, b->canon_enc, a->canon_enclen);
  226|       |
  227|   767k|}

X509_STORE_load_locations:
   87|     30|{
   88|     30|    X509_LOOKUP *lookup;
   89|       |
   90|     30|    if (file != NULL) {
   91|     30|        lookup = X509_STORE_add_lookup(ctx, X509_LOOKUP_file());
   92|     30|        if (lookup == NULL)
   93|      0|            return (0);
   94|     30|        if (X509_LOOKUP_load_file(lookup, file, X509_FILETYPE_PEM) != 1)
   95|      0|            return (0);
   96|     30|    }
   97|     30|    if (path != NULL) {
   98|      0|        lookup = X509_STORE_add_lookup(ctx, X509_LOOKUP_hash_dir());
   99|      0|        if (lookup == NULL)
  100|      0|            return (0);
  101|      0|        if (X509_LOOKUP_add_dir(lookup, path, X509_FILETYPE_PEM) != 1)
  102|      0|            return (0);
  103|      0|    }
  104|     30|    if ((path == NULL) && (file == NULL))
  105|      0|        return (0);
  106|     30|    return (1);
  107|     30|}

X509_get_default_cert_area:
   70|      2|{
   71|      2|    return (X509_CERT_AREA);
   72|      2|}

ERR_load_X509_strings:
  180|      1|{
  181|      1|#ifndef OPENSSL_NO_ERR
  182|       |
  183|      1|    if (ERR_func_error_string(X509_str_functs[0].error) == NULL) {
  184|      1|        ERR_load_strings(0, X509_str_functs);
  185|      1|        ERR_load_strings(0, X509_str_reasons);
  186|      1|    }
  187|      1|#endif
  188|      1|}

X509_LOOKUP_new:
   66|     30|{
   67|     30|    X509_LOOKUP *ret;
   68|       |
   69|     30|    ret = (X509_LOOKUP *)OPENSSL_malloc(sizeof(X509_LOOKUP));
   70|     30|    if (ret == NULL)
   71|      0|        return NULL;
   72|       |
   73|     30|    ret->init = 0;
   74|     30|    ret->skip = 0;
   75|     30|    ret->method = method;
   76|     30|    ret->method_data = NULL;
   77|     30|    ret->store_ctx = NULL;
   78|     30|    if ((method->new_item != NULL) && !method->new_item(ret)) {
   79|      0|        OPENSSL_free(ret);
   80|      0|        return NULL;
   81|      0|    }
   82|     30|    return ret;
   83|     30|}
X509_LOOKUP_free:
   86|     30|{
   87|     30|    if (ctx == NULL)
   88|      0|        return;
   89|     30|    if ((ctx->method != NULL) && (ctx->method->free != NULL))
   90|      0|        (*ctx->method->free) (ctx);
   91|     30|    OPENSSL_free(ctx);
   92|     30|}
X509_LOOKUP_shutdown:
  105|     30|{
  106|     30|    if (ctx->method == NULL)
  107|      0|        return 0;
  108|     30|    if (ctx->method->shutdown != NULL)
  109|      0|        return ctx->method->shutdown(ctx);
  110|     30|    else
  111|     30|        return 1;
  112|     30|}
X509_LOOKUP_ctrl:
  116|     30|{
  117|     30|    if (ctx->method == NULL)
  118|      0|        return -1;
  119|     30|    if (ctx->method->ctrl != NULL)
  120|     30|        return ctx->method->ctrl(ctx, cmd, argc, argl, ret);
  121|      0|    else
  122|      0|        return 1;
  123|     30|}
X509_STORE_new:
  183|     30|{
  184|     30|    X509_STORE *ret;
  185|       |
  186|     30|    if ((ret = (X509_STORE *)OPENSSL_malloc(sizeof(X509_STORE))) == NULL)
  187|      0|        return NULL;
  188|     30|    if ((ret->objs = sk_X509_OBJECT_new(x509_object_cmp)) == NULL)
  189|      0|        goto err0;
  190|     30|    ret->cache = 1;
  191|     30|    if ((ret->get_cert_methods = sk_X509_LOOKUP_new_null()) == NULL)
  192|      0|        goto err1;
  193|     30|    ret->verify = 0;
  194|     30|    ret->verify_cb = 0;
  195|       |
  196|     30|    if ((ret->param = X509_VERIFY_PARAM_new()) == NULL)
  197|      0|        goto err2;
  198|       |
  199|     30|    ret->get_issuer = 0;
  200|     30|    ret->check_issued = 0;
  201|     30|    ret->check_revocation = 0;
  202|     30|    ret->get_crl = 0;
  203|     30|    ret->check_crl = 0;
  204|     30|    ret->cert_crl = 0;
  205|     30|    ret->lookup_certs = 0;
  206|     30|    ret->lookup_crls = 0;
  207|     30|    ret->cleanup = 0;
  208|       |
  209|     30|    if (!CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE, ret, &ret->ex_data))
  210|      0|       goto err3;
  211|       |
  212|     30|    ret->references = 1;
  213|     30|    return ret;
  214|       |
  215|      0| err3:
  216|      0|    X509_VERIFY_PARAM_free(ret->param);
  217|      0| err2:
  218|      0|    sk_X509_LOOKUP_free(ret->get_cert_methods);
  219|      0| err1:
  220|      0|    sk_X509_OBJECT_free(ret->objs);
  221|      0| err0:
  222|      0|    OPENSSL_free(ret);
  223|      0|    return NULL;
  224|      0|}
X509_STORE_free:
  242|     30|{
  243|     30|    int i;
  244|     30|    STACK_OF(X509_LOOKUP) *sk;
  245|     30|    X509_LOOKUP *lu;
  246|       |
  247|     30|    if (vfy == NULL)
  248|      0|        return;
  249|       |
  250|     30|    i = CRYPTO_add(&vfy->references, -1, CRYPTO_LOCK_X509_STORE);
  251|       |#ifdef REF_PRINT
  252|       |    REF_PRINT("X509_STORE", vfy);
  253|       |#endif
  254|     30|    if (i > 0)
  255|      0|        return;
  256|       |#ifdef REF_CHECK
  257|       |    if (i < 0) {
  258|       |        fprintf(stderr, "X509_STORE_free, bad reference count\n");
  259|       |        abort();                /* ok */
  260|       |    }
  261|       |#endif
  262|       |
  263|     30|    sk = vfy->get_cert_methods;
  264|     60|    for (i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
  265|     30|        lu = sk_X509_LOOKUP_value(sk, i);
  266|     30|        X509_LOOKUP_shutdown(lu);
  267|     30|        X509_LOOKUP_free(lu);
  268|     30|    }
  269|     30|    sk_X509_LOOKUP_free(sk);
  270|     30|    sk_X509_OBJECT_pop_free(vfy->objs, cleanup);
  271|       |
  272|     30|    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE, vfy, &vfy->ex_data);
  273|     30|    if (vfy->param)
  274|     30|        X509_VERIFY_PARAM_free(vfy->param);
  275|     30|    OPENSSL_free(vfy);
  276|     30|}
X509_STORE_add_lookup:
  279|     30|{
  280|     30|    int i;
  281|     30|    STACK_OF(X509_LOOKUP) *sk;
  282|     30|    X509_LOOKUP *lu;
  283|       |
  284|     30|    sk = v->get_cert_methods;
  285|     30|    for (i = 0; i < sk_X509_LOOKUP_num(sk); i++) {
  286|      0|        lu = sk_X509_LOOKUP_value(sk, i);
  287|      0|        if (m == lu->method) {
  288|      0|            return lu;
  289|      0|        }
  290|      0|    }
  291|       |    /* a new one */
  292|     30|    lu = X509_LOOKUP_new(m);
  293|     30|    if (lu == NULL)
  294|      0|        return NULL;
  295|     30|    else {
  296|     30|        lu->store_ctx = v;
  297|     30|        if (sk_X509_LOOKUP_push(v->get_cert_methods, lu))
  298|     30|            return lu;
  299|      0|        else {
  300|      0|            X509_LOOKUP_free(lu);
  301|      0|            return NULL;
  302|      0|        }
  303|     30|    }
  304|     30|}
X509_STORE_add_cert:
  348|  3.84k|{
  349|  3.84k|    X509_OBJECT *obj;
  350|  3.84k|    int ret = 1;
  351|       |
  352|  3.84k|    if (x == NULL)
  353|      0|        return 0;
  354|  3.84k|    obj = (X509_OBJECT *)OPENSSL_malloc(sizeof(X509_OBJECT));
  355|  3.84k|    if (obj == NULL) {
  356|      0|        X509err(X509_F_X509_STORE_ADD_CERT, ERR_R_MALLOC_FAILURE);
  357|      0|        return 0;
  358|      0|    }
  359|  3.84k|    obj->type = X509_LU_X509;
  360|  3.84k|    obj->data.x509 = x;
  361|       |
  362|  3.84k|    CRYPTO_w_lock(CRYPTO_LOCK_X509_STORE);
  363|       |
  364|  3.84k|    X509_OBJECT_up_ref_count(obj);
  365|       |
  366|  3.84k|    if (X509_OBJECT_retrieve_match(ctx->objs, obj)) {
  367|      0|        X509_OBJECT_free_contents(obj);
  368|      0|        OPENSSL_free(obj);
  369|      0|        X509err(X509_F_X509_STORE_ADD_CERT,
  370|      0|                X509_R_CERT_ALREADY_IN_HASH_TABLE);
  371|      0|        ret = 0;
  372|  3.84k|    } else if (!sk_X509_OBJECT_push(ctx->objs, obj)) {
  373|      0|        X509_OBJECT_free_contents(obj);
  374|      0|        OPENSSL_free(obj);
  375|      0|        X509err(X509_F_X509_STORE_ADD_CERT, ERR_R_MALLOC_FAILURE);
  376|      0|        ret = 0;
  377|      0|    }
  378|       |
  379|  3.84k|    CRYPTO_w_unlock(CRYPTO_LOCK_X509_STORE);
  380|       |
  381|  3.84k|    return ret;
  382|  3.84k|}
X509_OBJECT_up_ref_count:
  421|  3.84k|{
  422|  3.84k|    switch (a->type) {
  423|  3.84k|    case X509_LU_X509:
  424|  3.84k|        CRYPTO_add(&a->data.x509->references, 1, CRYPTO_LOCK_X509);
  425|  3.84k|        break;
  426|      0|    case X509_LU_CRL:
  427|      0|        CRYPTO_add(&a->data.crl->references, 1, CRYPTO_LOCK_X509_CRL);
  428|      0|        break;
  429|  3.84k|    }
  430|  3.84k|}
X509_OBJECT_retrieve_match:
  591|  3.84k|{
  592|  3.84k|    int idx, i;
  593|  3.84k|    X509_OBJECT *obj;
  594|  3.84k|    idx = sk_X509_OBJECT_find(h, x);
  595|  3.84k|    if (idx == -1)
  596|  3.84k|        return NULL;
  597|      0|    if ((x->type != X509_LU_X509) && (x->type != X509_LU_CRL))
  598|      0|        return sk_X509_OBJECT_value(h, idx);
  599|      0|    for (i = idx; i < sk_X509_OBJECT_num(h); i++) {
  600|      0|        obj = sk_X509_OBJECT_value(h, i);
  601|      0|        if (x509_object_cmp
  602|      0|            ((const X509_OBJECT **)&obj, (const X509_OBJECT **)&x))
  603|      0|            return NULL;
  604|      0|        if (x->type == X509_LU_X509) {
  605|      0|            if (!X509_cmp(obj->data.x509, x->data.x509))
  606|      0|                return obj;
  607|      0|        } else if (x->type == X509_LU_CRL) {
  608|      0|            if (!X509_CRL_match(obj->data.crl, x->data.crl))
  609|      0|                return obj;
  610|      0|        } else
  611|      0|            return obj;
  612|      0|    }
  613|      0|    return NULL;
  614|      0|}
X509_STORE_set_flags:
  681|     60|{
  682|     60|    return X509_VERIFY_PARAM_set_flags(ctx->param, flags);
  683|     60|}
x509_lu.c:x509_object_cmp:
  162|   767k|{
  163|   767k|    int ret;
  164|       |
  165|   767k|    ret = ((*a)->type - (*b)->type);
  166|   767k|    if (ret)
  167|      0|        return ret;
  168|   767k|    switch ((*a)->type) {
  169|   767k|    case X509_LU_X509:
  170|   767k|        ret = X509_subject_name_cmp((*a)->data.x509, (*b)->data.x509);
  171|   767k|        break;
  172|      0|    case X509_LU_CRL:
  173|      0|        ret = X509_CRL_cmp((*a)->data.crl, (*b)->data.crl);
  174|      0|        break;
  175|      0|    default:
  176|       |        /* abort(); */
  177|      0|        return 0;
  178|   767k|    }
  179|   767k|    return ret;
  180|   767k|}
x509_lu.c:cleanup:
  227|  3.84k|{
  228|  3.84k|    if (!a)
  229|      0|        return;
  230|  3.84k|    if (a->type == X509_LU_X509) {
  231|  3.84k|        X509_free(a->data.x509);
  232|  3.84k|    } else if (a->type == X509_LU_CRL) {
  233|      0|        X509_CRL_free(a->data.crl);
  234|      0|    } else {
  235|       |        /* abort(); */
  236|      0|    }
  237|       |
  238|  3.84k|    OPENSSL_free(a);
  239|  3.84k|}

X509_NAME_oneline:
   74|  3.84k|{
   75|  3.84k|    X509_NAME_ENTRY *ne;
   76|  3.84k|    int i;
   77|  3.84k|    int n, lold, l, l1, l2, num, j, type;
   78|  3.84k|    const char *s;
   79|  3.84k|    char *p;
   80|  3.84k|    unsigned char *q;
   81|  3.84k|    BUF_MEM *b = NULL;
   82|  3.84k|    static const char hex[17] = "0123456789ABCDEF";
   83|  3.84k|    int gs_doit[4];
   84|  3.84k|    char tmp_buf[80];
   85|       |#ifdef CHARSET_EBCDIC
   86|       |    char ebcdic_buf[1024];
   87|       |#endif
   88|       |
   89|  3.84k|    if (buf == NULL) {
   90|  3.84k|        if ((b = BUF_MEM_new()) == NULL)
   91|      0|            goto err;
   92|  3.84k|        if (!BUF_MEM_grow(b, 200))
   93|      0|            goto err;
   94|  3.84k|        b->data[0] = '\0';
   95|  3.84k|        len = 200;
   96|  3.84k|    } else if (len == 0) {
   97|      0|        return NULL;
   98|      0|    }
   99|  3.84k|    if (a == NULL) {
  100|      0|        if (b) {
  101|      0|            buf = b->data;
  102|      0|            OPENSSL_free(b);
  103|      0|        }
  104|      0|        strncpy(buf, "NO X509_NAME", len);
  105|      0|        buf[len - 1] = '\0';
  106|      0|        return buf;
  107|      0|    }
  108|       |
  109|  3.84k|    len--;                      /* space for '\0' */
  110|  3.84k|    l = 0;
  111|  18.3k|    for (i = 0; i < sk_X509_NAME_ENTRY_num(a->entries); i++) {
  112|  14.4k|        ne = sk_X509_NAME_ENTRY_value(a->entries, i);
  113|  14.4k|        n = OBJ_obj2nid(ne->object);
  114|  14.4k|        if ((n == NID_undef) || ((s = OBJ_nid2sn(n)) == NULL)) {
  115|     30|            i2t_ASN1_OBJECT(tmp_buf, sizeof(tmp_buf), ne->object);
  116|     30|            s = tmp_buf;
  117|     30|        }
  118|  14.4k|        l1 = strlen(s);
  119|       |
  120|  14.4k|        type = ne->value->type;
  121|  14.4k|        num = ne->value->length;
  122|  14.4k|        if (num > NAME_ONELINE_MAX) {
  123|      0|            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);
  124|      0|            goto end;
  125|      0|        }
  126|  14.4k|        q = ne->value->data;
  127|       |#ifdef CHARSET_EBCDIC
  128|       |        if (type == V_ASN1_GENERALSTRING ||
  129|       |            type == V_ASN1_VISIBLESTRING ||
  130|       |            type == V_ASN1_PRINTABLESTRING ||
  131|       |            type == V_ASN1_TELETEXSTRING ||
  132|       |            type == V_ASN1_IA5STRING) {
  133|       |            if (num > (int)sizeof(ebcdic_buf))
  134|       |                num = sizeof(ebcdic_buf);
  135|       |            ascii2ebcdic(ebcdic_buf, q, num);
  136|       |            q = ebcdic_buf;
  137|       |        }
  138|       |#endif
  139|       |
  140|  14.4k|        if ((type == V_ASN1_GENERALSTRING) && ((num % 4) == 0)) {
  141|      0|            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 0;
  142|      0|            for (j = 0; j < num; j++)
  143|      0|                if (q[j] != 0)
  144|      0|                    gs_doit[j & 3] = 1;
  145|       |
  146|      0|            if (gs_doit[0] | gs_doit[1] | gs_doit[2])
  147|      0|                gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;
  148|      0|            else {
  149|      0|                gs_doit[0] = gs_doit[1] = gs_doit[2] = 0;
  150|      0|                gs_doit[3] = 1;
  151|      0|            }
  152|      0|        } else
  153|  14.4k|            gs_doit[0] = gs_doit[1] = gs_doit[2] = gs_doit[3] = 1;
  154|       |
  155|   256k|        for (l2 = j = 0; j < num; j++) {
  156|   242k|            if (!gs_doit[j & 3])
  157|      0|                continue;
  158|   242k|            l2++;
  159|   242k|#ifndef CHARSET_EBCDIC
  160|   242k|            if ((q[j] < ' ') || (q[j] > '~'))
  161|    660|                l2 += 3;
  162|       |#else
  163|       |            if ((os_toascii[q[j]] < os_toascii[' ']) ||
  164|       |                (os_toascii[q[j]] > os_toascii['~']))
  165|       |                l2 += 3;
  166|       |#endif
  167|   242k|        }
  168|       |
  169|  14.4k|        lold = l;
  170|  14.4k|        l += 1 + l1 + 1 + l2;
  171|  14.4k|        if (l > NAME_ONELINE_MAX) {
  172|      0|            X509err(X509_F_X509_NAME_ONELINE, X509_R_NAME_TOO_LONG);
  173|      0|            goto end;
  174|      0|        }
  175|  14.4k|        if (b != NULL) {
  176|  14.4k|            if (!BUF_MEM_grow(b, l + 1))
  177|      0|                goto err;
  178|  14.4k|            p = &(b->data[lold]);
  179|  14.4k|        } else if (l > len) {
  180|      0|            break;
  181|      0|        } else
  182|      0|            p = &(buf[lold]);
  183|  14.4k|        *(p++) = '/';
  184|  14.4k|        memcpy(p, s, (unsigned int)l1);
  185|  14.4k|        p += l1;
  186|  14.4k|        *(p++) = '=';
  187|       |
  188|  14.4k|#ifndef CHARSET_EBCDIC          /* q was assigned above already. */
  189|  14.4k|        q = ne->value->data;
  190|  14.4k|#endif
  191|       |
  192|   256k|        for (j = 0; j < num; j++) {
  193|   242k|            if (!gs_doit[j & 3])
  194|      0|                continue;
  195|   242k|#ifndef CHARSET_EBCDIC
  196|   242k|            n = q[j];
  197|   242k|            if ((n < ' ') || (n > '~')) {
  198|    660|                *(p++) = '\\';
  199|    660|                *(p++) = 'x';
  200|    660|                *(p++) = hex[(n >> 4) & 0x0f];
  201|    660|                *(p++) = hex[n & 0x0f];
  202|    660|            } else
  203|   241k|                *(p++) = n;
  204|       |#else
  205|       |            n = os_toascii[q[j]];
  206|       |            if ((n < os_toascii[' ']) || (n > os_toascii['~'])) {
  207|       |                *(p++) = '\\';
  208|       |                *(p++) = 'x';
  209|       |                *(p++) = hex[(n >> 4) & 0x0f];
  210|       |                *(p++) = hex[n & 0x0f];
  211|       |            } else
  212|       |                *(p++) = q[j];
  213|       |#endif
  214|   242k|        }
  215|  14.4k|        *p = '\0';
  216|  14.4k|    }
  217|  3.84k|    if (b != NULL) {
  218|  3.84k|        p = b->data;
  219|  3.84k|        OPENSSL_free(b);
  220|  3.84k|    } else
  221|      0|        p = buf;
  222|  3.84k|    if (i == 0)
  223|      0|        *p = '\0';
  224|  3.84k|    return (p);
  225|      0| err:
  226|      0|    X509err(X509_F_X509_NAME_ONELINE, ERR_R_MALLOC_FAILURE);
  227|      0| end:
  228|      0|    BUF_MEM_free(b);
  229|      0|    return (NULL);
  230|      0|}

X509_STORE_CTX_get_ex_new_index:
 2237|      1|{
 2238|       |    /*
 2239|       |     * This function is (usually) called only once, by
 2240|       |     * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c).
 2241|       |     */
 2242|      1|    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, argl, argp,
 2243|      1|                                   new_func, dup_func, free_func);
 2244|      1|}

X509_VERIFY_PARAM_new:
  172|     90|{
  173|     90|    X509_VERIFY_PARAM *param;
  174|     90|    X509_VERIFY_PARAM_ID *paramid;
  175|       |
  176|     90|    param = OPENSSL_malloc(sizeof *param);
  177|     90|    if (!param)
  178|      0|        return NULL;
  179|     90|    memset(param, 0, sizeof(*param));
  180|       |
  181|     90|    paramid = OPENSSL_malloc(sizeof(*paramid));
  182|     90|    if (!paramid) {
  183|      0|        OPENSSL_free(param);
  184|      0|        return NULL;
  185|      0|    }
  186|     90|    memset(paramid, 0, sizeof(*paramid));
  187|       |    /* Exotic platforms may have non-zero bit representation of NULL */
  188|     90|    paramid->hosts = NULL;
  189|     90|    paramid->peername = NULL;
  190|     90|    paramid->email = NULL;
  191|     90|    paramid->ip = NULL;
  192|       |
  193|     90|    param->id = paramid;
  194|     90|    x509_verify_param_zero(param);
  195|     90|    return param;
  196|     90|}
X509_VERIFY_PARAM_free:
  199|     90|{
  200|     90|    if (param == NULL)
  201|      0|        return;
  202|     90|    x509_verify_param_zero(param);
  203|     90|    OPENSSL_free(param->id);
  204|     90|    OPENSSL_free(param);
  205|     90|}
X509_VERIFY_PARAM_inherit:
  258|     30|{
  259|     30|    unsigned long inh_flags;
  260|     30|    int to_default, to_overwrite;
  261|     30|    X509_VERIFY_PARAM_ID *id;
  262|     30|    if (!src)
  263|      0|        return 1;
  264|     30|    id = src->id;
  265|     30|    inh_flags = dest->inh_flags | src->inh_flags;
  266|       |
  267|     30|    if (inh_flags & X509_VP_FLAG_ONCE)
  268|      0|        dest->inh_flags = 0;
  269|       |
  270|     30|    if (inh_flags & X509_VP_FLAG_LOCKED)
  271|      0|        return 1;
  272|       |
  273|     30|    if (inh_flags & X509_VP_FLAG_DEFAULT)
  274|      0|        to_default = 1;
  275|     30|    else
  276|     30|        to_default = 0;
  277|       |
  278|     30|    if (inh_flags & X509_VP_FLAG_OVERWRITE)
  279|      0|        to_overwrite = 1;
  280|     30|    else
  281|     30|        to_overwrite = 0;
  282|       |
  283|     30|    x509_verify_param_copy(purpose, 0);
  284|     30|    x509_verify_param_copy(trust, 0);
  285|     30|    x509_verify_param_copy(depth, -1);
  286|       |
  287|       |    /* If overwrite or check time not set, copy across */
  288|       |
  289|     30|    if (to_overwrite || !(dest->flags & X509_V_FLAG_USE_CHECK_TIME)) {
  290|     30|        dest->check_time = src->check_time;
  291|     30|        dest->flags &= ~X509_V_FLAG_USE_CHECK_TIME;
  292|       |        /* Don't need to copy flag: that is done below */
  293|     30|    }
  294|       |
  295|     30|    if (inh_flags & X509_VP_FLAG_RESET_FLAGS)
  296|      0|        dest->flags = 0;
  297|       |
  298|     30|    dest->flags |= src->flags;
  299|       |
  300|     30|    if (test_x509_verify_param_copy(policies, NULL)) {
  301|      0|        if (!X509_VERIFY_PARAM_set1_policies(dest, src->policies))
  302|      0|            return 0;
  303|      0|    }
  304|       |
  305|       |    /* Copy the host flags if and only if we're copying the host list */
  306|     30|    if (test_x509_verify_param_copy_id(hosts, NULL)) {
  307|      0|        if (dest->id->hosts) {
  308|      0|            string_stack_free(dest->id->hosts);
  309|      0|            dest->id->hosts = NULL;
  310|      0|        }
  311|      0|        if (id->hosts) {
  312|      0|            dest->id->hosts =
  313|      0|                sk_OPENSSL_STRING_deep_copy(id->hosts, str_copy, str_free);
  314|      0|            if (dest->id->hosts == NULL)
  315|      0|                return 0;
  316|      0|            dest->id->hostflags = id->hostflags;
  317|      0|        }
  318|      0|    }
  319|       |
  320|     30|    if (test_x509_verify_param_copy_id(email, NULL)) {
  321|      0|        if (!X509_VERIFY_PARAM_set1_email(dest, id->email, id->emaillen))
  322|      0|            return 0;
  323|      0|    }
  324|       |
  325|     30|    if (test_x509_verify_param_copy_id(ip, NULL)) {
  326|      0|        if (!X509_VERIFY_PARAM_set1_ip(dest, id->ip, id->iplen))
  327|      0|            return 0;
  328|      0|    }
  329|       |
  330|     30|    return 1;
  331|     30|}
X509_VERIFY_PARAM_set_flags:
  379|     60|{
  380|     60|    param->flags |= flags;
  381|     60|    if (flags & X509_V_FLAG_POLICY_MASK)
  382|      0|        param->flags |= X509_V_FLAG_POLICY_CHECK;
  383|     60|    return 1;
  384|     60|}
x509_vpm.c:x509_verify_param_zero:
  134|    180|{
  135|    180|    X509_VERIFY_PARAM_ID *paramid;
  136|    180|    if (!param)
  137|      0|        return;
  138|    180|    param->name = NULL;
  139|    180|    param->purpose = 0;
  140|    180|    param->trust = 0;
  141|       |    /*
  142|       |     * param->inh_flags = X509_VP_FLAG_DEFAULT;
  143|       |     */
  144|    180|    param->inh_flags = 0;
  145|    180|    param->flags = 0;
  146|    180|    param->depth = -1;
  147|    180|    if (param->policies) {
  148|      0|        sk_ASN1_OBJECT_pop_free(param->policies, ASN1_OBJECT_free);
  149|      0|        param->policies = NULL;
  150|      0|    }
  151|    180|    paramid = param->id;
  152|    180|    if (paramid->hosts) {
  153|      0|        string_stack_free(paramid->hosts);
  154|      0|        paramid->hosts = NULL;
  155|      0|    }
  156|    180|    if (paramid->peername)
  157|      0|        OPENSSL_free(paramid->peername);
  158|    180|    paramid->peername = NULL;
  159|    180|    if (paramid->email) {
  160|      0|        OPENSSL_free(paramid->email);
  161|      0|        paramid->email = NULL;
  162|      0|        paramid->emaillen = 0;
  163|      0|    }
  164|    180|    if (paramid->ip) {
  165|      0|        OPENSSL_free(paramid->ip);
  166|      0|        paramid->ip = NULL;
  167|      0|        paramid->iplen = 0;
  168|      0|    }
  169|    180|}

GENERAL_NAMES_free:
  852|  3.84k|        { \
  853|  3.84k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  3.84k|        }
CRL_DIST_POINTS_free:
  852|  3.84k|        { \
  853|  3.84k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  3.84k|        }
AUTHORITY_KEYID_free:
  852|  3.84k|        { \
  853|  3.84k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  3.84k|        }
NAME_CONSTRAINTS_free:
  852|  3.84k|        { \
  853|  3.84k|                ASN1_item_free((ASN1_VALUE *)a, ASN1_ITEM_rptr(itname)); \
  854|  3.84k|        }

policy_cache_free:
  220|  3.84k|{
  221|  3.84k|    if (!cache)
  222|  3.84k|        return;
  223|      0|    if (cache->anyPolicy)
  224|      0|        policy_data_free(cache->anyPolicy);
  225|      0|    if (cache->data)
  226|      0|        sk_X509_POLICY_DATA_pop_free(cache->data, policy_data_free);
  227|      0|    OPENSSL_free(cache);
  228|      0|}

ERR_load_X509V3_strings:
  241|      1|{
  242|      1|#ifndef OPENSSL_NO_ERR
  243|       |
  244|      1|    if (ERR_func_error_string(X509V3_str_functs[0].error) == NULL) {
  245|      1|        ERR_load_strings(0, X509V3_str_functs);
  246|      1|        ERR_load_strings(0, X509V3_str_reasons);
  247|      1|    }
  248|      1|#endif
  249|      1|}

ERR_load_GOST_strings:
  183|      1|{
  184|      1|    if (GOST_lib_error_code == 0)
  185|      1|        GOST_lib_error_code = ERR_get_next_error_library();
  186|       |
  187|      1|    if (GOST_error_init) {
  188|      1|        GOST_error_init = 0;
  189|      1|#ifndef OPENSSL_NO_ERR
  190|      1|        ERR_load_strings(GOST_lib_error_code, GOST_str_functs);
  191|      1|        ERR_load_strings(GOST_lib_error_code, GOST_str_reasons);
  192|      1|#endif
  193|       |
  194|       |#ifdef GOST_LIB_NAME
  195|       |        GOST_lib_name->error = ERR_PACK(GOST_lib_error_code, 0, 0);
  196|       |        ERR_load_strings(0, GOST_lib_name);
  197|       |#endif
  198|      1|    }
  199|      1|}

register_ameth_gost:
  912|      3|{
  913|      3|    *ameth = EVP_PKEY_asn1_new(nid, ASN1_PKEY_SIGPARAM_NULL, pemstr, info);
  914|      3|    if (!*ameth)
  915|      0|        return 0;
  916|      3|    switch (nid) {
  917|      1|    case NID_id_GostR3410_94:
  918|      1|        EVP_PKEY_asn1_set_free(*ameth, pkey_free_gost94);
  919|      1|        EVP_PKEY_asn1_set_private(*ameth,
  920|      1|                                  priv_decode_gost, priv_encode_gost,
  921|      1|                                  priv_print_gost94);
  922|       |
  923|      1|        EVP_PKEY_asn1_set_param(*ameth,
  924|      1|                                gost94_param_decode, gost94_param_encode,
  925|      1|                                param_missing_gost94, param_copy_gost94,
  926|      1|                                param_cmp_gost94, param_print_gost94);
  927|      1|        EVP_PKEY_asn1_set_public(*ameth,
  928|      1|                                 pub_decode_gost94, pub_encode_gost94,
  929|      1|                                 pub_cmp_gost94, pub_print_gost94,
  930|      1|                                 pkey_size_gost, pkey_bits_gost);
  931|       |
  932|      1|        EVP_PKEY_asn1_set_ctrl(*ameth, pkey_ctrl_gost);
  933|      1|        break;
  934|      1|    case NID_id_GostR3410_2001:
  935|      1|        EVP_PKEY_asn1_set_free(*ameth, pkey_free_gost01);
  936|      1|        EVP_PKEY_asn1_set_private(*ameth,
  937|      1|                                  priv_decode_gost, priv_encode_gost,
  938|      1|                                  priv_print_gost01);
  939|       |
  940|      1|        EVP_PKEY_asn1_set_param(*ameth,
  941|      1|                                gost2001_param_decode, gost2001_param_encode,
  942|      1|                                param_missing_gost01, param_copy_gost01,
  943|      1|                                param_cmp_gost01, param_print_gost01);
  944|      1|        EVP_PKEY_asn1_set_public(*ameth,
  945|      1|                                 pub_decode_gost01, pub_encode_gost01,
  946|      1|                                 pub_cmp_gost01, pub_print_gost01,
  947|      1|                                 pkey_size_gost, pkey_bits_gost);
  948|       |
  949|      1|        EVP_PKEY_asn1_set_ctrl(*ameth, pkey_ctrl_gost);
  950|      1|        break;
  951|      1|    case NID_id_Gost28147_89_MAC:
  952|      1|        EVP_PKEY_asn1_set_free(*ameth, mackey_free_gost);
  953|      1|        EVP_PKEY_asn1_set_ctrl(*ameth, mac_ctrl_gost);
  954|      1|        break;
  955|      3|    }
  956|      3|    return 1;
  957|      3|}

ENGINE_load_gost:
  270|      1|{
  271|      1|    ENGINE *toadd;
  272|      1|    if (pmeth_GostR3410_94)
  273|      0|        return;
  274|      1|    toadd = engine_gost();
  275|      1|    if (!toadd)
  276|      0|        return;
  277|      1|    ENGINE_add(toadd);
  278|      1|    ENGINE_free(toadd);
  279|      1|    ERR_clear_error();
  280|      1|}
gost_eng.c:engine_gost:
  258|      1|{
  259|      1|    ENGINE *ret = ENGINE_new();
  260|      1|    if (!ret)
  261|      0|        return NULL;
  262|      1|    if (!bind_gost(ret, engine_gost_id)) {
  263|      0|        ENGINE_free(ret);
  264|      0|        return NULL;
  265|      0|    }
  266|      1|    return ret;
  267|      1|}
gost_eng.c:bind_gost:
   75|      1|{
   76|      1|    int ret = 0;
   77|      1|    if (id && strcmp(id, engine_gost_id))
   78|      0|        return 0;
   79|      1|    if (ameth_GostR3410_94) {
   80|      0|        printf("GOST engine already loaded\n");
   81|      0|        goto end;
   82|      0|    }
   83|       |
   84|      1|    if (!ENGINE_set_id(e, engine_gost_id)) {
   85|      0|        printf("ENGINE_set_id failed\n");
   86|      0|        goto end;
   87|      0|    }
   88|      1|    if (!ENGINE_set_name(e, engine_gost_name)) {
   89|      0|        printf("ENGINE_set_name failed\n");
   90|      0|        goto end;
   91|      0|    }
   92|      1|    if (!ENGINE_set_digests(e, gost_digests)) {
   93|      0|        printf("ENGINE_set_digests failed\n");
   94|      0|        goto end;
   95|      0|    }
   96|      1|    if (!ENGINE_set_ciphers(e, gost_ciphers)) {
   97|      0|        printf("ENGINE_set_ciphers failed\n");
   98|      0|        goto end;
   99|      0|    }
  100|      1|    if (!ENGINE_set_pkey_meths(e, gost_pkey_meths)) {
  101|      0|        printf("ENGINE_set_pkey_meths failed\n");
  102|      0|        goto end;
  103|      0|    }
  104|      1|    if (!ENGINE_set_pkey_asn1_meths(e, gost_pkey_asn1_meths)) {
  105|      0|        printf("ENGINE_set_pkey_asn1_meths failed\n");
  106|      0|        goto end;
  107|      0|    }
  108|       |    /* Control function and commands */
  109|      1|    if (!ENGINE_set_cmd_defns(e, gost_cmds)) {
  110|      0|        fprintf(stderr, "ENGINE_set_cmd_defns failed\n");
  111|      0|        goto end;
  112|      0|    }
  113|      1|    if (!ENGINE_set_ctrl_function(e, gost_control_func)) {
  114|      0|        fprintf(stderr, "ENGINE_set_ctrl_func failed\n");
  115|      0|        goto end;
  116|      0|    }
  117|      1|    if (!ENGINE_set_destroy_function(e, gost_engine_destroy)
  118|      1|        || !ENGINE_set_init_function(e, gost_engine_init)
  119|      1|        || !ENGINE_set_finish_function(e, gost_engine_finish)) {
  120|      0|        goto end;
  121|      0|    }
  122|       |
  123|      1|    if (!register_ameth_gost
  124|      1|        (NID_id_GostR3410_94, &ameth_GostR3410_94, "GOST94",
  125|      1|         "GOST R 34.10-94"))
  126|      0|        goto end;
  127|      1|    if (!register_ameth_gost
  128|      1|        (NID_id_GostR3410_2001, &ameth_GostR3410_2001, "GOST2001",
  129|      1|         "GOST R 34.10-2001"))
  130|      0|        goto end;
  131|      1|    if (!register_ameth_gost(NID_id_Gost28147_89_MAC, &ameth_Gost28147_MAC,
  132|      1|                             "GOST-MAC", "GOST 28147-89 MAC"))
  133|      0|        goto end;
  134|       |
  135|      1|    if (!register_pmeth_gost(NID_id_GostR3410_94, &pmeth_GostR3410_94, 0))
  136|      0|        goto end;
  137|      1|    if (!register_pmeth_gost(NID_id_GostR3410_2001, &pmeth_GostR3410_2001, 0))
  138|      0|        goto end;
  139|      1|    if (!register_pmeth_gost
  140|      1|        (NID_id_Gost28147_89_MAC, &pmeth_Gost28147_MAC, 0))
  141|      0|        goto end;
  142|      1|    if (!ENGINE_register_ciphers(e)
  143|      1|        || !ENGINE_register_digests(e)
  144|      1|        || !ENGINE_register_pkey_meths(e)
  145|       |        /* These two actually should go in LIST_ADD command */
  146|      1|        || !EVP_add_cipher(&cipher_gost)
  147|      1|        || !EVP_add_cipher(&cipher_gost_cpacnt)
  148|      1|        || !EVP_add_digest(&digest_gost)
  149|      1|        || !EVP_add_digest(&imit_gost_cpa)
  150|      1|        ) {
  151|      0|        goto end;
  152|      0|    }
  153|       |
  154|      1|    ERR_load_GOST_strings();
  155|      1|    ret = 1;
  156|      1| end:
  157|      1|    return ret;
  158|      1|}
gost_eng.c:gost_digests:
  166|      2|{
  167|      2|    int ok = 1;
  168|      2|    if (!digest) {
  169|      2|        *nids = gost_digest_nids;
  170|      2|        return 2;
  171|      2|    }
  172|       |    /*
  173|       |     * printf("Digest no %d requested\n",nid);
  174|       |     */
  175|      0|    if (nid == NID_id_GostR3411_94) {
  176|      0|        *digest = &digest_gost;
  177|      0|    } else if (nid == NID_id_Gost28147_89_MAC) {
  178|      0|        *digest = &imit_gost_cpa;
  179|      0|    } else {
  180|      0|        ok = 0;
  181|      0|        *digest = NULL;
  182|      0|    }
  183|      0|    return ok;
  184|      2|}
gost_eng.c:gost_ciphers:
  188|      2|{
  189|      2|    int ok = 1;
  190|      2|    if (!cipher) {
  191|      2|        *nids = gost_cipher_nids;
  192|      2|        return 2;               /* two ciphers are supported */
  193|      2|    }
  194|       |
  195|      0|    if (nid == NID_id_Gost28147_89) {
  196|      0|        *cipher = &cipher_gost;
  197|      0|    } else if (nid == NID_gost89_cnt) {
  198|      0|        *cipher = &cipher_gost_cpacnt;
  199|      0|    } else {
  200|      0|        ok = 0;
  201|      0|        *cipher = NULL;
  202|      0|    }
  203|      0|    return ok;
  204|      2|}
gost_eng.c:gost_pkey_meths:
  208|      2|{
  209|      2|    if (!pmeth) {
  210|      2|        *nids = gost_pkey_meth_nids;
  211|      2|        return 3;
  212|      2|    }
  213|       |
  214|      0|    switch (nid) {
  215|      0|    case NID_id_GostR3410_94:
  216|      0|        *pmeth = pmeth_GostR3410_94;
  217|      0|        return 1;
  218|      0|    case NID_id_GostR3410_2001:
  219|      0|        *pmeth = pmeth_GostR3410_2001;
  220|      0|        return 1;
  221|      0|    case NID_id_Gost28147_89_MAC:
  222|      0|        *pmeth = pmeth_Gost28147_MAC;
  223|      0|        return 1;
  224|      0|    default:;
  225|      0|    }
  226|       |
  227|      0|    *pmeth = NULL;
  228|      0|    return 0;
  229|      0|}

register_pmeth_gost:
  567|      3|{
  568|      3|    *pmeth = EVP_PKEY_meth_new(id, flags);
  569|      3|    if (!*pmeth)
  570|      0|        return 0;
  571|       |
  572|      3|    switch (id) {
  573|      1|    case NID_id_GostR3410_94:
  574|      1|        EVP_PKEY_meth_set_ctrl(*pmeth, pkey_gost_ctrl, pkey_gost_ctrl94_str);
  575|      1|        EVP_PKEY_meth_set_keygen(*pmeth, NULL, pkey_gost94cp_keygen);
  576|      1|        EVP_PKEY_meth_set_sign(*pmeth, NULL, pkey_gost94_cp_sign);
  577|      1|        EVP_PKEY_meth_set_verify(*pmeth, NULL, pkey_gost94_cp_verify);
  578|      1|        EVP_PKEY_meth_set_encrypt(*pmeth,
  579|      1|                                  pkey_gost_encrypt_init,
  580|      1|                                  pkey_GOST94cp_encrypt);
  581|      1|        EVP_PKEY_meth_set_decrypt(*pmeth, NULL, pkey_GOST94cp_decrypt);
  582|      1|        EVP_PKEY_meth_set_derive(*pmeth,
  583|      1|                                 pkey_gost_derive_init, pkey_gost94_derive);
  584|      1|        EVP_PKEY_meth_set_paramgen(*pmeth, pkey_gost_paramgen_init,
  585|      1|                                   pkey_gost94_paramgen);
  586|      1|        break;
  587|      1|    case NID_id_GostR3410_2001:
  588|      1|        EVP_PKEY_meth_set_ctrl(*pmeth, pkey_gost_ctrl, pkey_gost_ctrl01_str);
  589|      1|        EVP_PKEY_meth_set_sign(*pmeth, NULL, pkey_gost01_cp_sign);
  590|      1|        EVP_PKEY_meth_set_verify(*pmeth, NULL, pkey_gost01_cp_verify);
  591|       |
  592|      1|        EVP_PKEY_meth_set_keygen(*pmeth, NULL, pkey_gost01cp_keygen);
  593|       |
  594|      1|        EVP_PKEY_meth_set_encrypt(*pmeth,
  595|      1|                                  pkey_gost_encrypt_init,
  596|      1|                                  pkey_GOST01cp_encrypt);
  597|      1|        EVP_PKEY_meth_set_decrypt(*pmeth, NULL, pkey_GOST01cp_decrypt);
  598|      1|        EVP_PKEY_meth_set_derive(*pmeth,
  599|      1|                                 pkey_gost_derive_init, pkey_gost2001_derive);
  600|      1|        EVP_PKEY_meth_set_paramgen(*pmeth, pkey_gost_paramgen_init,
  601|      1|                                   pkey_gost01_paramgen);
  602|      1|        break;
  603|      1|    case NID_id_Gost28147_89_MAC:
  604|      1|        EVP_PKEY_meth_set_ctrl(*pmeth, pkey_gost_mac_ctrl,
  605|      1|                               pkey_gost_mac_ctrl_str);
  606|      1|        EVP_PKEY_meth_set_signctx(*pmeth, pkey_gost_mac_signctx_init,
  607|      1|                                  pkey_gost_mac_signctx);
  608|      1|        EVP_PKEY_meth_set_keygen(*pmeth, NULL, pkey_gost_mac_keygen);
  609|      1|        EVP_PKEY_meth_set_init(*pmeth, pkey_gost_mac_init);
  610|      1|        EVP_PKEY_meth_set_cleanup(*pmeth, pkey_gost_mac_cleanup);
  611|      1|        EVP_PKEY_meth_set_copy(*pmeth, pkey_gost_mac_copy);
  612|      1|        return 1;
  613|      0|    default:                   /* Unsupported method */
  614|      0|        return 0;
  615|      3|    }
  616|      2|    EVP_PKEY_meth_set_init(*pmeth, pkey_gost_init);
  617|      2|    EVP_PKEY_meth_set_cleanup(*pmeth, pkey_gost_cleanup);
  618|       |
  619|      2|    EVP_PKEY_meth_set_copy(*pmeth, pkey_gost_copy);
  620|       |    /*
  621|       |     * FIXME derive etc...
  622|       |     */
  623|       |
  624|      2|    return 1;
  625|      3|}

ENGINE_load_4758cca:
  264|      1|{
  265|      1|    ENGINE *e_4758 = engine_4758_cca();
  266|      1|    if (!e_4758)
  267|      0|        return;
  268|      1|    ENGINE_add(e_4758);
  269|      1|    ENGINE_free(e_4758);
  270|      1|    ERR_clear_error();
  271|      1|}
e_4758cca.c:engine_4758_cca:
  252|      1|{
  253|      1|    ENGINE *ret = ENGINE_new();
  254|      1|    if (!ret)
  255|      0|        return NULL;
  256|      1|    if (!bind_helper(ret)) {
  257|      0|        ENGINE_free(ret);
  258|      0|        return NULL;
  259|      0|    }
  260|      1|    return ret;
  261|      1|}
e_4758cca.c:bind_helper:
  228|      1|{
  229|      1|    if (!ENGINE_set_id(e, engine_4758_cca_id) ||
  230|      1|        !ENGINE_set_name(e, engine_4758_cca_name) ||
  231|      1|#  ifndef OPENSSL_NO_RSA
  232|      1|        !ENGINE_set_RSA(e, &ibm_4758_cca_rsa) ||
  233|      1|#  endif
  234|      1|        !ENGINE_set_RAND(e, &ibm_4758_cca_rand) ||
  235|      1|        !ENGINE_set_destroy_function(e, ibm_4758_cca_destroy) ||
  236|      1|        !ENGINE_set_init_function(e, ibm_4758_cca_init) ||
  237|      1|        !ENGINE_set_finish_function(e, ibm_4758_cca_finish) ||
  238|      1|        !ENGINE_set_ctrl_function(e, ibm_4758_cca_ctrl) ||
  239|      1|#  ifndef OPENSSL_NO_RSA
  240|      1|        !ENGINE_set_load_privkey_function(e, ibm_4758_load_privkey) ||
  241|      1|        !ENGINE_set_load_pubkey_function(e, ibm_4758_load_pubkey) ||
  242|      1|#  endif
  243|      1|        !ENGINE_set_cmd_defns(e, cca4758_cmd_defns))
  244|      0|        return 0;
  245|       |    /* Ensure the error handling is set up */
  246|      1|    ERR_load_CCA4758_strings();
  247|      1|    return 1;
  248|      1|}
e_4758cca.c:ibm_4758_cca_init:
  282|      1|{
  283|      1|    if (dso) {
  284|      0|        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_ALREADY_LOADED);
  285|      0|        goto err;
  286|      0|    }
  287|       |
  288|      1|    dso = DSO_load(NULL, get_CCA4758_LIB_NAME(), NULL, 0);
  289|      1|    if (!dso) {
  290|      1|        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_DSO_FAILURE);
  291|      1|        goto err;
  292|      1|    }
  293|      0|#  ifndef OPENSSL_NO_RSA
  294|      0|    if (!(keyRecordRead = (F_KEYRECORDREAD)
  295|      0|          DSO_bind_func(dso, n_keyRecordRead)) ||
  296|      0|        !(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)
  297|      0|          DSO_bind_func(dso, n_randomNumberGenerate)) ||
  298|      0|        !(digitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)
  299|      0|          DSO_bind_func(dso, n_digitalSignatureGenerate)) ||
  300|      0|        !(digitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)
  301|      0|          DSO_bind_func(dso, n_digitalSignatureVerify)) ||
  302|      0|        !(publicKeyExtract = (F_PUBLICKEYEXTRACT)
  303|      0|          DSO_bind_func(dso, n_publicKeyExtract)) ||
  304|      0|        !(pkaEncrypt = (F_PKAENCRYPT)
  305|      0|          DSO_bind_func(dso, n_pkaEncrypt)) || !(pkaDecrypt = (F_PKADECRYPT)
  306|      0|                                                 DSO_bind_func(dso,
  307|      0|                                                               n_pkaDecrypt)))
  308|      0|    {
  309|      0|        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_DSO_FAILURE);
  310|      0|        goto err;
  311|      0|    }
  312|       |#  else
  313|       |    if (!(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)
  314|       |          DSO_bind_func(dso, n_randomNumberGenerate))) {
  315|       |        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_DSO_FAILURE);
  316|       |        goto err;
  317|       |    }
  318|       |#  endif
  319|       |
  320|      0|#  ifndef OPENSSL_NO_RSA
  321|      0|    hndidx = RSA_get_ex_new_index(0, "IBM 4758 CCA RSA key handle",
  322|      0|                                  NULL, NULL, cca_ex_free);
  323|      0|#  endif
  324|       |
  325|      0|    return 1;
  326|      1| err:
  327|      1|    if (dso)
  328|      0|        DSO_free(dso);
  329|      1|    dso = NULL;
  330|       |
  331|      1|#  ifndef OPENSSL_NO_RSA
  332|      1|    keyRecordRead = (F_KEYRECORDREAD) 0;
  333|      1|    digitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE) 0;
  334|      1|    digitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)0;
  335|      1|    publicKeyExtract = (F_PUBLICKEYEXTRACT)0;
  336|      1|    pkaEncrypt = (F_PKAENCRYPT) 0;
  337|      1|    pkaDecrypt = (F_PKADECRYPT) 0;
  338|      1|#  endif
  339|      1|    randomNumberGenerate = (F_RANDOMNUMBERGENERATE) 0;
  340|      1|    return 0;
  341|      0|}
e_4758cca.c:get_CCA4758_LIB_NAME:
  142|      1|{
  143|      1|    if (CCA4758_LIB_NAME)
  144|      0|        return CCA4758_LIB_NAME;
  145|      1|    return CCA_LIB_NAME;
  146|      1|}

e_4758cca.c:ERR_CCA4758_error:
  149|      1|{
  150|      1|    if (CCA4758_lib_error_code == 0)
  151|      0|        CCA4758_lib_error_code = ERR_get_next_error_library();
  152|      1|    ERR_PUT_error(CCA4758_lib_error_code, function, reason, file, line);
  153|      1|}
e_4758cca.c:ERR_load_CCA4758_strings:
  115|      1|{
  116|      1|    if (CCA4758_lib_error_code == 0)
  117|      1|        CCA4758_lib_error_code = ERR_get_next_error_library();
  118|       |
  119|      1|    if (CCA4758_error_init) {
  120|      1|        CCA4758_error_init = 0;
  121|      1|#ifndef OPENSSL_NO_ERR
  122|      1|        ERR_load_strings(CCA4758_lib_error_code, CCA4758_str_functs);
  123|      1|        ERR_load_strings(CCA4758_lib_error_code, CCA4758_str_reasons);
  124|      1|#endif
  125|       |
  126|       |#ifdef CCA4758_LIB_NAME
  127|       |        CCA4758_lib_name->error = ERR_PACK(CCA4758_lib_error_code, 0, 0);
  128|       |        ERR_load_strings(0, CCA4758_lib_name);
  129|       |#endif
  130|      1|    }
  131|      1|}

ENGINE_load_aep:
  373|      1|{
  374|       |    /* Copied from eng_[openssl|dyn].c */
  375|      1|    ENGINE *toadd = engine_aep();
  376|      1|    if (!toadd)
  377|      0|        return;
  378|      1|    ENGINE_add(toadd);
  379|      1|    ENGINE_free(toadd);
  380|      1|    ERR_clear_error();
  381|      1|}
e_aep.c:engine_aep:
  361|      1|{
  362|      1|    ENGINE *ret = ENGINE_new();
  363|      1|    if (!ret)
  364|      0|        return NULL;
  365|      1|    if (!bind_aep(ret)) {
  366|      0|        ENGINE_free(ret);
  367|      0|        return NULL;
  368|      0|    }
  369|      1|    return ret;
  370|      1|}
e_aep.c:bind_aep:
  271|      1|{
  272|      1|#  ifndef OPENSSL_NO_RSA
  273|      1|    const RSA_METHOD *meth1;
  274|      1|#  endif
  275|      1|#  ifndef OPENSSL_NO_DSA
  276|      1|    const DSA_METHOD *meth2;
  277|      1|#  endif
  278|      1|#  ifndef OPENSSL_NO_DH
  279|      1|    const DH_METHOD *meth3;
  280|      1|#  endif
  281|       |
  282|      1|    if (!ENGINE_set_id(e, engine_aep_id) ||
  283|      1|        !ENGINE_set_name(e, engine_aep_name) ||
  284|      1|#  ifndef OPENSSL_NO_RSA
  285|      1|        !ENGINE_set_RSA(e, &aep_rsa) ||
  286|      1|#  endif
  287|      1|#  ifndef OPENSSL_NO_DSA
  288|      1|        !ENGINE_set_DSA(e, &aep_dsa) ||
  289|      1|#  endif
  290|      1|#  ifndef OPENSSL_NO_DH
  291|      1|        !ENGINE_set_DH(e, &aep_dh) ||
  292|      1|#  endif
  293|       |#  ifdef AEPRAND
  294|       |        !ENGINE_set_RAND(e, &aep_random) ||
  295|       |#  endif
  296|      1|        !ENGINE_set_init_function(e, aep_init) ||
  297|      1|        !ENGINE_set_destroy_function(e, aep_destroy) ||
  298|      1|        !ENGINE_set_finish_function(e, aep_finish) ||
  299|      1|        !ENGINE_set_ctrl_function(e, aep_ctrl) ||
  300|      1|        !ENGINE_set_cmd_defns(e, aep_cmd_defns))
  301|      0|        return 0;
  302|       |
  303|      1|#  ifndef OPENSSL_NO_RSA
  304|       |    /*
  305|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  306|       |     * aep-specific mod_exp and mod_exp_crt so we use those functions. NB: We
  307|       |     * don't use ENGINE_openssl() or anything "more generic" because
  308|       |     * something like the RSAref code may not hook properly, and if you own
  309|       |     * one of these cards then you have the right to do RSA operations on it
  310|       |     * anyway!
  311|       |     */
  312|      1|    meth1 = RSA_PKCS1_SSLeay();
  313|      1|    aep_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  314|      1|    aep_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  315|      1|    aep_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  316|      1|    aep_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  317|      1|#  endif
  318|       |
  319|      1|#  ifndef OPENSSL_NO_DSA
  320|       |    /*
  321|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  322|       |     */
  323|      1|    meth2 = DSA_OpenSSL();
  324|      1|    aep_dsa.dsa_do_sign = meth2->dsa_do_sign;
  325|      1|    aep_dsa.dsa_sign_setup = meth2->dsa_sign_setup;
  326|      1|    aep_dsa.dsa_do_verify = meth2->dsa_do_verify;
  327|       |
  328|      1|    aep_dsa = *DSA_get_default_method();
  329|      1|    aep_dsa.dsa_mod_exp = aep_dsa_mod_exp;
  330|      1|    aep_dsa.bn_mod_exp = aep_mod_exp_dsa;
  331|      1|#  endif
  332|       |
  333|      1|#  ifndef OPENSSL_NO_DH
  334|       |    /* Much the same for Diffie-Hellman */
  335|      1|    meth3 = DH_OpenSSL();
  336|      1|    aep_dh.generate_key = meth3->generate_key;
  337|      1|    aep_dh.compute_key = meth3->compute_key;
  338|      1|    aep_dh.bn_mod_exp = meth3->bn_mod_exp;
  339|      1|#  endif
  340|       |
  341|       |    /* Ensure the aep error handling is set up */
  342|      1|    ERR_load_AEPHK_strings();
  343|       |
  344|      1|    return 1;
  345|      1|}

e_aep.c:ERR_load_AEPHK_strings:
  121|      1|{
  122|      1|    if (AEPHK_lib_error_code == 0)
  123|      1|        AEPHK_lib_error_code = ERR_get_next_error_library();
  124|       |
  125|      1|    if (AEPHK_error_init) {
  126|      1|        AEPHK_error_init = 0;
  127|      1|#ifndef OPENSSL_NO_ERR
  128|      1|        ERR_load_strings(AEPHK_lib_error_code, AEPHK_str_functs);
  129|      1|        ERR_load_strings(AEPHK_lib_error_code, AEPHK_str_reasons);
  130|      1|#endif
  131|       |
  132|       |#ifdef AEPHK_LIB_NAME
  133|       |        AEPHK_lib_name->error = ERR_PACK(AEPHK_lib_error_code, 0, 0);
  134|       |        ERR_load_strings(0, AEPHK_lib_name);
  135|       |#endif
  136|      1|    }
  137|      1|}

ENGINE_load_atalla:
  279|      1|{
  280|       |    /* Copied from eng_[openssl|dyn].c */
  281|      1|    ENGINE *toadd = engine_atalla();
  282|      1|    if (!toadd)
  283|      0|        return;
  284|      1|    ENGINE_add(toadd);
  285|      1|    ENGINE_free(toadd);
  286|      1|    ERR_clear_error();
  287|      1|}
e_atalla.c:engine_atalla:
  267|      1|{
  268|      1|    ENGINE *ret = ENGINE_new();
  269|      1|    if (!ret)
  270|      0|        return NULL;
  271|      1|    if (!bind_helper(ret)) {
  272|      0|        ENGINE_free(ret);
  273|      0|        return NULL;
  274|      0|    }
  275|      1|    return ret;
  276|      1|}
e_atalla.c:bind_helper:
  199|      1|{
  200|      1|#  ifndef OPENSSL_NO_RSA
  201|      1|    const RSA_METHOD *meth1;
  202|      1|#  endif
  203|      1|#  ifndef OPENSSL_NO_DSA
  204|      1|    const DSA_METHOD *meth2;
  205|      1|#  endif
  206|      1|#  ifndef OPENSSL_NO_DH
  207|      1|    const DH_METHOD *meth3;
  208|      1|#  endif
  209|      1|    if (!ENGINE_set_id(e, engine_atalla_id) ||
  210|      1|        !ENGINE_set_name(e, engine_atalla_name) ||
  211|      1|#  ifndef OPENSSL_NO_RSA
  212|      1|        !ENGINE_set_RSA(e, &atalla_rsa) ||
  213|      1|#  endif
  214|      1|#  ifndef OPENSSL_NO_DSA
  215|      1|        !ENGINE_set_DSA(e, &atalla_dsa) ||
  216|      1|#  endif
  217|      1|#  ifndef OPENSSL_NO_DH
  218|      1|        !ENGINE_set_DH(e, &atalla_dh) ||
  219|      1|#  endif
  220|      1|        !ENGINE_set_destroy_function(e, atalla_destroy) ||
  221|      1|        !ENGINE_set_init_function(e, atalla_init) ||
  222|      1|        !ENGINE_set_finish_function(e, atalla_finish) ||
  223|      1|        !ENGINE_set_ctrl_function(e, atalla_ctrl) ||
  224|      1|        !ENGINE_set_cmd_defns(e, atalla_cmd_defns))
  225|      0|        return 0;
  226|       |
  227|      1|#  ifndef OPENSSL_NO_RSA
  228|       |    /*
  229|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  230|       |     * atalla-specific mod_exp and mod_exp_crt so we use those functions. NB:
  231|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  232|       |     * something like the RSAref code may not hook properly, and if you own
  233|       |     * one of these cards then you have the right to do RSA operations on it
  234|       |     * anyway!
  235|       |     */
  236|      1|    meth1 = RSA_PKCS1_SSLeay();
  237|      1|    atalla_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  238|      1|    atalla_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  239|      1|    atalla_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  240|      1|    atalla_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  241|      1|#  endif
  242|       |
  243|      1|#  ifndef OPENSSL_NO_DSA
  244|       |    /*
  245|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  246|       |     */
  247|      1|    meth2 = DSA_OpenSSL();
  248|      1|    atalla_dsa.dsa_do_sign = meth2->dsa_do_sign;
  249|      1|    atalla_dsa.dsa_sign_setup = meth2->dsa_sign_setup;
  250|      1|    atalla_dsa.dsa_do_verify = meth2->dsa_do_verify;
  251|      1|#  endif
  252|       |
  253|      1|#  ifndef OPENSSL_NO_DH
  254|       |    /* Much the same for Diffie-Hellman */
  255|      1|    meth3 = DH_OpenSSL();
  256|      1|    atalla_dh.generate_key = meth3->generate_key;
  257|      1|    atalla_dh.compute_key = meth3->compute_key;
  258|      1|#  endif
  259|       |
  260|       |    /* Ensure the atalla error handling is set up */
  261|      1|    ERR_load_ATALLA_strings();
  262|      1|    return 1;
  263|      1|}

e_atalla.c:ERR_load_ATALLA_strings:
  107|      1|{
  108|      1|    if (ATALLA_lib_error_code == 0)
  109|      1|        ATALLA_lib_error_code = ERR_get_next_error_library();
  110|       |
  111|      1|    if (ATALLA_error_init) {
  112|      1|        ATALLA_error_init = 0;
  113|      1|#ifndef OPENSSL_NO_ERR
  114|      1|        ERR_load_strings(ATALLA_lib_error_code, ATALLA_str_functs);
  115|      1|        ERR_load_strings(ATALLA_lib_error_code, ATALLA_str_reasons);
  116|      1|#endif
  117|       |
  118|      1|#ifdef ATALLA_LIB_NAME
  119|      1|        ATALLA_lib_name->error = ERR_PACK(ATALLA_lib_error_code, 0, 0);
  120|      1|        ERR_load_strings(0, ATALLA_lib_name);
  121|      1|#endif
  122|      1|    }
  123|      1|}

ENGINE_load_chil:
  419|      1|{
  420|       |    /* Copied from eng_[openssl|dyn].c */
  421|      1|    ENGINE *toadd = engine_chil();
  422|      1|    if (!toadd)
  423|      0|        return;
  424|      1|    ENGINE_add(toadd);
  425|      1|    ENGINE_free(toadd);
  426|      1|    ERR_clear_error();
  427|      1|}
e_chil.c:engine_chil:
  407|      1|{
  408|      1|    ENGINE *ret = ENGINE_new();
  409|      1|    if (!ret)
  410|      0|        return NULL;
  411|      1|    if (!bind_helper(ret)) {
  412|      0|        ENGINE_free(ret);
  413|      0|        return NULL;
  414|      0|    }
  415|      1|    return ret;
  416|      1|}
e_chil.c:bind_helper:
  352|      1|{
  353|      1|#  ifndef OPENSSL_NO_RSA
  354|      1|    const RSA_METHOD *meth1;
  355|      1|#  endif
  356|      1|#  ifndef OPENSSL_NO_DH
  357|      1|    const DH_METHOD *meth2;
  358|      1|#  endif
  359|      1|    if (!ENGINE_set_id(e, engine_hwcrhk_id) ||
  360|      1|        !ENGINE_set_name(e, engine_hwcrhk_name) ||
  361|      1|#  ifndef OPENSSL_NO_RSA
  362|      1|        !ENGINE_set_RSA(e, &hwcrhk_rsa) ||
  363|      1|#  endif
  364|      1|#  ifndef OPENSSL_NO_DH
  365|      1|        !ENGINE_set_DH(e, &hwcrhk_dh) ||
  366|      1|#  endif
  367|      1|        !ENGINE_set_RAND(e, &hwcrhk_rand) ||
  368|      1|        !ENGINE_set_destroy_function(e, hwcrhk_destroy) ||
  369|      1|        !ENGINE_set_init_function(e, hwcrhk_init) ||
  370|      1|        !ENGINE_set_finish_function(e, hwcrhk_finish) ||
  371|      1|        !ENGINE_set_ctrl_function(e, hwcrhk_ctrl) ||
  372|      1|        !ENGINE_set_load_privkey_function(e, hwcrhk_load_privkey) ||
  373|      1|        !ENGINE_set_load_pubkey_function(e, hwcrhk_load_pubkey) ||
  374|      1|        !ENGINE_set_cmd_defns(e, hwcrhk_cmd_defns))
  375|      0|        return 0;
  376|       |
  377|      1|#  ifndef OPENSSL_NO_RSA
  378|       |    /*
  379|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  380|       |     * cswift-specific mod_exp and mod_exp_crt so we use those functions. NB:
  381|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  382|       |     * something like the RSAref code may not hook properly, and if you own
  383|       |     * one of these cards then you have the right to do RSA operations on it
  384|       |     * anyway!
  385|       |     */
  386|      1|    meth1 = RSA_PKCS1_SSLeay();
  387|      1|    hwcrhk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  388|      1|    hwcrhk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  389|      1|    hwcrhk_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  390|      1|    hwcrhk_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  391|      1|#  endif
  392|       |
  393|      1|#  ifndef OPENSSL_NO_DH
  394|       |    /* Much the same for Diffie-Hellman */
  395|      1|    meth2 = DH_OpenSSL();
  396|      1|    hwcrhk_dh.generate_key = meth2->generate_key;
  397|      1|    hwcrhk_dh.compute_key = meth2->compute_key;
  398|      1|#  endif
  399|       |
  400|       |    /* Ensure the hwcrhk error handling is set up */
  401|      1|    ERR_load_HWCRHK_strings();
  402|      1|    return 1;
  403|      1|}
e_chil.c:hwcrhk_init:
  536|      1|{
  537|      1|    HWCryptoHook_Init_t *p1;
  538|      1|    HWCryptoHook_Finish_t *p2;
  539|      1|    HWCryptoHook_ModExp_t *p3;
  540|      1|#  ifndef OPENSSL_NO_RSA
  541|      1|    HWCryptoHook_RSA_t *p4;
  542|      1|    HWCryptoHook_RSALoadKey_t *p5;
  543|      1|    HWCryptoHook_RSAGetPublicKey_t *p6;
  544|      1|    HWCryptoHook_RSAUnloadKey_t *p7;
  545|      1|#  endif
  546|      1|    HWCryptoHook_RandomBytes_t *p8;
  547|      1|    HWCryptoHook_ModExpCRT_t *p9;
  548|       |
  549|      1|    if (hwcrhk_dso != NULL) {
  550|      0|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_ALREADY_LOADED);
  551|      0|        goto err;
  552|      0|    }
  553|       |    /* Attempt to load libnfhwcrhk.so/nfhwcrhk.dll/whatever. */
  554|      1|    hwcrhk_dso = DSO_load(NULL, get_HWCRHK_LIBNAME(), NULL, 0);
  555|      1|    if (hwcrhk_dso == NULL) {
  556|      1|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_DSO_FAILURE);
  557|      1|        goto err;
  558|      1|    }
  559|      0|    if (!(p1 = (HWCryptoHook_Init_t *)
  560|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_Init)) ||
  561|      0|        !(p2 = (HWCryptoHook_Finish_t *)
  562|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_Finish)) ||
  563|      0|        !(p3 = (HWCryptoHook_ModExp_t *)
  564|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExp)) ||
  565|      0|#  ifndef OPENSSL_NO_RSA
  566|      0|        !(p4 = (HWCryptoHook_RSA_t *)
  567|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSA)) ||
  568|      0|        !(p5 = (HWCryptoHook_RSALoadKey_t *)
  569|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSALoadKey)) ||
  570|      0|        !(p6 = (HWCryptoHook_RSAGetPublicKey_t *)
  571|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAGetPublicKey)) ||
  572|      0|        !(p7 = (HWCryptoHook_RSAUnloadKey_t *)
  573|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAUnloadKey)) ||
  574|      0|#  endif
  575|      0|        !(p8 = (HWCryptoHook_RandomBytes_t *)
  576|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RandomBytes)) ||
  577|      0|        !(p9 = (HWCryptoHook_ModExpCRT_t *)
  578|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExpCRT))) {
  579|      0|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_DSO_FAILURE);
  580|      0|        goto err;
  581|      0|    }
  582|       |    /* Copy the pointers */
  583|      0|    p_hwcrhk_Init = p1;
  584|      0|    p_hwcrhk_Finish = p2;
  585|      0|    p_hwcrhk_ModExp = p3;
  586|      0|#  ifndef OPENSSL_NO_RSA
  587|      0|    p_hwcrhk_RSA = p4;
  588|      0|    p_hwcrhk_RSALoadKey = p5;
  589|      0|    p_hwcrhk_RSAGetPublicKey = p6;
  590|      0|    p_hwcrhk_RSAUnloadKey = p7;
  591|      0|#  endif
  592|      0|    p_hwcrhk_RandomBytes = p8;
  593|      0|    p_hwcrhk_ModExpCRT = p9;
  594|       |
  595|       |    /*
  596|       |     * Check if the application decided to support dynamic locks, and if it
  597|       |     * does, use them.
  598|       |     */
  599|      0|    if (disable_mutex_callbacks == 0) {
  600|      0|        if (CRYPTO_get_dynlock_create_callback() != NULL &&
  601|      0|            CRYPTO_get_dynlock_lock_callback() != NULL &&
  602|      0|            CRYPTO_get_dynlock_destroy_callback() != NULL) {
  603|      0|            hwcrhk_globals.mutex_init = hwcrhk_mutex_init;
  604|      0|            hwcrhk_globals.mutex_acquire = hwcrhk_mutex_lock;
  605|      0|            hwcrhk_globals.mutex_release = hwcrhk_mutex_unlock;
  606|      0|            hwcrhk_globals.mutex_destroy = hwcrhk_mutex_destroy;
  607|      0|        }
  608|      0|    }
  609|       |
  610|       |    /*
  611|       |     * Try and get a context - if not, we may have a DSO but no accelerator!
  612|       |     */
  613|      0|    if (!get_context(&hwcrhk_context, &password_context)) {
  614|      0|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_UNIT_FAILURE);
  615|      0|        goto err;
  616|      0|    }
  617|       |    /* Everything's fine. */
  618|      0|#  ifndef OPENSSL_NO_RSA
  619|      0|    if (hndidx_rsa == -1)
  620|      0|        hndidx_rsa = RSA_get_ex_new_index(0,
  621|      0|                                          "nFast HWCryptoHook RSA key handle",
  622|      0|                                          NULL, NULL, NULL);
  623|      0|#  endif
  624|      0|    return 1;
  625|      1| err:
  626|      1|    if (hwcrhk_dso)
  627|      0|        DSO_free(hwcrhk_dso);
  628|      1|    hwcrhk_dso = NULL;
  629|      1|    p_hwcrhk_Init = NULL;
  630|      1|    p_hwcrhk_Finish = NULL;
  631|      1|    p_hwcrhk_ModExp = NULL;
  632|      1|#  ifndef OPENSSL_NO_RSA
  633|      1|    p_hwcrhk_RSA = NULL;
  634|      1|    p_hwcrhk_RSALoadKey = NULL;
  635|      1|    p_hwcrhk_RSAGetPublicKey = NULL;
  636|      1|    p_hwcrhk_RSAUnloadKey = NULL;
  637|      1|#  endif
  638|      1|    p_hwcrhk_ModExpCRT = NULL;
  639|      1|    p_hwcrhk_RandomBytes = NULL;
  640|      1|    return 0;
  641|      0|}
e_chil.c:get_HWCRHK_LIBNAME:
  471|      1|{
  472|      1|    if (HWCRHK_LIBNAME)
  473|      0|        return HWCRHK_LIBNAME;
  474|      1|    return "nfhwcrhk";
  475|      1|}

e_chil.c:ERR_HWCRHK_error:
  153|      1|{
  154|      1|    if (HWCRHK_lib_error_code == 0)
  155|      0|        HWCRHK_lib_error_code = ERR_get_next_error_library();
  156|      1|    ERR_PUT_error(HWCRHK_lib_error_code, function, reason, file, line);
  157|      1|}
e_chil.c:ERR_load_HWCRHK_strings:
  119|      1|{
  120|      1|    if (HWCRHK_lib_error_code == 0)
  121|      1|        HWCRHK_lib_error_code = ERR_get_next_error_library();
  122|       |
  123|      1|    if (HWCRHK_error_init) {
  124|      1|        HWCRHK_error_init = 0;
  125|      1|#ifndef OPENSSL_NO_ERR
  126|      1|        ERR_load_strings(HWCRHK_lib_error_code, HWCRHK_str_functs);
  127|      1|        ERR_load_strings(HWCRHK_lib_error_code, HWCRHK_str_reasons);
  128|      1|#endif
  129|       |
  130|      1|#ifdef HWCRHK_LIB_NAME
  131|      1|        HWCRHK_lib_name->error = ERR_PACK(HWCRHK_lib_error_code, 0, 0);
  132|      1|        ERR_load_strings(0, HWCRHK_lib_name);
  133|      1|#endif
  134|      1|    }
  135|      1|}

ENGINE_load_cswift:
  302|      1|{
  303|       |    /* Copied from eng_[openssl|dyn].c */
  304|      1|    ENGINE *toadd = engine_cswift();
  305|      1|    if (!toadd)
  306|      0|        return;
  307|      1|    ENGINE_add(toadd);
  308|      1|    ENGINE_free(toadd);
  309|      1|    ERR_clear_error();
  310|      1|}
e_cswift.c:engine_cswift:
  290|      1|{
  291|      1|    ENGINE *ret = ENGINE_new();
  292|      1|    if (!ret)
  293|      0|        return NULL;
  294|      1|    if (!bind_helper(ret)) {
  295|      0|        ENGINE_free(ret);
  296|      0|        return NULL;
  297|      0|    }
  298|      1|    return ret;
  299|      1|}
e_cswift.c:bind_helper:
  234|      1|{
  235|      1|#  ifndef OPENSSL_NO_RSA
  236|      1|    const RSA_METHOD *meth1;
  237|      1|#  endif
  238|      1|#  ifndef OPENSSL_NO_DH
  239|      1|    const DH_METHOD *meth2;
  240|      1|#  endif
  241|      1|    if (!ENGINE_set_id(e, engine_cswift_id) ||
  242|      1|        !ENGINE_set_name(e, engine_cswift_name) ||
  243|      1|#  ifndef OPENSSL_NO_RSA
  244|      1|        !ENGINE_set_RSA(e, &cswift_rsa) ||
  245|      1|#  endif
  246|      1|#  ifndef OPENSSL_NO_DSA
  247|      1|        !ENGINE_set_DSA(e, &cswift_dsa) ||
  248|      1|#  endif
  249|      1|#  ifndef OPENSSL_NO_DH
  250|      1|        !ENGINE_set_DH(e, &cswift_dh) ||
  251|      1|#  endif
  252|      1|        !ENGINE_set_RAND(e, &cswift_random) ||
  253|      1|        !ENGINE_set_destroy_function(e, cswift_destroy) ||
  254|      1|        !ENGINE_set_init_function(e, cswift_init) ||
  255|      1|        !ENGINE_set_finish_function(e, cswift_finish) ||
  256|      1|        !ENGINE_set_ctrl_function(e, cswift_ctrl) ||
  257|      1|        !ENGINE_set_cmd_defns(e, cswift_cmd_defns))
  258|      0|        return 0;
  259|       |
  260|      1|#  ifndef OPENSSL_NO_RSA
  261|       |    /*
  262|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  263|       |     * cswift-specific mod_exp and mod_exp_crt so we use those functions. NB:
  264|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  265|       |     * something like the RSAref code may not hook properly, and if you own
  266|       |     * one of these cards then you have the right to do RSA operations on it
  267|       |     * anyway!
  268|       |     */
  269|      1|    meth1 = RSA_PKCS1_SSLeay();
  270|      1|    cswift_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  271|      1|    cswift_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  272|      1|    cswift_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  273|      1|    cswift_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  274|      1|#  endif
  275|       |
  276|      1|#  ifndef OPENSSL_NO_DH
  277|       |    /* Much the same for Diffie-Hellman */
  278|      1|    meth2 = DH_OpenSSL();
  279|      1|    cswift_dh.generate_key = meth2->generate_key;
  280|      1|    cswift_dh.compute_key = meth2->compute_key;
  281|      1|#  endif
  282|       |
  283|       |    /* Ensure the cswift error handling is set up */
  284|      1|    ERR_load_CSWIFT_strings();
  285|      1|    return 1;
  286|      1|}
e_cswift.c:cswift_init:
  391|      1|{
  392|      1|    SW_CONTEXT_HANDLE hac;
  393|      1|    t_swAcquireAccContext *p1;
  394|      1|    t_swAttachKeyParam *p2;
  395|      1|    t_swSimpleRequest *p3;
  396|      1|    t_swReleaseAccContext *p4;
  397|       |
  398|      1|    if (cswift_dso != NULL) {
  399|      0|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_ALREADY_LOADED);
  400|      0|        goto err;
  401|      0|    }
  402|       |    /* Attempt to load libswift.so/swift.dll/whatever. */
  403|      1|    cswift_dso = DSO_load(NULL, get_CSWIFT_LIBNAME(), NULL, 0);
  404|      1|    if (cswift_dso == NULL) {
  405|      1|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_NOT_LOADED);
  406|      1|        goto err;
  407|      1|    }
  408|      0|    if (!(p1 = (t_swAcquireAccContext *)
  409|      0|          DSO_bind_func(cswift_dso, CSWIFT_F1)) ||
  410|      0|        !(p2 = (t_swAttachKeyParam *)
  411|      0|          DSO_bind_func(cswift_dso, CSWIFT_F2)) ||
  412|      0|        !(p3 = (t_swSimpleRequest *)
  413|      0|          DSO_bind_func(cswift_dso, CSWIFT_F3)) ||
  414|      0|        !(p4 = (t_swReleaseAccContext *)
  415|      0|          DSO_bind_func(cswift_dso, CSWIFT_F4))) {
  416|      0|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_NOT_LOADED);
  417|      0|        goto err;
  418|      0|    }
  419|       |    /* Copy the pointers */
  420|      0|    p_CSwift_AcquireAccContext = p1;
  421|      0|    p_CSwift_AttachKeyParam = p2;
  422|      0|    p_CSwift_SimpleRequest = p3;
  423|      0|    p_CSwift_ReleaseAccContext = p4;
  424|       |    /*
  425|       |     * Try and get a context - if not, we may have a DSO but no accelerator!
  426|       |     */
  427|      0|    if (!get_context(&hac)) {
  428|      0|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_UNIT_FAILURE);
  429|      0|        goto err;
  430|      0|    }
  431|      0|    release_context(hac);
  432|       |    /* Everything's fine. */
  433|      0|    return 1;
  434|      1| err:
  435|      1|    if (cswift_dso) {
  436|      0|        DSO_free(cswift_dso);
  437|      0|        cswift_dso = NULL;
  438|      0|    }
  439|      1|    p_CSwift_AcquireAccContext = NULL;
  440|      1|    p_CSwift_AttachKeyParam = NULL;
  441|      1|    p_CSwift_SimpleRequest = NULL;
  442|      1|    p_CSwift_ReleaseAccContext = NULL;
  443|      1|    return 0;
  444|      0|}
e_cswift.c:get_CSWIFT_LIBNAME:
  333|      1|{
  334|      1|    if (CSWIFT_LIBNAME)
  335|      0|        return CSWIFT_LIBNAME;
  336|      1|    return "swift";
  337|      1|}

e_cswift.c:ERR_CSWIFT_error:
  146|      1|{
  147|      1|    if (CSWIFT_lib_error_code == 0)
  148|      0|        CSWIFT_lib_error_code = ERR_get_next_error_library();
  149|      1|    ERR_PUT_error(CSWIFT_lib_error_code, function, reason, file, line);
  150|      1|}
e_cswift.c:ERR_load_CSWIFT_strings:
  112|      1|{
  113|      1|    if (CSWIFT_lib_error_code == 0)
  114|      1|        CSWIFT_lib_error_code = ERR_get_next_error_library();
  115|       |
  116|      1|    if (CSWIFT_error_init) {
  117|      1|        CSWIFT_error_init = 0;
  118|      1|#ifndef OPENSSL_NO_ERR
  119|      1|        ERR_load_strings(CSWIFT_lib_error_code, CSWIFT_str_functs);
  120|      1|        ERR_load_strings(CSWIFT_lib_error_code, CSWIFT_str_reasons);
  121|      1|#endif
  122|       |
  123|      1|#ifdef CSWIFT_LIB_NAME
  124|      1|        CSWIFT_lib_name->error = ERR_PACK(CSWIFT_lib_error_code, 0, 0);
  125|      1|        ERR_load_strings(0, CSWIFT_lib_name);
  126|      1|#endif
  127|      1|    }
  128|      1|}

ENGINE_load_nuron:
  407|      1|{
  408|       |    /* Copied from eng_[openssl|dyn].c */
  409|      1|    ENGINE *toadd = engine_nuron();
  410|      1|    if (!toadd)
  411|      0|        return;
  412|      1|    ENGINE_add(toadd);
  413|      1|    ENGINE_free(toadd);
  414|      1|    ERR_clear_error();
  415|      1|}
e_nuron.c:engine_nuron:
  395|      1|{
  396|      1|    ENGINE *ret = ENGINE_new();
  397|      1|    if (!ret)
  398|      0|        return NULL;
  399|      1|    if (!bind_helper(ret)) {
  400|      0|        ENGINE_free(ret);
  401|      0|        return NULL;
  402|      0|    }
  403|      1|    return ret;
  404|      1|}
e_nuron.c:bind_helper:
  327|      1|{
  328|      1|#  ifndef OPENSSL_NO_RSA
  329|      1|    const RSA_METHOD *meth1;
  330|      1|#  endif
  331|      1|#  ifndef OPENSSL_NO_DSA
  332|      1|    const DSA_METHOD *meth2;
  333|      1|#  endif
  334|      1|#  ifndef OPENSSL_NO_DH
  335|      1|    const DH_METHOD *meth3;
  336|      1|#  endif
  337|      1|    if (!ENGINE_set_id(e, engine_nuron_id) ||
  338|      1|        !ENGINE_set_name(e, engine_nuron_name) ||
  339|      1|#  ifndef OPENSSL_NO_RSA
  340|      1|        !ENGINE_set_RSA(e, &nuron_rsa) ||
  341|      1|#  endif
  342|      1|#  ifndef OPENSSL_NO_DSA
  343|      1|        !ENGINE_set_DSA(e, &nuron_dsa) ||
  344|      1|#  endif
  345|      1|#  ifndef OPENSSL_NO_DH
  346|      1|        !ENGINE_set_DH(e, &nuron_dh) ||
  347|      1|#  endif
  348|      1|        !ENGINE_set_destroy_function(e, nuron_destroy) ||
  349|      1|        !ENGINE_set_init_function(e, nuron_init) ||
  350|      1|        !ENGINE_set_finish_function(e, nuron_finish) ||
  351|      1|        !ENGINE_set_ctrl_function(e, nuron_ctrl) ||
  352|      1|        !ENGINE_set_cmd_defns(e, nuron_cmd_defns))
  353|      0|        return 0;
  354|       |
  355|      1|#  ifndef OPENSSL_NO_RSA
  356|       |    /*
  357|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  358|       |     * nuron-specific mod_exp and mod_exp_crt so we use those functions. NB:
  359|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  360|       |     * something like the RSAref code may not hook properly, and if you own
  361|       |     * one of these cards then you have the right to do RSA operations on it
  362|       |     * anyway!
  363|       |     */
  364|      1|    meth1 = RSA_PKCS1_SSLeay();
  365|      1|    nuron_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  366|      1|    nuron_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  367|      1|    nuron_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  368|      1|    nuron_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  369|      1|#  endif
  370|       |
  371|      1|#  ifndef OPENSSL_NO_DSA
  372|       |    /*
  373|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  374|       |     */
  375|      1|    meth2 = DSA_OpenSSL();
  376|      1|    nuron_dsa.dsa_do_sign = meth2->dsa_do_sign;
  377|      1|    nuron_dsa.dsa_sign_setup = meth2->dsa_sign_setup;
  378|      1|    nuron_dsa.dsa_do_verify = meth2->dsa_do_verify;
  379|      1|#  endif
  380|       |
  381|      1|#  ifndef OPENSSL_NO_DH
  382|       |    /* Much the same for Diffie-Hellman */
  383|      1|    meth3 = DH_OpenSSL();
  384|      1|    nuron_dh.generate_key = meth3->generate_key;
  385|      1|    nuron_dh.compute_key = meth3->compute_key;
  386|      1|#  endif
  387|       |
  388|       |    /* Ensure the nuron error handling is set up */
  389|      1|    ERR_load_NURON_strings();
  390|      1|    return 1;
  391|      1|}

e_nuron.c:ERR_load_NURON_strings:
  104|      1|{
  105|      1|    if (NURON_lib_error_code == 0)
  106|      1|        NURON_lib_error_code = ERR_get_next_error_library();
  107|       |
  108|      1|    if (NURON_error_init) {
  109|      1|        NURON_error_init = 0;
  110|      1|#ifndef OPENSSL_NO_ERR
  111|      1|        ERR_load_strings(NURON_lib_error_code, NURON_str_functs);
  112|      1|        ERR_load_strings(NURON_lib_error_code, NURON_str_reasons);
  113|      1|#endif
  114|       |
  115|      1|#ifdef NURON_LIB_NAME
  116|      1|        NURON_lib_name->error = ERR_PACK(NURON_lib_error_code, 0, 0);
  117|      1|        ERR_load_strings(0, NURON_lib_name);
  118|      1|#endif
  119|      1|    }
  120|      1|}

ENGINE_load_padlock:
  116|      1|{
  117|       |/* On non-x86 CPUs it just returns. */
  118|       |#   ifdef COMPILE_HW_PADLOCK
  119|       |    ENGINE *toadd = ENGINE_padlock();
  120|       |    if (!toadd)
  121|       |        return;
  122|       |    ENGINE_add(toadd);
  123|       |    ENGINE_free(toadd);
  124|       |    ERR_clear_error();
  125|       |#   endif
  126|      1|}

ENGINE_load_sureware:
  330|      1|{
  331|       |    /* Copied from eng_[openssl|dyn].c */
  332|      1|    ENGINE *toadd = engine_sureware();
  333|      1|    if (!toadd)
  334|      0|        return;
  335|      1|    ENGINE_add(toadd);
  336|      1|    ENGINE_free(toadd);
  337|      1|    ERR_clear_error();
  338|      1|}
e_sureware.c:engine_sureware:
  318|      1|{
  319|      1|    ENGINE *ret = ENGINE_new();
  320|      1|    if (!ret)
  321|      0|        return NULL;
  322|      1|    if (!bind_sureware(ret)) {
  323|      0|        ENGINE_free(ret);
  324|      0|        return NULL;
  325|      0|    }
  326|      1|    return ret;
  327|      1|}
e_sureware.c:bind_sureware:
  233|      1|{
  234|      1|#  ifndef OPENSSL_NO_RSA
  235|      1|    const RSA_METHOD *meth1;
  236|      1|#  endif
  237|      1|#  ifndef OPENSSL_NO_DSA
  238|      1|    const DSA_METHOD *meth2;
  239|      1|#  endif
  240|      1|#  ifndef OPENSSL_NO_DH
  241|      1|    const DH_METHOD *meth3;
  242|      1|#  endif
  243|       |
  244|      1|    if (!ENGINE_set_id(e, engine_sureware_id) ||
  245|      1|        !ENGINE_set_name(e, engine_sureware_name) ||
  246|      1|#  ifndef OPENSSL_NO_RSA
  247|      1|        !ENGINE_set_RSA(e, &surewarehk_rsa) ||
  248|      1|#  endif
  249|      1|#  ifndef OPENSSL_NO_DSA
  250|      1|        !ENGINE_set_DSA(e, &surewarehk_dsa) ||
  251|      1|#  endif
  252|      1|#  ifndef OPENSSL_NO_DH
  253|      1|        !ENGINE_set_DH(e, &surewarehk_dh) ||
  254|      1|#  endif
  255|      1|        !ENGINE_set_RAND(e, &surewarehk_rand) ||
  256|      1|        !ENGINE_set_destroy_function(e, surewarehk_destroy) ||
  257|      1|        !ENGINE_set_init_function(e, surewarehk_init) ||
  258|      1|        !ENGINE_set_finish_function(e, surewarehk_finish) ||
  259|      1|        !ENGINE_set_ctrl_function(e, surewarehk_ctrl) ||
  260|      1|        !ENGINE_set_load_privkey_function(e, surewarehk_load_privkey) ||
  261|      1|        !ENGINE_set_load_pubkey_function(e, surewarehk_load_pubkey))
  262|      0|        return 0;
  263|       |
  264|      1|#  ifndef OPENSSL_NO_RSA
  265|       |    /*
  266|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  267|       |     * cswift-specific mod_exp and mod_exp_crt so we use those functions. NB:
  268|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  269|       |     * something like the RSAref code may not hook properly, and if you own
  270|       |     * one of these cards then you have the right to do RSA operations on it
  271|       |     * anyway!
  272|       |     */
  273|      1|    meth1 = RSA_PKCS1_SSLeay();
  274|      1|    if (meth1) {
  275|      1|        surewarehk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  276|      1|        surewarehk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  277|      1|    }
  278|      1|#  endif
  279|       |
  280|      1|#  ifndef OPENSSL_NO_DSA
  281|       |    /*
  282|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  283|       |     */
  284|      1|    meth2 = DSA_OpenSSL();
  285|      1|    if (meth2) {
  286|      1|        surewarehk_dsa.dsa_do_verify = meth2->dsa_do_verify;
  287|      1|    }
  288|      1|#  endif
  289|       |
  290|      1|#  ifndef OPENSSL_NO_DH
  291|       |    /* Much the same for Diffie-Hellman */
  292|      1|    meth3 = DH_OpenSSL();
  293|      1|    if (meth3) {
  294|      1|        surewarehk_dh.generate_key = meth3->generate_key;
  295|      1|        surewarehk_dh.compute_key = meth3->compute_key;
  296|      1|    }
  297|      1|#  endif
  298|       |
  299|       |    /* Ensure the sureware error handling is set up */
  300|      1|    ERR_load_SUREWARE_strings();
  301|      1|    return 1;
  302|      1|}
e_sureware.c:surewarehk_init:
  456|      1|{
  457|      1|    char msg[64] = "ENGINE_init";
  458|      1|    SureWareHook_Init_t *p1 = NULL;
  459|      1|    SureWareHook_Finish_t *p2 = NULL;
  460|      1|    SureWareHook_Rand_Bytes_t *p3 = NULL;
  461|      1|    SureWareHook_Rand_Seed_t *p4 = NULL;
  462|      1|    SureWareHook_Load_Privkey_t *p5 = NULL;
  463|      1|    SureWareHook_Load_Rsa_Pubkey_t *p6 = NULL;
  464|      1|    SureWareHook_Free_t *p7 = NULL;
  465|      1|    SureWareHook_Rsa_Priv_Dec_t *p8 = NULL;
  466|      1|    SureWareHook_Rsa_Sign_t *p9 = NULL;
  467|      1|    SureWareHook_Dsa_Sign_t *p12 = NULL;
  468|      1|    SureWareHook_Info_Pubkey_t *p13 = NULL;
  469|      1|    SureWareHook_Load_Dsa_Pubkey_t *p14 = NULL;
  470|      1|    SureWareHook_Mod_Exp_t *p15 = NULL;
  471|       |
  472|      1|    if (surewarehk_dso != NULL) {
  473|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, ENGINE_R_ALREADY_LOADED);
  474|      0|        goto err;
  475|      0|    }
  476|       |    /* Attempt to load libsurewarehk.so/surewarehk.dll/whatever. */
  477|      1|    surewarehk_dso = DSO_load(NULL, surewarehk_LIBNAME, NULL, 0);
  478|      1|    if (surewarehk_dso == NULL) {
  479|      1|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, ENGINE_R_DSO_FAILURE);
  480|      1|        goto err;
  481|      1|    }
  482|      0|    if (!
  483|      0|        (p1 =
  484|      0|         (SureWareHook_Init_t *) DSO_bind_func(surewarehk_dso,
  485|      0|                                               n_surewarehk_Init))
  486|      0||| !(p2 =
  487|      0|     (SureWareHook_Finish_t *) DSO_bind_func(surewarehk_dso,
  488|      0|                                             n_surewarehk_Finish))
  489|      0||| !(p3 =
  490|      0|     (SureWareHook_Rand_Bytes_t *) DSO_bind_func(surewarehk_dso,
  491|      0|                                                 n_surewarehk_Rand_Bytes))
  492|      0||| !(p4 =
  493|      0|     (SureWareHook_Rand_Seed_t *) DSO_bind_func(surewarehk_dso,
  494|      0|                                                n_surewarehk_Rand_Seed))
  495|      0||| !(p5 =
  496|      0|     (SureWareHook_Load_Privkey_t *) DSO_bind_func(surewarehk_dso,
  497|      0|                                                   n_surewarehk_Load_Privkey))
  498|      0||| !(p6 =
  499|      0|     (SureWareHook_Load_Rsa_Pubkey_t *) DSO_bind_func(surewarehk_dso,
  500|      0|                                                      n_surewarehk_Load_Rsa_Pubkey))
  501|      0||| !(p7 =
  502|      0|     (SureWareHook_Free_t *) DSO_bind_func(surewarehk_dso, n_surewarehk_Free))
  503|      0||| !(p8 =
  504|      0|     (SureWareHook_Rsa_Priv_Dec_t *) DSO_bind_func(surewarehk_dso,
  505|      0|                                                   n_surewarehk_Rsa_Priv_Dec))
  506|      0||| !(p9 =
  507|      0|     (SureWareHook_Rsa_Sign_t *) DSO_bind_func(surewarehk_dso,
  508|      0|                                               n_surewarehk_Rsa_Sign))
  509|      0||| !(p12 =
  510|      0|     (SureWareHook_Dsa_Sign_t *) DSO_bind_func(surewarehk_dso,
  511|      0|                                               n_surewarehk_Dsa_Sign))
  512|      0||| !(p13 =
  513|      0|     (SureWareHook_Info_Pubkey_t *) DSO_bind_func(surewarehk_dso,
  514|      0|                                                  n_surewarehk_Info_Pubkey))
  515|      0||| !(p14 =
  516|      0|     (SureWareHook_Load_Dsa_Pubkey_t *) DSO_bind_func(surewarehk_dso,
  517|      0|                                                      n_surewarehk_Load_Dsa_Pubkey))
  518|      0||| !(p15 =
  519|      0|     (SureWareHook_Mod_Exp_t *) DSO_bind_func(surewarehk_dso,
  520|      0|                                              n_surewarehk_Mod_Exp))) {
  521|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, ENGINE_R_DSO_FAILURE);
  522|      0|        goto err;
  523|      0|    }
  524|       |    /* Copy the pointers */
  525|      0|    p_surewarehk_Init = p1;
  526|      0|    p_surewarehk_Finish = p2;
  527|      0|    p_surewarehk_Rand_Bytes = p3;
  528|      0|    p_surewarehk_Rand_Seed = p4;
  529|      0|    p_surewarehk_Load_Privkey = p5;
  530|      0|    p_surewarehk_Load_Rsa_Pubkey = p6;
  531|      0|    p_surewarehk_Free = p7;
  532|      0|    p_surewarehk_Rsa_Priv_Dec = p8;
  533|      0|    p_surewarehk_Rsa_Sign = p9;
  534|      0|    p_surewarehk_Dsa_Sign = p12;
  535|      0|    p_surewarehk_Info_Pubkey = p13;
  536|      0|    p_surewarehk_Load_Dsa_Pubkey = p14;
  537|      0|    p_surewarehk_Mod_Exp = p15;
  538|       |    /* Contact the hardware and initialises it. */
  539|      0|    if (p_surewarehk_Init(msg, threadsafe) == SUREWAREHOOK_ERROR_UNIT_FAILURE) {
  540|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, SUREWARE_R_UNIT_FAILURE);
  541|      0|        goto err;
  542|      0|    }
  543|      0|    if (p_surewarehk_Init(msg, threadsafe) == SUREWAREHOOK_ERROR_UNIT_FAILURE) {
  544|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, SUREWARE_R_UNIT_FAILURE);
  545|      0|        goto err;
  546|      0|    }
  547|       |    /*
  548|       |     * try to load the default private key, if failed does not return a
  549|       |     * failure but wait for an explicit ENGINE_load_privakey
  550|       |     */
  551|      0|    surewarehk_load_privkey(e, NULL, NULL, NULL);
  552|       |
  553|       |    /* Everything's fine. */
  554|      0|#  ifndef OPENSSL_NO_RSA
  555|      0|    if (rsaHndidx == -1)
  556|      0|        rsaHndidx = RSA_get_ex_new_index(0,
  557|      0|                                         "SureWareHook RSA key handle",
  558|      0|                                         NULL, NULL, surewarehk_ex_free);
  559|      0|#  endif
  560|      0|#  ifndef OPENSSL_NO_DSA
  561|      0|    if (dsaHndidx == -1)
  562|      0|        dsaHndidx = DSA_get_ex_new_index(0,
  563|      0|                                         "SureWareHook DSA key handle",
  564|      0|                                         NULL, NULL, surewarehk_ex_free);
  565|      0|#  endif
  566|       |
  567|      0|    return 1;
  568|      1| err:
  569|      1|    if (surewarehk_dso)
  570|      0|        DSO_free(surewarehk_dso);
  571|      1|    surewarehk_dso = NULL;
  572|      1|    p_surewarehk_Init = NULL;
  573|      1|    p_surewarehk_Finish = NULL;
  574|      1|    p_surewarehk_Rand_Bytes = NULL;
  575|      1|    p_surewarehk_Rand_Seed = NULL;
  576|      1|    p_surewarehk_Load_Privkey = NULL;
  577|      1|    p_surewarehk_Load_Rsa_Pubkey = NULL;
  578|      1|    p_surewarehk_Free = NULL;
  579|      1|    p_surewarehk_Rsa_Priv_Dec = NULL;
  580|      1|    p_surewarehk_Rsa_Sign = NULL;
  581|      1|    p_surewarehk_Dsa_Sign = NULL;
  582|      1|    p_surewarehk_Info_Pubkey = NULL;
  583|      1|    p_surewarehk_Load_Dsa_Pubkey = NULL;
  584|      1|    p_surewarehk_Mod_Exp = NULL;
  585|      1|    return 0;
  586|      0|}

e_sureware.c:ERR_SUREWARE_error:
  150|      1|{
  151|      1|    if (SUREWARE_lib_error_code == 0)
  152|      0|        SUREWARE_lib_error_code = ERR_get_next_error_library();
  153|      1|    ERR_PUT_error(SUREWARE_lib_error_code, function, reason, file, line);
  154|      1|}
e_sureware.c:ERR_load_SUREWARE_strings:
  116|      1|{
  117|      1|    if (SUREWARE_lib_error_code == 0)
  118|      1|        SUREWARE_lib_error_code = ERR_get_next_error_library();
  119|       |
  120|      1|    if (SUREWARE_error_init) {
  121|      1|        SUREWARE_error_init = 0;
  122|      1|#ifndef OPENSSL_NO_ERR
  123|      1|        ERR_load_strings(SUREWARE_lib_error_code, SUREWARE_str_functs);
  124|      1|        ERR_load_strings(SUREWARE_lib_error_code, SUREWARE_str_reasons);
  125|      1|#endif
  126|       |
  127|      1|#ifdef SUREWARE_LIB_NAME
  128|      1|        SUREWARE_lib_name->error = ERR_PACK(SUREWARE_lib_error_code, 0, 0);
  129|      1|        ERR_load_strings(0, SUREWARE_lib_name);
  130|      1|#endif
  131|      1|    }
  132|      1|}

ENGINE_load_ubsec:
  278|      1|{
  279|       |    /* Copied from eng_[openssl|dyn].c */
  280|      1|    ENGINE *toadd = engine_ubsec();
  281|      1|    if (!toadd)
  282|      0|        return;
  283|      1|    ENGINE_add(toadd);
  284|      1|    ENGINE_free(toadd);
  285|      1|    ERR_clear_error();
  286|      1|}
e_ubsec.c:engine_ubsec:
  266|      1|{
  267|      1|    ENGINE *ret = ENGINE_new();
  268|      1|    if (!ret)
  269|      0|        return NULL;
  270|      1|    if (!bind_helper(ret)) {
  271|      0|        ENGINE_free(ret);
  272|      0|        return NULL;
  273|      0|    }
  274|      1|    return ret;
  275|      1|}
e_ubsec.c:bind_helper:
  207|      1|{
  208|      1|#  ifndef OPENSSL_NO_RSA
  209|      1|    const RSA_METHOD *meth1;
  210|      1|#  endif
  211|      1|#  ifndef OPENSSL_NO_DH
  212|      1|#   ifndef HAVE_UBSEC_DH
  213|      1|    const DH_METHOD *meth3;
  214|      1|#   endif                       /* HAVE_UBSEC_DH */
  215|      1|#  endif
  216|      1|    if (!ENGINE_set_id(e, engine_ubsec_id) ||
  217|      1|        !ENGINE_set_name(e, engine_ubsec_name) ||
  218|      1|#  ifndef OPENSSL_NO_RSA
  219|      1|        !ENGINE_set_RSA(e, &ubsec_rsa) ||
  220|      1|#  endif
  221|      1|#  ifndef OPENSSL_NO_DSA
  222|      1|        !ENGINE_set_DSA(e, &ubsec_dsa) ||
  223|      1|#  endif
  224|      1|#  ifndef OPENSSL_NO_DH
  225|      1|        !ENGINE_set_DH(e, &ubsec_dh) ||
  226|      1|#  endif
  227|      1|        !ENGINE_set_destroy_function(e, ubsec_destroy) ||
  228|      1|        !ENGINE_set_init_function(e, ubsec_init) ||
  229|      1|        !ENGINE_set_finish_function(e, ubsec_finish) ||
  230|      1|        !ENGINE_set_ctrl_function(e, ubsec_ctrl) ||
  231|      1|        !ENGINE_set_cmd_defns(e, ubsec_cmd_defns))
  232|      0|        return 0;
  233|       |
  234|      1|#  ifndef OPENSSL_NO_RSA
  235|       |    /*
  236|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  237|       |     * Broadcom-specific mod_exp and mod_exp_crt so we use those functions.
  238|       |     * NB: We don't use ENGINE_openssl() or anything "more generic" because
  239|       |     * something like the RSAref code may not hook properly, and if you own
  240|       |     * one of these cards then you have the right to do RSA operations on it
  241|       |     * anyway!
  242|       |     */
  243|      1|    meth1 = RSA_PKCS1_SSLeay();
  244|      1|    ubsec_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  245|      1|    ubsec_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  246|      1|    ubsec_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  247|      1|    ubsec_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  248|      1|#  endif
  249|       |
  250|      1|#  ifndef OPENSSL_NO_DH
  251|      1|#   ifndef HAVE_UBSEC_DH
  252|       |    /* Much the same for Diffie-Hellman */
  253|      1|    meth3 = DH_OpenSSL();
  254|      1|    ubsec_dh.generate_key = meth3->generate_key;
  255|      1|    ubsec_dh.compute_key = meth3->compute_key;
  256|      1|#   endif                       /* HAVE_UBSEC_DH */
  257|      1|#  endif
  258|       |
  259|       |    /* Ensure the ubsec error handling is set up */
  260|      1|    ERR_load_UBSEC_strings();
  261|      1|    return 1;
  262|      1|}

e_ubsec.c:ERR_load_UBSEC_strings:
  116|      1|{
  117|      1|    if (UBSEC_lib_error_code == 0)
  118|      1|        UBSEC_lib_error_code = ERR_get_next_error_library();
  119|       |
  120|      1|    if (UBSEC_error_init) {
  121|      1|        UBSEC_error_init = 0;
  122|      1|#ifndef OPENSSL_NO_ERR
  123|      1|        ERR_load_strings(UBSEC_lib_error_code, UBSEC_str_functs);
  124|      1|        ERR_load_strings(UBSEC_lib_error_code, UBSEC_str_reasons);
  125|      1|#endif
  126|       |
  127|      1|#ifdef UBSEC_LIB_NAME
  128|      1|        UBSEC_lib_name->error = ERR_PACK(UBSEC_lib_error_code, 0, 0);
  129|      1|        ERR_load_strings(0, UBSEC_lib_name);
  130|      1|#endif
  131|      1|    }
  132|      1|}

ssl23_connect:
  147|     60|{
  148|     60|    BUF_MEM *buf = NULL;
  149|     60|    unsigned long Time = (unsigned long)time(NULL);
  150|     60|    void (*cb) (const SSL *ssl, int type, int val) = NULL;
  151|     60|    int ret = -1;
  152|     60|    int new_state, state;
  153|       |
  154|     60|    RAND_add(&Time, sizeof(Time), 0);
  155|     60|    ERR_clear_error();
  156|     60|    clear_sys_error();
  157|       |
  158|     60|    if (s->info_callback != NULL)
  159|      0|        cb = s->info_callback;
  160|     60|    else if (s->ctx->info_callback != NULL)
  161|      0|        cb = s->ctx->info_callback;
  162|       |
  163|     60|    s->in_handshake++;
  164|     60|    if (!SSL_in_init(s) || SSL_in_before(s))
  165|     30|        SSL_clear(s);
  166|       |
  167|    120|    for (;;) {
  168|    120|        state = s->state;
  169|       |
  170|    120|        switch (s->state) {
  171|      0|        case SSL_ST_BEFORE:
  172|      0|        case SSL_ST_CONNECT:
  173|     30|        case SSL_ST_BEFORE | SSL_ST_CONNECT:
  174|     30|        case SSL_ST_OK | SSL_ST_CONNECT:
  175|       |
  176|     30|            if (s->session != NULL) {
  177|      0|                SSLerr(SSL_F_SSL23_CONNECT,
  178|      0|                       SSL_R_SSL23_DOING_SESSION_ID_REUSE);
  179|      0|                ret = -1;
  180|      0|                goto end;
  181|      0|            }
  182|     30|            s->server = 0;
  183|     30|            if (cb != NULL)
  184|      0|                cb(s, SSL_CB_HANDSHAKE_START, 1);
  185|       |
  186|       |            /* s->version=TLS1_VERSION; */
  187|     30|            s->type = SSL_ST_CONNECT;
  188|       |
  189|     30|            if (s->init_buf == NULL) {
  190|     30|                if ((buf = BUF_MEM_new()) == NULL) {
  191|      0|                    ret = -1;
  192|      0|                    goto end;
  193|      0|                }
  194|     30|                if (!BUF_MEM_grow(buf, SSL3_RT_MAX_PLAIN_LENGTH)) {
  195|      0|                    ret = -1;
  196|      0|                    goto end;
  197|      0|                }
  198|     30|                s->init_buf = buf;
  199|     30|                buf = NULL;
  200|     30|            }
  201|       |
  202|     30|            if (!ssl3_setup_buffers(s)) {
  203|      0|                ret = -1;
  204|      0|                goto end;
  205|      0|            }
  206|       |
  207|     30|            if (!ssl3_init_finished_mac(s)) {
  208|      0|                ret = -1;
  209|      0|                goto end;
  210|      0|            }
  211|       |
  212|     30|            s->state = SSL23_ST_CW_CLNT_HELLO_A;
  213|     30|            s->ctx->stats.sess_connect++;
  214|     30|            s->init_num = 0;
  215|     30|            break;
  216|       |
  217|     30|        case SSL23_ST_CW_CLNT_HELLO_A:
  218|     30|        case SSL23_ST_CW_CLNT_HELLO_B:
  219|       |
  220|     30|            s->shutdown = 0;
  221|     30|            ret = ssl23_client_hello(s);
  222|     30|            if (ret <= 0)
  223|      0|                goto end;
  224|     30|            s->state = SSL23_ST_CR_SRVR_HELLO_A;
  225|     30|            s->init_num = 0;
  226|       |
  227|     30|            break;
  228|       |
  229|     60|        case SSL23_ST_CR_SRVR_HELLO_A:
  230|     60|        case SSL23_ST_CR_SRVR_HELLO_B:
  231|     60|            ret = ssl23_get_server_hello(s);
  232|     60|            if (ret >= 0)
  233|     60|                cb = NULL;
  234|     60|            goto end;
  235|       |            /* break; */
  236|       |
  237|      0|        default:
  238|      0|            SSLerr(SSL_F_SSL23_CONNECT, SSL_R_UNKNOWN_STATE);
  239|      0|            ret = -1;
  240|      0|            goto end;
  241|       |            /* break; */
  242|    120|        }
  243|       |
  244|     60|        if (s->debug) {
  245|      0|            (void)BIO_flush(s->wbio);
  246|      0|        }
  247|       |
  248|     60|        if ((cb != NULL) && (s->state != state)) {
  249|      0|            new_state = s->state;
  250|      0|            s->state = state;
  251|      0|            cb(s, SSL_CB_CONNECT_LOOP, 1);
  252|      0|            s->state = new_state;
  253|      0|        }
  254|     60|    }
  255|     60| end:
  256|     60|    s->in_handshake--;
  257|     60|    if (buf != NULL)
  258|      0|        BUF_MEM_free(buf);
  259|     60|    if (cb != NULL)
  260|      0|        cb(s, SSL_CB_CONNECT_EXIT, ret);
  261|     60|    return (ret);
  262|     60|}
ssl_fill_hello_random:
  283|     30|{
  284|     30|    int send_time = 0;
  285|     30|    if (len < 4)
  286|      0|        return 0;
  287|     30|    if (server)
  288|      0|        send_time = (s->mode & SSL_MODE_SEND_SERVERHELLO_TIME) != 0;
  289|     30|    else
  290|     30|        send_time = (s->mode & SSL_MODE_SEND_CLIENTHELLO_TIME) != 0;
  291|     30|    if (send_time) {
  292|      0|        unsigned long Time = (unsigned long)time(NULL);
  293|      0|        unsigned char *p = result;
  294|      0|        l2n(Time, p);
  295|      0|        return RAND_bytes(p, len - 4);
  296|      0|    } else
  297|     30|        return RAND_bytes(result, len);
  298|     30|}
s23_clnt.c:ssl23_client_hello:
  301|     30|{
  302|     30|    unsigned char *buf;
  303|     30|    unsigned char *p, *d;
  304|     30|    int i, ch_len;
  305|     30|    unsigned long l;
  306|     30|    int ssl2_compat;
  307|     30|    int version = 0, version_major, version_minor;
  308|     30|    int al = 0;
  309|     30|#ifndef OPENSSL_NO_COMP
  310|     30|    int j;
  311|     30|    SSL_COMP *comp;
  312|     30|#endif
  313|     30|    int ret;
  314|     30|    unsigned long mask, options = s->options;
  315|       |
  316|     30|    ssl2_compat = (options & SSL_OP_NO_SSLv2) ? 0 : 1;
  317|       |
  318|     30|    if (ssl2_compat && ssl23_no_ssl2_ciphers(s))
  319|      0|        ssl2_compat = 0;
  320|       |
  321|       |    /*
  322|       |     * SSL_OP_NO_X disables all protocols above X *if* there are
  323|       |     * some protocols below X enabled. This is required in order
  324|       |     * to maintain "version capability" vector contiguous. So
  325|       |     * that if application wants to disable TLS1.0 in favour of
  326|       |     * TLS1>=1, it would be insufficient to pass SSL_NO_TLSv1, the
  327|       |     * answer is SSL_OP_NO_TLSv1|SSL_OP_NO_SSLv3|SSL_OP_NO_SSLv2.
  328|       |     */
  329|     30|    mask = SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1
  330|     30|#if !defined(OPENSSL_NO_SSL3)
  331|     30|        | SSL_OP_NO_SSLv3
  332|     30|#endif
  333|       |#if !defined(OPENSSL_NO_SSL2)
  334|       |        | (ssl2_compat ? SSL_OP_NO_SSLv2 : 0)
  335|       |#endif
  336|     30|        ;
  337|     30|#if !defined(OPENSSL_NO_TLS1_2_CLIENT)
  338|     30|    version = TLS1_2_VERSION;
  339|       |
  340|     30|    if ((options & SSL_OP_NO_TLSv1_2) && (options & mask) != mask)
  341|      0|        version = TLS1_1_VERSION;
  342|       |#else
  343|       |    version = TLS1_1_VERSION;
  344|       |#endif
  345|     30|    mask &= ~SSL_OP_NO_TLSv1_1;
  346|     30|    if ((options & SSL_OP_NO_TLSv1_1) && (options & mask) != mask)
  347|      0|        version = TLS1_VERSION;
  348|     30|    mask &= ~SSL_OP_NO_TLSv1;
  349|     30|#if !defined(OPENSSL_NO_SSL3)
  350|     30|    if ((options & SSL_OP_NO_TLSv1) && (options & mask) != mask)
  351|      0|        version = SSL3_VERSION;
  352|     30|    mask &= ~SSL_OP_NO_SSLv3;
  353|     30|#endif
  354|       |#if !defined(OPENSSL_NO_SSL2)
  355|       |    if ((options & SSL_OP_NO_SSLv3) && (options & mask) != mask)
  356|       |        version = SSL2_VERSION;
  357|       |#endif
  358|       |
  359|     30|#ifndef OPENSSL_NO_TLSEXT
  360|     30|    if (version != SSL2_VERSION) {
  361|       |        /*
  362|       |         * have to disable SSL 2.0 compatibility if we need TLS extensions
  363|       |         */
  364|       |
  365|     30|        if (s->tlsext_hostname != NULL)
  366|     26|            ssl2_compat = 0;
  367|     30|        if (s->tlsext_status_type != -1)
  368|      0|            ssl2_compat = 0;
  369|       |# ifdef TLSEXT_TYPE_opaque_prf_input
  370|       |        if (s->ctx->tlsext_opaque_prf_input_callback != 0
  371|       |            || s->tlsext_opaque_prf_input != NULL)
  372|       |            ssl2_compat = 0;
  373|       |# endif
  374|     30|        if (s->cert->cli_ext.meths_count != 0)
  375|      0|            ssl2_compat = 0;
  376|     30|    }
  377|     30|#endif
  378|       |
  379|     30|    buf = (unsigned char *)s->init_buf->data;
  380|     30|    if (s->state == SSL23_ST_CW_CLNT_HELLO_A) {
  381|       |        /*
  382|       |         * Since we're sending s23 client hello, we're not reusing a session, as
  383|       |         * we'd be using the method from the saved session instead
  384|       |         */
  385|     30|        if (!ssl_get_new_session(s, 0)) {
  386|      0|            return -1;
  387|      0|        }
  388|       |
  389|     30|        p = s->s3->client_random;
  390|     30|        if (ssl_fill_hello_random(s, 0, p, SSL3_RANDOM_SIZE) <= 0)
  391|      0|            return -1;
  392|       |
  393|     30|        if (version == TLS1_2_VERSION) {
  394|     30|            version_major = TLS1_2_VERSION_MAJOR;
  395|     30|            version_minor = TLS1_2_VERSION_MINOR;
  396|     30|        } else if (tls1_suiteb(s)) {
  397|      0|            SSLerr(SSL_F_SSL23_CLIENT_HELLO,
  398|      0|                   SSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE);
  399|      0|            return -1;
  400|      0|        } else if (version == TLS1_1_VERSION) {
  401|      0|            version_major = TLS1_1_VERSION_MAJOR;
  402|      0|            version_minor = TLS1_1_VERSION_MINOR;
  403|      0|        } else if (version == TLS1_VERSION) {
  404|      0|            version_major = TLS1_VERSION_MAJOR;
  405|      0|            version_minor = TLS1_VERSION_MINOR;
  406|      0|        }
  407|       |#ifdef OPENSSL_FIPS
  408|       |        else if (FIPS_mode()) {
  409|       |            SSLerr(SSL_F_SSL23_CLIENT_HELLO,
  410|       |                   SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
  411|       |            return -1;
  412|       |        }
  413|       |#endif
  414|      0|        else if (version == SSL3_VERSION) {
  415|      0|            version_major = SSL3_VERSION_MAJOR;
  416|      0|            version_minor = SSL3_VERSION_MINOR;
  417|      0|        } else if (version == SSL2_VERSION) {
  418|      0|            version_major = SSL2_VERSION_MAJOR;
  419|      0|            version_minor = SSL2_VERSION_MINOR;
  420|      0|        } else {
  421|      0|            SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_NO_PROTOCOLS_AVAILABLE);
  422|      0|            return (-1);
  423|      0|        }
  424|       |
  425|     30|        s->client_version = version;
  426|       |
  427|     30|        if (ssl2_compat) {
  428|       |            /* create SSL 2.0 compatible Client Hello */
  429|       |
  430|       |            /* two byte record header will be written last */
  431|      0|            d = &(buf[2]);
  432|      0|            p = d + 9;          /* leave space for message type, version,
  433|       |                                 * individual length fields */
  434|       |
  435|      0|            *(d++) = SSL2_MT_CLIENT_HELLO;
  436|      0|            *(d++) = version_major;
  437|      0|            *(d++) = version_minor;
  438|       |
  439|       |            /* Ciphers supported */
  440|      0|            i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), p, 0);
  441|      0|            if (i == 0) {
  442|       |                /* no ciphers */
  443|      0|                SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
  444|      0|                return -1;
  445|      0|            }
  446|      0|            s2n(i, d);
  447|      0|            p += i;
  448|       |
  449|       |            /*
  450|       |             * put in the session-id length (zero since there is no reuse)
  451|       |             */
  452|      0|            s2n(0, d);
  453|       |
  454|      0|            if (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)
  455|      0|                ch_len = SSL2_CHALLENGE_LENGTH;
  456|      0|            else
  457|      0|                ch_len = SSL2_MAX_CHALLENGE_LENGTH;
  458|       |
  459|       |            /* write out sslv2 challenge */
  460|       |            /*
  461|       |             * Note that ch_len must be <= SSL3_RANDOM_SIZE (32), because it
  462|       |             * is one of SSL2_MAX_CHALLENGE_LENGTH (32) or
  463|       |             * SSL2_MAX_CHALLENGE_LENGTH (16), but leave the check in for
  464|       |             * futurproofing
  465|       |             */
  466|      0|            if (SSL3_RANDOM_SIZE < ch_len)
  467|      0|                i = SSL3_RANDOM_SIZE;
  468|      0|            else
  469|      0|                i = ch_len;
  470|      0|            s2n(i, d);
  471|      0|            memset(&(s->s3->client_random[0]), 0, SSL3_RANDOM_SIZE);
  472|      0|            if (RAND_bytes (&(s->s3->client_random[SSL3_RANDOM_SIZE - i]), i)
  473|      0|                    <= 0)
  474|      0|                return -1;
  475|       |
  476|      0|            memcpy(p, &(s->s3->client_random[SSL3_RANDOM_SIZE - i]), i);
  477|      0|            p += i;
  478|       |
  479|      0|            i = p - &(buf[2]);
  480|      0|            buf[0] = ((i >> 8) & 0xff) | 0x80;
  481|      0|            buf[1] = (i & 0xff);
  482|       |
  483|       |            /* number of bytes to write */
  484|      0|            s->init_num = i + 2;
  485|      0|            s->init_off = 0;
  486|       |
  487|      0|            ssl3_finish_mac(s, &(buf[2]), i);
  488|     30|        } else {
  489|       |            /* create Client Hello in SSL 3.0/TLS 1.0 format */
  490|       |
  491|       |            /*
  492|       |             * do the record header (5 bytes) and handshake message header (4
  493|       |             * bytes) last
  494|       |             */
  495|     30|            d = p = &(buf[9]);
  496|       |
  497|     30|            *(p++) = version_major;
  498|     30|            *(p++) = version_minor;
  499|       |
  500|       |            /* Random stuff */
  501|     30|            memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
  502|     30|            p += SSL3_RANDOM_SIZE;
  503|       |
  504|       |            /* Session ID (zero since there is no reuse) */
  505|     30|            *(p++) = 0;
  506|       |
  507|       |            /* Ciphers supported (using SSL 3.0/TLS 1.0 format) */
  508|     30|            i = ssl_cipher_list_to_bytes(s, SSL_get_ciphers(s), &(p[2]),
  509|     30|                                         ssl3_put_cipher_by_char);
  510|     30|            if (i == 0) {
  511|      0|                SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_NO_CIPHERS_AVAILABLE);
  512|      0|                return -1;
  513|      0|            }
  514|       |#ifdef OPENSSL_MAX_TLS1_2_CIPHER_LENGTH
  515|       |            /*
  516|       |             * Some servers hang if client hello > 256 bytes as hack
  517|       |             * workaround chop number of supported ciphers to keep it well
  518|       |             * below this if we use TLS v1.2
  519|       |             */
  520|       |            if (TLS1_get_version(s) >= TLS1_2_VERSION
  521|       |                && i > OPENSSL_MAX_TLS1_2_CIPHER_LENGTH)
  522|       |                i = OPENSSL_MAX_TLS1_2_CIPHER_LENGTH & ~1;
  523|       |#endif
  524|     30|            s2n(i, p);
  525|     30|            p += i;
  526|       |
  527|       |            /* COMPRESSION */
  528|       |#ifdef OPENSSL_NO_COMP
  529|       |            *(p++) = 1;
  530|       |#else
  531|     30|            if ((s->options & SSL_OP_NO_COMPRESSION)
  532|     30|                || !s->ctx->comp_methods)
  533|     30|                j = 0;
  534|      0|            else
  535|      0|                j = sk_SSL_COMP_num(s->ctx->comp_methods);
  536|     30|            *(p++) = 1 + j;
  537|     30|            for (i = 0; i < j; i++) {
  538|      0|                comp = sk_SSL_COMP_value(s->ctx->comp_methods, i);
  539|      0|                *(p++) = comp->id;
  540|      0|            }
  541|     30|#endif
  542|     30|            *(p++) = 0;         /* Add the NULL method */
  543|       |
  544|     30|#ifndef OPENSSL_NO_TLSEXT
  545|       |            /* TLS extensions */
  546|     30|            if (ssl_prepare_clienthello_tlsext(s) <= 0) {
  547|      0|                SSLerr(SSL_F_SSL23_CLIENT_HELLO, SSL_R_CLIENTHELLO_TLSEXT);
  548|      0|                return -1;
  549|      0|            }
  550|     30|            if ((p =
  551|     30|                 ssl_add_clienthello_tlsext(s, p,
  552|     30|                                            buf + SSL3_RT_MAX_PLAIN_LENGTH,
  553|     30|                                            &al)) == NULL) {
  554|      0|                ssl3_send_alert(s, SSL3_AL_FATAL, al);
  555|      0|                SSLerr(SSL_F_SSL23_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
  556|      0|                return -1;
  557|      0|            }
  558|     30|#endif
  559|       |
  560|     30|            l = p - d;
  561|       |
  562|       |            /* fill in 4-byte handshake header */
  563|     30|            d = &(buf[5]);
  564|     30|            *(d++) = SSL3_MT_CLIENT_HELLO;
  565|     30|            l2n3(l, d);
  566|       |
  567|     30|            l += 4;
  568|       |
  569|     30|            if (l > SSL3_RT_MAX_PLAIN_LENGTH) {
  570|      0|                SSLerr(SSL_F_SSL23_CLIENT_HELLO, ERR_R_INTERNAL_ERROR);
  571|      0|                return -1;
  572|      0|            }
  573|       |
  574|       |            /* fill in 5-byte record header */
  575|     30|            d = buf;
  576|     30|            *(d++) = SSL3_RT_HANDSHAKE;
  577|     30|            *(d++) = version_major;
  578|       |            /*
  579|       |             * Some servers hang if we use long client hellos and a record
  580|       |             * number > TLS 1.0.
  581|       |             */
  582|     30|            if (TLS1_get_client_version(s) > TLS1_VERSION)
  583|     30|                *(d++) = 1;
  584|      0|            else
  585|      0|                *(d++) = version_minor;
  586|     30|            s2n((int)l, d);
  587|       |
  588|       |            /* number of bytes to write */
  589|     30|            s->init_num = p - buf;
  590|     30|            s->init_off = 0;
  591|       |
  592|     30|            ssl3_finish_mac(s, &(buf[5]), s->init_num - 5);
  593|     30|        }
  594|       |
  595|     30|        s->state = SSL23_ST_CW_CLNT_HELLO_B;
  596|     30|        s->init_off = 0;
  597|     30|    }
  598|       |
  599|       |    /* SSL3_ST_CW_CLNT_HELLO_B */
  600|     30|    ret = ssl23_write_bytes(s);
  601|       |
  602|     30|    if ((ret >= 2) && s->msg_callback) {
  603|       |        /* Client Hello has been sent; tell msg_callback */
  604|       |
  605|      0|        if (ssl2_compat)
  606|      0|            s->msg_callback(1, SSL2_VERSION, 0, s->init_buf->data + 2,
  607|      0|                            ret - 2, s, s->msg_callback_arg);
  608|      0|        else {
  609|      0|            s->msg_callback(1, version, SSL3_RT_HEADER, s->init_buf->data, 5,
  610|      0|                            s, s->msg_callback_arg);
  611|      0|            s->msg_callback(1, version, SSL3_RT_HANDSHAKE,
  612|      0|                            s->init_buf->data + 5, ret - 5, s,
  613|      0|                            s->msg_callback_arg);
  614|      0|        }
  615|      0|    }
  616|       |
  617|     30|    return ret;
  618|     30|}
s23_clnt.c:ssl23_get_server_hello:
  621|     60|{
  622|     60|    char buf[8];
  623|     60|    unsigned char *p;
  624|     60|    int i;
  625|     60|    int n;
  626|       |
  627|     60|    n = ssl23_read_bytes(s, 7);
  628|       |
  629|     60|    if (n != 7)
  630|     60|        return (n);
  631|      0|    p = s->packet;
  632|       |
  633|      0|    memcpy(buf, p, n);
  634|       |
  635|      0|    if ((p[0] & 0x80) && (p[2] == SSL2_MT_SERVER_HELLO) &&
  636|      0|        (p[5] == 0x00) && (p[6] == 0x02)) {
  637|      0|#ifdef OPENSSL_NO_SSL2
  638|      0|        SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
  639|      0|        goto err;
  640|       |#else
  641|       |        /* we are talking sslv2 */
  642|       |        /*
  643|       |         * we need to clean up the SSLv3 setup and put in the sslv2 stuff.
  644|       |         */
  645|       |        int ch_len;
  646|       |
  647|       |        if (s->options & SSL_OP_NO_SSLv2) {
  648|       |            SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
  649|       |            goto err;
  650|       |        }
  651|       |        if (s->s2 == NULL) {
  652|       |            if (!ssl2_new(s))
  653|       |                goto err;
  654|       |        } else
  655|       |            ssl2_clear(s);
  656|       |
  657|       |        if (s->options & SSL_OP_NETSCAPE_CHALLENGE_BUG)
  658|       |            ch_len = SSL2_CHALLENGE_LENGTH;
  659|       |        else
  660|       |            ch_len = SSL2_MAX_CHALLENGE_LENGTH;
  661|       |
  662|       |        /* write out sslv2 challenge */
  663|       |        /*
  664|       |         * Note that ch_len must be <= SSL3_RANDOM_SIZE (32), because it is
  665|       |         * one of SSL2_MAX_CHALLENGE_LENGTH (32) or SSL2_MAX_CHALLENGE_LENGTH
  666|       |         * (16), but leave the check in for futurproofing
  667|       |         */
  668|       |        i = (SSL3_RANDOM_SIZE < ch_len)
  669|       |            ? SSL3_RANDOM_SIZE : ch_len;
  670|       |        s->s2->challenge_length = i;
  671|       |        memcpy(s->s2->challenge,
  672|       |               &(s->s3->client_random[SSL3_RANDOM_SIZE - i]), i);
  673|       |
  674|       |        if (s->s3 != NULL)
  675|       |            ssl3_free(s);
  676|       |
  677|       |        if (!BUF_MEM_grow_clean(s->init_buf,
  678|       |                                SSL2_MAX_RECORD_LENGTH_3_BYTE_HEADER)) {
  679|       |            SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, ERR_R_BUF_LIB);
  680|       |            goto err;
  681|       |        }
  682|       |
  683|       |        s->state = SSL2_ST_GET_SERVER_HELLO_A;
  684|       |        if (!(s->client_version == SSL2_VERSION))
  685|       |            /*
  686|       |             * use special padding (SSL 3.0 draft/RFC 2246, App. E.2)
  687|       |             */
  688|       |            s->s2->ssl2_rollback = 1;
  689|       |
  690|       |        /*
  691|       |         * setup the 7 bytes we have read so we get them from the sslv2
  692|       |         * buffer
  693|       |         */
  694|       |        s->rstate = SSL_ST_READ_HEADER;
  695|       |        s->packet_length = n;
  696|       |        s->packet = &(s->s2->rbuf[0]);
  697|       |        memcpy(s->packet, buf, n);
  698|       |        s->s2->rbuf_left = n;
  699|       |        s->s2->rbuf_offs = 0;
  700|       |
  701|       |        /* we have already written one */
  702|       |        s->s2->write_sequence = 1;
  703|       |
  704|       |        s->method = SSLv2_client_method();
  705|       |        s->handshake_func = s->method->ssl_connect;
  706|       |#endif
  707|      0|    } else if (p[1] == SSL3_VERSION_MAJOR &&
  708|      0|               p[2] <= TLS1_2_VERSION_MINOR &&
  709|      0|               ((p[0] == SSL3_RT_HANDSHAKE && p[5] == SSL3_MT_SERVER_HELLO) ||
  710|      0|                (p[0] == SSL3_RT_ALERT && p[3] == 0 && p[4] == 2))) {
  711|       |        /* we have sslv3 or tls1 (server hello or alert) */
  712|       |
  713|      0|#ifndef OPENSSL_NO_SSL3
  714|      0|        if ((p[2] == SSL3_VERSION_MINOR) && !(s->options & SSL_OP_NO_SSLv3)) {
  715|       |# ifdef OPENSSL_FIPS
  716|       |            if (FIPS_mode()) {
  717|       |                SSLerr(SSL_F_SSL23_GET_SERVER_HELLO,
  718|       |                       SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
  719|       |                goto err;
  720|       |            }
  721|       |# endif
  722|      0|            s->version = SSL3_VERSION;
  723|      0|            s->method = SSLv3_client_method();
  724|      0|        } else
  725|      0|#endif
  726|      0|        if ((p[2] == TLS1_VERSION_MINOR) && !(s->options & SSL_OP_NO_TLSv1)) {
  727|      0|            s->version = TLS1_VERSION;
  728|      0|            s->method = TLSv1_client_method();
  729|      0|        } else if ((p[2] == TLS1_1_VERSION_MINOR) &&
  730|      0|                   !(s->options & SSL_OP_NO_TLSv1_1)) {
  731|      0|            s->version = TLS1_1_VERSION;
  732|      0|            s->method = TLSv1_1_client_method();
  733|      0|        } else if ((p[2] == TLS1_2_VERSION_MINOR) &&
  734|      0|                   !(s->options & SSL_OP_NO_TLSv1_2)) {
  735|      0|            s->version = TLS1_2_VERSION;
  736|      0|            s->method = TLSv1_2_client_method();
  737|      0|        } else {
  738|       |            /*
  739|       |             * Unrecognised version, we'll send a protocol version alert using
  740|       |             * our preferred version.
  741|       |             */
  742|      0|            switch(s->client_version) {
  743|      0|            default:
  744|       |                /*
  745|       |                 * Shouldn't happen
  746|       |                 * Fall through
  747|       |                 */
  748|      0|            case TLS1_2_VERSION:
  749|      0|                s->version = TLS1_2_VERSION;
  750|      0|                s->method = TLSv1_2_client_method();
  751|      0|                break;
  752|      0|            case TLS1_1_VERSION:
  753|      0|                s->version = TLS1_1_VERSION;
  754|      0|                s->method = TLSv1_1_client_method();
  755|      0|                break;
  756|      0|            case TLS1_VERSION:
  757|      0|                s->version = TLS1_VERSION;
  758|      0|                s->method = TLSv1_client_method();
  759|      0|                break;
  760|      0|            case SSL3_VERSION:
  761|      0|                s->version = SSL3_VERSION;
  762|      0|                s->method = SSLv3_client_method();
  763|      0|                break;
  764|      0|            }
  765|      0|            SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNSUPPORTED_PROTOCOL);
  766|      0|            ssl3_send_alert(s, SSL3_AL_FATAL, SSL_AD_PROTOCOL_VERSION);
  767|      0|            goto err;
  768|      0|        }
  769|       |
  770|      0|        s->session->ssl_version = s->version;
  771|       |
  772|       |        /* ensure that TLS_MAX_VERSION is up-to-date */
  773|      0|        OPENSSL_assert(s->version <= TLS_MAX_VERSION);
  774|       |
  775|      0|        if (p[0] == SSL3_RT_ALERT && p[5] != SSL3_AL_WARNING) {
  776|       |            /* fatal alert */
  777|       |
  778|      0|            void (*cb) (const SSL *ssl, int type, int val) = NULL;
  779|      0|            int j;
  780|       |
  781|      0|            if (s->info_callback != NULL)
  782|      0|                cb = s->info_callback;
  783|      0|            else if (s->ctx->info_callback != NULL)
  784|      0|                cb = s->ctx->info_callback;
  785|       |
  786|      0|            i = p[5];
  787|      0|            if (cb != NULL) {
  788|      0|                j = (i << 8) | p[6];
  789|      0|                cb(s, SSL_CB_READ_ALERT, j);
  790|      0|            }
  791|       |
  792|      0|            if (s->msg_callback) {
  793|      0|                s->msg_callback(0, s->version, SSL3_RT_HEADER, p, 5, s,
  794|      0|                                s->msg_callback_arg);
  795|      0|                s->msg_callback(0, s->version, SSL3_RT_ALERT, p + 5, 2, s,
  796|      0|                                s->msg_callback_arg);
  797|      0|            }
  798|       |
  799|      0|            s->rwstate = SSL_NOTHING;
  800|      0|            SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_AD_REASON_OFFSET + p[6]);
  801|      0|            goto err;
  802|      0|        }
  803|       |
  804|      0|        if (!ssl_init_wbio_buffer(s, 1))
  805|      0|            goto err;
  806|       |
  807|       |        /* we are in this state */
  808|      0|        s->state = SSL3_ST_CR_SRVR_HELLO_A;
  809|       |
  810|       |        /*
  811|       |         * put the 7 bytes we have read into the input buffer for SSLv3
  812|       |         */
  813|      0|        s->rstate = SSL_ST_READ_HEADER;
  814|      0|        s->packet_length = n;
  815|      0|        if (s->s3->rbuf.buf == NULL)
  816|      0|            if (!ssl3_setup_read_buffer(s))
  817|      0|                goto err;
  818|      0|        s->packet = &(s->s3->rbuf.buf[0]);
  819|      0|        memcpy(s->packet, buf, n);
  820|      0|        s->s3->rbuf.left = n;
  821|      0|        s->s3->rbuf.offset = 0;
  822|       |
  823|      0|        s->handshake_func = s->method->ssl_connect;
  824|      0|    } else {
  825|      0|        SSLerr(SSL_F_SSL23_GET_SERVER_HELLO, SSL_R_UNKNOWN_PROTOCOL);
  826|      0|        goto err;
  827|      0|    }
  828|      0|    s->init_num = 0;
  829|       |
  830|      0|    return (SSL_connect(s));
  831|      0| err:
  832|      0|    return (-1);
  833|      0|}

ssl23_default_timeout:
   64|     30|{
   65|     30|    return (300);
   66|     30|}
ssl23_num_ciphers:
   69|     60|{
   70|     60|    return (ssl3_num_ciphers()
   71|       |#ifndef OPENSSL_NO_SSL2
   72|       |            + ssl2_num_ciphers()
   73|       |#endif
   74|     60|        );
   75|     60|}
ssl23_get_cipher:
   78|  8.40k|{
   79|  8.40k|    unsigned int uu = ssl3_num_ciphers();
   80|       |
   81|  8.40k|    if (u < uu)
   82|  8.40k|        return (ssl3_get_cipher(u));
   83|      0|    else
   84|       |#ifndef OPENSSL_NO_SSL2
   85|       |        return (ssl2_get_cipher(u - uu));
   86|       |#else
   87|      0|        return (NULL);
   88|  8.40k|#endif
   89|  8.40k|}
ssl23_read:
  128|     30|{
  129|     30|    int n;
  130|       |
  131|     30|    clear_sys_error();
  132|     30|    if (SSL_in_init(s) && (!s->in_handshake)) {
  133|     30|        n = s->handshake_func(s);
  134|     30|        if (n < 0)
  135|      0|            return (n);
  136|     30|        if (n == 0) {
  137|     30|            SSLerr(SSL_F_SSL23_READ, SSL_R_SSL_HANDSHAKE_FAILURE);
  138|     30|            return (-1);
  139|     30|        }
  140|      0|        return (SSL_read(s, buf, len));
  141|     30|    } else {
  142|      0|        ssl_undefined_function(s);
  143|      0|        return (-1);
  144|      0|    }
  145|     30|}

ssl23_write_bytes:
   70|     30|{
   71|     30|    int i, num, tot;
   72|     30|    char *buf;
   73|       |
   74|     30|    buf = s->init_buf->data;
   75|     30|    tot = s->init_off;
   76|     30|    num = s->init_num;
   77|     30|    for (;;) {
   78|     30|        s->rwstate = SSL_WRITING;
   79|     30|        i = BIO_write(s->wbio, &(buf[tot]), num);
   80|     30|        if (i <= 0) {
   81|      0|            s->init_off = tot;
   82|      0|            s->init_num = num;
   83|      0|            return i;
   84|      0|        }
   85|     30|        s->rwstate = SSL_NOTHING;
   86|     30|        if (i == num)
   87|     30|            return (tot + i);
   88|       |
   89|      0|        num -= i;
   90|      0|        tot += i;
   91|      0|    }
   92|     30|}
ssl23_read_bytes:
   99|     60|{
  100|     60|    unsigned char *p;
  101|     60|    int j;
  102|       |
  103|     60|    if (s->packet_length < (unsigned int)n) {
  104|     60|        p = s->packet;
  105|       |
  106|     60|        for (;;) {
  107|     60|            s->rwstate = SSL_READING;
  108|     60|            j = BIO_read(s->rbio, (char *)&(p[s->packet_length]),
  109|     60|                         n - s->packet_length);
  110|     60|            if (j <= 0)
  111|     60|                return j;
  112|      0|            s->rwstate = SSL_NOTHING;
  113|      0|            s->packet_length += j;
  114|      0|            if (s->packet_length >= (unsigned int)n)
  115|      0|                return (s->packet_length);
  116|      0|        }
  117|     60|    }
  118|      0|    return (n);
  119|     60|}

ssl3_setup_read_buffer:
  658|     30|{
  659|     30|    unsigned char *p;
  660|     30|    size_t len, align = 0, headerlen;
  661|       |
  662|     30|    if (SSL_IS_DTLS(s))
  663|      0|        headerlen = DTLS1_RT_HEADER_LENGTH;
  664|     30|    else
  665|     30|        headerlen = SSL3_RT_HEADER_LENGTH;
  666|       |
  667|     30|#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
  668|     30|    align = (-SSL3_RT_HEADER_LENGTH) & (SSL3_ALIGN_PAYLOAD - 1);
  669|     30|#endif
  670|       |
  671|     30|    if (s->s3->rbuf.buf == NULL) {
  672|     30|        len = SSL3_RT_MAX_PLAIN_LENGTH
  673|     30|            + SSL3_RT_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
  674|     30|        if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER) {
  675|     30|            s->s3->init_extra = 1;
  676|     30|            len += SSL3_RT_MAX_EXTRA;
  677|     30|        }
  678|     30|#ifndef OPENSSL_NO_COMP
  679|     30|        if (!(s->options & SSL_OP_NO_COMPRESSION))
  680|      0|            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
  681|     30|#endif
  682|     30|        if ((p = freelist_extract(s->ctx, 1, len)) == NULL)
  683|      0|            goto err;
  684|     30|        s->s3->rbuf.buf = p;
  685|     30|        s->s3->rbuf.len = len;
  686|     30|    }
  687|       |
  688|     30|    s->packet = &(s->s3->rbuf.buf[0]);
  689|     30|    return 1;
  690|       |
  691|      0| err:
  692|      0|    SSLerr(SSL_F_SSL3_SETUP_READ_BUFFER, ERR_R_MALLOC_FAILURE);
  693|      0|    return 0;
  694|     30|}
ssl3_setup_write_buffer:
  697|     30|{
  698|     30|    unsigned char *p;
  699|     30|    size_t len, align = 0, headerlen;
  700|       |
  701|     30|    if (SSL_IS_DTLS(s))
  702|      0|        headerlen = DTLS1_RT_HEADER_LENGTH + 1;
  703|     30|    else
  704|     30|        headerlen = SSL3_RT_HEADER_LENGTH;
  705|       |
  706|     30|#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
  707|     30|    align = (-SSL3_RT_HEADER_LENGTH) & (SSL3_ALIGN_PAYLOAD - 1);
  708|     30|#endif
  709|       |
  710|     30|    if (s->s3->wbuf.buf == NULL) {
  711|     30|        len = s->max_send_fragment
  712|     30|            + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
  713|     30|#ifndef OPENSSL_NO_COMP
  714|     30|        if (!(s->options & SSL_OP_NO_COMPRESSION))
  715|      0|            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
  716|     30|#endif
  717|     30|        if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
  718|     30|            len += headerlen + align + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;
  719|       |
  720|     30|        if ((p = freelist_extract(s->ctx, 0, len)) == NULL)
  721|      0|            goto err;
  722|     30|        s->s3->wbuf.buf = p;
  723|     30|        s->s3->wbuf.len = len;
  724|     30|    }
  725|       |
  726|     30|    return 1;
  727|       |
  728|      0| err:
  729|      0|    SSLerr(SSL_F_SSL3_SETUP_WRITE_BUFFER, ERR_R_MALLOC_FAILURE);
  730|      0|    return 0;
  731|     30|}
ssl3_setup_buffers:
  734|     30|{
  735|     30|    if (!ssl3_setup_read_buffer(s))
  736|      0|        return 0;
  737|     30|    if (!ssl3_setup_write_buffer(s))
  738|      0|        return 0;
  739|     30|    return 1;
  740|     30|}
ssl3_release_write_buffer:
  743|     30|{
  744|     30|    if (s->s3->wbuf.buf != NULL) {
  745|     30|        freelist_insert(s->ctx, 0, s->s3->wbuf.len, s->s3->wbuf.buf);
  746|     30|        s->s3->wbuf.buf = NULL;
  747|     30|    }
  748|     30|    return 1;
  749|     30|}
ssl3_release_read_buffer:
  752|     30|{
  753|     30|    if (s->s3->rbuf.buf != NULL) {
  754|     30|        freelist_insert(s->ctx, 1, s->s3->rbuf.len, s->s3->rbuf.buf);
  755|     30|        s->s3->rbuf.buf = NULL;
  756|     30|    }
  757|     30|    return 1;
  758|     30|}
s3_both.c:freelist_extract:
  609|     60|{
  610|     60|    SSL3_BUF_FREELIST *list;
  611|     60|    SSL3_BUF_FREELIST_ENTRY *ent = NULL;
  612|     60|    void *result = NULL;
  613|       |
  614|     60|    CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
  615|     60|    list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
  616|     60|    if (list != NULL && sz == (int)list->chunklen)
  617|      0|        ent = list->head;
  618|     60|    if (ent != NULL) {
  619|      0|        list->head = ent->next;
  620|      0|        result = ent;
  621|      0|        if (--list->len == 0)
  622|      0|            list->chunklen = 0;
  623|      0|    }
  624|     60|    CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  625|     60|    if (!result)
  626|     60|        result = OPENSSL_malloc(sz);
  627|     60|    return result;
  628|     60|}
s3_both.c:freelist_insert:
  631|     60|{
  632|     60|    SSL3_BUF_FREELIST *list;
  633|     60|    SSL3_BUF_FREELIST_ENTRY *ent;
  634|       |
  635|     60|    CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
  636|     60|    list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
  637|     60|    if (list != NULL &&
  638|     60|        (sz == list->chunklen || list->chunklen == 0) &&
  639|     60|        list->len < ctx->freelist_max_len && sz >= sizeof(*ent)) {
  640|     60|        list->chunklen = sz;
  641|     60|        ent = mem;
  642|     60|        ent->next = list->head;
  643|     60|        list->head = ent;
  644|     60|        ++list->len;
  645|     60|        mem = NULL;
  646|     60|    }
  647|       |
  648|     60|    CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  649|     60|    if (mem)
  650|      0|        OPENSSL_free(mem);
  651|     60|}

ssl3_cleanup_key_block:
  493|    150|{
  494|    150|    if (s->s3->tmp.key_block != NULL) {
  495|      0|        OPENSSL_cleanse(s->s3->tmp.key_block, s->s3->tmp.key_block_length);
  496|      0|        OPENSSL_free(s->s3->tmp.key_block);
  497|      0|        s->s3->tmp.key_block = NULL;
  498|      0|    }
  499|    150|    s->s3->tmp.key_block_length = 0;
  500|    150|}
ssl3_init_finished_mac:
  577|     30|{
  578|     30|    if (s->s3->handshake_buffer)
  579|      0|        BIO_free(s->s3->handshake_buffer);
  580|     30|    if (s->s3->handshake_dgst)
  581|      0|        ssl3_free_digest_list(s);
  582|     30|    s->s3->handshake_buffer = BIO_new(BIO_s_mem());
  583|     30|    if (s->s3->handshake_buffer == NULL)
  584|      0|        return 0;
  585|     30|    (void)BIO_set_close(s->s3->handshake_buffer, BIO_CLOSE);
  586|     30|    return 1;
  587|     30|}
ssl3_finish_mac:
  603|     30|{
  604|     30|    if (s->s3->handshake_buffer
  605|     30|        && !(s->s3->flags & TLS1_FLAGS_KEEP_HANDSHAKE)) {
  606|     30|        BIO_write(s->s3->handshake_buffer, (void *)buf, len);
  607|     30|    } else {
  608|      0|        int i;
  609|      0|        for (i = 0; i < SSL_MAX_DIGEST; i++) {
  610|      0|            if (s->s3->handshake_dgst[i] != NULL)
  611|      0|                EVP_DigestUpdate(s->s3->handshake_dgst[i], buf, len);
  612|      0|        }
  613|      0|    }
  614|     30|}

ssl3_num_ciphers:
 2982|  8.46k|{
 2983|  8.46k|    return (SSL3_NUM_CIPHERS);
 2984|  8.46k|}
ssl3_get_cipher:
 2987|  8.40k|{
 2988|  8.40k|    if (u < SSL3_NUM_CIPHERS)
 2989|  8.40k|        return (&(ssl3_ciphers[SSL3_NUM_CIPHERS - 1 - u]));
 2990|      0|    else
 2991|      0|        return (NULL);
 2992|  8.40k|}
ssl3_new:
 3018|     30|{
 3019|     30|    SSL3_STATE *s3;
 3020|       |
 3021|     30|    if ((s3 = OPENSSL_malloc(sizeof *s3)) == NULL)
 3022|      0|        goto err;
 3023|     30|    memset(s3, 0, sizeof *s3);
 3024|     30|    memset(s3->rrec.seq_num, 0, sizeof(s3->rrec.seq_num));
 3025|     30|    memset(s3->wrec.seq_num, 0, sizeof(s3->wrec.seq_num));
 3026|       |
 3027|     30|    s->s3 = s3;
 3028|       |
 3029|     30|#ifndef OPENSSL_NO_SRP
 3030|     30|    SSL_SRP_CTX_init(s);
 3031|     30|#endif
 3032|     30|    s->method->ssl_clear(s);
 3033|     30|    return (1);
 3034|      0| err:
 3035|      0|    return (0);
 3036|     30|}
ssl3_free:
 3039|     30|{
 3040|     30|    if (s == NULL || s->s3 == NULL)
 3041|      0|        return;
 3042|       |
 3043|       |#ifdef TLSEXT_TYPE_opaque_prf_input
 3044|       |    if (s->s3->client_opaque_prf_input != NULL)
 3045|       |        OPENSSL_free(s->s3->client_opaque_prf_input);
 3046|       |    if (s->s3->server_opaque_prf_input != NULL)
 3047|       |        OPENSSL_free(s->s3->server_opaque_prf_input);
 3048|       |#endif
 3049|       |
 3050|     30|    ssl3_cleanup_key_block(s);
 3051|     30|    if (s->s3->rbuf.buf != NULL)
 3052|     30|        ssl3_release_read_buffer(s);
 3053|     30|    if (s->s3->wbuf.buf != NULL)
 3054|     30|        ssl3_release_write_buffer(s);
 3055|     30|    if (s->s3->rrec.comp != NULL)
 3056|      0|        OPENSSL_free(s->s3->rrec.comp);
 3057|     30|#ifndef OPENSSL_NO_DH
 3058|     30|    if (s->s3->tmp.dh != NULL)
 3059|      0|        DH_free(s->s3->tmp.dh);
 3060|     30|#endif
 3061|     30|#ifndef OPENSSL_NO_ECDH
 3062|     30|    if (s->s3->tmp.ecdh != NULL)
 3063|      0|        EC_KEY_free(s->s3->tmp.ecdh);
 3064|     30|#endif
 3065|       |
 3066|     30|    if (s->s3->tmp.ca_names != NULL)
 3067|     30|        sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);
 3068|     30|    if (s->s3->handshake_buffer) {
 3069|     30|        BIO_free(s->s3->handshake_buffer);
 3070|     30|    }
 3071|     30|    if (s->s3->handshake_dgst)
 3072|      0|        ssl3_free_digest_list(s);
 3073|     30|#ifndef OPENSSL_NO_TLSEXT
 3074|     30|    if (s->s3->alpn_selected)
 3075|      0|        OPENSSL_free(s->s3->alpn_selected);
 3076|     30|#endif
 3077|       |
 3078|     30|#ifndef OPENSSL_NO_SRP
 3079|     30|    SSL_SRP_CTX_free(s);
 3080|     30|#endif
 3081|     30|    OPENSSL_cleanse(s->s3, sizeof *s->s3);
 3082|     30|    OPENSSL_free(s->s3);
 3083|     30|    s->s3 = NULL;
 3084|     30|}
ssl3_clear:
 3087|    120|{
 3088|    120|    unsigned char *rp, *wp;
 3089|    120|    size_t rlen, wlen;
 3090|    120|    int init_extra;
 3091|       |
 3092|       |#ifdef TLSEXT_TYPE_opaque_prf_input
 3093|       |    if (s->s3->client_opaque_prf_input != NULL)
 3094|       |        OPENSSL_free(s->s3->client_opaque_prf_input);
 3095|       |    s->s3->client_opaque_prf_input = NULL;
 3096|       |    if (s->s3->server_opaque_prf_input != NULL)
 3097|       |        OPENSSL_free(s->s3->server_opaque_prf_input);
 3098|       |    s->s3->server_opaque_prf_input = NULL;
 3099|       |#endif
 3100|       |
 3101|    120|    ssl3_cleanup_key_block(s);
 3102|    120|    if (s->s3->tmp.ca_names != NULL)
 3103|    120|        sk_X509_NAME_pop_free(s->s3->tmp.ca_names, X509_NAME_free);
 3104|       |
 3105|    120|    if (s->s3->rrec.comp != NULL) {
 3106|      0|        OPENSSL_free(s->s3->rrec.comp);
 3107|      0|        s->s3->rrec.comp = NULL;
 3108|      0|    }
 3109|    120|#ifndef OPENSSL_NO_DH
 3110|    120|    if (s->s3->tmp.dh != NULL) {
 3111|      0|        DH_free(s->s3->tmp.dh);
 3112|      0|        s->s3->tmp.dh = NULL;
 3113|      0|    }
 3114|    120|#endif
 3115|    120|#ifndef OPENSSL_NO_ECDH
 3116|    120|    if (s->s3->tmp.ecdh != NULL) {
 3117|      0|        EC_KEY_free(s->s3->tmp.ecdh);
 3118|      0|        s->s3->tmp.ecdh = NULL;
 3119|      0|    }
 3120|    120|#endif
 3121|    120|#ifndef OPENSSL_NO_TLSEXT
 3122|    120|# ifndef OPENSSL_NO_EC
 3123|    120|    s->s3->is_probably_safari = 0;
 3124|    120|# endif                         /* !OPENSSL_NO_EC */
 3125|    120|#endif                          /* !OPENSSL_NO_TLSEXT */
 3126|       |
 3127|    120|    rp = s->s3->rbuf.buf;
 3128|    120|    wp = s->s3->wbuf.buf;
 3129|    120|    rlen = s->s3->rbuf.len;
 3130|    120|    wlen = s->s3->wbuf.len;
 3131|    120|    init_extra = s->s3->init_extra;
 3132|    120|    if (s->s3->handshake_buffer) {
 3133|      0|        BIO_free(s->s3->handshake_buffer);
 3134|      0|        s->s3->handshake_buffer = NULL;
 3135|      0|    }
 3136|    120|    if (s->s3->handshake_dgst) {
 3137|      0|        ssl3_free_digest_list(s);
 3138|      0|    }
 3139|    120|#if !defined(OPENSSL_NO_TLSEXT)
 3140|    120|    if (s->s3->alpn_selected) {
 3141|      0|        OPENSSL_free(s->s3->alpn_selected);
 3142|      0|        s->s3->alpn_selected = NULL;
 3143|      0|    }
 3144|    120|#endif
 3145|    120|    memset(s->s3, 0, sizeof *s->s3);
 3146|    120|    s->s3->rbuf.buf = rp;
 3147|    120|    s->s3->wbuf.buf = wp;
 3148|    120|    s->s3->rbuf.len = rlen;
 3149|    120|    s->s3->wbuf.len = wlen;
 3150|    120|    s->s3->init_extra = init_extra;
 3151|       |
 3152|    120|    ssl_free_wbio_buffer(s);
 3153|       |
 3154|    120|    s->packet_length = 0;
 3155|    120|    s->s3->renegotiate = 0;
 3156|    120|    s->s3->total_renegotiations = 0;
 3157|    120|    s->s3->num_renegotiations = 0;
 3158|    120|    s->s3->in_read_app_data = 0;
 3159|    120|    s->version = SSL3_VERSION;
 3160|       |
 3161|    120|#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
 3162|    120|    if (s->next_proto_negotiated) {
 3163|      0|        OPENSSL_free(s->next_proto_negotiated);
 3164|      0|        s->next_proto_negotiated = NULL;
 3165|      0|        s->next_proto_negotiated_len = 0;
 3166|      0|    }
 3167|    120|#endif
 3168|    120|}
ssl3_ctrl:
 3181|     28|{
 3182|     28|    int ret = 0;
 3183|       |
 3184|     28|#if !defined(OPENSSL_NO_DSA) || !defined(OPENSSL_NO_RSA)
 3185|     28|    if (
 3186|     28|# ifndef OPENSSL_NO_RSA
 3187|     28|           cmd == SSL_CTRL_SET_TMP_RSA || cmd == SSL_CTRL_SET_TMP_RSA_CB ||
 3188|     28|# endif
 3189|     28|# ifndef OPENSSL_NO_DSA
 3190|     28|           cmd == SSL_CTRL_SET_TMP_DH || cmd == SSL_CTRL_SET_TMP_DH_CB ||
 3191|     28|# endif
 3192|     28|           0) {
 3193|      0|        if (!ssl_cert_inst(&s->cert)) {
 3194|      0|            SSLerr(SSL_F_SSL3_CTRL, ERR_R_MALLOC_FAILURE);
 3195|      0|            return (0);
 3196|      0|        }
 3197|      0|    }
 3198|     28|#endif
 3199|       |
 3200|     28|    switch (cmd) {
 3201|      0|    case SSL_CTRL_GET_SESSION_REUSED:
 3202|      0|        ret = s->hit;
 3203|      0|        break;
 3204|      0|    case SSL_CTRL_GET_CLIENT_CERT_REQUEST:
 3205|      0|        break;
 3206|      0|    case SSL_CTRL_GET_NUM_RENEGOTIATIONS:
 3207|      0|        ret = s->s3->num_renegotiations;
 3208|      0|        break;
 3209|      0|    case SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS:
 3210|      0|        ret = s->s3->num_renegotiations;
 3211|      0|        s->s3->num_renegotiations = 0;
 3212|      0|        break;
 3213|      0|    case SSL_CTRL_GET_TOTAL_RENEGOTIATIONS:
 3214|      0|        ret = s->s3->total_renegotiations;
 3215|      0|        break;
 3216|      0|    case SSL_CTRL_GET_FLAGS:
 3217|      0|        ret = (int)(s->s3->flags);
 3218|      0|        break;
 3219|      0|#ifndef OPENSSL_NO_RSA
 3220|      0|    case SSL_CTRL_NEED_TMP_RSA:
 3221|      0|        if ((s->cert != NULL) && (s->cert->rsa_tmp == NULL) &&
 3222|      0|            ((s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey == NULL) ||
 3223|      0|             (EVP_PKEY_size(s->cert->pkeys[SSL_PKEY_RSA_ENC].privatekey) >
 3224|      0|              (512 / 8))))
 3225|      0|            ret = 1;
 3226|      0|        break;
 3227|      0|    case SSL_CTRL_SET_TMP_RSA:
 3228|      0|        {
 3229|      0|            RSA *rsa = (RSA *)parg;
 3230|      0|            if (rsa == NULL) {
 3231|      0|                SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);
 3232|      0|                return (ret);
 3233|      0|            }
 3234|      0|            if ((rsa = RSAPrivateKey_dup(rsa)) == NULL) {
 3235|      0|                SSLerr(SSL_F_SSL3_CTRL, ERR_R_RSA_LIB);
 3236|      0|                return (ret);
 3237|      0|            }
 3238|      0|            if (s->cert->rsa_tmp != NULL)
 3239|      0|                RSA_free(s->cert->rsa_tmp);
 3240|      0|            s->cert->rsa_tmp = rsa;
 3241|      0|            ret = 1;
 3242|      0|        }
 3243|      0|        break;
 3244|      0|    case SSL_CTRL_SET_TMP_RSA_CB:
 3245|      0|        {
 3246|      0|            SSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
 3247|      0|            return (ret);
 3248|      0|        }
 3249|      0|        break;
 3250|      0|#endif
 3251|      0|#ifndef OPENSSL_NO_DH
 3252|      0|    case SSL_CTRL_SET_TMP_DH:
 3253|      0|        {
 3254|      0|            DH *dh = (DH *)parg;
 3255|      0|            if (dh == NULL) {
 3256|      0|                SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);
 3257|      0|                return (ret);
 3258|      0|            }
 3259|      0|            if ((dh = DHparams_dup(dh)) == NULL) {
 3260|      0|                SSLerr(SSL_F_SSL3_CTRL, ERR_R_DH_LIB);
 3261|      0|                return (ret);
 3262|      0|            }
 3263|      0|            if (s->cert->dh_tmp != NULL)
 3264|      0|                DH_free(s->cert->dh_tmp);
 3265|      0|            s->cert->dh_tmp = dh;
 3266|      0|            ret = 1;
 3267|      0|        }
 3268|      0|        break;
 3269|      0|    case SSL_CTRL_SET_TMP_DH_CB:
 3270|      0|        {
 3271|      0|            SSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
 3272|      0|            return (ret);
 3273|      0|        }
 3274|      0|        break;
 3275|      0|#endif
 3276|      0|#ifndef OPENSSL_NO_ECDH
 3277|      0|    case SSL_CTRL_SET_TMP_ECDH:
 3278|      0|        {
 3279|      0|            EC_KEY *ecdh = NULL;
 3280|       |
 3281|      0|            if (parg == NULL) {
 3282|      0|                SSLerr(SSL_F_SSL3_CTRL, ERR_R_PASSED_NULL_PARAMETER);
 3283|      0|                return (ret);
 3284|      0|            }
 3285|      0|            if (!EC_KEY_up_ref((EC_KEY *)parg)) {
 3286|      0|                SSLerr(SSL_F_SSL3_CTRL, ERR_R_ECDH_LIB);
 3287|      0|                return (ret);
 3288|      0|            }
 3289|      0|            ecdh = (EC_KEY *)parg;
 3290|      0|            if (!(s->options & SSL_OP_SINGLE_ECDH_USE)) {
 3291|      0|                if (!EC_KEY_generate_key(ecdh)) {
 3292|      0|                    EC_KEY_free(ecdh);
 3293|      0|                    SSLerr(SSL_F_SSL3_CTRL, ERR_R_ECDH_LIB);
 3294|      0|                    return (ret);
 3295|      0|                }
 3296|      0|            }
 3297|      0|            if (s->cert->ecdh_tmp != NULL)
 3298|      0|                EC_KEY_free(s->cert->ecdh_tmp);
 3299|      0|            s->cert->ecdh_tmp = ecdh;
 3300|      0|            ret = 1;
 3301|      0|        }
 3302|      0|        break;
 3303|      0|    case SSL_CTRL_SET_TMP_ECDH_CB:
 3304|      0|        {
 3305|      0|            SSLerr(SSL_F_SSL3_CTRL, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
 3306|      0|            return (ret);
 3307|      0|        }
 3308|      0|        break;
 3309|      0|#endif                          /* !OPENSSL_NO_ECDH */
 3310|      0|#ifndef OPENSSL_NO_TLSEXT
 3311|     28|    case SSL_CTRL_SET_TLSEXT_HOSTNAME:
 3312|     28|        if (larg == TLSEXT_NAMETYPE_host_name) {
 3313|     28|            size_t len;
 3314|       |
 3315|     28|            if (s->tlsext_hostname != NULL)
 3316|      0|                OPENSSL_free(s->tlsext_hostname);
 3317|     28|            s->tlsext_hostname = NULL;
 3318|       |
 3319|     28|            ret = 1;
 3320|     28|            if (parg == NULL)
 3321|      0|                break;
 3322|     28|            len = strlen((char *)parg);
 3323|     28|            if (len == 0 || len > TLSEXT_MAXLEN_host_name) {
 3324|      2|                SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME);
 3325|      2|                return 0;
 3326|      2|            }
 3327|     26|            if ((s->tlsext_hostname = BUF_strdup((char *)parg)) == NULL) {
 3328|      0|                SSLerr(SSL_F_SSL3_CTRL, ERR_R_INTERNAL_ERROR);
 3329|      0|                return 0;
 3330|      0|            }
 3331|     26|        } else {
 3332|      0|            SSLerr(SSL_F_SSL3_CTRL, SSL_R_SSL3_EXT_INVALID_SERVERNAME_TYPE);
 3333|      0|            return 0;
 3334|      0|        }
 3335|     26|        break;
 3336|     26|    case SSL_CTRL_SET_TLSEXT_DEBUG_ARG:
 3337|      0|        s->tlsext_debug_arg = parg;
 3338|      0|        ret = 1;
 3339|      0|        break;
 3340|       |
 3341|       |# ifdef TLSEXT_TYPE_opaque_prf_input
 3342|       |    case SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT:
 3343|       |        if (larg > 12288) {     /* actual internal limit is 2^16 for the
 3344|       |                                 * complete hello message * (including the
 3345|       |                                 * cert chain and everything) */
 3346|       |            SSLerr(SSL_F_SSL3_CTRL, SSL_R_OPAQUE_PRF_INPUT_TOO_LONG);
 3347|       |            break;
 3348|       |        }
 3349|       |        if (s->tlsext_opaque_prf_input != NULL)
 3350|       |            OPENSSL_free(s->tlsext_opaque_prf_input);
 3351|       |        if ((size_t)larg == 0)
 3352|       |            s->tlsext_opaque_prf_input = OPENSSL_malloc(1); /* dummy byte
 3353|       |                                                             * just to get
 3354|       |                                                             * non-NULL */
 3355|       |        else
 3356|       |            s->tlsext_opaque_prf_input = BUF_memdup(parg, (size_t)larg);
 3357|       |        if (s->tlsext_opaque_prf_input != NULL) {
 3358|       |            s->tlsext_opaque_prf_input_len = (size_t)larg;
 3359|       |            ret = 1;
 3360|       |        } else
 3361|       |            s->tlsext_opaque_prf_input_len = 0;
 3362|       |        break;
 3363|       |# endif
 3364|       |
 3365|      0|    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE:
 3366|      0|        s->tlsext_status_type = larg;
 3367|      0|        ret = 1;
 3368|      0|        break;
 3369|       |
 3370|      0|    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS:
 3371|      0|        *(STACK_OF(X509_EXTENSION) **)parg = s->tlsext_ocsp_exts;
 3372|      0|        ret = 1;
 3373|      0|        break;
 3374|       |
 3375|      0|    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS:
 3376|      0|        s->tlsext_ocsp_exts = parg;
 3377|      0|        ret = 1;
 3378|      0|        break;
 3379|       |
 3380|      0|    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS:
 3381|      0|        *(STACK_OF(OCSP_RESPID) **)parg = s->tlsext_ocsp_ids;
 3382|      0|        ret = 1;
 3383|      0|        break;
 3384|       |
 3385|      0|    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS:
 3386|      0|        s->tlsext_ocsp_ids = parg;
 3387|      0|        ret = 1;
 3388|      0|        break;
 3389|       |
 3390|      0|    case SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP:
 3391|      0|        *(unsigned char **)parg = s->tlsext_ocsp_resp;
 3392|      0|        return s->tlsext_ocsp_resplen;
 3393|       |
 3394|      0|    case SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP:
 3395|      0|        if (s->tlsext_ocsp_resp)
 3396|      0|            OPENSSL_free(s->tlsext_ocsp_resp);
 3397|      0|        s->tlsext_ocsp_resp = parg;
 3398|      0|        s->tlsext_ocsp_resplen = larg;
 3399|      0|        ret = 1;
 3400|      0|        break;
 3401|       |
 3402|      0|# ifndef OPENSSL_NO_HEARTBEATS
 3403|      0|    case SSL_CTRL_TLS_EXT_SEND_HEARTBEAT:
 3404|      0|        if (SSL_IS_DTLS(s))
 3405|      0|            ret = dtls1_heartbeat(s);
 3406|      0|        else
 3407|      0|            ret = tls1_heartbeat(s);
 3408|      0|        break;
 3409|       |
 3410|      0|    case SSL_CTRL_GET_TLS_EXT_HEARTBEAT_PENDING:
 3411|      0|        ret = s->tlsext_hb_pending;
 3412|      0|        break;
 3413|       |
 3414|      0|    case SSL_CTRL_SET_TLS_EXT_HEARTBEAT_NO_REQUESTS:
 3415|      0|        if (larg)
 3416|      0|            s->tlsext_heartbeat |= SSL_TLSEXT_HB_DONT_RECV_REQUESTS;
 3417|      0|        else
 3418|      0|            s->tlsext_heartbeat &= ~SSL_TLSEXT_HB_DONT_RECV_REQUESTS;
 3419|      0|        ret = 1;
 3420|      0|        break;
 3421|      0|# endif
 3422|       |
 3423|      0|#endif                          /* !OPENSSL_NO_TLSEXT */
 3424|       |
 3425|      0|    case SSL_CTRL_CHAIN:
 3426|      0|        if (larg)
 3427|      0|            return ssl_cert_set1_chain(s->cert, (STACK_OF(X509) *)parg);
 3428|      0|        else
 3429|      0|            return ssl_cert_set0_chain(s->cert, (STACK_OF(X509) *)parg);
 3430|       |
 3431|      0|    case SSL_CTRL_CHAIN_CERT:
 3432|      0|        if (larg)
 3433|      0|            return ssl_cert_add1_chain_cert(s->cert, (X509 *)parg);
 3434|      0|        else
 3435|      0|            return ssl_cert_add0_chain_cert(s->cert, (X509 *)parg);
 3436|       |
 3437|      0|    case SSL_CTRL_GET_CHAIN_CERTS:
 3438|      0|        *(STACK_OF(X509) **)parg = s->cert->key->chain;
 3439|      0|        break;
 3440|       |
 3441|      0|    case SSL_CTRL_SELECT_CURRENT_CERT:
 3442|      0|        return ssl_cert_select_current(s->cert, (X509 *)parg);
 3443|       |
 3444|      0|    case SSL_CTRL_SET_CURRENT_CERT:
 3445|      0|        if (larg == SSL_CERT_SET_SERVER) {
 3446|      0|            CERT_PKEY *cpk;
 3447|      0|            const SSL_CIPHER *cipher;
 3448|      0|            if (!s->server)
 3449|      0|                return 0;
 3450|      0|            cipher = s->s3->tmp.new_cipher;
 3451|      0|            if (!cipher)
 3452|      0|                return 0;
 3453|       |            /*
 3454|       |             * No certificate for unauthenticated ciphersuites or using SRP
 3455|       |             * authentication
 3456|       |             */
 3457|      0|            if (cipher->algorithm_auth & (SSL_aNULL | SSL_aSRP))
 3458|      0|                return 2;
 3459|      0|            cpk = ssl_get_server_send_pkey(s);
 3460|      0|            if (!cpk)
 3461|      0|                return 0;
 3462|      0|            s->cert->key = cpk;
 3463|      0|            return 1;
 3464|      0|        }
 3465|      0|        return ssl_cert_set_current(s->cert, larg);
 3466|       |
 3467|      0|#ifndef OPENSSL_NO_EC
 3468|      0|    case SSL_CTRL_GET_CURVES:
 3469|      0|        {
 3470|      0|            unsigned char *clist;
 3471|      0|            size_t clistlen;
 3472|      0|            if (!s->session)
 3473|      0|                return 0;
 3474|      0|            clist = s->session->tlsext_ellipticcurvelist;
 3475|      0|            clistlen = s->session->tlsext_ellipticcurvelist_length / 2;
 3476|      0|            if (parg) {
 3477|      0|                size_t i;
 3478|      0|                int *cptr = parg;
 3479|      0|                unsigned int cid, nid;
 3480|      0|                for (i = 0; i < clistlen; i++) {
 3481|      0|                    n2s(clist, cid);
 3482|      0|                    nid = tls1_ec_curve_id2nid(cid);
 3483|      0|                    if (nid != 0)
 3484|      0|                        cptr[i] = nid;
 3485|      0|                    else
 3486|      0|                        cptr[i] = TLSEXT_nid_unknown | cid;
 3487|      0|                }
 3488|      0|            }
 3489|      0|            return (int)clistlen;
 3490|      0|        }
 3491|       |
 3492|      0|    case SSL_CTRL_SET_CURVES:
 3493|      0|        return tls1_set_curves(&s->tlsext_ellipticcurvelist,
 3494|      0|                               &s->tlsext_ellipticcurvelist_length,
 3495|      0|                               parg, larg);
 3496|       |
 3497|      0|    case SSL_CTRL_SET_CURVES_LIST:
 3498|      0|        return tls1_set_curves_list(&s->tlsext_ellipticcurvelist,
 3499|      0|                                    &s->tlsext_ellipticcurvelist_length,
 3500|      0|                                    parg);
 3501|       |
 3502|      0|    case SSL_CTRL_GET_SHARED_CURVE:
 3503|      0|        return tls1_shared_curve(s, larg);
 3504|       |
 3505|      0|# ifndef OPENSSL_NO_ECDH
 3506|      0|    case SSL_CTRL_SET_ECDH_AUTO:
 3507|      0|        s->cert->ecdh_tmp_auto = larg;
 3508|      0|        return 1;
 3509|      0|# endif
 3510|      0|#endif
 3511|      0|    case SSL_CTRL_SET_SIGALGS:
 3512|      0|        return tls1_set_sigalgs(s->cert, parg, larg, 0);
 3513|       |
 3514|      0|    case SSL_CTRL_SET_SIGALGS_LIST:
 3515|      0|        return tls1_set_sigalgs_list(s->cert, parg, 0);
 3516|       |
 3517|      0|    case SSL_CTRL_SET_CLIENT_SIGALGS:
 3518|      0|        return tls1_set_sigalgs(s->cert, parg, larg, 1);
 3519|       |
 3520|      0|    case SSL_CTRL_SET_CLIENT_SIGALGS_LIST:
 3521|      0|        return tls1_set_sigalgs_list(s->cert, parg, 1);
 3522|       |
 3523|      0|    case SSL_CTRL_GET_CLIENT_CERT_TYPES:
 3524|      0|        {
 3525|      0|            const unsigned char **pctype = parg;
 3526|      0|            if (s->server || !s->s3->tmp.cert_req)
 3527|      0|                return 0;
 3528|      0|            if (s->cert->ctypes) {
 3529|      0|                if (pctype)
 3530|      0|                    *pctype = s->cert->ctypes;
 3531|      0|                return (int)s->cert->ctype_num;
 3532|      0|            }
 3533|      0|            if (pctype)
 3534|      0|                *pctype = (unsigned char *)s->s3->tmp.ctype;
 3535|      0|            return s->s3->tmp.ctype_num;
 3536|      0|        }
 3537|       |
 3538|      0|    case SSL_CTRL_SET_CLIENT_CERT_TYPES:
 3539|      0|        if (!s->server)
 3540|      0|            return 0;
 3541|      0|        return ssl3_set_req_cert_type(s->cert, parg, larg);
 3542|       |
 3543|      0|    case SSL_CTRL_BUILD_CERT_CHAIN:
 3544|      0|        return ssl_build_cert_chain(s->cert, s->ctx->cert_store, larg);
 3545|       |
 3546|      0|    case SSL_CTRL_SET_VERIFY_CERT_STORE:
 3547|      0|        return ssl_cert_set_cert_store(s->cert, parg, 0, larg);
 3548|       |
 3549|      0|    case SSL_CTRL_SET_CHAIN_CERT_STORE:
 3550|      0|        return ssl_cert_set_cert_store(s->cert, parg, 1, larg);
 3551|       |
 3552|      0|    case SSL_CTRL_GET_PEER_SIGNATURE_NID:
 3553|      0|        if (SSL_USE_SIGALGS(s)) {
 3554|      0|            if (s->session && s->session->sess_cert) {
 3555|      0|                const EVP_MD *sig;
 3556|      0|                sig = s->session->sess_cert->peer_key->digest;
 3557|      0|                if (sig) {
 3558|      0|                    *(int *)parg = EVP_MD_type(sig);
 3559|      0|                    return 1;
 3560|      0|                }
 3561|      0|            }
 3562|      0|            return 0;
 3563|      0|        }
 3564|       |        /* Might want to do something here for other versions */
 3565|      0|        else
 3566|      0|            return 0;
 3567|       |
 3568|      0|    case SSL_CTRL_GET_SERVER_TMP_KEY:
 3569|      0|        if (s->server || !s->session || !s->session->sess_cert)
 3570|      0|            return 0;
 3571|      0|        else {
 3572|      0|            SESS_CERT *sc;
 3573|      0|            EVP_PKEY *ptmp;
 3574|      0|            int rv = 0;
 3575|      0|            sc = s->session->sess_cert;
 3576|      0|#if !defined(OPENSSL_NO_RSA) && !defined(OPENSSL_NO_DH) && !defined(OPENSSL_NO_EC) && !defined(OPENSSL_NO_ECDH)
 3577|      0|            if (!sc->peer_rsa_tmp && !sc->peer_dh_tmp && !sc->peer_ecdh_tmp)
 3578|      0|                return 0;
 3579|      0|#endif
 3580|      0|            ptmp = EVP_PKEY_new();
 3581|      0|            if (!ptmp)
 3582|      0|                return 0;
 3583|      0|            if (0) ;
 3584|      0|#ifndef OPENSSL_NO_RSA
 3585|      0|            else if (sc->peer_rsa_tmp)
 3586|      0|                rv = EVP_PKEY_set1_RSA(ptmp, sc->peer_rsa_tmp);
 3587|      0|#endif
 3588|      0|#ifndef OPENSSL_NO_DH
 3589|      0|            else if (sc->peer_dh_tmp)
 3590|      0|                rv = EVP_PKEY_set1_DH(ptmp, sc->peer_dh_tmp);
 3591|      0|#endif
 3592|      0|#ifndef OPENSSL_NO_ECDH
 3593|      0|            else if (sc->peer_ecdh_tmp)
 3594|      0|                rv = EVP_PKEY_set1_EC_KEY(ptmp, sc->peer_ecdh_tmp);
 3595|      0|#endif
 3596|      0|            if (rv) {
 3597|      0|                *(EVP_PKEY **)parg = ptmp;
 3598|      0|                return 1;
 3599|      0|            }
 3600|      0|            EVP_PKEY_free(ptmp);
 3601|      0|            return 0;
 3602|      0|        }
 3603|      0|#ifndef OPENSSL_NO_EC
 3604|      0|    case SSL_CTRL_GET_EC_POINT_FORMATS:
 3605|      0|        {
 3606|      0|            SSL_SESSION *sess = s->session;
 3607|      0|            const unsigned char **pformat = parg;
 3608|      0|            if (!sess || !sess->tlsext_ecpointformatlist)
 3609|      0|                return 0;
 3610|      0|            *pformat = sess->tlsext_ecpointformatlist;
 3611|      0|            return (int)sess->tlsext_ecpointformatlist_length;
 3612|      0|        }
 3613|      0|#endif
 3614|       |
 3615|      0|    case SSL_CTRL_CHECK_PROTO_VERSION:
 3616|       |        /*
 3617|       |         * For library-internal use; checks that the current protocol is the
 3618|       |         * highest enabled version (according to s->ctx->method, as version
 3619|       |         * negotiation may have changed s->method).
 3620|       |         */
 3621|      0|        if (s->version == s->ctx->method->version)
 3622|      0|            return 1;
 3623|       |        /*
 3624|       |         * Apparently we're using a version-flexible SSL_METHOD (not at its
 3625|       |         * highest protocol version).
 3626|       |         */
 3627|      0|        if (s->ctx->method->version == SSLv23_method()->version) {
 3628|       |#if TLS_MAX_VERSION != TLS1_2_VERSION
 3629|       |# error Code needs update for SSLv23_method() support beyond TLS1_2_VERSION.
 3630|       |#endif
 3631|      0|            if (!(s->options & SSL_OP_NO_TLSv1_2))
 3632|      0|                return s->version == TLS1_2_VERSION;
 3633|      0|            if (!(s->options & SSL_OP_NO_TLSv1_1))
 3634|      0|                return s->version == TLS1_1_VERSION;
 3635|      0|            if (!(s->options & SSL_OP_NO_TLSv1))
 3636|      0|                return s->version == TLS1_VERSION;
 3637|      0|            if (!(s->options & SSL_OP_NO_SSLv3))
 3638|      0|                return s->version == SSL3_VERSION;
 3639|      0|            if (!(s->options & SSL_OP_NO_SSLv2))
 3640|      0|                return s->version == SSL2_VERSION;
 3641|      0|        }
 3642|      0|        return 0;               /* Unexpected state; fail closed. */
 3643|       |
 3644|      0|    default:
 3645|      0|        break;
 3646|     28|    }
 3647|     26|    return (ret);
 3648|     28|}
ssl3_put_cipher_by_char:
 4072|  2.40k|{
 4073|  2.40k|    long l;
 4074|       |
 4075|  2.40k|    if (p != NULL) {
 4076|  2.40k|        l = c->id;
 4077|  2.40k|        if ((l & 0xff000000) != 0x03000000)
 4078|      0|            return (0);
 4079|  2.40k|        p[0] = ((unsigned char)(l >> 8L)) & 0xFF;
 4080|  2.40k|        p[1] = ((unsigned char)(l)) & 0xFF;
 4081|  2.40k|    }
 4082|  2.40k|    return (2);
 4083|  2.40k|}

SSL_library_init:
   65|      1|{
   66|       |
   67|      1|#ifndef OPENSSL_NO_DES
   68|      1|    EVP_add_cipher(EVP_des_cbc());
   69|      1|    EVP_add_cipher(EVP_des_ede3_cbc());
   70|      1|#endif
   71|      1|#ifndef OPENSSL_NO_IDEA
   72|      1|    EVP_add_cipher(EVP_idea_cbc());
   73|      1|#endif
   74|      1|#ifndef OPENSSL_NO_RC4
   75|      1|    EVP_add_cipher(EVP_rc4());
   76|      1|# if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))
   77|      1|    EVP_add_cipher(EVP_rc4_hmac_md5());
   78|      1|# endif
   79|      1|#endif
   80|      1|#ifndef OPENSSL_NO_RC2
   81|      1|    EVP_add_cipher(EVP_rc2_cbc());
   82|       |    /*
   83|       |     * Not actually used for SSL/TLS but this makes PKCS#12 work if an
   84|       |     * application only calls SSL_library_init().
   85|       |     */
   86|      1|    EVP_add_cipher(EVP_rc2_40_cbc());
   87|      1|#endif
   88|      1|#ifndef OPENSSL_NO_AES
   89|      1|    EVP_add_cipher(EVP_aes_128_cbc());
   90|      1|    EVP_add_cipher(EVP_aes_192_cbc());
   91|      1|    EVP_add_cipher(EVP_aes_256_cbc());
   92|      1|    EVP_add_cipher(EVP_aes_128_gcm());
   93|      1|    EVP_add_cipher(EVP_aes_256_gcm());
   94|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
   95|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
   96|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
   97|      1|# endif
   98|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA256)
   99|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha256());
  100|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha256());
  101|      1|# endif
  102|       |
  103|      1|#endif
  104|      1|#ifndef OPENSSL_NO_CAMELLIA
  105|      1|    EVP_add_cipher(EVP_camellia_128_cbc());
  106|      1|    EVP_add_cipher(EVP_camellia_256_cbc());
  107|      1|#endif
  108|       |
  109|      1|#ifndef OPENSSL_NO_SEED
  110|      1|    EVP_add_cipher(EVP_seed_cbc());
  111|      1|#endif
  112|       |
  113|      1|#ifndef OPENSSL_NO_MD5
  114|      1|    EVP_add_digest(EVP_md5());
  115|      1|    EVP_add_digest_alias(SN_md5, "ssl2-md5");
  116|      1|    EVP_add_digest_alias(SN_md5, "ssl3-md5");
  117|      1|#endif
  118|      1|#ifndef OPENSSL_NO_SHA
  119|      1|    EVP_add_digest(EVP_sha1()); /* RSA with sha1 */
  120|      1|    EVP_add_digest_alias(SN_sha1, "ssl3-sha1");
  121|      1|    EVP_add_digest_alias(SN_sha1WithRSAEncryption, SN_sha1WithRSA);
  122|      1|#endif
  123|      1|#ifndef OPENSSL_NO_SHA256
  124|      1|    EVP_add_digest(EVP_sha224());
  125|      1|    EVP_add_digest(EVP_sha256());
  126|      1|#endif
  127|      1|#ifndef OPENSSL_NO_SHA512
  128|      1|    EVP_add_digest(EVP_sha384());
  129|      1|    EVP_add_digest(EVP_sha512());
  130|      1|#endif
  131|      1|#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)
  132|      1|    EVP_add_digest(EVP_dss1()); /* DSA with sha1 */
  133|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, SN_dsaWithSHA1_2);
  134|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "DSS1");
  135|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "dss1");
  136|      1|#endif
  137|      1|#ifndef OPENSSL_NO_ECDSA
  138|      1|    EVP_add_digest(EVP_ecdsa());
  139|      1|#endif
  140|       |    /* If you want support for phased out ciphers, add the following */
  141|       |#if 0
  142|       |    EVP_add_digest(EVP_sha());
  143|       |    EVP_add_digest(EVP_dss());
  144|       |#endif
  145|      1|#ifndef OPENSSL_NO_COMP
  146|       |    /*
  147|       |     * This will initialise the built-in compression algorithms. The value
  148|       |     * returned is a STACK_OF(SSL_COMP), but that can be discarded safely
  149|       |     */
  150|      1|    (void)SSL_COMP_get_compression_methods();
  151|      1|#endif
  152|       |    /* initialize cipher/digest methods table */
  153|      1|    ssl_load_ciphers();
  154|      1|    return (1);
  155|      1|}

SSL_get_ex_data_X509_STORE_CTX_idx:
  138|     30|{
  139|     30|    static volatile int ssl_x509_store_ctx_idx = -1;
  140|     30|    int got_write_lock = 0;
  141|       |
  142|     30|    if (((size_t)&ssl_x509_store_ctx_idx &
  143|     30|         (sizeof(ssl_x509_store_ctx_idx) - 1))
  144|     30|        == 0) {                 /* check alignment, practically always true */
  145|     30|        int ret;
  146|       |
  147|     30|        if ((ret = ssl_x509_store_ctx_idx) < 0) {
  148|      1|            CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
  149|      1|            if ((ret = ssl_x509_store_ctx_idx) < 0) {
  150|      1|                ret = ssl_x509_store_ctx_idx =
  151|      1|                    X509_STORE_CTX_get_ex_new_index(0,
  152|      1|                                                    "SSL for verify callback",
  153|      1|                                                    NULL, NULL, NULL);
  154|      1|            }
  155|      1|            CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  156|      1|        }
  157|       |
  158|     30|        return ret;
  159|     30|    } else {                    /* commonly eliminated */
  160|       |
  161|      0|        CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
  162|       |
  163|      0|        if (ssl_x509_store_ctx_idx < 0) {
  164|      0|            CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
  165|      0|            CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
  166|      0|            got_write_lock = 1;
  167|       |
  168|      0|            if (ssl_x509_store_ctx_idx < 0) {
  169|      0|                ssl_x509_store_ctx_idx =
  170|      0|                    X509_STORE_CTX_get_ex_new_index(0,
  171|      0|                                                    "SSL for verify callback",
  172|      0|                                                    NULL, NULL, NULL);
  173|      0|            }
  174|      0|        }
  175|       |
  176|      0|        if (got_write_lock)
  177|      0|            CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
  178|      0|        else
  179|      0|            CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
  180|       |
  181|      0|        return ssl_x509_store_ctx_idx;
  182|      0|    }
  183|     30|}
ssl_cert_set_default_md:
  186|     60|{
  187|       |    /* Set digest values to defaults */
  188|     60|#ifndef OPENSSL_NO_DSA
  189|     60|    cert->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();
  190|     60|#endif
  191|     60|#ifndef OPENSSL_NO_RSA
  192|     60|    cert->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();
  193|     60|    cert->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();
  194|     60|#endif
  195|     60|#ifndef OPENSSL_NO_ECDSA
  196|     60|    cert->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();
  197|     60|#endif
  198|     60|}
ssl_cert_new:
  201|     30|{
  202|     30|    CERT *ret;
  203|       |
  204|     30|    ret = (CERT *)OPENSSL_malloc(sizeof(CERT));
  205|     30|    if (ret == NULL) {
  206|      0|        SSLerr(SSL_F_SSL_CERT_NEW, ERR_R_MALLOC_FAILURE);
  207|      0|        return (NULL);
  208|      0|    }
  209|     30|    memset(ret, 0, sizeof(CERT));
  210|       |
  211|     30|    ret->key = &(ret->pkeys[SSL_PKEY_RSA_ENC]);
  212|     30|    ret->references = 1;
  213|     30|    ssl_cert_set_default_md(ret);
  214|     30|    return (ret);
  215|     30|}
ssl_cert_dup:
  218|     30|{
  219|     30|    CERT *ret;
  220|     30|    int i;
  221|       |
  222|     30|    ret = (CERT *)OPENSSL_malloc(sizeof(CERT));
  223|     30|    if (ret == NULL) {
  224|      0|        SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);
  225|      0|        return (NULL);
  226|      0|    }
  227|       |
  228|     30|    memset(ret, 0, sizeof(CERT));
  229|       |
  230|     30|    ret->references = 1;
  231|     30|    ret->key = &ret->pkeys[cert->key - &cert->pkeys[0]];
  232|       |    /*
  233|       |     * or ret->key = ret->pkeys + (cert->key - cert->pkeys), if you find that
  234|       |     * more readable
  235|       |     */
  236|       |
  237|     30|    ret->valid = cert->valid;
  238|     30|    ret->mask_k = cert->mask_k;
  239|     30|    ret->mask_a = cert->mask_a;
  240|     30|    ret->export_mask_k = cert->export_mask_k;
  241|     30|    ret->export_mask_a = cert->export_mask_a;
  242|       |
  243|     30|#ifndef OPENSSL_NO_RSA
  244|     30|    if (cert->rsa_tmp != NULL) {
  245|      0|        RSA_up_ref(cert->rsa_tmp);
  246|      0|        ret->rsa_tmp = cert->rsa_tmp;
  247|      0|    }
  248|     30|    ret->rsa_tmp_cb = cert->rsa_tmp_cb;
  249|     30|#endif
  250|       |
  251|     30|#ifndef OPENSSL_NO_DH
  252|     30|    if (cert->dh_tmp != NULL) {
  253|      0|        ret->dh_tmp = DHparams_dup(cert->dh_tmp);
  254|      0|        if (ret->dh_tmp == NULL) {
  255|      0|            SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_DH_LIB);
  256|      0|            goto err;
  257|      0|        }
  258|      0|        if (cert->dh_tmp->priv_key) {
  259|      0|            BIGNUM *b = BN_dup(cert->dh_tmp->priv_key);
  260|      0|            if (!b) {
  261|      0|                SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);
  262|      0|                goto err;
  263|      0|            }
  264|      0|            ret->dh_tmp->priv_key = b;
  265|      0|        }
  266|      0|        if (cert->dh_tmp->pub_key) {
  267|      0|            BIGNUM *b = BN_dup(cert->dh_tmp->pub_key);
  268|      0|            if (!b) {
  269|      0|                SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);
  270|      0|                goto err;
  271|      0|            }
  272|      0|            ret->dh_tmp->pub_key = b;
  273|      0|        }
  274|      0|    }
  275|     30|    ret->dh_tmp_cb = cert->dh_tmp_cb;
  276|     30|#endif
  277|       |
  278|     30|#ifndef OPENSSL_NO_ECDH
  279|     30|    if (cert->ecdh_tmp) {
  280|      0|        ret->ecdh_tmp = EC_KEY_dup(cert->ecdh_tmp);
  281|      0|        if (ret->ecdh_tmp == NULL) {
  282|      0|            SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_EC_LIB);
  283|      0|            goto err;
  284|      0|        }
  285|      0|    }
  286|     30|    ret->ecdh_tmp_cb = cert->ecdh_tmp_cb;
  287|     30|    ret->ecdh_tmp_auto = cert->ecdh_tmp_auto;
  288|     30|#endif
  289|       |
  290|    270|    for (i = 0; i < SSL_PKEY_NUM; i++) {
  291|    240|        CERT_PKEY *cpk = cert->pkeys + i;
  292|    240|        CERT_PKEY *rpk = ret->pkeys + i;
  293|    240|        if (cpk->x509 != NULL) {
  294|      0|            rpk->x509 = cpk->x509;
  295|      0|            CRYPTO_add(&rpk->x509->references, 1, CRYPTO_LOCK_X509);
  296|      0|        }
  297|       |
  298|    240|        if (cpk->privatekey != NULL) {
  299|      0|            rpk->privatekey = cpk->privatekey;
  300|      0|            CRYPTO_add(&cpk->privatekey->references, 1, CRYPTO_LOCK_EVP_PKEY);
  301|      0|        }
  302|       |
  303|    240|        if (cpk->chain) {
  304|      0|            rpk->chain = X509_chain_up_ref(cpk->chain);
  305|      0|            if (!rpk->chain) {
  306|      0|                SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);
  307|      0|                goto err;
  308|      0|            }
  309|      0|        }
  310|    240|        rpk->valid_flags = 0;
  311|    240|#ifndef OPENSSL_NO_TLSEXT
  312|    240|        if (cert->pkeys[i].serverinfo != NULL) {
  313|       |            /* Just copy everything. */
  314|      0|            ret->pkeys[i].serverinfo =
  315|      0|                OPENSSL_malloc(cert->pkeys[i].serverinfo_length);
  316|      0|            if (ret->pkeys[i].serverinfo == NULL) {
  317|      0|                SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);
  318|      0|                goto err;
  319|      0|            }
  320|      0|            ret->pkeys[i].serverinfo_length =
  321|      0|                cert->pkeys[i].serverinfo_length;
  322|      0|            memcpy(ret->pkeys[i].serverinfo,
  323|      0|                   cert->pkeys[i].serverinfo,
  324|      0|                   cert->pkeys[i].serverinfo_length);
  325|      0|        }
  326|    240|#endif
  327|    240|    }
  328|       |
  329|       |    /*
  330|       |     * Set digests to defaults. NB: we don't copy existing values as they
  331|       |     * will be set during handshake.
  332|       |     */
  333|     30|    ssl_cert_set_default_md(ret);
  334|       |    /* Peer sigalgs set to NULL as we get these from handshake too */
  335|     30|    ret->peer_sigalgs = NULL;
  336|     30|    ret->peer_sigalgslen = 0;
  337|       |    /* Configured sigalgs however we copy across */
  338|       |
  339|     30|    if (cert->conf_sigalgs) {
  340|      0|        ret->conf_sigalgs = OPENSSL_malloc(cert->conf_sigalgslen);
  341|      0|        if (!ret->conf_sigalgs)
  342|      0|            goto err;
  343|      0|        memcpy(ret->conf_sigalgs, cert->conf_sigalgs, cert->conf_sigalgslen);
  344|      0|        ret->conf_sigalgslen = cert->conf_sigalgslen;
  345|      0|    } else
  346|     30|        ret->conf_sigalgs = NULL;
  347|       |
  348|     30|    if (cert->client_sigalgs) {
  349|      0|        ret->client_sigalgs = OPENSSL_malloc(cert->client_sigalgslen);
  350|      0|        if (!ret->client_sigalgs)
  351|      0|            goto err;
  352|      0|        memcpy(ret->client_sigalgs, cert->client_sigalgs,
  353|      0|               cert->client_sigalgslen);
  354|      0|        ret->client_sigalgslen = cert->client_sigalgslen;
  355|      0|    } else
  356|     30|        ret->client_sigalgs = NULL;
  357|       |    /* Shared sigalgs also NULL */
  358|     30|    ret->shared_sigalgs = NULL;
  359|       |    /* Copy any custom client certificate types */
  360|     30|    if (cert->ctypes) {
  361|      0|        ret->ctypes = OPENSSL_malloc(cert->ctype_num);
  362|      0|        if (!ret->ctypes)
  363|      0|            goto err;
  364|      0|        memcpy(ret->ctypes, cert->ctypes, cert->ctype_num);
  365|      0|        ret->ctype_num = cert->ctype_num;
  366|      0|    }
  367|       |
  368|     30|    ret->cert_flags = cert->cert_flags;
  369|       |
  370|     30|    ret->cert_cb = cert->cert_cb;
  371|     30|    ret->cert_cb_arg = cert->cert_cb_arg;
  372|       |
  373|     30|    if (cert->verify_store) {
  374|      0|        CRYPTO_add(&cert->verify_store->references, 1,
  375|      0|                   CRYPTO_LOCK_X509_STORE);
  376|      0|        ret->verify_store = cert->verify_store;
  377|      0|    }
  378|       |
  379|     30|    if (cert->chain_store) {
  380|      0|        CRYPTO_add(&cert->chain_store->references, 1, CRYPTO_LOCK_X509_STORE);
  381|      0|        ret->chain_store = cert->chain_store;
  382|      0|    }
  383|       |
  384|     30|    ret->ciphers_raw = NULL;
  385|       |
  386|     30|#ifndef OPENSSL_NO_TLSEXT
  387|     30|    if (!custom_exts_copy(&ret->cli_ext, &cert->cli_ext))
  388|      0|        goto err;
  389|     30|    if (!custom_exts_copy(&ret->srv_ext, &cert->srv_ext))
  390|      0|        goto err;
  391|     30|#endif
  392|       |
  393|     30|    return (ret);
  394|       |
  395|      0| err:
  396|      0|#ifndef OPENSSL_NO_RSA
  397|      0|    if (ret->rsa_tmp != NULL)
  398|      0|        RSA_free(ret->rsa_tmp);
  399|      0|#endif
  400|      0|#ifndef OPENSSL_NO_DH
  401|      0|    if (ret->dh_tmp != NULL)
  402|      0|        DH_free(ret->dh_tmp);
  403|      0|#endif
  404|      0|#ifndef OPENSSL_NO_ECDH
  405|      0|    if (ret->ecdh_tmp != NULL)
  406|      0|        EC_KEY_free(ret->ecdh_tmp);
  407|      0|#endif
  408|       |
  409|      0|#ifndef OPENSSL_NO_TLSEXT
  410|      0|    custom_exts_free(&ret->cli_ext);
  411|      0|    custom_exts_free(&ret->srv_ext);
  412|      0|#endif
  413|       |
  414|      0|    ssl_cert_clear_certs(ret);
  415|      0|    OPENSSL_free(ret);
  416|       |
  417|      0|    return NULL;
  418|     30|}
ssl_cert_clear_certs:
  423|     60|{
  424|     60|    int i;
  425|     60|    if (c == NULL)
  426|      0|        return;
  427|    540|    for (i = 0; i < SSL_PKEY_NUM; i++) {
  428|    480|        CERT_PKEY *cpk = c->pkeys + i;
  429|    480|        if (cpk->x509) {
  430|      0|            X509_free(cpk->x509);
  431|      0|            cpk->x509 = NULL;
  432|      0|        }
  433|    480|        if (cpk->privatekey) {
  434|      0|            EVP_PKEY_free(cpk->privatekey);
  435|      0|            cpk->privatekey = NULL;
  436|      0|        }
  437|    480|        if (cpk->chain) {
  438|      0|            sk_X509_pop_free(cpk->chain, X509_free);
  439|      0|            cpk->chain = NULL;
  440|      0|        }
  441|    480|#ifndef OPENSSL_NO_TLSEXT
  442|    480|        if (cpk->serverinfo) {
  443|      0|            OPENSSL_free(cpk->serverinfo);
  444|      0|            cpk->serverinfo = NULL;
  445|      0|            cpk->serverinfo_length = 0;
  446|      0|        }
  447|    480|#endif
  448|       |        /* Clear all flags apart from explicit sign */
  449|    480|        cpk->valid_flags &= CERT_PKEY_EXPLICIT_SIGN;
  450|    480|    }
  451|     60|}
ssl_cert_free:
  454|     60|{
  455|     60|    int i;
  456|       |
  457|     60|    if (c == NULL)
  458|      0|        return;
  459|       |
  460|     60|    i = CRYPTO_add(&c->references, -1, CRYPTO_LOCK_SSL_CERT);
  461|       |#ifdef REF_PRINT
  462|       |    REF_PRINT("CERT", c);
  463|       |#endif
  464|     60|    if (i > 0)
  465|      0|        return;
  466|       |#ifdef REF_CHECK
  467|       |    if (i < 0) {
  468|       |        fprintf(stderr, "ssl_cert_free, bad reference count\n");
  469|       |        abort();                /* ok */
  470|       |    }
  471|       |#endif
  472|       |
  473|     60|#ifndef OPENSSL_NO_RSA
  474|     60|    if (c->rsa_tmp)
  475|      0|        RSA_free(c->rsa_tmp);
  476|     60|#endif
  477|     60|#ifndef OPENSSL_NO_DH
  478|     60|    if (c->dh_tmp)
  479|      0|        DH_free(c->dh_tmp);
  480|     60|#endif
  481|     60|#ifndef OPENSSL_NO_ECDH
  482|     60|    if (c->ecdh_tmp)
  483|      0|        EC_KEY_free(c->ecdh_tmp);
  484|     60|#endif
  485|       |
  486|     60|    ssl_cert_clear_certs(c);
  487|     60|    if (c->peer_sigalgs)
  488|      0|        OPENSSL_free(c->peer_sigalgs);
  489|     60|    if (c->conf_sigalgs)
  490|      0|        OPENSSL_free(c->conf_sigalgs);
  491|     60|    if (c->client_sigalgs)
  492|      0|        OPENSSL_free(c->client_sigalgs);
  493|     60|    if (c->shared_sigalgs)
  494|      0|        OPENSSL_free(c->shared_sigalgs);
  495|     60|    if (c->ctypes)
  496|      0|        OPENSSL_free(c->ctypes);
  497|     60|    if (c->verify_store)
  498|      0|        X509_STORE_free(c->verify_store);
  499|     60|    if (c->chain_store)
  500|      0|        X509_STORE_free(c->chain_store);
  501|     60|    if (c->ciphers_raw)
  502|      0|        OPENSSL_free(c->ciphers_raw);
  503|     60|#ifndef OPENSSL_NO_TLSEXT
  504|     60|    custom_exts_free(&c->cli_ext);
  505|     60|    custom_exts_free(&c->srv_ext);
  506|     60|    if (c->alpn_proposed)
  507|      0|        OPENSSL_free(c->alpn_proposed);
  508|     60|#endif
  509|     60|    OPENSSL_free(c);
  510|     60|}

ssl_load_ciphers:
  406|      1|{
  407|      1|    ssl_cipher_methods[SSL_ENC_DES_IDX] = EVP_get_cipherbyname(SN_des_cbc);
  408|      1|    ssl_cipher_methods[SSL_ENC_3DES_IDX] =
  409|      1|        EVP_get_cipherbyname(SN_des_ede3_cbc);
  410|      1|    ssl_cipher_methods[SSL_ENC_RC4_IDX] = EVP_get_cipherbyname(SN_rc4);
  411|      1|    ssl_cipher_methods[SSL_ENC_RC2_IDX] = EVP_get_cipherbyname(SN_rc2_cbc);
  412|      1|#ifndef OPENSSL_NO_IDEA
  413|      1|    ssl_cipher_methods[SSL_ENC_IDEA_IDX] = EVP_get_cipherbyname(SN_idea_cbc);
  414|       |#else
  415|       |    ssl_cipher_methods[SSL_ENC_IDEA_IDX] = NULL;
  416|       |#endif
  417|      1|    ssl_cipher_methods[SSL_ENC_AES128_IDX] =
  418|      1|        EVP_get_cipherbyname(SN_aes_128_cbc);
  419|      1|    ssl_cipher_methods[SSL_ENC_AES256_IDX] =
  420|      1|        EVP_get_cipherbyname(SN_aes_256_cbc);
  421|      1|    ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] =
  422|      1|        EVP_get_cipherbyname(SN_camellia_128_cbc);
  423|      1|    ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] =
  424|      1|        EVP_get_cipherbyname(SN_camellia_256_cbc);
  425|      1|    ssl_cipher_methods[SSL_ENC_GOST89_IDX] =
  426|      1|        EVP_get_cipherbyname(SN_gost89_cnt);
  427|      1|    ssl_cipher_methods[SSL_ENC_SEED_IDX] = EVP_get_cipherbyname(SN_seed_cbc);
  428|       |
  429|      1|    ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] =
  430|      1|        EVP_get_cipherbyname(SN_aes_128_gcm);
  431|      1|    ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] =
  432|      1|        EVP_get_cipherbyname(SN_aes_256_gcm);
  433|       |
  434|      1|    ssl_digest_methods[SSL_MD_MD5_IDX] = EVP_get_digestbyname(SN_md5);
  435|      1|    ssl_mac_secret_size[SSL_MD_MD5_IDX] =
  436|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_MD5_IDX]);
  437|      1|    OPENSSL_assert(ssl_mac_secret_size[SSL_MD_MD5_IDX] >= 0);
  438|      1|    ssl_digest_methods[SSL_MD_SHA1_IDX] = EVP_get_digestbyname(SN_sha1);
  439|      1|    ssl_mac_secret_size[SSL_MD_SHA1_IDX] =
  440|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_SHA1_IDX]);
  441|      1|    OPENSSL_assert(ssl_mac_secret_size[SSL_MD_SHA1_IDX] >= 0);
  442|      1|    ssl_digest_methods[SSL_MD_GOST94_IDX] =
  443|      1|        EVP_get_digestbyname(SN_id_GostR3411_94);
  444|      1|    if (ssl_digest_methods[SSL_MD_GOST94_IDX]) {
  445|      1|        ssl_mac_secret_size[SSL_MD_GOST94_IDX] =
  446|      1|            EVP_MD_size(ssl_digest_methods[SSL_MD_GOST94_IDX]);
  447|      1|        OPENSSL_assert(ssl_mac_secret_size[SSL_MD_GOST94_IDX] >= 0);
  448|      1|    }
  449|      1|    ssl_digest_methods[SSL_MD_GOST89MAC_IDX] =
  450|      1|        EVP_get_digestbyname(SN_id_Gost28147_89_MAC);
  451|      1|    ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] = get_optional_pkey_id("gost-mac");
  452|      1|    if (ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]) {
  453|      0|        ssl_mac_secret_size[SSL_MD_GOST89MAC_IDX] = 32;
  454|      0|    }
  455|       |
  456|      1|    ssl_digest_methods[SSL_MD_SHA256_IDX] = EVP_get_digestbyname(SN_sha256);
  457|      1|    ssl_mac_secret_size[SSL_MD_SHA256_IDX] =
  458|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_SHA256_IDX]);
  459|      1|    ssl_digest_methods[SSL_MD_SHA384_IDX] = EVP_get_digestbyname(SN_sha384);
  460|      1|    ssl_mac_secret_size[SSL_MD_SHA384_IDX] =
  461|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_SHA384_IDX]);
  462|      1|}
ssl_create_cipher_list:
 1471|     60|{
 1472|     60|    int ok, num_of_ciphers, num_of_alias_max, num_of_group_aliases;
 1473|     60|    unsigned long disabled_mkey, disabled_auth, disabled_enc, disabled_mac,
 1474|     60|        disabled_ssl;
 1475|     60|    STACK_OF(SSL_CIPHER) *cipherstack, *tmp_cipher_list;
 1476|     60|    const char *rule_p;
 1477|     60|    CIPHER_ORDER *co_list = NULL, *head = NULL, *tail = NULL, *curr;
 1478|     60|    const SSL_CIPHER **ca_list = NULL;
 1479|       |
 1480|       |    /*
 1481|       |     * Return with error if nothing to do.
 1482|       |     */
 1483|     60|    if (rule_str == NULL || cipher_list == NULL || cipher_list_by_id == NULL)
 1484|      0|        return NULL;
 1485|     60|#ifndef OPENSSL_NO_EC
 1486|     60|    if (!check_suiteb_cipher_list(ssl_method, c, &rule_str))
 1487|      0|        return NULL;
 1488|     60|#endif
 1489|       |
 1490|       |    /*
 1491|       |     * To reduce the work to do we only want to process the compiled
 1492|       |     * in algorithms, so we first get the mask of disabled ciphers.
 1493|       |     */
 1494|     60|    ssl_cipher_get_disabled(&disabled_mkey, &disabled_auth, &disabled_enc,
 1495|     60|                            &disabled_mac, &disabled_ssl);
 1496|       |
 1497|       |    /*
 1498|       |     * Now we have to collect the available ciphers from the compiled
 1499|       |     * in ciphers. We cannot get more than the number compiled in, so
 1500|       |     * it is used for allocation.
 1501|       |     */
 1502|     60|    num_of_ciphers = ssl_method->num_ciphers();
 1503|       |#ifdef KSSL_DEBUG
 1504|       |    fprintf(stderr, "ssl_create_cipher_list() for %d ciphers\n",
 1505|       |            num_of_ciphers);
 1506|       |#endif                          /* KSSL_DEBUG */
 1507|     60|    co_list =
 1508|     60|        (CIPHER_ORDER *)OPENSSL_malloc(sizeof(CIPHER_ORDER) * num_of_ciphers);
 1509|     60|    if (co_list == NULL) {
 1510|      0|        SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST, ERR_R_MALLOC_FAILURE);
 1511|      0|        return (NULL);          /* Failure */
 1512|      0|    }
 1513|       |
 1514|     60|    ssl_cipher_collect_ciphers(ssl_method, num_of_ciphers,
 1515|     60|                               disabled_mkey, disabled_auth, disabled_enc,
 1516|     60|                               disabled_mac, disabled_ssl, co_list, &head,
 1517|     60|                               &tail);
 1518|       |
 1519|       |    /* Now arrange all ciphers by preference: */
 1520|       |
 1521|       |    /*
 1522|       |     * Everything else being equal, prefer ephemeral ECDH over other key
 1523|       |     * exchange mechanisms
 1524|       |     */
 1525|     60|    ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head,
 1526|     60|                          &tail);
 1527|     60|    ssl_cipher_apply_rule(0, SSL_kEECDH, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head,
 1528|     60|                          &tail);
 1529|       |
 1530|       |    /* AES is our preferred symmetric cipher */
 1531|     60|    ssl_cipher_apply_rule(0, 0, 0, SSL_AES, 0, 0, 0, CIPHER_ADD, -1, &head,
 1532|     60|                          &tail);
 1533|       |
 1534|       |    /* Temporarily enable everything else for sorting */
 1535|     60|    ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ADD, -1, &head, &tail);
 1536|       |
 1537|       |    /* Low priority for MD5 */
 1538|     60|    ssl_cipher_apply_rule(0, 0, 0, 0, SSL_MD5, 0, 0, CIPHER_ORD, -1, &head,
 1539|     60|                          &tail);
 1540|       |
 1541|       |    /*
 1542|       |     * Move anonymous ciphers to the end.  Usually, these will remain
 1543|       |     * disabled. (For applications that allow them, they aren't too bad, but
 1544|       |     * we prefer authenticated ciphers.)
 1545|       |     */
 1546|     60|    ssl_cipher_apply_rule(0, 0, SSL_aNULL, 0, 0, 0, 0, CIPHER_ORD, -1, &head,
 1547|     60|                          &tail);
 1548|       |
 1549|       |    /* Move ciphers without forward secrecy to the end */
 1550|     60|    ssl_cipher_apply_rule(0, 0, SSL_aECDH, 0, 0, 0, 0, CIPHER_ORD, -1, &head,
 1551|     60|                          &tail);
 1552|       |    /*
 1553|       |     * ssl_cipher_apply_rule(0, 0, SSL_aDH, 0, 0, 0, 0, CIPHER_ORD, -1,
 1554|       |     * &head, &tail);
 1555|       |     */
 1556|     60|    ssl_cipher_apply_rule(0, SSL_kRSA, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head,
 1557|     60|                          &tail);
 1558|     60|    ssl_cipher_apply_rule(0, SSL_kPSK, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head,
 1559|     60|                          &tail);
 1560|     60|    ssl_cipher_apply_rule(0, SSL_kKRB5, 0, 0, 0, 0, 0, CIPHER_ORD, -1, &head,
 1561|     60|                          &tail);
 1562|       |
 1563|       |    /* RC4 is sort-of broken -- move the the end */
 1564|     60|    ssl_cipher_apply_rule(0, 0, 0, SSL_RC4, 0, 0, 0, CIPHER_ORD, -1, &head,
 1565|     60|                          &tail);
 1566|       |
 1567|       |    /*
 1568|       |     * Now sort by symmetric encryption strength.  The above ordering remains
 1569|       |     * in force within each class
 1570|       |     */
 1571|     60|    if (!ssl_cipher_strength_sort(&head, &tail)) {
 1572|      0|        OPENSSL_free(co_list);
 1573|      0|        return NULL;
 1574|      0|    }
 1575|       |
 1576|       |    /* Now disable everything (maintaining the ordering!) */
 1577|     60|    ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_DEL, -1, &head, &tail);
 1578|       |
 1579|       |    /*
 1580|       |     * We also need cipher aliases for selecting based on the rule_str.
 1581|       |     * There might be two types of entries in the rule_str: 1) names
 1582|       |     * of ciphers themselves 2) aliases for groups of ciphers.
 1583|       |     * For 1) we need the available ciphers and for 2) the cipher
 1584|       |     * groups of cipher_aliases added together in one list (otherwise
 1585|       |     * we would be happy with just the cipher_aliases table).
 1586|       |     */
 1587|     60|    num_of_group_aliases = sizeof(cipher_aliases) / sizeof(SSL_CIPHER);
 1588|     60|    num_of_alias_max = num_of_ciphers + num_of_group_aliases + 1;
 1589|     60|    ca_list = OPENSSL_malloc(sizeof(SSL_CIPHER *) * num_of_alias_max);
 1590|     60|    if (ca_list == NULL) {
 1591|      0|        OPENSSL_free(co_list);
 1592|      0|        SSLerr(SSL_F_SSL_CREATE_CIPHER_LIST, ERR_R_MALLOC_FAILURE);
 1593|      0|        return (NULL);          /* Failure */
 1594|      0|    }
 1595|     60|    ssl_cipher_collect_aliases(ca_list, num_of_group_aliases,
 1596|     60|                               disabled_mkey, disabled_auth, disabled_enc,
 1597|     60|                               disabled_mac, disabled_ssl, head);
 1598|       |
 1599|       |    /*
 1600|       |     * If the rule_string begins with DEFAULT, apply the default rule
 1601|       |     * before using the (possibly available) additional rules.
 1602|       |     */
 1603|     60|    ok = 1;
 1604|     60|    rule_p = rule_str;
 1605|     60|    if (strncmp(rule_str, "DEFAULT", 7) == 0) {
 1606|      0|        ok = ssl_cipher_process_rulestr(SSL_DEFAULT_CIPHER_LIST,
 1607|      0|                                        &head, &tail, ca_list);
 1608|      0|        rule_p += 7;
 1609|      0|        if (*rule_p == ':')
 1610|      0|            rule_p++;
 1611|      0|    }
 1612|       |
 1613|     60|    if (ok && (strlen(rule_p) > 0))
 1614|     60|        ok = ssl_cipher_process_rulestr(rule_p, &head, &tail, ca_list);
 1615|       |
 1616|     60|    OPENSSL_free((void *)ca_list); /* Not needed anymore */
 1617|       |
 1618|     60|    if (!ok) {                  /* Rule processing failure */
 1619|      0|        OPENSSL_free(co_list);
 1620|      0|        return (NULL);
 1621|      0|    }
 1622|       |
 1623|       |    /*
 1624|       |     * Allocate new "cipherstack" for the result, return with error
 1625|       |     * if we cannot get one.
 1626|       |     */
 1627|     60|    if ((cipherstack = sk_SSL_CIPHER_new_null()) == NULL) {
 1628|      0|        OPENSSL_free(co_list);
 1629|      0|        return (NULL);
 1630|      0|    }
 1631|       |
 1632|       |    /*
 1633|       |     * The cipher selection for the list is done. The ciphers are added
 1634|       |     * to the resulting precedence to the STACK_OF(SSL_CIPHER).
 1635|       |     */
 1636|  5.94k|    for (curr = head; curr != NULL; curr = curr->next) {
 1637|       |#ifdef OPENSSL_FIPS
 1638|       |        if (curr->active
 1639|       |            && (!FIPS_mode() || curr->cipher->algo_strength & SSL_FIPS))
 1640|       |#else
 1641|  5.88k|        if (curr->active)
 1642|  5.67k|#endif
 1643|  5.67k|        {
 1644|  5.67k|            sk_SSL_CIPHER_push(cipherstack, curr->cipher);
 1645|       |#ifdef CIPHER_DEBUG
 1646|       |            fprintf(stderr, "<%s>\n", curr->cipher->name);
 1647|       |#endif
 1648|  5.67k|        }
 1649|  5.88k|    }
 1650|     60|    OPENSSL_free(co_list);      /* Not needed any longer */
 1651|       |
 1652|     60|    tmp_cipher_list = sk_SSL_CIPHER_dup(cipherstack);
 1653|     60|    if (tmp_cipher_list == NULL) {
 1654|      0|        sk_SSL_CIPHER_free(cipherstack);
 1655|      0|        return NULL;
 1656|      0|    }
 1657|     60|    if (*cipher_list != NULL)
 1658|     60|        sk_SSL_CIPHER_free(*cipher_list);
 1659|     60|    *cipher_list = cipherstack;
 1660|     60|    if (*cipher_list_by_id != NULL)
 1661|     60|        sk_SSL_CIPHER_free(*cipher_list_by_id);
 1662|     60|    *cipher_list_by_id = tmp_cipher_list;
 1663|     60|    (void)sk_SSL_CIPHER_set_cmp_func(*cipher_list_by_id,
 1664|     60|                                     ssl_cipher_ptr_id_cmp);
 1665|       |
 1666|     60|    sk_SSL_CIPHER_sort(*cipher_list_by_id);
 1667|     60|    return (cipherstack);
 1668|     60|}
SSL_COMP_get_compression_methods:
 1961|     31|{
 1962|     31|    load_builtin_compressions();
 1963|     31|    return (ssl_comp_methods);
 1964|     31|}
ssl_ciph.c:get_optional_pkey_id:
  388|    121|{
  389|    121|    const EVP_PKEY_ASN1_METHOD *ameth;
  390|    121|    ENGINE *tmpeng = NULL;
  391|    121|    int pkey_id = 0;
  392|    121|    ameth = EVP_PKEY_asn1_find_str(&tmpeng, pkey_name, -1);
  393|    121|    if (ameth) {
  394|      0|        if (EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL,
  395|      0|                                    ameth) <= 0)
  396|      0|            pkey_id = 0;
  397|      0|    }
  398|    121|    if (tmpeng)
  399|      0|        ENGINE_finish(tmpeng);
  400|    121|    return pkey_id;
  401|    121|}
ssl_ciph.c:load_builtin_compressions:
  472|     31|{
  473|     31|    int got_write_lock = 0;
  474|       |
  475|     31|    CRYPTO_r_lock(CRYPTO_LOCK_SSL);
  476|     31|    if (ssl_comp_methods == NULL) {
  477|      1|        CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
  478|      1|        CRYPTO_w_lock(CRYPTO_LOCK_SSL);
  479|      1|        got_write_lock = 1;
  480|       |
  481|      1|        if (ssl_comp_methods == NULL) {
  482|      1|            SSL_COMP *comp = NULL;
  483|       |
  484|      1|            MemCheck_off();
  485|      1|            ssl_comp_methods = sk_SSL_COMP_new(sk_comp_cmp);
  486|      1|            if (ssl_comp_methods != NULL) {
  487|      1|                comp = (SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
  488|      1|                if (comp != NULL) {
  489|      1|                    comp->method = COMP_zlib();
  490|      1|                    if (comp->method && comp->method->type == NID_undef)
  491|      1|                        OPENSSL_free(comp);
  492|      0|                    else {
  493|      0|                        comp->id = SSL_COMP_ZLIB_IDX;
  494|      0|                        comp->name = comp->method->name;
  495|      0|                        sk_SSL_COMP_push(ssl_comp_methods, comp);
  496|      0|                    }
  497|      1|                }
  498|      1|                sk_SSL_COMP_sort(ssl_comp_methods);
  499|      1|            }
  500|      1|            MemCheck_on();
  501|      1|        }
  502|      1|    }
  503|       |
  504|     31|    if (got_write_lock)
  505|      1|        CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
  506|     30|    else
  507|     30|        CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
  508|     31|}
ssl_ciph.c:check_suiteb_cipher_list:
 1408|     60|{
 1409|     60|    unsigned int suiteb_flags = 0, suiteb_comb2 = 0;
 1410|     60|    if (strncmp(*prule_str, "SUITEB128ONLY", 13) == 0) {
 1411|      0|        suiteb_flags = SSL_CERT_FLAG_SUITEB_128_LOS_ONLY;
 1412|     60|    } else if (strncmp(*prule_str, "SUITEB128C2", 11) == 0) {
 1413|      0|        suiteb_comb2 = 1;
 1414|      0|        suiteb_flags = SSL_CERT_FLAG_SUITEB_128_LOS;
 1415|     60|    } else if (strncmp(*prule_str, "SUITEB128", 9) == 0) {
 1416|      0|        suiteb_flags = SSL_CERT_FLAG_SUITEB_128_LOS;
 1417|     60|    } else if (strncmp(*prule_str, "SUITEB192", 9) == 0) {
 1418|      0|        suiteb_flags = SSL_CERT_FLAG_SUITEB_192_LOS;
 1419|      0|    }
 1420|       |
 1421|     60|    if (suiteb_flags) {
 1422|      0|        c->cert_flags &= ~SSL_CERT_FLAG_SUITEB_128_LOS;
 1423|      0|        c->cert_flags |= suiteb_flags;
 1424|      0|    } else
 1425|     60|        suiteb_flags = c->cert_flags & SSL_CERT_FLAG_SUITEB_128_LOS;
 1426|       |
 1427|     60|    if (!suiteb_flags)
 1428|     60|        return 1;
 1429|       |    /* Check version: if TLS 1.2 ciphers allowed we can use Suite B */
 1430|       |
 1431|      0|    if (!(meth->ssl3_enc->enc_flags & SSL_ENC_FLAG_TLS1_2_CIPHERS)) {
 1432|      0|        if (meth->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS)
 1433|      0|            SSLerr(SSL_F_CHECK_SUITEB_CIPHER_LIST,
 1434|      0|                   SSL_R_ONLY_DTLS_1_2_ALLOWED_IN_SUITEB_MODE);
 1435|      0|        else
 1436|      0|            SSLerr(SSL_F_CHECK_SUITEB_CIPHER_LIST,
 1437|      0|                   SSL_R_ONLY_TLS_1_2_ALLOWED_IN_SUITEB_MODE);
 1438|      0|        return 0;
 1439|      0|    }
 1440|      0|# ifndef OPENSSL_NO_ECDH
 1441|      0|    switch (suiteb_flags) {
 1442|      0|    case SSL_CERT_FLAG_SUITEB_128_LOS:
 1443|      0|        if (suiteb_comb2)
 1444|      0|            *prule_str = "ECDHE-ECDSA-AES256-GCM-SHA384";
 1445|      0|        else
 1446|      0|            *prule_str =
 1447|      0|                "ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384";
 1448|      0|        break;
 1449|      0|    case SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:
 1450|      0|        *prule_str = "ECDHE-ECDSA-AES128-GCM-SHA256";
 1451|      0|        break;
 1452|      0|    case SSL_CERT_FLAG_SUITEB_192_LOS:
 1453|      0|        *prule_str = "ECDHE-ECDSA-AES256-GCM-SHA384";
 1454|      0|        break;
 1455|      0|    }
 1456|       |    /* Set auto ECDH parameter determination */
 1457|      0|    c->ecdh_tmp_auto = 1;
 1458|      0|    return 1;
 1459|       |# else
 1460|       |    SSLerr(SSL_F_CHECK_SUITEB_CIPHER_LIST,
 1461|       |           SSL_R_ECDH_REQUIRED_FOR_SUITEB_MODE);
 1462|       |    return 0;
 1463|       |# endif
 1464|      0|}
ssl_ciph.c:ssl_cipher_get_disabled:
  729|     60|{
  730|     60|    *mkey = 0;
  731|     60|    *auth = 0;
  732|     60|    *enc = 0;
  733|     60|    *mac = 0;
  734|     60|    *ssl = 0;
  735|       |
  736|       |#ifdef OPENSSL_NO_RSA
  737|       |    *mkey |= SSL_kRSA;
  738|       |    *auth |= SSL_aRSA;
  739|       |#endif
  740|       |#ifdef OPENSSL_NO_DSA
  741|       |    *auth |= SSL_aDSS;
  742|       |#endif
  743|       |#ifdef OPENSSL_NO_DH
  744|       |    *mkey |= SSL_kDHr | SSL_kDHd | SSL_kEDH;
  745|       |    *auth |= SSL_aDH;
  746|       |#endif
  747|     60|#ifdef OPENSSL_NO_KRB5
  748|     60|    *mkey |= SSL_kKRB5;
  749|     60|    *auth |= SSL_aKRB5;
  750|     60|#endif
  751|       |#ifdef OPENSSL_NO_ECDSA
  752|       |    *auth |= SSL_aECDSA;
  753|       |#endif
  754|       |#ifdef OPENSSL_NO_ECDH
  755|       |    *mkey |= SSL_kECDHe | SSL_kECDHr;
  756|       |    *auth |= SSL_aECDH;
  757|       |#endif
  758|       |#ifdef OPENSSL_NO_PSK
  759|       |    *mkey |= SSL_kPSK;
  760|       |    *auth |= SSL_aPSK;
  761|       |#endif
  762|       |#ifdef OPENSSL_NO_SRP
  763|       |    *mkey |= SSL_kSRP;
  764|       |#endif
  765|       |    /*
  766|       |     * Check for presence of GOST 34.10 algorithms, and if they do not
  767|       |     * present, disable appropriate auth and key exchange
  768|       |     */
  769|     60|    if (!get_optional_pkey_id("gost94")) {
  770|     60|        *auth |= SSL_aGOST94;
  771|     60|    }
  772|     60|    if (!get_optional_pkey_id("gost2001")) {
  773|     60|        *auth |= SSL_aGOST01;
  774|     60|    }
  775|       |    /*
  776|       |     * Disable GOST key exchange if no GOST signature algs are available *
  777|       |     */
  778|     60|    if ((*auth & (SSL_aGOST94 | SSL_aGOST01)) == (SSL_aGOST94 | SSL_aGOST01)) {
  779|     60|        *mkey |= SSL_kGOST;
  780|     60|    }
  781|       |#ifdef SSL_FORBID_ENULL
  782|       |    *enc |= SSL_eNULL;
  783|       |#endif
  784|       |
  785|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_DES_IDX] == NULL) ? SSL_DES : 0;
  786|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_3DES_IDX] == NULL) ? SSL_3DES : 0;
  787|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_RC4_IDX] == NULL) ? SSL_RC4 : 0;
  788|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_RC2_IDX] == NULL) ? SSL_RC2 : 0;
  789|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_IDEA_IDX] == NULL) ? SSL_IDEA : 0;
  790|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_AES128_IDX] == NULL) ? SSL_AES128 : 0;
  791|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_AES256_IDX] == NULL) ? SSL_AES256 : 0;
  792|     60|    *enc |=
  793|     60|        (ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] ==
  794|     60|         NULL) ? SSL_AES128GCM : 0;
  795|     60|    *enc |=
  796|     60|        (ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] ==
  797|     60|         NULL) ? SSL_AES256GCM : 0;
  798|     60|    *enc |=
  799|     60|        (ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] ==
  800|     60|         NULL) ? SSL_CAMELLIA128 : 0;
  801|     60|    *enc |=
  802|     60|        (ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] ==
  803|     60|         NULL) ? SSL_CAMELLIA256 : 0;
  804|     60|    *enc |=
  805|     60|        (ssl_cipher_methods[SSL_ENC_GOST89_IDX] ==
  806|     60|         NULL) ? SSL_eGOST2814789CNT : 0;
  807|     60|    *enc |= (ssl_cipher_methods[SSL_ENC_SEED_IDX] == NULL) ? SSL_SEED : 0;
  808|       |
  809|     60|    *mac |= (ssl_digest_methods[SSL_MD_MD5_IDX] == NULL) ? SSL_MD5 : 0;
  810|     60|    *mac |= (ssl_digest_methods[SSL_MD_SHA1_IDX] == NULL) ? SSL_SHA1 : 0;
  811|     60|    *mac |= (ssl_digest_methods[SSL_MD_SHA256_IDX] == NULL) ? SSL_SHA256 : 0;
  812|     60|    *mac |= (ssl_digest_methods[SSL_MD_SHA384_IDX] == NULL) ? SSL_SHA384 : 0;
  813|     60|    *mac |= (ssl_digest_methods[SSL_MD_GOST94_IDX] == NULL) ? SSL_GOST94 : 0;
  814|     60|    *mac |= (ssl_digest_methods[SSL_MD_GOST89MAC_IDX] == NULL
  815|     60|             || ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] ==
  816|     60|             NID_undef) ? SSL_GOST89MAC : 0;
  817|       |
  818|     60|}
ssl_ciph.c:ssl_cipher_collect_ciphers:
  830|     60|{
  831|     60|    int i, co_list_num;
  832|     60|    const SSL_CIPHER *c;
  833|       |
  834|       |    /*
  835|       |     * We have num_of_ciphers descriptions compiled in, depending on the
  836|       |     * method selected (SSLv2 and/or SSLv3, TLSv1 etc).
  837|       |     * These will later be sorted in a linked list with at most num
  838|       |     * entries.
  839|       |     */
  840|       |
  841|       |    /* Get the initial list of ciphers */
  842|     60|    co_list_num = 0;            /* actual count of ciphers */
  843|  8.46k|    for (i = 0; i < num_of_ciphers; i++) {
  844|  8.40k|        c = ssl_method->get_cipher(i);
  845|       |        /* drop those that use any of that is not available */
  846|  8.40k|        if ((c != NULL) && c->valid &&
  847|       |#ifdef OPENSSL_FIPS
  848|       |            (!FIPS_mode() || (c->algo_strength & SSL_FIPS)) &&
  849|       |#endif
  850|  8.40k|            !(c->algorithm_mkey & disabled_mkey) &&
  851|  8.40k|            !(c->algorithm_auth & disabled_auth) &&
  852|  8.40k|            !(c->algorithm_enc & disabled_enc) &&
  853|  8.40k|            !(c->algorithm_mac & disabled_mac) &&
  854|  8.40k|            !(c->algorithm_ssl & disabled_ssl)) {
  855|  8.04k|            co_list[co_list_num].cipher = c;
  856|  8.04k|            co_list[co_list_num].next = NULL;
  857|  8.04k|            co_list[co_list_num].prev = NULL;
  858|  8.04k|            co_list[co_list_num].active = 0;
  859|  8.04k|            co_list_num++;
  860|       |#ifdef KSSL_DEBUG
  861|       |            fprintf(stderr, "\t%d: %s %lx %lx %lx\n", i, c->name, c->id,
  862|       |                    c->algorithm_mkey, c->algorithm_auth);
  863|       |#endif                          /* KSSL_DEBUG */
  864|       |            /*
  865|       |             * if (!sk_push(ca_list,(char *)c)) goto err;
  866|       |             */
  867|  8.04k|        }
  868|  8.40k|    }
  869|       |
  870|       |    /*
  871|       |     * Prepare linked list from list entries
  872|       |     */
  873|     60|    if (co_list_num > 0) {
  874|     60|        co_list[0].prev = NULL;
  875|       |
  876|     60|        if (co_list_num > 1) {
  877|     60|            co_list[0].next = &co_list[1];
  878|       |
  879|  7.98k|            for (i = 1; i < co_list_num - 1; i++) {
  880|  7.92k|                co_list[i].prev = &co_list[i - 1];
  881|  7.92k|                co_list[i].next = &co_list[i + 1];
  882|  7.92k|            }
  883|       |
  884|     60|            co_list[co_list_num - 1].prev = &co_list[co_list_num - 2];
  885|     60|        }
  886|       |
  887|     60|        co_list[co_list_num - 1].next = NULL;
  888|       |
  889|     60|        *head_p = &co_list[0];
  890|     60|        *tail_p = &co_list[co_list_num - 1];
  891|     60|    }
  892|     60|}
ssl_ciph.c:ssl_cipher_apply_rule:
  972|  1.56k|{
  973|  1.56k|    CIPHER_ORDER *head, *tail, *curr, *next, *last;
  974|  1.56k|    const SSL_CIPHER *cp;
  975|  1.56k|    int reverse = 0;
  976|       |
  977|       |#ifdef CIPHER_DEBUG
  978|       |    fprintf(stderr,
  979|       |            "Applying rule %d with %08lx/%08lx/%08lx/%08lx/%08lx %08lx (%d)\n",
  980|       |            rule, alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl,
  981|       |            algo_strength, strength_bits);
  982|       |#endif
  983|       |
  984|  1.56k|    if (rule == CIPHER_DEL)
  985|    120|        reverse = 1;            /* needed to maintain sorting between
  986|       |                                 * currently deleted ciphers */
  987|       |
  988|  1.56k|    head = *head_p;
  989|  1.56k|    tail = *tail_p;
  990|       |
  991|  1.56k|    if (reverse) {
  992|    120|        next = tail;
  993|    120|        last = head;
  994|  1.44k|    } else {
  995|  1.44k|        next = head;
  996|  1.44k|        last = tail;
  997|  1.44k|    }
  998|       |
  999|  1.56k|    curr = NULL;
 1000|   202k|    for (;;) {
 1001|   202k|        if (curr == last)
 1002|  1.56k|            break;
 1003|       |
 1004|   201k|        curr = next;
 1005|       |
 1006|   201k|        if (curr == NULL)
 1007|      0|            break;
 1008|       |
 1009|   201k|        next = reverse ? curr->prev : curr->next;
 1010|       |
 1011|   201k|        cp = curr->cipher;
 1012|       |
 1013|       |        /*
 1014|       |         * Selection criteria is either the value of strength_bits
 1015|       |         * or the algorithms used.
 1016|       |         */
 1017|   201k|        if (strength_bits >= 0) {
 1018|  57.0k|            if (strength_bits != cp->strength_bits)
 1019|  46.2k|                continue;
 1020|   143k|        } else {
 1021|       |#ifdef CIPHER_DEBUG
 1022|       |            fprintf(stderr,
 1023|       |                    "\nName: %s:\nAlgo = %08lx/%08lx/%08lx/%08lx/%08lx Algo_strength = %08lx\n",
 1024|       |                    cp->name, cp->algorithm_mkey, cp->algorithm_auth,
 1025|       |                    cp->algorithm_enc, cp->algorithm_mac, cp->algorithm_ssl,
 1026|       |                    cp->algo_strength);
 1027|       |#endif
 1028|       |#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL
 1029|       |            if (cipher_id && cipher_id != cp->id)
 1030|       |                continue;
 1031|       |#endif
 1032|   143k|            if (alg_mkey && !(alg_mkey & cp->algorithm_mkey))
 1033|  36.0k|                continue;
 1034|   107k|            if (alg_auth && !(alg_auth & cp->algorithm_auth))
 1035|  20.3k|                continue;
 1036|  87.6k|            if (alg_enc && !(alg_enc & cp->algorithm_enc))
 1037|  17.5k|                continue;
 1038|  70.0k|            if (alg_mac && !(alg_mac & cp->algorithm_mac))
 1039|  7.68k|                continue;
 1040|  62.4k|            if (alg_ssl && !(alg_ssl & cp->algorithm_ssl))
 1041|  2.94k|                continue;
 1042|  59.4k|            if ((algo_strength & SSL_EXP_MASK)
 1043|  59.4k|                && !(algo_strength & SSL_EXP_MASK & cp->algo_strength))
 1044|  7.62k|                continue;
 1045|  51.8k|            if ((algo_strength & SSL_STRONG_MASK)
 1046|  51.8k|                && !(algo_strength & SSL_STRONG_MASK & cp->algo_strength))
 1047|  14.4k|                continue;
 1048|  37.4k|            if ((algo_strength & SSL_NOT_DEFAULT)
 1049|  37.4k|                && !(cp->algo_strength & SSL_NOT_DEFAULT))
 1050|      0|                continue;
 1051|  37.4k|        }
 1052|       |
 1053|       |#ifdef CIPHER_DEBUG
 1054|       |        fprintf(stderr, "Action = %d\n", rule);
 1055|       |#endif
 1056|       |
 1057|       |        /* add the cipher if it has not been added yet. */
 1058|  48.2k|        if (rule == CIPHER_ADD) {
 1059|       |            /* reverse == 0 */
 1060|  21.1k|            if (!curr->active) {
 1061|  16.9k|                ll_append_tail(&head, curr, &tail);
 1062|  16.9k|                curr->active = 1;
 1063|  16.9k|            }
 1064|  21.1k|        }
 1065|       |        /* Move the added cipher to this location */
 1066|  27.0k|        else if (rule == CIPHER_ORD) {
 1067|       |            /* reverse == 0 */
 1068|  15.4k|            if (curr->active) {
 1069|  15.4k|                ll_append_tail(&head, curr, &tail);
 1070|  15.4k|            }
 1071|  15.4k|        } else if (rule == CIPHER_DEL) {
 1072|       |            /* reverse == 1 */
 1073|  9.42k|            if (curr->active) {
 1074|       |                /*
 1075|       |                 * most recently deleted ciphersuites get best positions for
 1076|       |                 * any future CIPHER_ADD (note that the CIPHER_DEL loop works
 1077|       |                 * in reverse to maintain the order)
 1078|       |                 */
 1079|  9.42k|                ll_append_head(&head, curr, &tail);
 1080|  9.42k|                curr->active = 0;
 1081|  9.42k|            }
 1082|  9.42k|        } else if (rule == CIPHER_KILL) {
 1083|       |            /* reverse == 0 */
 1084|  2.16k|            if (head == curr)
 1085|    210|                head = curr->next;
 1086|  1.95k|            else
 1087|  1.95k|                curr->prev->next = curr->next;
 1088|  2.16k|            if (tail == curr)
 1089|    120|                tail = curr->prev;
 1090|  2.16k|            curr->active = 0;
 1091|  2.16k|            if (curr->next != NULL)
 1092|  2.04k|                curr->next->prev = curr->prev;
 1093|  2.16k|            if (curr->prev != NULL)
 1094|  1.95k|                curr->prev->next = curr->next;
 1095|  2.16k|            curr->next = NULL;
 1096|  2.16k|            curr->prev = NULL;
 1097|  2.16k|        }
 1098|  48.2k|    }
 1099|       |
 1100|  1.56k|    *head_p = head;
 1101|  1.56k|    *tail_p = tail;
 1102|  1.56k|}
ssl_ciph.c:ll_append_tail:
  694|  32.4k|{
  695|  32.4k|    if (curr == *tail)
  696|      0|        return;
  697|  32.4k|    if (curr == *head)
  698|  13.8k|        *head = curr->next;
  699|  32.4k|    if (curr->prev != NULL)
  700|  18.5k|        curr->prev->next = curr->next;
  701|  32.4k|    if (curr->next != NULL)
  702|  32.4k|        curr->next->prev = curr->prev;
  703|  32.4k|    (*tail)->next = curr;
  704|  32.4k|    curr->prev = *tail;
  705|  32.4k|    curr->next = NULL;
  706|  32.4k|    *tail = curr;
  707|  32.4k|}
ssl_ciph.c:ll_append_head:
  711|  9.42k|{
  712|  9.42k|    if (curr == *head)
  713|      0|        return;
  714|  9.42k|    if (curr == *tail)
  715|  9.42k|        *tail = curr->prev;
  716|  9.42k|    if (curr->next != NULL)
  717|      0|        curr->next->prev = curr->prev;
  718|  9.42k|    if (curr->prev != NULL)
  719|  9.42k|        curr->prev->next = curr->next;
  720|  9.42k|    (*head)->prev = curr;
  721|  9.42k|    curr->next = *head;
  722|  9.42k|    curr->prev = NULL;
  723|  9.42k|    *head = curr;
  724|  9.42k|}
ssl_ciph.c:ssl_cipher_strength_sort:
 1106|     90|{
 1107|     90|    int max_strength_bits, i, *number_uses;
 1108|     90|    CIPHER_ORDER *curr;
 1109|       |
 1110|       |    /*
 1111|       |     * This routine sorts the ciphers with descending strength. The sorting
 1112|       |     * must keep the pre-sorted sequence, so we apply the normal sorting
 1113|       |     * routine as '+' movement to the end of the list.
 1114|       |     */
 1115|     90|    max_strength_bits = 0;
 1116|     90|    curr = *head_p;
 1117|  11.0k|    while (curr != NULL) {
 1118|  10.9k|        if (curr->active && (curr->cipher->strength_bits > max_strength_bits))
 1119|     90|            max_strength_bits = curr->cipher->strength_bits;
 1120|  10.9k|        curr = curr->next;
 1121|  10.9k|    }
 1122|       |
 1123|     90|    number_uses = OPENSSL_malloc((max_strength_bits + 1) * sizeof(int));
 1124|     90|    if (!number_uses) {
 1125|      0|        SSLerr(SSL_F_SSL_CIPHER_STRENGTH_SORT, ERR_R_MALLOC_FAILURE);
 1126|      0|        return (0);
 1127|      0|    }
 1128|     90|    memset(number_uses, 0, (max_strength_bits + 1) * sizeof(int));
 1129|       |
 1130|       |    /*
 1131|       |     * Now find the strength_bits values actually used
 1132|       |     */
 1133|     90|    curr = *head_p;
 1134|  11.0k|    while (curr != NULL) {
 1135|  10.9k|        if (curr->active)
 1136|  10.7k|            number_uses[curr->cipher->strength_bits]++;
 1137|  10.9k|        curr = curr->next;
 1138|  10.9k|    }
 1139|       |    /*
 1140|       |     * Go through the list of used strength_bits values in descending
 1141|       |     * order.
 1142|       |     */
 1143|  23.2k|    for (i = max_strength_bits; i >= 0; i--)
 1144|  23.1k|        if (number_uses[i] > 0)
 1145|    450|            ssl_cipher_apply_rule(0, 0, 0, 0, 0, 0, 0, CIPHER_ORD, i, head_p,
 1146|    450|                                  tail_p);
 1147|       |
 1148|     90|    OPENSSL_free(number_uses);
 1149|     90|    return (1);
 1150|     90|}
ssl_ciph.c:ssl_cipher_collect_aliases:
  902|     60|{
  903|     60|    CIPHER_ORDER *ciph_curr;
  904|     60|    const SSL_CIPHER **ca_curr;
  905|     60|    int i;
  906|     60|    unsigned long mask_mkey = ~disabled_mkey;
  907|     60|    unsigned long mask_auth = ~disabled_auth;
  908|     60|    unsigned long mask_enc = ~disabled_enc;
  909|     60|    unsigned long mask_mac = ~disabled_mac;
  910|     60|    unsigned long mask_ssl = ~disabled_ssl;
  911|       |
  912|       |    /*
  913|       |     * First, add the real ciphers as already collected
  914|       |     */
  915|     60|    ciph_curr = head;
  916|     60|    ca_curr = ca_list;
  917|  8.10k|    while (ciph_curr != NULL) {
  918|  8.04k|        *ca_curr = ciph_curr->cipher;
  919|  8.04k|        ca_curr++;
  920|  8.04k|        ciph_curr = ciph_curr->next;
  921|  8.04k|    }
  922|       |
  923|       |    /*
  924|       |     * Now we add the available ones from the cipher_aliases[] table.
  925|       |     * They represent either one or more algorithms, some of which
  926|       |     * in any affected category must be supported (set in enabled_mask),
  927|       |     * or represent a cipher strength value (will be added in any case because algorithms=0).
  928|       |     */
  929|  5.10k|    for (i = 0; i < num_of_group_aliases; i++) {
  930|  5.04k|        unsigned long algorithm_mkey = cipher_aliases[i].algorithm_mkey;
  931|  5.04k|        unsigned long algorithm_auth = cipher_aliases[i].algorithm_auth;
  932|  5.04k|        unsigned long algorithm_enc = cipher_aliases[i].algorithm_enc;
  933|  5.04k|        unsigned long algorithm_mac = cipher_aliases[i].algorithm_mac;
  934|  5.04k|        unsigned long algorithm_ssl = cipher_aliases[i].algorithm_ssl;
  935|       |
  936|  5.04k|        if (algorithm_mkey)
  937|  1.98k|            if ((algorithm_mkey & mask_mkey) == 0)
  938|    180|                continue;
  939|       |
  940|  4.86k|        if (algorithm_auth)
  941|  1.68k|            if ((algorithm_auth & mask_auth) == 0)
  942|    240|                continue;
  943|       |
  944|  4.62k|        if (algorithm_enc)
  945|  1.44k|            if ((algorithm_enc & mask_enc) == 0)
  946|      0|                continue;
  947|       |
  948|  4.62k|        if (algorithm_mac)
  949|    780|            if ((algorithm_mac & mask_mac) == 0)
  950|     60|                continue;
  951|       |
  952|  4.56k|        if (algorithm_ssl)
  953|    600|            if ((algorithm_ssl & mask_ssl) == 0)
  954|      0|                continue;
  955|       |
  956|  4.56k|        *ca_curr = (SSL_CIPHER *)(cipher_aliases + i);
  957|  4.56k|        ca_curr++;
  958|  4.56k|    }
  959|       |
  960|     60|    *ca_curr = NULL;            /* end of list */
  961|     60|}
ssl_ciph.c:ssl_cipher_process_rulestr:
 1156|     60|{
 1157|     60|    unsigned long alg_mkey, alg_auth, alg_enc, alg_mac, alg_ssl,
 1158|     60|        algo_strength;
 1159|     60|    const char *l, *buf;
 1160|     60|    int j, multi, found, rule, retval, ok, buflen;
 1161|     60|    unsigned long cipher_id = 0;
 1162|     60|    char ch;
 1163|       |
 1164|     60|    retval = 1;
 1165|     60|    l = rule_str;
 1166|    780|    for (;;) {
 1167|    780|        ch = *l;
 1168|       |
 1169|    780|        if (ch == '\0')
 1170|      0|            break;              /* done */
 1171|    780|        if (ch == '-') {
 1172|      0|            rule = CIPHER_DEL;
 1173|      0|            l++;
 1174|    780|        } else if (ch == '+') {
 1175|      0|            rule = CIPHER_ORD;
 1176|      0|            l++;
 1177|    780|        } else if (ch == '!') {
 1178|    330|            rule = CIPHER_KILL;
 1179|    330|            l++;
 1180|    450|        } else if (ch == '@') {
 1181|     30|            rule = CIPHER_SPECIAL;
 1182|     30|            l++;
 1183|    420|        } else {
 1184|    420|            rule = CIPHER_ADD;
 1185|    420|        }
 1186|       |
 1187|    780|        if (ITEM_SEP(ch)) {
 1188|    360|            l++;
 1189|    360|            continue;
 1190|    360|        }
 1191|       |
 1192|    420|        alg_mkey = 0;
 1193|    420|        alg_auth = 0;
 1194|    420|        alg_enc = 0;
 1195|    420|        alg_mac = 0;
 1196|    420|        alg_ssl = 0;
 1197|    420|        algo_strength = 0;
 1198|       |
 1199|    420|        for (;;) {
 1200|    420|            ch = *l;
 1201|    420|            buf = l;
 1202|    420|            buflen = 0;
 1203|    420|#ifndef CHARSET_EBCDIC
 1204|  2.55k|            while (((ch >= 'A') && (ch <= 'Z')) ||
 1205|  2.55k|                   ((ch >= '0') && (ch <= '9')) ||
 1206|  2.55k|                   ((ch >= 'a') && (ch <= 'z')) || (ch == '-') || (ch == '.'))
 1207|       |#else
 1208|       |            while (isalnum((unsigned char)ch) || (ch == '-') || (ch == '.'))
 1209|       |#endif
 1210|  2.13k|            {
 1211|  2.13k|                ch = *(++l);
 1212|  2.13k|                buflen++;
 1213|  2.13k|            }
 1214|       |
 1215|    420|            if (buflen == 0) {
 1216|       |                /*
 1217|       |                 * We hit something we cannot deal with,
 1218|       |                 * it is no command or separator nor
 1219|       |                 * alphanumeric, so we call this an error.
 1220|       |                 */
 1221|      0|                SSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,
 1222|      0|                       SSL_R_INVALID_COMMAND);
 1223|      0|                retval = found = 0;
 1224|      0|                l++;
 1225|      0|                break;
 1226|      0|            }
 1227|       |
 1228|    420|            if (rule == CIPHER_SPECIAL) {
 1229|     30|                found = 0;      /* unused -- avoid compiler warning */
 1230|     30|                break;          /* special treatment */
 1231|     30|            }
 1232|       |
 1233|       |            /* check for multi-part specification */
 1234|    390|            if (ch == '+') {
 1235|      0|                multi = 1;
 1236|      0|                l++;
 1237|      0|            } else
 1238|    390|                multi = 0;
 1239|       |
 1240|       |            /*
 1241|       |             * Now search for the cipher alias in the ca_list. Be careful
 1242|       |             * with the strncmp, because the "buflen" limitation
 1243|       |             * will make the rule "ADH:SOME" and the cipher
 1244|       |             * "ADH-MY-CIPHER" look like a match for buflen=3.
 1245|       |             * So additionally check whether the cipher name found
 1246|       |             * has the correct length. We can save a strlen() call:
 1247|       |             * just checking for the '\0' at the right place is
 1248|       |             * sufficient, we have to strncmp() anyway. (We cannot
 1249|       |             * use strcmp(), because buf is not '\0' terminated.)
 1250|       |             */
 1251|    390|            j = found = 0;
 1252|    390|            cipher_id = 0;
 1253|  69.7k|            while (ca_list[j]) {
 1254|  69.7k|                if (!strncmp(buf, ca_list[j]->name, buflen) &&
 1255|  69.7k|                    (ca_list[j]->name[buflen] == '\0')) {
 1256|    390|                    found = 1;
 1257|    390|                    break;
 1258|    390|                } else
 1259|  69.3k|                    j++;
 1260|  69.7k|            }
 1261|       |
 1262|    390|            if (!found)
 1263|      0|                break;          /* ignore this entry */
 1264|       |
 1265|    390|            if (ca_list[j]->algorithm_mkey) {
 1266|      0|                if (alg_mkey) {
 1267|      0|                    alg_mkey &= ca_list[j]->algorithm_mkey;
 1268|      0|                    if (!alg_mkey) {
 1269|      0|                        found = 0;
 1270|      0|                        break;
 1271|      0|                    }
 1272|      0|                } else
 1273|      0|                    alg_mkey = ca_list[j]->algorithm_mkey;
 1274|      0|            }
 1275|       |
 1276|    390|            if (ca_list[j]->algorithm_auth) {
 1277|     60|                if (alg_auth) {
 1278|      0|                    alg_auth &= ca_list[j]->algorithm_auth;
 1279|      0|                    if (!alg_auth) {
 1280|      0|                        found = 0;
 1281|      0|                        break;
 1282|      0|                    }
 1283|      0|                } else
 1284|     60|                    alg_auth = ca_list[j]->algorithm_auth;
 1285|     60|            }
 1286|       |
 1287|    390|            if (ca_list[j]->algorithm_enc) {
 1288|    120|                if (alg_enc) {
 1289|      0|                    alg_enc &= ca_list[j]->algorithm_enc;
 1290|      0|                    if (!alg_enc) {
 1291|      0|                        found = 0;
 1292|      0|                        break;
 1293|      0|                    }
 1294|      0|                } else
 1295|    120|                    alg_enc = ca_list[j]->algorithm_enc;
 1296|    120|            }
 1297|       |
 1298|    390|            if (ca_list[j]->algorithm_mac) {
 1299|      0|                if (alg_mac) {
 1300|      0|                    alg_mac &= ca_list[j]->algorithm_mac;
 1301|      0|                    if (!alg_mac) {
 1302|      0|                        found = 0;
 1303|      0|                        break;
 1304|      0|                    }
 1305|      0|                } else
 1306|      0|                    alg_mac = ca_list[j]->algorithm_mac;
 1307|      0|            }
 1308|       |
 1309|    390|            if (ca_list[j]->algo_strength & SSL_EXP_MASK) {
 1310|     60|                if (algo_strength & SSL_EXP_MASK) {
 1311|      0|                    algo_strength &=
 1312|      0|                        (ca_list[j]->algo_strength & SSL_EXP_MASK) |
 1313|      0|                        ~SSL_EXP_MASK;
 1314|      0|                    if (!(algo_strength & SSL_EXP_MASK)) {
 1315|      0|                        found = 0;
 1316|      0|                        break;
 1317|      0|                    }
 1318|      0|                } else
 1319|     60|                    algo_strength |= ca_list[j]->algo_strength & SSL_EXP_MASK;
 1320|     60|            }
 1321|       |
 1322|    390|            if (ca_list[j]->algo_strength & SSL_STRONG_MASK) {
 1323|    120|                if (algo_strength & SSL_STRONG_MASK) {
 1324|      0|                    algo_strength &=
 1325|      0|                        (ca_list[j]->algo_strength & SSL_STRONG_MASK) |
 1326|      0|                        ~SSL_STRONG_MASK;
 1327|      0|                    if (!(algo_strength & SSL_STRONG_MASK)) {
 1328|      0|                        found = 0;
 1329|      0|                        break;
 1330|      0|                    }
 1331|      0|                } else
 1332|    120|                    algo_strength |=
 1333|    120|                        ca_list[j]->algo_strength & SSL_STRONG_MASK;
 1334|    120|            }
 1335|       |
 1336|    390|            if (ca_list[j]->algo_strength & SSL_NOT_DEFAULT) {
 1337|      0|                algo_strength |= SSL_NOT_DEFAULT;
 1338|      0|            }
 1339|       |
 1340|    390|            if (ca_list[j]->valid) {
 1341|       |                /*
 1342|       |                 * explicit ciphersuite found; its protocol version does not
 1343|       |                 * become part of the search pattern!
 1344|       |                 */
 1345|       |
 1346|      0|                cipher_id = ca_list[j]->id;
 1347|    390|            } else {
 1348|       |                /*
 1349|       |                 * not an explicit ciphersuite; only in this case, the
 1350|       |                 * protocol version is considered part of the search pattern
 1351|       |                 */
 1352|       |
 1353|    390|                if (ca_list[j]->algorithm_ssl) {
 1354|     30|                    if (alg_ssl) {
 1355|      0|                        alg_ssl &= ca_list[j]->algorithm_ssl;
 1356|      0|                        if (!alg_ssl) {
 1357|      0|                            found = 0;
 1358|      0|                            break;
 1359|      0|                        }
 1360|      0|                    } else
 1361|     30|                        alg_ssl = ca_list[j]->algorithm_ssl;
 1362|     30|                }
 1363|    390|            }
 1364|       |
 1365|    390|            if (!multi)
 1366|    390|                break;
 1367|    390|        }
 1368|       |
 1369|       |        /*
 1370|       |         * Ok, we have the rule, now apply it
 1371|       |         */
 1372|    420|        if (rule == CIPHER_SPECIAL) { /* special command */
 1373|     30|            ok = 0;
 1374|     30|            if ((buflen == 8) && !strncmp(buf, "STRENGTH", 8))
 1375|     30|                ok = ssl_cipher_strength_sort(head_p, tail_p);
 1376|      0|            else
 1377|     30|                SSLerr(SSL_F_SSL_CIPHER_PROCESS_RULESTR,
 1378|     30|                       SSL_R_INVALID_COMMAND);
 1379|     30|            if (ok == 0)
 1380|      0|                retval = 0;
 1381|       |            /*
 1382|       |             * We do not support any "multi" options
 1383|       |             * together with "@", so throw away the
 1384|       |             * rest of the command, if any left, until
 1385|       |             * end or ':' is found.
 1386|       |             */
 1387|     30|            while ((*l != '\0') && !ITEM_SEP(*l))
 1388|      0|                l++;
 1389|    390|        } else if (found) {
 1390|    390|            ssl_cipher_apply_rule(cipher_id,
 1391|    390|                                  alg_mkey, alg_auth, alg_enc, alg_mac,
 1392|    390|                                  alg_ssl, algo_strength, rule, -1, head_p,
 1393|    390|                                  tail_p);
 1394|    390|        } else {
 1395|      0|            while ((*l != '\0') && !ITEM_SEP(*l))
 1396|      0|                l++;
 1397|      0|        }
 1398|    420|        if (*l == '\0')
 1399|     60|            break;              /* done */
 1400|    420|    }
 1401|       |
 1402|     60|    return (retval);
 1403|     60|}

ERR_load_SSL_strings:
  832|      1|{
  833|      1|#ifndef OPENSSL_NO_ERR
  834|       |
  835|      1|    if (ERR_func_error_string(SSL_str_functs[0].error) == NULL) {
  836|      1|        ERR_load_strings(0, SSL_str_functs);
  837|      1|        ERR_load_strings(0, SSL_str_reasons);
  838|      1|    }
  839|      1|#endif
  840|      1|}

SSL_load_error_strings:
   64|      1|{
   65|      1|#ifndef OPENSSL_NO_ERR
   66|      1|    ERR_load_crypto_strings();
   67|      1|    ERR_load_SSL_strings();
   68|      1|#endif
   69|      1|}

SSL_clear:
  191|     60|{
  192|       |
  193|     60|    if (s->method == NULL) {
  194|      0|        SSLerr(SSL_F_SSL_CLEAR, SSL_R_NO_METHOD_SPECIFIED);
  195|      0|        return (0);
  196|      0|    }
  197|       |
  198|     60|    if (ssl_clear_bad_session(s)) {
  199|      0|        SSL_SESSION_free(s->session);
  200|      0|        s->session = NULL;
  201|      0|    }
  202|       |
  203|     60|    s->error = 0;
  204|     60|    s->hit = 0;
  205|     60|    s->shutdown = 0;
  206|       |
  207|       |#if 0
  208|       |    /*
  209|       |     * Disabled since version 1.10 of this file (early return not
  210|       |     * needed because SSL_clear is not called when doing renegotiation)
  211|       |     */
  212|       |    /*
  213|       |     * This is set if we are doing dynamic renegotiation so keep
  214|       |     * the old cipher.  It is sort of a SSL_clear_lite :-)
  215|       |     */
  216|       |    if (s->renegotiate)
  217|       |        return (1);
  218|       |#else
  219|     60|    if (s->renegotiate) {
  220|      0|        SSLerr(SSL_F_SSL_CLEAR, ERR_R_INTERNAL_ERROR);
  221|      0|        return 0;
  222|      0|    }
  223|     60|#endif
  224|       |
  225|     60|    s->type = 0;
  226|       |
  227|     60|    s->state = SSL_ST_BEFORE | ((s->server) ? SSL_ST_ACCEPT : SSL_ST_CONNECT);
  228|       |
  229|     60|    s->version = s->method->version;
  230|     60|    s->client_version = s->version;
  231|     60|    s->rwstate = SSL_NOTHING;
  232|     60|    s->rstate = SSL_ST_READ_HEADER;
  233|       |#if 0
  234|       |    s->read_ahead = s->ctx->read_ahead;
  235|       |#endif
  236|       |
  237|     60|    if (s->init_buf != NULL) {
  238|      0|        BUF_MEM_free(s->init_buf);
  239|      0|        s->init_buf = NULL;
  240|      0|    }
  241|       |
  242|     60|    ssl_clear_cipher_ctx(s);
  243|     60|    ssl_clear_hash_ctx(&s->read_hash);
  244|     60|    ssl_clear_hash_ctx(&s->write_hash);
  245|       |
  246|     60|    s->first_packet = 0;
  247|     60|#ifndef OPENSSL_NO_TLSEXT
  248|     60|    if (s->cert != NULL) {
  249|     60|        if (s->cert->alpn_proposed) {
  250|      0|            OPENSSL_free(s->cert->alpn_proposed);
  251|      0|            s->cert->alpn_proposed = NULL;
  252|      0|        }
  253|     60|        s->cert->alpn_proposed_len = 0;
  254|     60|        s->cert->alpn_sent = 0;
  255|     60|    }
  256|     60|#endif
  257|     60|#if 1
  258|       |    /*
  259|       |     * Check to see if we were changed into a different method, if so, revert
  260|       |     * back if we are not doing session-id reuse.
  261|       |     */
  262|     60|    if (!s->in_handshake && (s->session == NULL)
  263|     60|        && (s->method != s->ctx->method)) {
  264|      0|        s->method->ssl_free(s);
  265|      0|        s->method = s->ctx->method;
  266|      0|        if (!s->method->ssl_new(s))
  267|      0|            return (0);
  268|      0|    } else
  269|     60|#endif
  270|     60|        s->method->ssl_clear(s);
  271|     60|    return (1);
  272|     60|}
SSL_new:
  295|     30|{
  296|     30|    SSL *s;
  297|       |
  298|     30|    if (ctx == NULL) {
  299|      0|        SSLerr(SSL_F_SSL_NEW, SSL_R_NULL_SSL_CTX);
  300|      0|        return (NULL);
  301|      0|    }
  302|     30|    if (ctx->method == NULL) {
  303|      0|        SSLerr(SSL_F_SSL_NEW, SSL_R_SSL_CTX_HAS_NO_DEFAULT_SSL_VERSION);
  304|      0|        return (NULL);
  305|      0|    }
  306|       |
  307|     30|    s = (SSL *)OPENSSL_malloc(sizeof(SSL));
  308|     30|    if (s == NULL)
  309|      0|        goto err;
  310|     30|    memset(s, 0, sizeof(SSL));
  311|       |
  312|       |#ifndef OPENSSL_NO_KRB5
  313|       |    s->kssl_ctx = kssl_ctx_new();
  314|       |#endif                          /* OPENSSL_NO_KRB5 */
  315|       |
  316|     30|    s->options = ctx->options;
  317|     30|    s->mode = ctx->mode;
  318|     30|    s->max_cert_list = ctx->max_cert_list;
  319|     30|    s->references = 1;
  320|       |
  321|     30|    if (ctx->cert != NULL) {
  322|       |        /*
  323|       |         * Earlier library versions used to copy the pointer to the CERT, not
  324|       |         * its contents; only when setting new parameters for the per-SSL
  325|       |         * copy, ssl_cert_new would be called (and the direct reference to
  326|       |         * the per-SSL_CTX settings would be lost, but those still were
  327|       |         * indirectly accessed for various purposes, and for that reason they
  328|       |         * used to be known as s->ctx->default_cert). Now we don't look at the
  329|       |         * SSL_CTX's CERT after having duplicated it once.
  330|       |         */
  331|       |
  332|     30|        s->cert = ssl_cert_dup(ctx->cert);
  333|     30|        if (s->cert == NULL)
  334|      0|            goto err;
  335|     30|    } else
  336|      0|        s->cert = NULL;         /* Cannot really happen (see SSL_CTX_new) */
  337|       |
  338|     30|    s->read_ahead = ctx->read_ahead;
  339|     30|    s->msg_callback = ctx->msg_callback;
  340|     30|    s->msg_callback_arg = ctx->msg_callback_arg;
  341|     30|    s->verify_mode = ctx->verify_mode;
  342|       |#if 0
  343|       |    s->verify_depth = ctx->verify_depth;
  344|       |#endif
  345|     30|    s->sid_ctx_length = ctx->sid_ctx_length;
  346|     30|    OPENSSL_assert(s->sid_ctx_length <= sizeof s->sid_ctx);
  347|     30|    memcpy(&s->sid_ctx, &ctx->sid_ctx, sizeof(s->sid_ctx));
  348|     30|    s->verify_callback = ctx->default_verify_callback;
  349|     30|    s->generate_session_id = ctx->generate_session_id;
  350|       |
  351|     30|    s->param = X509_VERIFY_PARAM_new();
  352|     30|    if (!s->param)
  353|      0|        goto err;
  354|     30|    X509_VERIFY_PARAM_inherit(s->param, ctx->param);
  355|       |#if 0
  356|       |    s->purpose = ctx->purpose;
  357|       |    s->trust = ctx->trust;
  358|       |#endif
  359|     30|    s->quiet_shutdown = ctx->quiet_shutdown;
  360|     30|    s->max_send_fragment = ctx->max_send_fragment;
  361|       |
  362|     30|    CRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);
  363|     30|    s->ctx = ctx;
  364|     30|#ifndef OPENSSL_NO_TLSEXT
  365|     30|    s->tlsext_debug_cb = 0;
  366|     30|    s->tlsext_debug_arg = NULL;
  367|     30|    s->tlsext_ticket_expected = 0;
  368|     30|    s->tlsext_status_type = -1;
  369|     30|    s->tlsext_status_expected = 0;
  370|     30|    s->tlsext_ocsp_ids = NULL;
  371|     30|    s->tlsext_ocsp_exts = NULL;
  372|     30|    s->tlsext_ocsp_resp = NULL;
  373|     30|    s->tlsext_ocsp_resplen = -1;
  374|     30|    CRYPTO_add(&ctx->references, 1, CRYPTO_LOCK_SSL_CTX);
  375|     30|    s->initial_ctx = ctx;
  376|     30|# ifndef OPENSSL_NO_EC
  377|     30|    if (ctx->tlsext_ecpointformatlist) {
  378|      0|        s->tlsext_ecpointformatlist =
  379|      0|            BUF_memdup(ctx->tlsext_ecpointformatlist,
  380|      0|                       ctx->tlsext_ecpointformatlist_length);
  381|      0|        if (!s->tlsext_ecpointformatlist)
  382|      0|            goto err;
  383|      0|        s->tlsext_ecpointformatlist_length =
  384|      0|            ctx->tlsext_ecpointformatlist_length;
  385|      0|    }
  386|     30|    if (ctx->tlsext_ellipticcurvelist) {
  387|      0|        s->tlsext_ellipticcurvelist =
  388|      0|            BUF_memdup(ctx->tlsext_ellipticcurvelist,
  389|      0|                       ctx->tlsext_ellipticcurvelist_length);
  390|      0|        if (!s->tlsext_ellipticcurvelist)
  391|      0|            goto err;
  392|      0|        s->tlsext_ellipticcurvelist_length =
  393|      0|            ctx->tlsext_ellipticcurvelist_length;
  394|      0|    }
  395|     30|# endif
  396|     30|# ifndef OPENSSL_NO_NEXTPROTONEG
  397|     30|    s->next_proto_negotiated = NULL;
  398|     30|# endif
  399|       |
  400|     30|    if (s->ctx->alpn_client_proto_list) {
  401|      0|        s->alpn_client_proto_list =
  402|      0|            OPENSSL_malloc(s->ctx->alpn_client_proto_list_len);
  403|      0|        if (s->alpn_client_proto_list == NULL)
  404|      0|            goto err;
  405|      0|        memcpy(s->alpn_client_proto_list, s->ctx->alpn_client_proto_list,
  406|      0|               s->ctx->alpn_client_proto_list_len);
  407|      0|        s->alpn_client_proto_list_len = s->ctx->alpn_client_proto_list_len;
  408|      0|    }
  409|     30|#endif
  410|       |
  411|     30|    s->verify_result = X509_V_OK;
  412|       |
  413|     30|    s->method = ctx->method;
  414|       |
  415|     30|    if (!s->method->ssl_new(s))
  416|      0|        goto err;
  417|       |
  418|     30|    s->server = (ctx->method->ssl_accept == ssl_undefined_function) ? 0 : 1;
  419|       |
  420|     30|    SSL_clear(s);
  421|       |
  422|     30|    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
  423|       |
  424|     30|#ifndef OPENSSL_NO_PSK
  425|     30|    s->psk_client_callback = ctx->psk_client_callback;
  426|     30|    s->psk_server_callback = ctx->psk_server_callback;
  427|     30|#endif
  428|       |
  429|     30|    return (s);
  430|      0| err:
  431|      0|    if (s != NULL)
  432|      0|        SSL_free(s);
  433|      0|    SSLerr(SSL_F_SSL_NEW, ERR_R_MALLOC_FAILURE);
  434|      0|    return (NULL);
  435|     30|}
SSL_free:
  563|     30|{
  564|     30|    int i;
  565|       |
  566|     30|    if (s == NULL)
  567|      0|        return;
  568|       |
  569|     30|    i = CRYPTO_add(&s->references, -1, CRYPTO_LOCK_SSL);
  570|       |#ifdef REF_PRINT
  571|       |    REF_PRINT("SSL", s);
  572|       |#endif
  573|     30|    if (i > 0)
  574|      0|        return;
  575|       |#ifdef REF_CHECK
  576|       |    if (i < 0) {
  577|       |        fprintf(stderr, "SSL_free, bad reference count\n");
  578|       |        abort();                /* ok */
  579|       |    }
  580|       |#endif
  581|       |
  582|     30|    if (s->param)
  583|     30|        X509_VERIFY_PARAM_free(s->param);
  584|       |
  585|     30|    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL, s, &s->ex_data);
  586|       |
  587|     30|    if (s->bbio != NULL) {
  588|       |        /* If the buffering BIO is in place, pop it off */
  589|      0|        if (s->bbio == s->wbio) {
  590|      0|            s->wbio = BIO_pop(s->wbio);
  591|      0|        }
  592|      0|        BIO_free(s->bbio);
  593|      0|        s->bbio = NULL;
  594|      0|    }
  595|     30|    if (s->rbio != NULL)
  596|     30|        BIO_free_all(s->rbio);
  597|     30|    if ((s->wbio != NULL) && (s->wbio != s->rbio))
  598|      0|        BIO_free_all(s->wbio);
  599|       |
  600|     30|    if (s->init_buf != NULL)
  601|     30|        BUF_MEM_free(s->init_buf);
  602|       |
  603|       |    /* add extra stuff */
  604|     30|    if (s->cipher_list != NULL)
  605|     30|        sk_SSL_CIPHER_free(s->cipher_list);
  606|     30|    if (s->cipher_list_by_id != NULL)
  607|     30|        sk_SSL_CIPHER_free(s->cipher_list_by_id);
  608|       |
  609|       |    /* Make the next call work :-) */
  610|     30|    if (s->session != NULL) {
  611|     30|        ssl_clear_bad_session(s);
  612|     30|        SSL_SESSION_free(s->session);
  613|     30|    }
  614|       |
  615|     30|    ssl_clear_cipher_ctx(s);
  616|     30|    ssl_clear_hash_ctx(&s->read_hash);
  617|     30|    ssl_clear_hash_ctx(&s->write_hash);
  618|       |
  619|     30|    if (s->cert != NULL)
  620|     30|        ssl_cert_free(s->cert);
  621|       |    /* Free up if allocated */
  622|       |
  623|     30|#ifndef OPENSSL_NO_TLSEXT
  624|     30|    if (s->tlsext_hostname)
  625|     26|        OPENSSL_free(s->tlsext_hostname);
  626|     30|    if (s->initial_ctx)
  627|     30|        SSL_CTX_free(s->initial_ctx);
  628|     30|# ifndef OPENSSL_NO_EC
  629|     30|    if (s->tlsext_ecpointformatlist)
  630|      0|        OPENSSL_free(s->tlsext_ecpointformatlist);
  631|     30|    if (s->tlsext_ellipticcurvelist)
  632|      0|        OPENSSL_free(s->tlsext_ellipticcurvelist);
  633|     30|# endif                         /* OPENSSL_NO_EC */
  634|     30|    if (s->tlsext_opaque_prf_input)
  635|      0|        OPENSSL_free(s->tlsext_opaque_prf_input);
  636|     30|    if (s->tlsext_ocsp_exts)
  637|     30|        sk_X509_EXTENSION_pop_free(s->tlsext_ocsp_exts, X509_EXTENSION_free);
  638|     30|    if (s->tlsext_ocsp_ids)
  639|     30|        sk_OCSP_RESPID_pop_free(s->tlsext_ocsp_ids, OCSP_RESPID_free);
  640|     30|    if (s->tlsext_ocsp_resp)
  641|      0|        OPENSSL_free(s->tlsext_ocsp_resp);
  642|     30|    if (s->alpn_client_proto_list)
  643|      0|        OPENSSL_free(s->alpn_client_proto_list);
  644|     30|#endif
  645|       |
  646|     30|    if (s->client_CA != NULL)
  647|     30|        sk_X509_NAME_pop_free(s->client_CA, X509_NAME_free);
  648|       |
  649|     30|    if (s->method != NULL)
  650|     30|        s->method->ssl_free(s);
  651|       |
  652|     30|    if (s->ctx)
  653|     30|        SSL_CTX_free(s->ctx);
  654|       |
  655|       |#ifndef OPENSSL_NO_KRB5
  656|       |    if (s->kssl_ctx != NULL)
  657|       |        kssl_ctx_free(s->kssl_ctx);
  658|       |#endif                          /* OPENSSL_NO_KRB5 */
  659|       |
  660|     30|#if !defined(OPENSSL_NO_TLSEXT) && !defined(OPENSSL_NO_NEXTPROTONEG)
  661|     30|    if (s->next_proto_negotiated)
  662|      0|        OPENSSL_free(s->next_proto_negotiated);
  663|     30|#endif
  664|       |
  665|     30|#ifndef OPENSSL_NO_SRTP
  666|     30|    if (s->srtp_profiles)
  667|     30|        sk_SRTP_PROTECTION_PROFILE_free(s->srtp_profiles);
  668|     30|#endif
  669|       |
  670|     30|    OPENSSL_free(s);
  671|     30|}
SSL_set_bio:
  674|     30|{
  675|       |    /*
  676|       |     * If the output buffering BIO is still in place, remove it
  677|       |     */
  678|     30|    if (s->bbio != NULL) {
  679|      0|        if (s->wbio == s->bbio) {
  680|      0|            s->wbio = s->wbio->next_bio;
  681|      0|            s->bbio->next_bio = NULL;
  682|      0|        }
  683|      0|    }
  684|     30|    if ((s->rbio != NULL) && (s->rbio != rbio))
  685|      0|        BIO_free_all(s->rbio);
  686|     30|    if ((s->wbio != NULL) && (s->wbio != wbio) && (s->rbio != s->wbio))
  687|      0|        BIO_free_all(s->wbio);
  688|     30|    s->rbio = rbio;
  689|     30|    s->wbio = wbio;
  690|     30|}
SSL_set_fd:
  733|     30|{
  734|     30|    int ret = 0;
  735|     30|    BIO *bio = NULL;
  736|       |
  737|     30|    bio = BIO_new(BIO_s_socket());
  738|       |
  739|     30|    if (bio == NULL) {
  740|      0|        SSLerr(SSL_F_SSL_SET_FD, ERR_R_BUF_LIB);
  741|      0|        goto err;
  742|      0|    }
  743|     30|    BIO_set_fd(bio, fd, BIO_NOCLOSE);
  744|     30|    SSL_set_bio(s, bio, bio);
  745|     30|    ret = 1;
  746|     30| err:
  747|     30|    return (ret);
  748|     30|}
SSL_connect:
 1003|     30|{
 1004|     30|    if (s->handshake_func == 0)
 1005|       |        /* Not properly initialized yet */
 1006|      0|        SSL_set_connect_state(s);
 1007|       |
 1008|     30|    return (s->method->ssl_connect(s));
 1009|     30|}
SSL_read:
 1017|     30|{
 1018|     30|    if (s->handshake_func == 0) {
 1019|      0|        SSLerr(SSL_F_SSL_READ, SSL_R_UNINITIALIZED);
 1020|      0|        return -1;
 1021|      0|    }
 1022|       |
 1023|     30|    if (s->shutdown & SSL_RECEIVED_SHUTDOWN) {
 1024|      0|        s->rwstate = SSL_NOTHING;
 1025|      0|        return (0);
 1026|      0|    }
 1027|     30|    return (s->method->ssl_read(s, buf, num));
 1028|     30|}
SSL_shutdown:
 1059|     30|{
 1060|       |    /*
 1061|       |     * Note that this function behaves differently from what one might
 1062|       |     * expect.  Return values are 0 for no success (yet), 1 for success; but
 1063|       |     * calling it once is usually not enough, even if blocking I/O is used
 1064|       |     * (see ssl3_shutdown).
 1065|       |     */
 1066|       |
 1067|     30|    if (s->handshake_func == 0) {
 1068|      0|        SSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_UNINITIALIZED);
 1069|      0|        return -1;
 1070|      0|    }
 1071|       |
 1072|     30|    if (!SSL_in_init(s)) {
 1073|      0|        return s->method->ssl_shutdown(s);
 1074|     30|    } else {
 1075|     30|        SSLerr(SSL_F_SSL_SHUTDOWN, SSL_R_SHUTDOWN_WHILE_IN_INIT);
 1076|     30|        return -1;
 1077|     30|    }
 1078|     30|}
SSL_ctrl:
 1110|     58|{
 1111|     58|    long l;
 1112|       |
 1113|     58|    switch (cmd) {
 1114|      0|    case SSL_CTRL_GET_READ_AHEAD:
 1115|      0|        return (s->read_ahead);
 1116|      0|    case SSL_CTRL_SET_READ_AHEAD:
 1117|      0|        l = s->read_ahead;
 1118|      0|        s->read_ahead = larg;
 1119|      0|        return (l);
 1120|       |
 1121|      0|    case SSL_CTRL_SET_MSG_CALLBACK_ARG:
 1122|      0|        s->msg_callback_arg = parg;
 1123|      0|        return 1;
 1124|       |
 1125|     30|    case SSL_CTRL_OPTIONS:
 1126|     30|        return (s->options |= larg);
 1127|      0|    case SSL_CTRL_CLEAR_OPTIONS:
 1128|      0|        return (s->options &= ~larg);
 1129|      0|    case SSL_CTRL_MODE:
 1130|      0|        return (s->mode |= larg);
 1131|      0|    case SSL_CTRL_CLEAR_MODE:
 1132|      0|        return (s->mode &= ~larg);
 1133|      0|    case SSL_CTRL_GET_MAX_CERT_LIST:
 1134|      0|        return (s->max_cert_list);
 1135|      0|    case SSL_CTRL_SET_MAX_CERT_LIST:
 1136|      0|        l = s->max_cert_list;
 1137|      0|        s->max_cert_list = larg;
 1138|      0|        return (l);
 1139|      0|    case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
 1140|      0|        if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
 1141|      0|            return 0;
 1142|      0|        s->max_send_fragment = larg;
 1143|      0|        return 1;
 1144|      0|    case SSL_CTRL_GET_RI_SUPPORT:
 1145|      0|        if (s->s3)
 1146|      0|            return s->s3->send_connection_binding;
 1147|      0|        else
 1148|      0|            return 0;
 1149|      0|    case SSL_CTRL_CERT_FLAGS:
 1150|      0|        return (s->cert->cert_flags |= larg);
 1151|      0|    case SSL_CTRL_CLEAR_CERT_FLAGS:
 1152|      0|        return (s->cert->cert_flags &= ~larg);
 1153|       |
 1154|      0|    case SSL_CTRL_GET_RAW_CIPHERLIST:
 1155|      0|        if (parg) {
 1156|      0|            if (s->cert->ciphers_raw == NULL)
 1157|      0|                return 0;
 1158|      0|            *(unsigned char **)parg = s->cert->ciphers_raw;
 1159|      0|            return (int)s->cert->ciphers_rawlen;
 1160|      0|        } else
 1161|      0|            return ssl_put_cipher_by_char(s, NULL, NULL);
 1162|     28|    default:
 1163|     28|        return (s->method->ssl_ctrl(s, cmd, larg, parg));
 1164|     58|    }
 1165|     58|}
SSL_CTX_ctrl:
 1188|     90|{
 1189|     90|    long l;
 1190|       |    /* For some cases with ctx == NULL perform syntax checks */
 1191|     90|    if (ctx == NULL) {
 1192|      0|        switch (cmd) {
 1193|      0|#ifndef OPENSSL_NO_EC
 1194|      0|        case SSL_CTRL_SET_CURVES_LIST:
 1195|      0|            return tls1_set_curves_list(NULL, NULL, parg);
 1196|      0|#endif
 1197|      0|        case SSL_CTRL_SET_SIGALGS_LIST:
 1198|      0|        case SSL_CTRL_SET_CLIENT_SIGALGS_LIST:
 1199|      0|            return tls1_set_sigalgs_list(NULL, parg, 0);
 1200|      0|        default:
 1201|      0|            return 0;
 1202|      0|        }
 1203|      0|    }
 1204|       |
 1205|     90|    switch (cmd) {
 1206|      0|    case SSL_CTRL_GET_READ_AHEAD:
 1207|      0|        return (ctx->read_ahead);
 1208|      0|    case SSL_CTRL_SET_READ_AHEAD:
 1209|      0|        l = ctx->read_ahead;
 1210|      0|        ctx->read_ahead = larg;
 1211|      0|        return (l);
 1212|       |
 1213|      0|    case SSL_CTRL_SET_MSG_CALLBACK_ARG:
 1214|      0|        ctx->msg_callback_arg = parg;
 1215|      0|        return 1;
 1216|       |
 1217|      0|    case SSL_CTRL_GET_MAX_CERT_LIST:
 1218|      0|        return (ctx->max_cert_list);
 1219|      0|    case SSL_CTRL_SET_MAX_CERT_LIST:
 1220|      0|        l = ctx->max_cert_list;
 1221|      0|        ctx->max_cert_list = larg;
 1222|      0|        return (l);
 1223|       |
 1224|      0|    case SSL_CTRL_SET_SESS_CACHE_SIZE:
 1225|      0|        l = ctx->session_cache_size;
 1226|      0|        ctx->session_cache_size = larg;
 1227|      0|        return (l);
 1228|      0|    case SSL_CTRL_GET_SESS_CACHE_SIZE:
 1229|      0|        return (ctx->session_cache_size);
 1230|     30|    case SSL_CTRL_SET_SESS_CACHE_MODE:
 1231|     30|        l = ctx->session_cache_mode;
 1232|     30|        ctx->session_cache_mode = larg;
 1233|     30|        return (l);
 1234|      0|    case SSL_CTRL_GET_SESS_CACHE_MODE:
 1235|      0|        return (ctx->session_cache_mode);
 1236|       |
 1237|      0|    case SSL_CTRL_SESS_NUMBER:
 1238|      0|        return (lh_SSL_SESSION_num_items(ctx->sessions));
 1239|      0|    case SSL_CTRL_SESS_CONNECT:
 1240|      0|        return (ctx->stats.sess_connect);
 1241|      0|    case SSL_CTRL_SESS_CONNECT_GOOD:
 1242|      0|        return (ctx->stats.sess_connect_good);
 1243|      0|    case SSL_CTRL_SESS_CONNECT_RENEGOTIATE:
 1244|      0|        return (ctx->stats.sess_connect_renegotiate);
 1245|      0|    case SSL_CTRL_SESS_ACCEPT:
 1246|      0|        return (ctx->stats.sess_accept);
 1247|      0|    case SSL_CTRL_SESS_ACCEPT_GOOD:
 1248|      0|        return (ctx->stats.sess_accept_good);
 1249|      0|    case SSL_CTRL_SESS_ACCEPT_RENEGOTIATE:
 1250|      0|        return (ctx->stats.sess_accept_renegotiate);
 1251|      0|    case SSL_CTRL_SESS_HIT:
 1252|      0|        return (ctx->stats.sess_hit);
 1253|      0|    case SSL_CTRL_SESS_CB_HIT:
 1254|      0|        return (ctx->stats.sess_cb_hit);
 1255|      0|    case SSL_CTRL_SESS_MISSES:
 1256|      0|        return (ctx->stats.sess_miss);
 1257|      0|    case SSL_CTRL_SESS_TIMEOUTS:
 1258|      0|        return (ctx->stats.sess_timeout);
 1259|      0|    case SSL_CTRL_SESS_CACHE_FULL:
 1260|      0|        return (ctx->stats.sess_cache_full);
 1261|     30|    case SSL_CTRL_OPTIONS:
 1262|     30|        return (ctx->options |= larg);
 1263|      0|    case SSL_CTRL_CLEAR_OPTIONS:
 1264|      0|        return (ctx->options &= ~larg);
 1265|     30|    case SSL_CTRL_MODE:
 1266|     30|        return (ctx->mode |= larg);
 1267|      0|    case SSL_CTRL_CLEAR_MODE:
 1268|      0|        return (ctx->mode &= ~larg);
 1269|      0|    case SSL_CTRL_SET_MAX_SEND_FRAGMENT:
 1270|      0|        if (larg < 512 || larg > SSL3_RT_MAX_PLAIN_LENGTH)
 1271|      0|            return 0;
 1272|      0|        ctx->max_send_fragment = larg;
 1273|      0|        return 1;
 1274|      0|    case SSL_CTRL_CERT_FLAGS:
 1275|      0|        return (ctx->cert->cert_flags |= larg);
 1276|      0|    case SSL_CTRL_CLEAR_CERT_FLAGS:
 1277|      0|        return (ctx->cert->cert_flags &= ~larg);
 1278|      0|    default:
 1279|      0|        return (ctx->method->ssl_ctx_ctrl(ctx, cmd, larg, parg));
 1280|     90|    }
 1281|     90|}
ssl_cipher_ptr_id_cmp:
 1311|  28.4k|{
 1312|  28.4k|    long l;
 1313|       |
 1314|  28.4k|    l = (*ap)->id - (*bp)->id;
 1315|  28.4k|    if (l == 0L)
 1316|      0|        return (0);
 1317|  28.4k|    else
 1318|  28.4k|        return ((l > 0) ? 1 : -1);
 1319|  28.4k|}
SSL_get_ciphers:
 1324|     60|{
 1325|     60|    if (s != NULL) {
 1326|     60|        if (s->cipher_list != NULL) {
 1327|      0|            return (s->cipher_list);
 1328|     60|        } else if ((s->ctx != NULL) && (s->ctx->cipher_list != NULL)) {
 1329|     60|            return (s->ctx->cipher_list);
 1330|     60|        }
 1331|     60|    }
 1332|      0|    return (NULL);
 1333|     60|}
SSL_CTX_set_cipher_list:
 1368|     30|{
 1369|     30|    STACK_OF(SSL_CIPHER) *sk;
 1370|       |
 1371|     30|    sk = ssl_create_cipher_list(ctx->method, &ctx->cipher_list,
 1372|     30|                                &ctx->cipher_list_by_id, str, ctx->cert);
 1373|       |    /*
 1374|       |     * ssl_create_cipher_list may return an empty stack if it was unable to
 1375|       |     * find a cipher matching the given rule string (for example if the rule
 1376|       |     * string specifies a cipher which has been disabled). This is not an
 1377|       |     * error as far as ssl_create_cipher_list is concerned, and hence
 1378|       |     * ctx->cipher_list and ctx->cipher_list_by_id has been updated.
 1379|       |     */
 1380|     30|    if (sk == NULL)
 1381|      0|        return 0;
 1382|     30|    else if (sk_SSL_CIPHER_num(sk) == 0) {
 1383|      0|        SSLerr(SSL_F_SSL_CTX_SET_CIPHER_LIST, SSL_R_NO_CIPHER_MATCH);
 1384|      0|        return 0;
 1385|      0|    }
 1386|     30|    return 1;
 1387|     30|}
ssl_cipher_list_to_bytes:
 1447|     30|{
 1448|     30|    int i, j = 0;
 1449|     30|    SSL_CIPHER *c;
 1450|     30|    CERT *ct = s->cert;
 1451|     30|    unsigned char *q;
 1452|     30|    int empty_reneg_info_scsv = !s->renegotiate;
 1453|       |    /* Set disabled masks for this session */
 1454|     30|    ssl_set_client_disabled(s);
 1455|       |
 1456|     30|    if (sk == NULL)
 1457|      0|        return (0);
 1458|     30|    q = p;
 1459|     30|    if (put_cb == NULL)
 1460|      0|        put_cb = s->method->put_cipher_by_char;
 1461|       |
 1462|  2.76k|    for (i = 0; i < sk_SSL_CIPHER_num(sk); i++) {
 1463|  2.73k|        c = sk_SSL_CIPHER_value(sk, i);
 1464|       |        /* Skip disabled ciphers */
 1465|  2.73k|        if (c->algorithm_ssl & ct->mask_ssl ||
 1466|  2.73k|            c->algorithm_mkey & ct->mask_k || c->algorithm_auth & ct->mask_a)
 1467|    360|            continue;
 1468|       |#ifdef OPENSSL_SSL_DEBUG_BROKEN_PROTOCOL
 1469|       |        if (c->id == SSL3_CK_SCSV) {
 1470|       |            if (!empty_reneg_info_scsv)
 1471|       |                continue;
 1472|       |            else
 1473|       |                empty_reneg_info_scsv = 0;
 1474|       |        }
 1475|       |#endif
 1476|  2.37k|        j = put_cb(c, p);
 1477|  2.37k|        p += j;
 1478|  2.37k|    }
 1479|       |    /*
 1480|       |     * If p == q, no ciphers; caller indicates an error. Otherwise, add
 1481|       |     * applicable SCSVs.
 1482|       |     */
 1483|     30|    if (p != q) {
 1484|     30|        if (empty_reneg_info_scsv) {
 1485|     30|            static SSL_CIPHER scsv = {
 1486|     30|                0, NULL, SSL3_CK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0
 1487|     30|            };
 1488|     30|            j = put_cb(&scsv, p);
 1489|     30|            p += j;
 1490|       |#ifdef OPENSSL_RI_DEBUG
 1491|       |            fprintf(stderr,
 1492|       |                    "TLS_EMPTY_RENEGOTIATION_INFO_SCSV sent by client\n");
 1493|       |#endif
 1494|     30|        }
 1495|     30|        if (s->mode & SSL_MODE_SEND_FALLBACK_SCSV) {
 1496|      0|            static SSL_CIPHER scsv = {
 1497|      0|                0, NULL, SSL3_CK_FALLBACK_SCSV, 0, 0, 0, 0, 0, 0, 0, 0, 0
 1498|      0|            };
 1499|      0|            j = put_cb(&scsv, p);
 1500|      0|            p += j;
 1501|      0|        }
 1502|     30|    }
 1503|       |
 1504|     30|    return (p - q);
 1505|     30|}
SSL_CTX_new:
 1885|     30|{
 1886|     30|    SSL_CTX *ret = NULL;
 1887|       |
 1888|     30|    if (meth == NULL) {
 1889|      0|        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_NULL_SSL_METHOD_PASSED);
 1890|      0|        return (NULL);
 1891|      0|    }
 1892|       |#ifdef OPENSSL_FIPS
 1893|       |    if (FIPS_mode() && (meth->version < TLS1_VERSION)) {
 1894|       |        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_ONLY_TLS_ALLOWED_IN_FIPS_MODE);
 1895|       |        return NULL;
 1896|       |    }
 1897|       |#endif
 1898|       |
 1899|     30|    if (SSL_get_ex_data_X509_STORE_CTX_idx() < 0) {
 1900|      0|        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_X509_VERIFICATION_SETUP_PROBLEMS);
 1901|      0|        goto err;
 1902|      0|    }
 1903|     30|    ret = (SSL_CTX *)OPENSSL_malloc(sizeof(SSL_CTX));
 1904|     30|    if (ret == NULL)
 1905|      0|        goto err;
 1906|       |
 1907|     30|    memset(ret, 0, sizeof(SSL_CTX));
 1908|       |
 1909|     30|    ret->method = meth;
 1910|       |
 1911|     30|    ret->cert_store = NULL;
 1912|     30|    ret->session_cache_mode = SSL_SESS_CACHE_SERVER;
 1913|     30|    ret->session_cache_size = SSL_SESSION_CACHE_MAX_SIZE_DEFAULT;
 1914|     30|    ret->session_cache_head = NULL;
 1915|     30|    ret->session_cache_tail = NULL;
 1916|       |
 1917|       |    /* We take the system default */
 1918|     30|    ret->session_timeout = meth->get_timeout();
 1919|       |
 1920|     30|    ret->new_session_cb = 0;
 1921|     30|    ret->remove_session_cb = 0;
 1922|     30|    ret->get_session_cb = 0;
 1923|     30|    ret->generate_session_id = 0;
 1924|       |
 1925|     30|    memset((char *)&ret->stats, 0, sizeof(ret->stats));
 1926|       |
 1927|     30|    ret->references = 1;
 1928|     30|    ret->quiet_shutdown = 0;
 1929|       |
 1930|       |/*  ret->cipher=NULL;*/
 1931|       |/*-
 1932|       |    ret->s2->challenge=NULL;
 1933|       |    ret->master_key=NULL;
 1934|       |    ret->key_arg=NULL;
 1935|       |    ret->s2->conn_id=NULL; */
 1936|       |
 1937|     30|    ret->info_callback = NULL;
 1938|       |
 1939|     30|    ret->app_verify_callback = 0;
 1940|     30|    ret->app_verify_arg = NULL;
 1941|       |
 1942|     30|    ret->max_cert_list = SSL_MAX_CERT_LIST_DEFAULT;
 1943|     30|    ret->read_ahead = 0;
 1944|     30|    ret->msg_callback = 0;
 1945|     30|    ret->msg_callback_arg = NULL;
 1946|     30|    ret->verify_mode = SSL_VERIFY_NONE;
 1947|       |#if 0
 1948|       |    ret->verify_depth = -1;     /* Don't impose a limit (but x509_lu.c does) */
 1949|       |#endif
 1950|     30|    ret->sid_ctx_length = 0;
 1951|     30|    ret->default_verify_callback = NULL;
 1952|     30|    if ((ret->cert = ssl_cert_new()) == NULL)
 1953|      0|        goto err;
 1954|       |
 1955|     30|    ret->default_passwd_callback = 0;
 1956|     30|    ret->default_passwd_callback_userdata = NULL;
 1957|     30|    ret->client_cert_cb = 0;
 1958|     30|    ret->app_gen_cookie_cb = 0;
 1959|     30|    ret->app_verify_cookie_cb = 0;
 1960|       |
 1961|     30|    ret->sessions = lh_SSL_SESSION_new();
 1962|     30|    if (ret->sessions == NULL)
 1963|      0|        goto err;
 1964|     30|    ret->cert_store = X509_STORE_new();
 1965|     30|    if (ret->cert_store == NULL)
 1966|      0|        goto err;
 1967|       |
 1968|     30|    ssl_create_cipher_list(ret->method,
 1969|     30|                           &ret->cipher_list, &ret->cipher_list_by_id,
 1970|     30|                           meth->version ==
 1971|     30|                           SSL2_VERSION ? "SSLv2" : SSL_DEFAULT_CIPHER_LIST,
 1972|     30|                           ret->cert);
 1973|     30|    if (ret->cipher_list == NULL || sk_SSL_CIPHER_num(ret->cipher_list) <= 0) {
 1974|      0|        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_LIBRARY_HAS_NO_CIPHERS);
 1975|      0|        goto err2;
 1976|      0|    }
 1977|       |
 1978|     30|    ret->param = X509_VERIFY_PARAM_new();
 1979|     30|    if (!ret->param)
 1980|      0|        goto err;
 1981|       |
 1982|     30|    if ((ret->rsa_md5 = EVP_get_digestbyname("ssl2-md5")) == NULL) {
 1983|      0|        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL2_MD5_ROUTINES);
 1984|      0|        goto err2;
 1985|      0|    }
 1986|     30|    if ((ret->md5 = EVP_get_digestbyname("ssl3-md5")) == NULL) {
 1987|      0|        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL3_MD5_ROUTINES);
 1988|      0|        goto err2;
 1989|      0|    }
 1990|     30|    if ((ret->sha1 = EVP_get_digestbyname("ssl3-sha1")) == NULL) {
 1991|      0|        SSLerr(SSL_F_SSL_CTX_NEW, SSL_R_UNABLE_TO_LOAD_SSL3_SHA1_ROUTINES);
 1992|      0|        goto err2;
 1993|      0|    }
 1994|       |
 1995|     30|    if ((ret->client_CA = sk_X509_NAME_new_null()) == NULL)
 1996|      0|        goto err;
 1997|       |
 1998|     30|    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_CTX, ret, &ret->ex_data);
 1999|       |
 2000|     30|    ret->extra_certs = NULL;
 2001|       |    /* No compression for DTLS */
 2002|     30|    if (!(meth->ssl3_enc->enc_flags & SSL_ENC_FLAG_DTLS))
 2003|     30|        ret->comp_methods = SSL_COMP_get_compression_methods();
 2004|       |
 2005|     30|    ret->max_send_fragment = SSL3_RT_MAX_PLAIN_LENGTH;
 2006|       |
 2007|     30|#ifndef OPENSSL_NO_TLSEXT
 2008|     30|    ret->tlsext_servername_callback = 0;
 2009|     30|    ret->tlsext_servername_arg = NULL;
 2010|       |    /* Setup RFC4507 ticket keys */
 2011|     30|    if ((RAND_bytes(ret->tlsext_tick_key_name, 16) <= 0)
 2012|     30|        || (RAND_bytes(ret->tlsext_tick_hmac_key, 16) <= 0)
 2013|     30|        || (RAND_bytes(ret->tlsext_tick_aes_key, 16) <= 0))
 2014|      0|        ret->options |= SSL_OP_NO_TICKET;
 2015|       |
 2016|     30|    ret->tlsext_status_cb = 0;
 2017|     30|    ret->tlsext_status_arg = NULL;
 2018|       |
 2019|     30|# ifndef OPENSSL_NO_NEXTPROTONEG
 2020|     30|    ret->next_protos_advertised_cb = 0;
 2021|     30|    ret->next_proto_select_cb = 0;
 2022|     30|# endif
 2023|     30|#endif
 2024|     30|#ifndef OPENSSL_NO_PSK
 2025|     30|    ret->psk_identity_hint = NULL;
 2026|     30|    ret->psk_client_callback = NULL;
 2027|     30|    ret->psk_server_callback = NULL;
 2028|     30|#endif
 2029|     30|#ifndef OPENSSL_NO_SRP
 2030|     30|    SSL_CTX_SRP_CTX_init(ret);
 2031|     30|#endif
 2032|     30|#ifndef OPENSSL_NO_BUF_FREELISTS
 2033|     30|    ret->freelist_max_len = SSL_MAX_BUF_FREELIST_LEN_DEFAULT;
 2034|     30|    ret->rbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
 2035|     30|    if (!ret->rbuf_freelist)
 2036|      0|        goto err;
 2037|     30|    ret->rbuf_freelist->chunklen = 0;
 2038|     30|    ret->rbuf_freelist->len = 0;
 2039|     30|    ret->rbuf_freelist->head = NULL;
 2040|     30|    ret->wbuf_freelist = OPENSSL_malloc(sizeof(SSL3_BUF_FREELIST));
 2041|     30|    if (!ret->wbuf_freelist)
 2042|      0|        goto err;
 2043|     30|    ret->wbuf_freelist->chunklen = 0;
 2044|     30|    ret->wbuf_freelist->len = 0;
 2045|     30|    ret->wbuf_freelist->head = NULL;
 2046|     30|#endif
 2047|     30|#ifndef OPENSSL_NO_ENGINE
 2048|     30|    ret->client_cert_engine = NULL;
 2049|       |# ifdef OPENSSL_SSL_CLIENT_ENGINE_AUTO
 2050|       |#  define eng_strx(x)     #x
 2051|       |#  define eng_str(x)      eng_strx(x)
 2052|       |    /* Use specific client engine automatically... ignore errors */
 2053|       |    {
 2054|       |        ENGINE *eng;
 2055|       |        eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
 2056|       |        if (!eng) {
 2057|       |            ERR_clear_error();
 2058|       |            ENGINE_load_builtin_engines();
 2059|       |            eng = ENGINE_by_id(eng_str(OPENSSL_SSL_CLIENT_ENGINE_AUTO));
 2060|       |        }
 2061|       |        if (!eng || !SSL_CTX_set_client_cert_engine(ret, eng))
 2062|       |            ERR_clear_error();
 2063|       |    }
 2064|       |# endif
 2065|     30|#endif
 2066|       |    /*
 2067|       |     * Default is to connect to non-RI servers. When RI is more widely
 2068|       |     * deployed might change this.
 2069|       |     */
 2070|     30|    ret->options |= SSL_OP_LEGACY_SERVER_CONNECT;
 2071|       |
 2072|       |    /*
 2073|       |     * Disable SSLv2 by default, callers that want to enable SSLv2 will have to
 2074|       |     * explicitly clear this option via either of SSL_CTX_clear_options() or
 2075|       |     * SSL_clear_options().
 2076|       |     */
 2077|     30|    ret->options |= SSL_OP_NO_SSLv2;
 2078|       |
 2079|     30|    return (ret);
 2080|      0| err:
 2081|      0|    SSLerr(SSL_F_SSL_CTX_NEW, ERR_R_MALLOC_FAILURE);
 2082|      0| err2:
 2083|      0|    if (ret != NULL)
 2084|      0|        SSL_CTX_free(ret);
 2085|      0|    return (NULL);
 2086|      0|}
SSL_CTX_free:
 2108|     90|{
 2109|     90|    int i;
 2110|       |
 2111|     90|    if (a == NULL)
 2112|      0|        return;
 2113|       |
 2114|     90|    i = CRYPTO_add(&a->references, -1, CRYPTO_LOCK_SSL_CTX);
 2115|       |#ifdef REF_PRINT
 2116|       |    REF_PRINT("SSL_CTX", a);
 2117|       |#endif
 2118|     90|    if (i > 0)
 2119|     60|        return;
 2120|       |#ifdef REF_CHECK
 2121|       |    if (i < 0) {
 2122|       |        fprintf(stderr, "SSL_CTX_free, bad reference count\n");
 2123|       |        abort();                /* ok */
 2124|       |    }
 2125|       |#endif
 2126|       |
 2127|     30|    if (a->param)
 2128|     30|        X509_VERIFY_PARAM_free(a->param);
 2129|       |
 2130|       |    /*
 2131|       |     * Free internal session cache. However: the remove_cb() may reference
 2132|       |     * the ex_data of SSL_CTX, thus the ex_data store can only be removed
 2133|       |     * after the sessions were flushed.
 2134|       |     * As the ex_data handling routines might also touch the session cache,
 2135|       |     * the most secure solution seems to be: empty (flush) the cache, then
 2136|       |     * free ex_data, then finally free the cache.
 2137|       |     * (See ticket [openssl.org #212].)
 2138|       |     */
 2139|     30|    if (a->sessions != NULL)
 2140|     30|        SSL_CTX_flush_sessions(a, 0);
 2141|       |
 2142|     30|    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_CTX, a, &a->ex_data);
 2143|       |
 2144|     30|    if (a->sessions != NULL)
 2145|     30|        lh_SSL_SESSION_free(a->sessions);
 2146|       |
 2147|     30|    if (a->cert_store != NULL)
 2148|     30|        X509_STORE_free(a->cert_store);
 2149|     30|    if (a->cipher_list != NULL)
 2150|     30|        sk_SSL_CIPHER_free(a->cipher_list);
 2151|     30|    if (a->cipher_list_by_id != NULL)
 2152|     30|        sk_SSL_CIPHER_free(a->cipher_list_by_id);
 2153|     30|    if (a->cert != NULL)
 2154|     30|        ssl_cert_free(a->cert);
 2155|     30|    if (a->client_CA != NULL)
 2156|     30|        sk_X509_NAME_pop_free(a->client_CA, X509_NAME_free);
 2157|     30|    if (a->extra_certs != NULL)
 2158|     30|        sk_X509_pop_free(a->extra_certs, X509_free);
 2159|       |#if 0                           /* This should never be done, since it
 2160|       |                                 * removes a global database */
 2161|       |    if (a->comp_methods != NULL)
 2162|       |        sk_SSL_COMP_pop_free(a->comp_methods, SSL_COMP_free);
 2163|       |#else
 2164|     30|    a->comp_methods = NULL;
 2165|     30|#endif
 2166|       |
 2167|     30|#ifndef OPENSSL_NO_SRTP
 2168|     30|    if (a->srtp_profiles)
 2169|     30|        sk_SRTP_PROTECTION_PROFILE_free(a->srtp_profiles);
 2170|     30|#endif
 2171|       |
 2172|     30|#ifndef OPENSSL_NO_PSK
 2173|     30|    if (a->psk_identity_hint)
 2174|      0|        OPENSSL_free(a->psk_identity_hint);
 2175|     30|#endif
 2176|     30|#ifndef OPENSSL_NO_SRP
 2177|     30|    SSL_CTX_SRP_CTX_free(a);
 2178|     30|#endif
 2179|     30|#ifndef OPENSSL_NO_ENGINE
 2180|     30|    if (a->client_cert_engine)
 2181|      0|        ENGINE_finish(a->client_cert_engine);
 2182|     30|#endif
 2183|       |
 2184|     30|#ifndef OPENSSL_NO_BUF_FREELISTS
 2185|     30|    if (a->wbuf_freelist)
 2186|     30|        ssl_buf_freelist_free(a->wbuf_freelist);
 2187|     30|    if (a->rbuf_freelist)
 2188|     30|        ssl_buf_freelist_free(a->rbuf_freelist);
 2189|     30|#endif
 2190|     30|#ifndef OPENSSL_NO_TLSEXT
 2191|     30|# ifndef OPENSSL_NO_EC
 2192|     30|    if (a->tlsext_ecpointformatlist)
 2193|      0|        OPENSSL_free(a->tlsext_ecpointformatlist);
 2194|     30|    if (a->tlsext_ellipticcurvelist)
 2195|      0|        OPENSSL_free(a->tlsext_ellipticcurvelist);
 2196|     30|# endif                         /* OPENSSL_NO_EC */
 2197|     30|    if (a->alpn_client_proto_list != NULL)
 2198|      0|        OPENSSL_free(a->alpn_client_proto_list);
 2199|     30|#endif
 2200|       |
 2201|     30|    OPENSSL_free(a);
 2202|     30|}
SSL_CTX_set_verify:
 2224|     30|{
 2225|     30|    ctx->verify_mode = mode;
 2226|     30|    ctx->default_verify_callback = cb;
 2227|     30|}
SSL_get_error:
 2699|     30|{
 2700|     30|    int reason;
 2701|     30|    unsigned long l;
 2702|     30|    BIO *bio;
 2703|       |
 2704|     30|    if (i > 0)
 2705|      0|        return (SSL_ERROR_NONE);
 2706|       |
 2707|       |    /*
 2708|       |     * Make things return SSL_ERROR_SYSCALL when doing SSL_do_handshake etc,
 2709|       |     * where we do encode the error
 2710|       |     */
 2711|     30|    if ((l = ERR_peek_error()) != 0) {
 2712|      0|        if (ERR_GET_LIB(l) == ERR_LIB_SYS)
 2713|      0|            return (SSL_ERROR_SYSCALL);
 2714|      0|        else
 2715|      0|            return (SSL_ERROR_SSL);
 2716|      0|    }
 2717|       |
 2718|     30|    if ((i < 0) && SSL_want_read(s)) {
 2719|      0|        bio = SSL_get_rbio(s);
 2720|      0|        if (BIO_should_read(bio))
 2721|      0|            return (SSL_ERROR_WANT_READ);
 2722|      0|        else if (BIO_should_write(bio))
 2723|       |            /*
 2724|       |             * This one doesn't make too much sense ... We never try to write
 2725|       |             * to the rbio, and an application program where rbio and wbio
 2726|       |             * are separate couldn't even know what it should wait for.
 2727|       |             * However if we ever set s->rwstate incorrectly (so that we have
 2728|       |             * SSL_want_read(s) instead of SSL_want_write(s)) and rbio and
 2729|       |             * wbio *are* the same, this test works around that bug; so it
 2730|       |             * might be safer to keep it.
 2731|       |             */
 2732|      0|            return (SSL_ERROR_WANT_WRITE);
 2733|      0|        else if (BIO_should_io_special(bio)) {
 2734|      0|            reason = BIO_get_retry_reason(bio);
 2735|      0|            if (reason == BIO_RR_CONNECT)
 2736|      0|                return (SSL_ERROR_WANT_CONNECT);
 2737|      0|            else if (reason == BIO_RR_ACCEPT)
 2738|      0|                return (SSL_ERROR_WANT_ACCEPT);
 2739|      0|            else
 2740|      0|                return (SSL_ERROR_SYSCALL); /* unknown */
 2741|      0|        }
 2742|      0|    }
 2743|       |
 2744|     30|    if ((i < 0) && SSL_want_write(s)) {
 2745|      0|        bio = SSL_get_wbio(s);
 2746|      0|        if (BIO_should_write(bio))
 2747|      0|            return (SSL_ERROR_WANT_WRITE);
 2748|      0|        else if (BIO_should_read(bio))
 2749|       |            /*
 2750|       |             * See above (SSL_want_read(s) with BIO_should_write(bio))
 2751|       |             */
 2752|      0|            return (SSL_ERROR_WANT_READ);
 2753|      0|        else if (BIO_should_io_special(bio)) {
 2754|      0|            reason = BIO_get_retry_reason(bio);
 2755|      0|            if (reason == BIO_RR_CONNECT)
 2756|      0|                return (SSL_ERROR_WANT_CONNECT);
 2757|      0|            else if (reason == BIO_RR_ACCEPT)
 2758|      0|                return (SSL_ERROR_WANT_ACCEPT);
 2759|      0|            else
 2760|      0|                return (SSL_ERROR_SYSCALL);
 2761|      0|        }
 2762|      0|    }
 2763|     30|    if ((i < 0) && SSL_want_x509_lookup(s)) {
 2764|      0|        return (SSL_ERROR_WANT_X509_LOOKUP);
 2765|      0|    }
 2766|       |
 2767|     30|    if (i == 0) {
 2768|     30|        if (s->version == SSL2_VERSION) {
 2769|       |            /* assume it is the socket being closed */
 2770|      0|            return (SSL_ERROR_ZERO_RETURN);
 2771|     30|        } else {
 2772|     30|            if ((s->shutdown & SSL_RECEIVED_SHUTDOWN) &&
 2773|     30|                (s->s3->warn_alert == SSL_AD_CLOSE_NOTIFY))
 2774|      0|                return (SSL_ERROR_ZERO_RETURN);
 2775|     30|        }
 2776|     30|    }
 2777|     30|    return (SSL_ERROR_SYSCALL);
 2778|     30|}
SSL_set_connect_state:
 2814|     60|{
 2815|     60|    s->server = 0;
 2816|     60|    s->shutdown = 0;
 2817|     60|    s->state = SSL_ST_CONNECT | SSL_ST_BEFORE;
 2818|     60|    s->handshake_func = s->method->ssl_connect;
 2819|       |    /* clear the current cipher */
 2820|     60|    ssl_clear_cipher_ctx(s);
 2821|     60|    ssl_clear_hash_ctx(&s->read_hash);
 2822|     60|    ssl_clear_hash_ctx(&s->write_hash);
 2823|     60|}
ssl_clear_cipher_ctx:
 2996|    150|{
 2997|    150|    if (s->enc_read_ctx != NULL) {
 2998|      0|        EVP_CIPHER_CTX_cleanup(s->enc_read_ctx);
 2999|      0|        OPENSSL_free(s->enc_read_ctx);
 3000|      0|        s->enc_read_ctx = NULL;
 3001|      0|    }
 3002|    150|    if (s->enc_write_ctx != NULL) {
 3003|      0|        EVP_CIPHER_CTX_cleanup(s->enc_write_ctx);
 3004|      0|        OPENSSL_free(s->enc_write_ctx);
 3005|      0|        s->enc_write_ctx = NULL;
 3006|      0|    }
 3007|    150|#ifndef OPENSSL_NO_COMP
 3008|    150|    if (s->expand != NULL) {
 3009|      0|        COMP_CTX_free(s->expand);
 3010|      0|        s->expand = NULL;
 3011|      0|    }
 3012|    150|    if (s->compress != NULL) {
 3013|      0|        COMP_CTX_free(s->compress);
 3014|      0|        s->compress = NULL;
 3015|      0|    }
 3016|    150|#endif
 3017|    150|}
ssl_free_wbio_buffer:
 3116|    120|{
 3117|    120|    if (s->bbio == NULL)
 3118|    120|        return;
 3119|       |
 3120|      0|    if (s->bbio == s->wbio) {
 3121|       |        /* remove buffering */
 3122|      0|        s->wbio = BIO_pop(s->wbio);
 3123|       |#ifdef REF_CHECK                /* not the usual REF_CHECK, but this avoids
 3124|       |                                 * adding one more preprocessor symbol */
 3125|       |        assert(s->wbio != NULL);
 3126|       |#endif
 3127|      0|    }
 3128|      0|    BIO_free(s->bbio);
 3129|      0|    s->bbio = NULL;
 3130|      0|}
SSL_CTX_load_verify_locations:
 3243|     30|{
 3244|     30|    return (X509_STORE_load_locations(ctx->cert_store, CAfile, CApath));
 3245|     30|}
SSL_state:
 3265|    210|{
 3266|    210|    return (ssl->state);
 3267|    210|}
SSL_get_ex_new_index:
 3286|      4|{
 3287|      4|    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,
 3288|      4|                                   new_func, dup_func, free_func);
 3289|      4|}
SSL_set_ex_data:
 3292|    360|{
 3293|    360|    return (CRYPTO_set_ex_data(&s->ex_data, idx, arg));
 3294|    360|}
SSL_CTX_get_cert_store:
 3325|     60|{
 3326|     60|    return (ctx->cert_store);
 3327|     60|}
ssl_clear_hash_ctx:
 3556|    300|{
 3557|       |
 3558|    300|    if (*hash)
 3559|      0|        EVP_MD_CTX_destroy(*hash);
 3560|    300|    *hash = NULL;
 3561|    300|}
ssl_lib.c:ssl_buf_freelist_free:
 2097|     60|{
 2098|     60|    SSL3_BUF_FREELIST_ENTRY *ent, *next;
 2099|    120|    for (ent = list->head; ent; ent = next) {
 2100|     60|        next = ent->next;
 2101|     60|        OPENSSL_free(ent);
 2102|     60|    }
 2103|     60|    OPENSSL_free(list);
 2104|     60|}

SSLv23_client_method:
  943|     30|        { \
  944|     30|        static const SSL_METHOD func_name##_data= { \
  945|     30|        TLS1_2_VERSION, \
  946|     30|        tls1_new, \
  947|     30|        tls1_clear, \
  948|     30|        tls1_free, \
  949|     30|        s_accept, \
  950|     30|        s_connect, \
  951|     30|        ssl23_read, \
  952|     30|        ssl23_peek, \
  953|     30|        ssl23_write, \
  954|     30|        ssl_undefined_function, \
  955|     30|        ssl_undefined_function, \
  956|     30|        ssl_ok, \
  957|     30|        ssl3_get_message, \
  958|     30|        ssl3_read_bytes, \
  959|     30|        ssl3_write_bytes, \
  960|     30|        ssl3_dispatch_alert, \
  961|     30|        ssl3_ctrl, \
  962|     30|        ssl3_ctx_ctrl, \
  963|     30|        ssl23_get_cipher_by_char, \
  964|     30|        ssl23_put_cipher_by_char, \
  965|     30|        ssl_undefined_const_function, \
  966|     30|        ssl23_num_ciphers, \
  967|     30|        ssl23_get_cipher, \
  968|     30|        s_get_meth, \
  969|     30|        ssl23_default_timeout, \
  970|     30|        &TLSv1_2_enc_data, \
  971|     30|        ssl_undefined_void_function, \
  972|     30|        ssl3_callback_ctrl, \
  973|     30|        ssl3_ctx_callback_ctrl, \
  974|     30|        }; \
  975|     30|        return &func_name##_data; \
  976|     30|        }

SSL_SESSION_new:
  193|     30|{
  194|     30|    SSL_SESSION *ss;
  195|       |
  196|     30|    ss = (SSL_SESSION *)OPENSSL_malloc(sizeof(SSL_SESSION));
  197|     30|    if (ss == NULL) {
  198|      0|        SSLerr(SSL_F_SSL_SESSION_NEW, ERR_R_MALLOC_FAILURE);
  199|      0|        return (0);
  200|      0|    }
  201|     30|    memset(ss, 0, sizeof(SSL_SESSION));
  202|       |
  203|     30|    ss->verify_result = 1;      /* avoid 0 (= X509_V_OK) just in case */
  204|     30|    ss->references = 1;
  205|     30|    ss->timeout = 60 * 5 + 4;   /* 5 minute timeout by default */
  206|     30|    ss->time = (unsigned long)time(NULL);
  207|     30|    ss->prev = NULL;
  208|     30|    ss->next = NULL;
  209|     30|    ss->compress_meth = 0;
  210|     30|#ifndef OPENSSL_NO_TLSEXT
  211|     30|    ss->tlsext_hostname = NULL;
  212|     30|# ifndef OPENSSL_NO_EC
  213|     30|    ss->tlsext_ecpointformatlist_length = 0;
  214|     30|    ss->tlsext_ecpointformatlist = NULL;
  215|     30|    ss->tlsext_ellipticcurvelist_length = 0;
  216|     30|    ss->tlsext_ellipticcurvelist = NULL;
  217|     30|# endif
  218|     30|#endif
  219|     30|    CRYPTO_new_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);
  220|     30|#ifndef OPENSSL_NO_PSK
  221|     30|    ss->psk_identity_hint = NULL;
  222|     30|    ss->psk_identity = NULL;
  223|     30|#endif
  224|     30|#ifndef OPENSSL_NO_SRP
  225|     30|    ss->srp_username = NULL;
  226|     30|#endif
  227|     30|    return (ss);
  228|     30|}
ssl_get_new_session:
  406|     30|{
  407|       |    /* This gets used by clients and servers. */
  408|       |
  409|     30|    unsigned int tmp;
  410|     30|    SSL_SESSION *ss = NULL;
  411|     30|    GEN_SESSION_CB cb = def_generate_session_id;
  412|       |
  413|     30|    if ((ss = SSL_SESSION_new()) == NULL)
  414|      0|        return (0);
  415|       |
  416|       |    /* If the context has a default timeout, use it */
  417|     30|    if (s->session_ctx->session_timeout == 0)
  418|      0|        ss->timeout = SSL_get_default_timeout(s);
  419|     30|    else
  420|     30|        ss->timeout = s->session_ctx->session_timeout;
  421|       |
  422|     30|    if (s->session != NULL) {
  423|      0|        SSL_SESSION_free(s->session);
  424|      0|        s->session = NULL;
  425|      0|    }
  426|       |
  427|     30|    if (session) {
  428|      0|        if (s->version == SSL2_VERSION) {
  429|      0|            ss->ssl_version = SSL2_VERSION;
  430|      0|            ss->session_id_length = SSL2_SSL_SESSION_ID_LENGTH;
  431|      0|        } else if (s->version == SSL3_VERSION) {
  432|      0|            ss->ssl_version = SSL3_VERSION;
  433|      0|            ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
  434|      0|        } else if (s->version == TLS1_VERSION) {
  435|      0|            ss->ssl_version = TLS1_VERSION;
  436|      0|            ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
  437|      0|        } else if (s->version == TLS1_1_VERSION) {
  438|      0|            ss->ssl_version = TLS1_1_VERSION;
  439|      0|            ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
  440|      0|        } else if (s->version == TLS1_2_VERSION) {
  441|      0|            ss->ssl_version = TLS1_2_VERSION;
  442|      0|            ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
  443|      0|        } else if (s->version == DTLS1_BAD_VER) {
  444|      0|            ss->ssl_version = DTLS1_BAD_VER;
  445|      0|            ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
  446|      0|        } else if (s->version == DTLS1_VERSION) {
  447|      0|            ss->ssl_version = DTLS1_VERSION;
  448|      0|            ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
  449|      0|        } else if (s->version == DTLS1_2_VERSION) {
  450|      0|            ss->ssl_version = DTLS1_2_VERSION;
  451|      0|            ss->session_id_length = SSL3_SSL_SESSION_ID_LENGTH;
  452|      0|        } else {
  453|      0|            SSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_UNSUPPORTED_SSL_VERSION);
  454|      0|            SSL_SESSION_free(ss);
  455|      0|            return (0);
  456|      0|        }
  457|      0|#ifndef OPENSSL_NO_TLSEXT
  458|       |        /*-
  459|       |         * If RFC5077 ticket, use empty session ID (as server).
  460|       |         * Note that:
  461|       |         * (a) ssl_get_prev_session() does lookahead into the
  462|       |         *     ClientHello extensions to find the session ticket.
  463|       |         *     When ssl_get_prev_session() fails, s3_srvr.c calls
  464|       |         *     ssl_get_new_session() in ssl3_get_client_hello().
  465|       |         *     At that point, it has not yet parsed the extensions,
  466|       |         *     however, because of the lookahead, it already knows
  467|       |         *     whether a ticket is expected or not.
  468|       |         *
  469|       |         * (b) s3_clnt.c calls ssl_get_new_session() before parsing
  470|       |         *     ServerHello extensions, and before recording the session
  471|       |         *     ID received from the server, so this block is a noop.
  472|       |         */
  473|      0|        if (s->tlsext_ticket_expected) {
  474|      0|            ss->session_id_length = 0;
  475|      0|            goto sess_id_done;
  476|      0|        }
  477|      0|#endif
  478|       |        /* Choose which callback will set the session ID */
  479|      0|        CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
  480|      0|        if (s->generate_session_id)
  481|      0|            cb = s->generate_session_id;
  482|      0|        else if (s->session_ctx->generate_session_id)
  483|      0|            cb = s->session_ctx->generate_session_id;
  484|      0|        CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
  485|       |        /* Choose a session ID */
  486|      0|        tmp = ss->session_id_length;
  487|      0|        if (!cb(s, ss->session_id, &tmp)) {
  488|       |            /* The callback failed */
  489|      0|            SSLerr(SSL_F_SSL_GET_NEW_SESSION,
  490|      0|                   SSL_R_SSL_SESSION_ID_CALLBACK_FAILED);
  491|      0|            SSL_SESSION_free(ss);
  492|      0|            return (0);
  493|      0|        }
  494|       |        /*
  495|       |         * Don't allow the callback to set the session length to zero. nor
  496|       |         * set it higher than it was.
  497|       |         */
  498|      0|        if (!tmp || (tmp > ss->session_id_length)) {
  499|       |            /* The callback set an illegal length */
  500|      0|            SSLerr(SSL_F_SSL_GET_NEW_SESSION,
  501|      0|                   SSL_R_SSL_SESSION_ID_HAS_BAD_LENGTH);
  502|      0|            SSL_SESSION_free(ss);
  503|      0|            return (0);
  504|      0|        }
  505|       |        /* If the session length was shrunk and we're SSLv2, pad it */
  506|      0|        if ((tmp < ss->session_id_length) && (s->version == SSL2_VERSION))
  507|      0|            memset(ss->session_id + tmp, 0, ss->session_id_length - tmp);
  508|      0|        else
  509|      0|            ss->session_id_length = tmp;
  510|       |        /* Finally, check for a conflict */
  511|      0|        if (SSL_has_matching_session_id(s, ss->session_id,
  512|      0|                                        ss->session_id_length)) {
  513|      0|            SSLerr(SSL_F_SSL_GET_NEW_SESSION, SSL_R_SSL_SESSION_ID_CONFLICT);
  514|      0|            SSL_SESSION_free(ss);
  515|      0|            return (0);
  516|      0|        }
  517|      0|#ifndef OPENSSL_NO_TLSEXT
  518|      0| sess_id_done:
  519|      0|        if (s->tlsext_hostname) {
  520|      0|            ss->tlsext_hostname = BUF_strdup(s->tlsext_hostname);
  521|      0|            if (ss->tlsext_hostname == NULL) {
  522|      0|                SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);
  523|      0|                SSL_SESSION_free(ss);
  524|      0|                return 0;
  525|      0|            }
  526|      0|        }
  527|      0|#endif
  528|     30|    } else {
  529|     30|        ss->session_id_length = 0;
  530|     30|    }
  531|       |
  532|     30|    if (s->sid_ctx_length > sizeof ss->sid_ctx) {
  533|      0|        SSLerr(SSL_F_SSL_GET_NEW_SESSION, ERR_R_INTERNAL_ERROR);
  534|      0|        SSL_SESSION_free(ss);
  535|      0|        return 0;
  536|      0|    }
  537|     30|    memcpy(ss->sid_ctx, s->sid_ctx, s->sid_ctx_length);
  538|     30|    ss->sid_ctx_length = s->sid_ctx_length;
  539|     30|    s->session = ss;
  540|     30|    ss->ssl_version = s->version;
  541|     30|    ss->verify_result = X509_V_OK;
  542|       |
  543|     30|    return (1);
  544|     30|}
SSL_SESSION_free:
  852|     30|{
  853|     30|    int i;
  854|       |
  855|     30|    if (ss == NULL)
  856|      0|        return;
  857|       |
  858|     30|    i = CRYPTO_add(&ss->references, -1, CRYPTO_LOCK_SSL_SESSION);
  859|       |#ifdef REF_PRINT
  860|       |    REF_PRINT("SSL_SESSION", ss);
  861|       |#endif
  862|     30|    if (i > 0)
  863|      0|        return;
  864|       |#ifdef REF_CHECK
  865|       |    if (i < 0) {
  866|       |        fprintf(stderr, "SSL_SESSION_free, bad reference count\n");
  867|       |        abort();                /* ok */
  868|       |    }
  869|       |#endif
  870|       |
  871|     30|    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_SSL_SESSION, ss, &ss->ex_data);
  872|       |
  873|     30|    OPENSSL_cleanse(ss->key_arg, sizeof ss->key_arg);
  874|     30|    OPENSSL_cleanse(ss->master_key, sizeof ss->master_key);
  875|     30|    OPENSSL_cleanse(ss->session_id, sizeof ss->session_id);
  876|     30|    if (ss->sess_cert != NULL)
  877|      0|        ssl_sess_cert_free(ss->sess_cert);
  878|     30|    if (ss->peer != NULL)
  879|      0|        X509_free(ss->peer);
  880|     30|    if (ss->ciphers != NULL)
  881|     30|        sk_SSL_CIPHER_free(ss->ciphers);
  882|     30|#ifndef OPENSSL_NO_TLSEXT
  883|     30|    if (ss->tlsext_hostname != NULL)
  884|      0|        OPENSSL_free(ss->tlsext_hostname);
  885|     30|    if (ss->tlsext_tick != NULL)
  886|      0|        OPENSSL_free(ss->tlsext_tick);
  887|     30|# ifndef OPENSSL_NO_EC
  888|     30|    ss->tlsext_ecpointformatlist_length = 0;
  889|     30|    if (ss->tlsext_ecpointformatlist != NULL)
  890|      0|        OPENSSL_free(ss->tlsext_ecpointformatlist);
  891|     30|    ss->tlsext_ellipticcurvelist_length = 0;
  892|     30|    if (ss->tlsext_ellipticcurvelist != NULL)
  893|      0|        OPENSSL_free(ss->tlsext_ellipticcurvelist);
  894|     30|# endif                         /* OPENSSL_NO_EC */
  895|     30|#endif
  896|     30|#ifndef OPENSSL_NO_PSK
  897|     30|    if (ss->psk_identity_hint != NULL)
  898|      0|        OPENSSL_free(ss->psk_identity_hint);
  899|     30|    if (ss->psk_identity != NULL)
  900|      0|        OPENSSL_free(ss->psk_identity);
  901|     30|#endif
  902|     30|#ifndef OPENSSL_NO_SRP
  903|     30|    if (ss->srp_username != NULL)
  904|      0|        OPENSSL_free(ss->srp_username);
  905|     30|#endif
  906|     30|    OPENSSL_cleanse(ss, sizeof(*ss));
  907|     30|    OPENSSL_free(ss);
  908|     30|}
SSL_CTX_flush_sessions:
 1119|     30|{
 1120|     30|    unsigned long i;
 1121|     30|    TIMEOUT_PARAM tp;
 1122|       |
 1123|     30|    tp.ctx = s;
 1124|     30|    tp.cache = s->sessions;
 1125|     30|    if (tp.cache == NULL)
 1126|      0|        return;
 1127|     30|    tp.time = t;
 1128|     30|    CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
 1129|     30|    i = CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load;
 1130|     30|    CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load = 0;
 1131|     30|    lh_SSL_SESSION_doall_arg(tp.cache, LHASH_DOALL_ARG_FN(timeout),
 1132|     30|                             TIMEOUT_PARAM, &tp);
 1133|     30|    CHECKED_LHASH_OF(SSL_SESSION, tp.cache)->down_load = i;
 1134|     30|    CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
 1135|     30|}
ssl_clear_bad_session:
 1138|     90|{
 1139|     90|    if ((s->session != NULL) &&
 1140|     90|        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
 1141|     90|        !(SSL_in_init(s) || SSL_in_before(s))) {
 1142|      0|        SSL_CTX_remove_session(s->session_ctx, s->session);
 1143|      0|        return (1);
 1144|      0|    } else
 1145|     90|        return (0);
 1146|     90|}
SSL_CTX_sess_set_new_cb:
 1199|     30|{
 1200|     30|    ctx->new_session_cb = cb;
 1201|     30|}

custom_ext_init:
   79|     30|{
   80|     30|    size_t i;
   81|     30|    custom_ext_method *meth = exts->meths;
   82|     30|    for (i = 0; i < exts->meths_count; i++, meth++)
   83|      0|        meth->ext_flags = 0;
   84|     30|}
custom_ext_add:
  127|     30|{
  128|     30|    custom_ext_methods *exts = server ? &s->cert->srv_ext : &s->cert->cli_ext;
  129|     30|    custom_ext_method *meth;
  130|     30|    unsigned char *ret = *pret;
  131|     30|    size_t i;
  132|       |
  133|     30|    for (i = 0; i < exts->meths_count; i++) {
  134|      0|        const unsigned char *out = NULL;
  135|      0|        size_t outlen = 0;
  136|      0|        meth = exts->meths + i;
  137|       |
  138|      0|        if (server) {
  139|       |            /*
  140|       |             * For ServerHello only send extensions present in ClientHello.
  141|       |             */
  142|      0|            if (!(meth->ext_flags & SSL_EXT_FLAG_RECEIVED))
  143|      0|                continue;
  144|       |            /* If callback absent for server skip it */
  145|      0|            if (!meth->add_cb)
  146|      0|                continue;
  147|      0|        }
  148|      0|        if (meth->add_cb) {
  149|      0|            int cb_retval = 0;
  150|      0|            cb_retval = meth->add_cb(s, meth->ext_type,
  151|      0|                                     &out, &outlen, al, meth->add_arg);
  152|      0|            if (cb_retval < 0)
  153|      0|                return 0;       /* error */
  154|      0|            if (cb_retval == 0)
  155|      0|                continue;       /* skip this extension */
  156|      0|        }
  157|      0|        if (4 > limit - ret || outlen > (size_t)(limit - ret - 4))
  158|      0|            return 0;
  159|      0|        s2n(meth->ext_type, ret);
  160|      0|        s2n(outlen, ret);
  161|      0|        if (outlen) {
  162|      0|            memcpy(ret, out, outlen);
  163|      0|            ret += outlen;
  164|      0|        }
  165|       |        /*
  166|       |         * We can't send duplicates: code logic should prevent this.
  167|       |         */
  168|      0|        OPENSSL_assert(!(meth->ext_flags & SSL_EXT_FLAG_SENT));
  169|       |        /*
  170|       |         * Indicate extension has been sent: this is both a sanity check to
  171|       |         * ensure we don't send duplicate extensions and indicates that it is
  172|       |         * not an error if the extension is present in ServerHello.
  173|       |         */
  174|      0|        meth->ext_flags |= SSL_EXT_FLAG_SENT;
  175|      0|        if (meth->free_cb)
  176|      0|            meth->free_cb(s, meth->ext_type, out, meth->add_arg);
  177|      0|    }
  178|     30|    *pret = ret;
  179|     30|    return 1;
  180|     30|}
custom_exts_copy:
  203|     60|{
  204|     60|    if (src->meths_count) {
  205|      0|        dst->meths =
  206|      0|            BUF_memdup(src->meths,
  207|      0|                       sizeof(custom_ext_method) * src->meths_count);
  208|      0|        if (dst->meths == NULL)
  209|      0|            return 0;
  210|      0|        dst->meths_count = src->meths_count;
  211|      0|    }
  212|     60|    return 1;
  213|     60|}
custom_exts_free:
  216|    120|{
  217|    120|    if (exts->meths)
  218|      0|        OPENSSL_free(exts->meths);
  219|    120|}

tls1_new:
  206|     30|{
  207|     30|    if (!ssl3_new(s))
  208|      0|        return (0);
  209|     30|    s->method->ssl_clear(s);
  210|     30|    return (1);
  211|     30|}
tls1_free:
  214|     30|{
  215|     30|#ifndef OPENSSL_NO_TLSEXT
  216|     30|    if (s->tlsext_session_ticket) {
  217|      0|        OPENSSL_free(s->tlsext_session_ticket);
  218|      0|    }
  219|     30|#endif                          /* OPENSSL_NO_TLSEXT */
  220|     30|    ssl3_free(s);
  221|     30|}
tls1_clear:
  224|    120|{
  225|    120|    ssl3_clear(s);
  226|    120|    s->version = s->method->version;
  227|    120|}
tls12_get_psigalgs:
 1039|     60|{
 1040|       |    /*
 1041|       |     * If Suite B mode use Suite B sigalgs only, ignore any other
 1042|       |     * preferences.
 1043|       |     */
 1044|     60|# ifndef OPENSSL_NO_EC
 1045|     60|    switch (tls1_suiteb(s)) {
 1046|      0|    case SSL_CERT_FLAG_SUITEB_128_LOS:
 1047|      0|        *psigs = suiteb_sigalgs;
 1048|      0|        return sizeof(suiteb_sigalgs);
 1049|       |
 1050|      0|    case SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:
 1051|      0|        *psigs = suiteb_sigalgs;
 1052|      0|        return 2;
 1053|       |
 1054|      0|    case SSL_CERT_FLAG_SUITEB_192_LOS:
 1055|      0|        *psigs = suiteb_sigalgs + 2;
 1056|      0|        return 2;
 1057|     60|    }
 1058|     60|# endif
 1059|       |    /* If server use client authentication sigalgs if not NULL */
 1060|     60|    if (s->server == sent && s->cert->client_sigalgs) {
 1061|      0|        *psigs = s->cert->client_sigalgs;
 1062|      0|        return s->cert->client_sigalgslen;
 1063|     60|    } else if (s->cert->conf_sigalgs) {
 1064|      0|        *psigs = s->cert->conf_sigalgs;
 1065|      0|        return s->cert->conf_sigalgslen;
 1066|     60|    } else {
 1067|     60|        *psigs = tls12_sigalgs;
 1068|     60|        return sizeof(tls12_sigalgs);
 1069|     60|    }
 1070|     60|}
ssl_set_client_disabled:
 1156|     30|{
 1157|     30|    CERT *c = s->cert;
 1158|     30|    const unsigned char *sigalgs;
 1159|     30|    size_t i, sigalgslen;
 1160|     30|    int have_rsa = 0, have_dsa = 0, have_ecdsa = 0;
 1161|     30|    c->mask_a = 0;
 1162|     30|    c->mask_k = 0;
 1163|       |    /* Don't allow TLS 1.2 only ciphers if we don't suppport them */
 1164|     30|    if (!SSL_CLIENT_USE_TLS1_2_CIPHERS(s))
 1165|      0|        c->mask_ssl = SSL_TLSV1_2;
 1166|     30|    else
 1167|     30|        c->mask_ssl = 0;
 1168|       |    /*
 1169|       |     * Now go through all signature algorithms seeing if we support any for
 1170|       |     * RSA, DSA, ECDSA. Do this for all versions not just TLS 1.2.
 1171|       |     */
 1172|     30|    sigalgslen = tls12_get_psigalgs(s, 1, &sigalgs);
 1173|    480|    for (i = 0; i < sigalgslen; i += 2, sigalgs += 2) {
 1174|    450|        switch (sigalgs[1]) {
 1175|      0|# ifndef OPENSSL_NO_RSA
 1176|    150|        case TLSEXT_signature_rsa:
 1177|    150|            have_rsa = 1;
 1178|    150|            break;
 1179|      0|# endif
 1180|      0|# ifndef OPENSSL_NO_DSA
 1181|    150|        case TLSEXT_signature_dsa:
 1182|    150|            have_dsa = 1;
 1183|    150|            break;
 1184|      0|# endif
 1185|      0|# ifndef OPENSSL_NO_ECDSA
 1186|    150|        case TLSEXT_signature_ecdsa:
 1187|    150|            have_ecdsa = 1;
 1188|    150|            break;
 1189|    450|# endif
 1190|    450|        }
 1191|    450|    }
 1192|       |    /*
 1193|       |     * Disable auth and static DH if we don't include any appropriate
 1194|       |     * signature algorithms.
 1195|       |     */
 1196|     30|    if (!have_rsa) {
 1197|      0|        c->mask_a |= SSL_aRSA;
 1198|      0|        c->mask_k |= SSL_kDHr | SSL_kECDHr;
 1199|      0|    }
 1200|     30|    if (!have_dsa) {
 1201|      0|        c->mask_a |= SSL_aDSS;
 1202|      0|        c->mask_k |= SSL_kDHd;
 1203|      0|    }
 1204|     30|    if (!have_ecdsa) {
 1205|      0|        c->mask_a |= SSL_aECDSA;
 1206|      0|        c->mask_k |= SSL_kECDHe;
 1207|      0|    }
 1208|       |# ifndef OPENSSL_NO_KRB5
 1209|       |    if (!kssl_tgt_is_available(s->kssl_ctx)) {
 1210|       |        c->mask_a |= SSL_aKRB5;
 1211|       |        c->mask_k |= SSL_kKRB5;
 1212|       |    }
 1213|       |# endif
 1214|     30|# ifndef OPENSSL_NO_PSK
 1215|       |    /* with PSK there must be client callback set */
 1216|     30|    if (!s->psk_client_callback) {
 1217|     30|        c->mask_a |= SSL_aPSK;
 1218|     30|        c->mask_k |= SSL_kPSK;
 1219|     30|    }
 1220|     30|# endif                         /* OPENSSL_NO_PSK */
 1221|     30|# ifndef OPENSSL_NO_SRP
 1222|     30|    if (!(s->srp_ctx.srp_Mask & SSL_kSRP)) {
 1223|     30|        c->mask_a |= SSL_aSRP;
 1224|     30|        c->mask_k |= SSL_kSRP;
 1225|     30|    }
 1226|     30|# endif
 1227|     30|    c->valid = 1;
 1228|     30|}
ssl_add_clienthello_tlsext:
 1232|     30|{
 1233|     30|    int extdatalen = 0;
 1234|     30|    unsigned char *orig = buf;
 1235|     30|    unsigned char *ret = buf;
 1236|     30|# ifndef OPENSSL_NO_EC
 1237|       |    /* See if we support any ECC ciphersuites */
 1238|     30|    int using_ecc = 0;
 1239|     30|    if (s->version >= TLS1_VERSION || SSL_IS_DTLS(s)) {
 1240|     30|        int i;
 1241|     30|        unsigned long alg_k, alg_a;
 1242|     30|        STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);
 1243|       |
 1244|     30|        for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {
 1245|     30|            SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);
 1246|       |
 1247|     30|            alg_k = c->algorithm_mkey;
 1248|     30|            alg_a = c->algorithm_auth;
 1249|     30|            if ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)
 1250|     30|                 || (alg_a & SSL_aECDSA))) {
 1251|     30|                using_ecc = 1;
 1252|     30|                break;
 1253|     30|            }
 1254|     30|        }
 1255|     30|    }
 1256|     30|# endif
 1257|       |
 1258|       |    /* don't add extensions for SSLv3 unless doing secure renegotiation */
 1259|     30|    if (s->client_version == SSL3_VERSION && !s->s3->send_connection_binding)
 1260|      0|        return orig;
 1261|       |
 1262|     30|    ret += 2;
 1263|       |
 1264|     30|    if (ret >= limit)
 1265|      0|        return NULL;            /* this really never occurs, but ... */
 1266|       |
 1267|     30|    if (s->tlsext_hostname != NULL) {
 1268|       |        /* Add TLS extension servername to the Client Hello message */
 1269|     26|        size_t size_str;
 1270|       |
 1271|       |        /*-
 1272|       |         * check for enough space.
 1273|       |         * 4 for the servername type and entension length
 1274|       |         * 2 for servernamelist length
 1275|       |         * 1 for the hostname type
 1276|       |         * 2 for hostname length
 1277|       |         * + hostname length
 1278|       |         */
 1279|     26|        size_str = strlen(s->tlsext_hostname);
 1280|     26|        if (CHECKLEN(ret, 9 + size_str, limit))
 1281|      0|            return NULL;
 1282|       |
 1283|       |        /* extension type and length */
 1284|     26|        s2n(TLSEXT_TYPE_server_name, ret);
 1285|     26|        s2n(size_str + 5, ret);
 1286|       |
 1287|       |        /* length of servername list */
 1288|     26|        s2n(size_str + 3, ret);
 1289|       |
 1290|       |        /* hostname type, length and hostname */
 1291|     26|        *(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;
 1292|     26|        s2n(size_str, ret);
 1293|     26|        memcpy(ret, s->tlsext_hostname, size_str);
 1294|     26|        ret += size_str;
 1295|     26|    }
 1296|       |
 1297|       |    /* Add RI if renegotiating */
 1298|     30|    if (s->renegotiate) {
 1299|      0|        int el;
 1300|       |
 1301|      0|        if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {
 1302|      0|            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
 1303|      0|            return NULL;
 1304|      0|        }
 1305|       |
 1306|      0|        if ((limit - ret - 4 - el) < 0)
 1307|      0|            return NULL;
 1308|       |
 1309|      0|        s2n(TLSEXT_TYPE_renegotiate, ret);
 1310|      0|        s2n(el, ret);
 1311|       |
 1312|      0|        if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {
 1313|      0|            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
 1314|      0|            return NULL;
 1315|      0|        }
 1316|       |
 1317|      0|        ret += el;
 1318|      0|    }
 1319|     30|# ifndef OPENSSL_NO_SRP
 1320|       |    /* Add SRP username if there is one */
 1321|     30|    if (s->srp_ctx.login != NULL) { /* Add TLS extension SRP username to the
 1322|       |                                     * Client Hello message */
 1323|       |
 1324|      0|        size_t login_len = strlen(s->srp_ctx.login);
 1325|      0|        if (login_len > 255 || login_len == 0) {
 1326|      0|            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
 1327|      0|            return NULL;
 1328|      0|        }
 1329|       |
 1330|       |        /*-
 1331|       |         * check for enough space.
 1332|       |         * 4 for the srp type type and entension length
 1333|       |         * 1 for the srp user identity
 1334|       |         * + srp user identity length
 1335|       |         */
 1336|      0|        if (CHECKLEN(ret, 5 + login_len, limit))
 1337|      0|            return NULL;
 1338|       |
 1339|       |        /* fill in the extension */
 1340|      0|        s2n(TLSEXT_TYPE_srp, ret);
 1341|      0|        s2n(login_len + 1, ret);
 1342|      0|        (*ret++) = (unsigned char)login_len;
 1343|      0|        memcpy(ret, s->srp_ctx.login, login_len);
 1344|      0|        ret += login_len;
 1345|      0|    }
 1346|     30|# endif
 1347|       |
 1348|     30|# ifndef OPENSSL_NO_EC
 1349|     30|    if (using_ecc) {
 1350|       |        /*
 1351|       |         * Add TLS extension ECPointFormats to the ClientHello message
 1352|       |         */
 1353|     30|        const unsigned char *pcurves, *pformats;
 1354|     30|        size_t num_curves, num_formats, curves_list_len;
 1355|       |
 1356|     30|        tls1_get_formatlist(s, &pformats, &num_formats);
 1357|       |
 1358|     30|        if (num_formats > 255) {
 1359|      0|            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
 1360|      0|            return NULL;
 1361|      0|        }
 1362|       |        /*-
 1363|       |         * check for enough space.
 1364|       |         * 4 bytes for the ec point formats type and extension length
 1365|       |         * 1 byte for the length of the formats
 1366|       |         * + formats length
 1367|       |         */
 1368|     30|        if (CHECKLEN(ret, 5 + num_formats, limit))
 1369|      0|            return NULL;
 1370|       |
 1371|     30|        s2n(TLSEXT_TYPE_ec_point_formats, ret);
 1372|       |        /* The point format list has 1-byte length. */
 1373|     30|        s2n(num_formats + 1, ret);
 1374|     30|        *(ret++) = (unsigned char)num_formats;
 1375|     30|        memcpy(ret, pformats, num_formats);
 1376|     30|        ret += num_formats;
 1377|       |
 1378|       |        /*
 1379|       |         * Add TLS extension EllipticCurves to the ClientHello message
 1380|       |         */
 1381|     30|        pcurves = s->tlsext_ellipticcurvelist;
 1382|     30|        if (!tls1_get_curvelist(s, 0, &pcurves, &num_curves))
 1383|      0|            return NULL;
 1384|       |
 1385|     30|        if (num_curves > 65532 / 2) {
 1386|      0|            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
 1387|      0|            return NULL;
 1388|      0|        }
 1389|     30|        curves_list_len = 2 * num_curves;
 1390|       |        /*-
 1391|       |         * check for enough space.
 1392|       |         * 4 bytes for the ec curves type and extension length
 1393|       |         * 2 bytes for the curve list length
 1394|       |         * + curve list length
 1395|       |         */
 1396|     30|        if (CHECKLEN(ret, 6 + curves_list_len, limit))
 1397|      0|            return NULL;
 1398|       |
 1399|     30|        s2n(TLSEXT_TYPE_elliptic_curves, ret);
 1400|     30|        s2n(curves_list_len + 2, ret);
 1401|     30|        s2n(curves_list_len, ret);
 1402|     30|        memcpy(ret, pcurves, curves_list_len);
 1403|     30|        ret += curves_list_len;
 1404|     30|    }
 1405|     30|# endif                         /* OPENSSL_NO_EC */
 1406|       |
 1407|     30|    if (!(SSL_get_options(s) & SSL_OP_NO_TICKET)) {
 1408|      0|        size_t ticklen;
 1409|      0|        if (!s->new_session && s->session && s->session->tlsext_tick)
 1410|      0|            ticklen = s->session->tlsext_ticklen;
 1411|      0|        else if (s->session && s->tlsext_session_ticket &&
 1412|      0|                 s->tlsext_session_ticket->data) {
 1413|      0|            ticklen = s->tlsext_session_ticket->length;
 1414|      0|            s->session->tlsext_tick = OPENSSL_malloc(ticklen);
 1415|      0|            if (!s->session->tlsext_tick)
 1416|      0|                return NULL;
 1417|      0|            memcpy(s->session->tlsext_tick,
 1418|      0|                   s->tlsext_session_ticket->data, ticklen);
 1419|      0|            s->session->tlsext_ticklen = ticklen;
 1420|      0|        } else
 1421|      0|            ticklen = 0;
 1422|      0|        if (ticklen == 0 && s->tlsext_session_ticket &&
 1423|      0|            s->tlsext_session_ticket->data == NULL)
 1424|      0|            goto skip_ext;
 1425|       |        /*
 1426|       |         * Check for enough room 2 for extension type, 2 for len rest for
 1427|       |         * ticket
 1428|       |         */
 1429|      0|        if (CHECKLEN(ret, 4 + ticklen, limit))
 1430|      0|            return NULL;
 1431|      0|        s2n(TLSEXT_TYPE_session_ticket, ret);
 1432|      0|        s2n(ticklen, ret);
 1433|      0|        if (ticklen > 0) {
 1434|      0|            memcpy(ret, s->session->tlsext_tick, ticklen);
 1435|      0|            ret += ticklen;
 1436|      0|        }
 1437|      0|    }
 1438|     30| skip_ext:
 1439|       |
 1440|     30|    if (SSL_CLIENT_USE_SIGALGS(s)) {
 1441|     30|        size_t salglen;
 1442|     30|        const unsigned char *salg;
 1443|     30|        salglen = tls12_get_psigalgs(s, 1, &salg);
 1444|       |
 1445|       |        /*-
 1446|       |         * check for enough space.
 1447|       |         * 4 bytes for the sigalgs type and extension length
 1448|       |         * 2 bytes for the sigalg list length
 1449|       |         * + sigalg list length
 1450|       |         */
 1451|     30|        if (CHECKLEN(ret, salglen + 6, limit))
 1452|      0|            return NULL;
 1453|     30|        s2n(TLSEXT_TYPE_signature_algorithms, ret);
 1454|     30|        s2n(salglen + 2, ret);
 1455|     30|        s2n(salglen, ret);
 1456|     30|        memcpy(ret, salg, salglen);
 1457|     30|        ret += salglen;
 1458|     30|    }
 1459|       |# ifdef TLSEXT_TYPE_opaque_prf_input
 1460|       |    if (s->s3->client_opaque_prf_input != NULL) {
 1461|       |        size_t col = s->s3->client_opaque_prf_input_len;
 1462|       |
 1463|       |        if ((long)(limit - ret - 6 - col < 0))
 1464|       |            return NULL;
 1465|       |        if (col > 0xFFFD)       /* can't happen */
 1466|       |            return NULL;
 1467|       |
 1468|       |        s2n(TLSEXT_TYPE_opaque_prf_input, ret);
 1469|       |        s2n(col + 2, ret);
 1470|       |        s2n(col, ret);
 1471|       |        memcpy(ret, s->s3->client_opaque_prf_input, col);
 1472|       |        ret += col;
 1473|       |    }
 1474|       |# endif
 1475|       |
 1476|     30|    if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {
 1477|      0|        int i;
 1478|      0|        size_t extlen, idlen;
 1479|      0|        int lentmp;
 1480|      0|        OCSP_RESPID *id;
 1481|       |
 1482|      0|        idlen = 0;
 1483|      0|        for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {
 1484|      0|            id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);
 1485|      0|            lentmp = i2d_OCSP_RESPID(id, NULL);
 1486|      0|            if (lentmp <= 0)
 1487|      0|                return NULL;
 1488|      0|            idlen += (size_t)lentmp + 2;
 1489|      0|        }
 1490|       |
 1491|      0|        if (s->tlsext_ocsp_exts) {
 1492|      0|            lentmp = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);
 1493|      0|            if (lentmp < 0)
 1494|      0|                return NULL;
 1495|      0|            extlen = (size_t)lentmp;
 1496|      0|        } else
 1497|      0|            extlen = 0;
 1498|       |
 1499|      0|        if (extlen + idlen > 0xFFF0)
 1500|      0|            return NULL;
 1501|       |        /*
 1502|       |         * 2 bytes for status request type
 1503|       |         * 2 bytes for status request len
 1504|       |         * 1 byte for OCSP request type
 1505|       |         * 2 bytes for length of ids
 1506|       |         * 2 bytes for length of extensions
 1507|       |         * + length of ids
 1508|       |         * + length of extensions
 1509|       |         */
 1510|      0|        if (CHECKLEN(ret, 9 + idlen + extlen, limit))
 1511|      0|            return NULL;
 1512|       |
 1513|      0|        s2n(TLSEXT_TYPE_status_request, ret);
 1514|      0|        s2n(extlen + idlen + 5, ret);
 1515|      0|        *(ret++) = TLSEXT_STATUSTYPE_ocsp;
 1516|      0|        s2n(idlen, ret);
 1517|      0|        for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {
 1518|       |            /* save position of id len */
 1519|      0|            unsigned char *q = ret;
 1520|      0|            id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);
 1521|       |            /* skip over id len */
 1522|      0|            ret += 2;
 1523|      0|            lentmp = i2d_OCSP_RESPID(id, &ret);
 1524|       |            /* write id len */
 1525|      0|            s2n(lentmp, q);
 1526|      0|        }
 1527|      0|        s2n(extlen, ret);
 1528|      0|        if (extlen > 0)
 1529|      0|            i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);
 1530|      0|    }
 1531|     30|# ifndef OPENSSL_NO_HEARTBEATS
 1532|       |    /* Add Heartbeat extension */
 1533|       |
 1534|       |    /*-
 1535|       |     * check for enough space.
 1536|       |     * 4 bytes for the heartbeat ext type and extension length
 1537|       |     * 1 byte for the mode
 1538|       |     */
 1539|     30|    if (CHECKLEN(ret, 5, limit))
 1540|      0|        return NULL;
 1541|       |
 1542|     30|    s2n(TLSEXT_TYPE_heartbeat, ret);
 1543|     30|    s2n(1, ret);
 1544|       |    /*-
 1545|       |     * Set mode:
 1546|       |     * 1: peer may send requests
 1547|       |     * 2: peer not allowed to send requests
 1548|       |     */
 1549|     30|    if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)
 1550|      0|        *(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;
 1551|     30|    else
 1552|     30|        *(ret++) = SSL_TLSEXT_HB_ENABLED;
 1553|     30|# endif
 1554|       |
 1555|     30|# ifndef OPENSSL_NO_NEXTPROTONEG
 1556|     30|    if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len) {
 1557|       |        /*
 1558|       |         * The client advertises an emtpy extension to indicate its support
 1559|       |         * for Next Protocol Negotiation
 1560|       |         */
 1561|       |
 1562|       |        /*-
 1563|       |         * check for enough space.
 1564|       |         * 4 bytes for the NPN ext type and extension length
 1565|       |         */
 1566|      0|        if (CHECKLEN(ret, 4, limit))
 1567|      0|            return NULL;
 1568|      0|        s2n(TLSEXT_TYPE_next_proto_neg, ret);
 1569|      0|        s2n(0, ret);
 1570|      0|    }
 1571|     30|# endif
 1572|       |
 1573|     30|    if (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len) {
 1574|       |        /*-
 1575|       |         * check for enough space.
 1576|       |         * 4 bytes for the ALPN type and extension length
 1577|       |         * 2 bytes for the ALPN protocol list length
 1578|       |         * + ALPN protocol list length
 1579|       |         */
 1580|      0|        if (CHECKLEN(ret, 6 + s->alpn_client_proto_list_len, limit))
 1581|      0|            return NULL;
 1582|      0|        s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);
 1583|      0|        s2n(2 + s->alpn_client_proto_list_len, ret);
 1584|      0|        s2n(s->alpn_client_proto_list_len, ret);
 1585|      0|        memcpy(ret, s->alpn_client_proto_list, s->alpn_client_proto_list_len);
 1586|      0|        ret += s->alpn_client_proto_list_len;
 1587|      0|        s->cert->alpn_sent = 1;
 1588|      0|    }
 1589|     30|# ifndef OPENSSL_NO_SRTP
 1590|     30|    if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)) {
 1591|      0|        int el;
 1592|       |
 1593|      0|        ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);
 1594|       |
 1595|       |        /*-
 1596|       |         * check for enough space.
 1597|       |         * 4 bytes for the SRTP type and extension length
 1598|       |         * + SRTP profiles length
 1599|       |         */
 1600|      0|        if (CHECKLEN(ret, 4 + el, limit))
 1601|      0|            return NULL;
 1602|       |
 1603|      0|        s2n(TLSEXT_TYPE_use_srtp, ret);
 1604|      0|        s2n(el, ret);
 1605|       |
 1606|      0|        if (ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) {
 1607|      0|            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);
 1608|      0|            return NULL;
 1609|      0|        }
 1610|      0|        ret += el;
 1611|      0|    }
 1612|     30|# endif
 1613|     30|    custom_ext_init(&s->cert->cli_ext);
 1614|       |    /* Add custom TLS Extensions to ClientHello */
 1615|     30|    if (!custom_ext_add(s, 0, &ret, limit, al))
 1616|      0|        return NULL;
 1617|       |
 1618|       |    /*
 1619|       |     * Add padding to workaround bugs in F5 terminators. See
 1620|       |     * https://tools.ietf.org/html/draft-agl-tls-padding-03 NB: because this
 1621|       |     * code works out the length of all existing extensions it MUST always
 1622|       |     * appear last.
 1623|       |     */
 1624|     30|    if (s->options & SSL_OP_TLSEXT_PADDING) {
 1625|     30|        int hlen = ret - (unsigned char *)s->init_buf->data;
 1626|       |        /*
 1627|       |         * The code in s23_clnt.c to build ClientHello messages includes the
 1628|       |         * 5-byte record header in the buffer, while the code in s3_clnt.c
 1629|       |         * does not.
 1630|       |         */
 1631|     30|        if (s->state == SSL23_ST_CW_CLNT_HELLO_A)
 1632|     30|            hlen -= 5;
 1633|     30|        if (hlen > 0xff && hlen < 0x200) {
 1634|     30|            hlen = 0x200 - hlen;
 1635|     30|            if (hlen >= 4)
 1636|     30|                hlen -= 4;
 1637|      0|            else
 1638|      0|                hlen = 0;
 1639|       |
 1640|       |            /*-
 1641|       |             * check for enough space. Strictly speaking we know we've already
 1642|       |             * got enough space because to get here the message size is < 0x200,
 1643|       |             * but we know that we've allocated far more than that in the buffer
 1644|       |             * - but for consistency and robustness we're going to check anyway.
 1645|       |             *
 1646|       |             * 4 bytes for the padding type and extension length
 1647|       |             * + padding length
 1648|       |             */
 1649|     30|            if (CHECKLEN(ret, 4 + hlen, limit))
 1650|      0|                return NULL;
 1651|     30|            s2n(TLSEXT_TYPE_padding, ret);
 1652|     30|            s2n(hlen, ret);
 1653|     30|            memset(ret, 0, hlen);
 1654|     30|            ret += hlen;
 1655|     30|        }
 1656|     30|    }
 1657|       |
 1658|     30|    if ((extdatalen = ret - orig - 2) == 0)
 1659|      0|        return orig;
 1660|       |
 1661|     30|    s2n(extdatalen, orig);
 1662|     30|    return ret;
 1663|     30|}
ssl_prepare_clienthello_tlsext:
 2966|     30|{
 2967|       |
 2968|       |# ifdef TLSEXT_TYPE_opaque_prf_input
 2969|       |    {
 2970|       |        int r = 1;
 2971|       |
 2972|       |        if (s->ctx->tlsext_opaque_prf_input_callback != 0) {
 2973|       |            r = s->ctx->tlsext_opaque_prf_input_callback(s, NULL, 0,
 2974|       |                                                         s->
 2975|       |                                                         ctx->tlsext_opaque_prf_input_callback_arg);
 2976|       |            if (!r)
 2977|       |                return -1;
 2978|       |        }
 2979|       |
 2980|       |        if (s->tlsext_opaque_prf_input != NULL) {
 2981|       |            if (s->s3->client_opaque_prf_input != NULL) {
 2982|       |                /* shouldn't really happen */
 2983|       |                OPENSSL_free(s->s3->client_opaque_prf_input);
 2984|       |            }
 2985|       |
 2986|       |            if (s->tlsext_opaque_prf_input_len == 0) {
 2987|       |                /* dummy byte just to get non-NULL */
 2988|       |                s->s3->client_opaque_prf_input = OPENSSL_malloc(1);
 2989|       |            } else {
 2990|       |                s->s3->client_opaque_prf_input =
 2991|       |                    BUF_memdup(s->tlsext_opaque_prf_input,
 2992|       |                               s->tlsext_opaque_prf_input_len);
 2993|       |            }
 2994|       |            if (s->s3->client_opaque_prf_input == NULL) {
 2995|       |                SSLerr(SSL_F_SSL_PREPARE_CLIENTHELLO_TLSEXT,
 2996|       |                       ERR_R_MALLOC_FAILURE);
 2997|       |                return -1;
 2998|       |            }
 2999|       |            s->s3->client_opaque_prf_input_len =
 3000|       |                s->tlsext_opaque_prf_input_len;
 3001|       |        }
 3002|       |
 3003|       |        if (r == 2)
 3004|       |            /*
 3005|       |             * at callback's request, insist on receiving an appropriate
 3006|       |             * server opaque PRF input
 3007|       |             */
 3008|       |            s->s3->server_opaque_prf_input_len =
 3009|       |                s->tlsext_opaque_prf_input_len;
 3010|       |    }
 3011|       |# endif
 3012|       |
 3013|     30|    s->cert->alpn_sent = 0;
 3014|     30|    return 1;
 3015|     30|}
t1_lib.c:tls1_get_curvelist:
  469|     30|{
  470|     30|    size_t pcurveslen = 0;
  471|     30|    if (sess) {
  472|      0|        *pcurves = s->session->tlsext_ellipticcurvelist;
  473|      0|        pcurveslen = s->session->tlsext_ellipticcurvelist_length;
  474|     30|    } else {
  475|       |        /* For Suite B mode only include P-256, P-384 */
  476|     30|        switch (tls1_suiteb(s)) {
  477|      0|        case SSL_CERT_FLAG_SUITEB_128_LOS:
  478|      0|            *pcurves = suiteb_curves;
  479|      0|            pcurveslen = sizeof(suiteb_curves);
  480|      0|            break;
  481|       |
  482|      0|        case SSL_CERT_FLAG_SUITEB_128_LOS_ONLY:
  483|      0|            *pcurves = suiteb_curves;
  484|      0|            pcurveslen = 2;
  485|      0|            break;
  486|       |
  487|      0|        case SSL_CERT_FLAG_SUITEB_192_LOS:
  488|      0|            *pcurves = suiteb_curves + 2;
  489|      0|            pcurveslen = 2;
  490|      0|            break;
  491|     30|        default:
  492|     30|            *pcurves = s->tlsext_ellipticcurvelist;
  493|     30|            pcurveslen = s->tlsext_ellipticcurvelist_length;
  494|     30|        }
  495|     30|        if (!*pcurves) {
  496|       |# ifdef OPENSSL_FIPS
  497|       |            if (FIPS_mode()) {
  498|       |                *pcurves = fips_curves_default;
  499|       |                pcurveslen = sizeof(fips_curves_default);
  500|       |            } else
  501|       |# endif
  502|     30|            {
  503|     30|                if (!s->server || s->cert->ecdh_tmp_auto) {
  504|     30|                    *pcurves = eccurves_auto;
  505|     30|                    pcurveslen = sizeof(eccurves_auto);
  506|     30|                } else {
  507|      0|                    *pcurves = eccurves_all;
  508|      0|                    pcurveslen = sizeof(eccurves_all);
  509|      0|                }
  510|     30|            }
  511|     30|        }
  512|     30|    }
  513|       |    /* We do not allow odd length arrays to enter the system. */
  514|     30|    if (pcurveslen & 1) {
  515|      0|        SSLerr(SSL_F_TLS1_GET_CURVELIST, ERR_R_INTERNAL_ERROR);
  516|      0|        *num_curves = 0;
  517|      0|        return 0;
  518|     30|    } else {
  519|     30|        *num_curves = pcurveslen / 2;
  520|     30|        return 1;
  521|     30|    }
  522|     30|}
t1_lib.c:tls1_get_formatlist:
  834|     30|{
  835|       |    /*
  836|       |     * If we have a custom point format list use it otherwise use default
  837|       |     */
  838|     30|    if (s->tlsext_ecpointformatlist) {
  839|      0|        *pformats = s->tlsext_ecpointformatlist;
  840|      0|        *num_formats = s->tlsext_ecpointformatlist_length;
  841|     30|    } else {
  842|     30|        *pformats = ecformats_default;
  843|       |        /* For Suite B we don't support char2 fields */
  844|     30|        if (tls1_suiteb(s))
  845|      0|            *num_formats = sizeof(ecformats_default) - 1;
  846|     30|        else
  847|     30|            *num_formats = sizeof(ecformats_default);
  848|     30|    }
  849|     30|}

SSL_CTX_SRP_CTX_free:
   68|     30|{
   69|     30|    if (ctx == NULL)
   70|      0|        return 0;
   71|     30|    OPENSSL_free(ctx->srp_ctx.login);
   72|     30|    BN_free(ctx->srp_ctx.N);
   73|     30|    BN_free(ctx->srp_ctx.g);
   74|     30|    BN_free(ctx->srp_ctx.s);
   75|     30|    BN_free(ctx->srp_ctx.B);
   76|     30|    BN_free(ctx->srp_ctx.A);
   77|     30|    BN_free(ctx->srp_ctx.a);
   78|     30|    BN_free(ctx->srp_ctx.b);
   79|     30|    BN_free(ctx->srp_ctx.v);
   80|     30|    ctx->srp_ctx.TLS_ext_srp_username_callback = NULL;
   81|     30|    ctx->srp_ctx.SRP_cb_arg = NULL;
   82|     30|    ctx->srp_ctx.SRP_verify_param_callback = NULL;
   83|     30|    ctx->srp_ctx.SRP_give_srp_client_pwd_callback = NULL;
   84|     30|    ctx->srp_ctx.N = NULL;
   85|     30|    ctx->srp_ctx.g = NULL;
   86|     30|    ctx->srp_ctx.s = NULL;
   87|     30|    ctx->srp_ctx.B = NULL;
   88|     30|    ctx->srp_ctx.A = NULL;
   89|     30|    ctx->srp_ctx.a = NULL;
   90|     30|    ctx->srp_ctx.b = NULL;
   91|     30|    ctx->srp_ctx.v = NULL;
   92|     30|    ctx->srp_ctx.login = NULL;
   93|     30|    ctx->srp_ctx.info = NULL;
   94|     30|    ctx->srp_ctx.strength = SRP_MINIMAL_N;
   95|     30|    ctx->srp_ctx.srp_Mask = 0;
   96|     30|    return (1);
   97|     30|}
SSL_SRP_CTX_free:
  100|     30|{
  101|     30|    if (s == NULL)
  102|      0|        return 0;
  103|     30|    OPENSSL_free(s->srp_ctx.login);
  104|     30|    BN_free(s->srp_ctx.N);
  105|     30|    BN_free(s->srp_ctx.g);
  106|     30|    BN_free(s->srp_ctx.s);
  107|     30|    BN_free(s->srp_ctx.B);
  108|     30|    BN_free(s->srp_ctx.A);
  109|     30|    BN_free(s->srp_ctx.a);
  110|     30|    BN_free(s->srp_ctx.b);
  111|     30|    BN_free(s->srp_ctx.v);
  112|     30|    s->srp_ctx.TLS_ext_srp_username_callback = NULL;
  113|     30|    s->srp_ctx.SRP_cb_arg = NULL;
  114|     30|    s->srp_ctx.SRP_verify_param_callback = NULL;
  115|     30|    s->srp_ctx.SRP_give_srp_client_pwd_callback = NULL;
  116|     30|    s->srp_ctx.N = NULL;
  117|     30|    s->srp_ctx.g = NULL;
  118|     30|    s->srp_ctx.s = NULL;
  119|     30|    s->srp_ctx.B = NULL;
  120|     30|    s->srp_ctx.A = NULL;
  121|     30|    s->srp_ctx.a = NULL;
  122|     30|    s->srp_ctx.b = NULL;
  123|     30|    s->srp_ctx.v = NULL;
  124|     30|    s->srp_ctx.login = NULL;
  125|     30|    s->srp_ctx.info = NULL;
  126|     30|    s->srp_ctx.strength = SRP_MINIMAL_N;
  127|     30|    s->srp_ctx.srp_Mask = 0;
  128|     30|    return (1);
  129|     30|}
SSL_SRP_CTX_init:
  132|     30|{
  133|     30|    SSL_CTX *ctx;
  134|       |
  135|     30|    if ((s == NULL) || ((ctx = s->ctx) == NULL))
  136|      0|        return 0;
  137|     30|    s->srp_ctx.SRP_cb_arg = ctx->srp_ctx.SRP_cb_arg;
  138|       |    /* set client Hello login callback */
  139|     30|    s->srp_ctx.TLS_ext_srp_username_callback =
  140|     30|        ctx->srp_ctx.TLS_ext_srp_username_callback;
  141|       |    /* set SRP N/g param callback for verification */
  142|     30|    s->srp_ctx.SRP_verify_param_callback =
  143|     30|        ctx->srp_ctx.SRP_verify_param_callback;
  144|       |    /* set SRP client passwd callback */
  145|     30|    s->srp_ctx.SRP_give_srp_client_pwd_callback =
  146|     30|        ctx->srp_ctx.SRP_give_srp_client_pwd_callback;
  147|       |
  148|     30|    s->srp_ctx.N = NULL;
  149|     30|    s->srp_ctx.g = NULL;
  150|     30|    s->srp_ctx.s = NULL;
  151|     30|    s->srp_ctx.B = NULL;
  152|     30|    s->srp_ctx.A = NULL;
  153|     30|    s->srp_ctx.a = NULL;
  154|     30|    s->srp_ctx.b = NULL;
  155|     30|    s->srp_ctx.v = NULL;
  156|     30|    s->srp_ctx.login = NULL;
  157|     30|    s->srp_ctx.info = ctx->srp_ctx.info;
  158|     30|    s->srp_ctx.strength = ctx->srp_ctx.strength;
  159|       |
  160|     30|    if (((ctx->srp_ctx.N != NULL) &&
  161|     30|         ((s->srp_ctx.N = BN_dup(ctx->srp_ctx.N)) == NULL)) ||
  162|     30|        ((ctx->srp_ctx.g != NULL) &&
  163|     30|         ((s->srp_ctx.g = BN_dup(ctx->srp_ctx.g)) == NULL)) ||
  164|     30|        ((ctx->srp_ctx.s != NULL) &&
  165|     30|         ((s->srp_ctx.s = BN_dup(ctx->srp_ctx.s)) == NULL)) ||
  166|     30|        ((ctx->srp_ctx.B != NULL) &&
  167|     30|         ((s->srp_ctx.B = BN_dup(ctx->srp_ctx.B)) == NULL)) ||
  168|     30|        ((ctx->srp_ctx.A != NULL) &&
  169|     30|         ((s->srp_ctx.A = BN_dup(ctx->srp_ctx.A)) == NULL)) ||
  170|     30|        ((ctx->srp_ctx.a != NULL) &&
  171|     30|         ((s->srp_ctx.a = BN_dup(ctx->srp_ctx.a)) == NULL)) ||
  172|     30|        ((ctx->srp_ctx.v != NULL) &&
  173|     30|         ((s->srp_ctx.v = BN_dup(ctx->srp_ctx.v)) == NULL)) ||
  174|     30|        ((ctx->srp_ctx.b != NULL) &&
  175|     30|         ((s->srp_ctx.b = BN_dup(ctx->srp_ctx.b)) == NULL))) {
  176|      0|        SSLerr(SSL_F_SSL_SRP_CTX_INIT, ERR_R_BN_LIB);
  177|      0|        goto err;
  178|      0|    }
  179|     30|    if ((ctx->srp_ctx.login != NULL) &&
  180|     30|        ((s->srp_ctx.login = BUF_strdup(ctx->srp_ctx.login)) == NULL)) {
  181|      0|        SSLerr(SSL_F_SSL_SRP_CTX_INIT, ERR_R_INTERNAL_ERROR);
  182|      0|        goto err;
  183|      0|    }
  184|     30|    s->srp_ctx.srp_Mask = ctx->srp_ctx.srp_Mask;
  185|       |
  186|     30|    return (1);
  187|      0| err:
  188|      0|    OPENSSL_free(s->srp_ctx.login);
  189|      0|    BN_free(s->srp_ctx.N);
  190|      0|    BN_free(s->srp_ctx.g);
  191|      0|    BN_free(s->srp_ctx.s);
  192|      0|    BN_free(s->srp_ctx.B);
  193|      0|    BN_free(s->srp_ctx.A);
  194|      0|    BN_free(s->srp_ctx.a);
  195|      0|    BN_free(s->srp_ctx.b);
  196|      0|    BN_free(s->srp_ctx.v);
  197|      0|    return (0);
  198|     30|}
SSL_CTX_SRP_CTX_init:
  201|     30|{
  202|     30|    if (ctx == NULL)
  203|      0|        return 0;
  204|       |
  205|     30|    ctx->srp_ctx.SRP_cb_arg = NULL;
  206|       |    /* set client Hello login callback */
  207|     30|    ctx->srp_ctx.TLS_ext_srp_username_callback = NULL;
  208|       |    /* set SRP N/g param callback for verification */
  209|     30|    ctx->srp_ctx.SRP_verify_param_callback = NULL;
  210|       |    /* set SRP client passwd callback */
  211|     30|    ctx->srp_ctx.SRP_give_srp_client_pwd_callback = NULL;
  212|       |
  213|     30|    ctx->srp_ctx.N = NULL;
  214|     30|    ctx->srp_ctx.g = NULL;
  215|     30|    ctx->srp_ctx.s = NULL;
  216|     30|    ctx->srp_ctx.B = NULL;
  217|     30|    ctx->srp_ctx.A = NULL;
  218|     30|    ctx->srp_ctx.a = NULL;
  219|     30|    ctx->srp_ctx.b = NULL;
  220|     30|    ctx->srp_ctx.v = NULL;
  221|     30|    ctx->srp_ctx.login = NULL;
  222|     30|    ctx->srp_ctx.srp_Mask = 0;
  223|     30|    ctx->srp_ctx.info = NULL;
  224|     30|    ctx->srp_ctx.strength = SRP_MINIMAL_N;
  225|       |
  226|     30|    return (1);
  227|     30|}

adler32_z:
   67|      3|{
   68|      3|    unsigned long sum2;
   69|      3|    unsigned n;
   70|       |
   71|       |    /* split Adler-32 into component sums */
   72|      3|    sum2 = (adler >> 16) & 0xffff;
   73|      3|    adler &= 0xffff;
   74|       |
   75|       |    /* in case user likes doing a byte at a time, keep it fast */
   76|      3|    if (len == 1) {
   77|      0|        adler += buf[0];
   78|      0|        if (adler >= BASE)
   79|      0|            adler -= BASE;
   80|      0|        sum2 += adler;
   81|      0|        if (sum2 >= BASE)
   82|      0|            sum2 -= BASE;
   83|      0|        return adler | (sum2 << 16);
   84|      0|    }
   85|       |
   86|       |    /* initial Adler-32 value (deferred check for len == 1 speed) */
   87|      3|    if (buf == Z_NULL)
   88|      3|        return 1L;
   89|       |
   90|       |    /* in case short lengths are provided, keep it somewhat fast */
   91|      0|    if (len < 16) {
   92|      0|        while (len--) {
   93|      0|            adler += *buf++;
   94|      0|            sum2 += adler;
   95|      0|        }
   96|      0|        if (adler >= BASE)
   97|      0|            adler -= BASE;
   98|      0|        MOD28(sum2);            /* only added so many BASE's */
   99|      0|        return adler | (sum2 << 16);
  100|      0|    }
  101|       |
  102|       |    /* do length NMAX blocks -- requires just one modulo operation */
  103|      0|    while (len >= NMAX) {
  104|      0|        len -= NMAX;
  105|      0|        n = NMAX / 16;          /* NMAX is divisible by 16 */
  106|      0|        do {
  107|      0|            DO16(buf);          /* 16 sums unrolled */
  108|      0|            buf += 16;
  109|      0|        } while (--n);
  110|      0|        MOD(adler);
  111|      0|        MOD(sum2);
  112|      0|    }
  113|       |
  114|       |    /* do remaining bytes (less than NMAX, still just one modulo) */
  115|      0|    if (len) {                  /* avoid modulos if none remaining */
  116|      0|        while (len >= 16) {
  117|      0|            len -= 16;
  118|      0|            DO16(buf);
  119|      0|            buf += 16;
  120|      0|        }
  121|      0|        while (len--) {
  122|      0|            adler += *buf++;
  123|      0|            sum2 += adler;
  124|      0|        }
  125|      0|        MOD(adler);
  126|      0|        MOD(sum2);
  127|      0|    }
  128|       |
  129|       |    /* return recombined sums */
  130|      0|    return adler | (sum2 << 16);
  131|      0|}
adler32:
  138|      3|{
  139|      3|    return adler32_z(adler, buf, len);
  140|      3|}

crc32_z:
  743|    355|{
  744|       |    /* Return initial CRC, if requested. */
  745|    355|    if (buf == Z_NULL) return 0;
  746|       |
  747|       |#ifdef DYNAMIC_CRC_TABLE
  748|       |    once(&made, make_crc_table);
  749|       |#endif /* DYNAMIC_CRC_TABLE */
  750|       |
  751|       |    /* Pre-condition the CRC */
  752|    179|    crc ^= 0xffffffff;
  753|       |
  754|    179|#ifdef W
  755|       |
  756|       |    /* If provided enough bytes, do a braided CRC calculation. */
  757|    179|    if (len >= N * W + W - 1) {
  758|     31|        z_size_t blks;
  759|     31|        z_word_t const *words;
  760|     31|        unsigned endian;
  761|     31|        int k;
  762|       |
  763|       |        /* Compute the CRC up to a z_word_t boundary. */
  764|     49|        while (len && ((z_size_t)buf & (W - 1)) != 0) {
  765|     18|            len--;
  766|     18|            crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
  767|     18|        }
  768|       |
  769|       |        /* Compute the CRC on as many N z_word_t blocks as are available. */
  770|     31|        blks = len / (N * W);
  771|     31|        len -= blks * N * W;
  772|     31|        words = (z_word_t const *)buf;
  773|       |
  774|       |        /* Do endian check at execution time instead of compile time, since ARM
  775|       |           processors can change the endianess at execution time. If the
  776|       |           compiler knows what the endianess will be, it can optimize out the
  777|       |           check and the unused branch. */
  778|     31|        endian = 1;
  779|     31|        if (*(unsigned char *)&endian) {
  780|       |            /* Little endian. */
  781|       |
  782|     31|            z_crc_t crc0;
  783|     31|            z_word_t word0;
  784|     31|#if N > 1
  785|     31|            z_crc_t crc1;
  786|     31|            z_word_t word1;
  787|     31|#if N > 2
  788|     31|            z_crc_t crc2;
  789|     31|            z_word_t word2;
  790|     31|#if N > 3
  791|     31|            z_crc_t crc3;
  792|     31|            z_word_t word3;
  793|     31|#if N > 4
  794|     31|            z_crc_t crc4;
  795|     31|            z_word_t word4;
  796|       |#if N > 5
  797|       |            z_crc_t crc5;
  798|       |            z_word_t word5;
  799|       |#endif
  800|     31|#endif
  801|     31|#endif
  802|     31|#endif
  803|     31|#endif
  804|       |
  805|       |            /* Initialize the CRC for each braid. */
  806|     31|            crc0 = crc;
  807|     31|#if N > 1
  808|     31|            crc1 = 0;
  809|     31|#if N > 2
  810|     31|            crc2 = 0;
  811|     31|#if N > 3
  812|     31|            crc3 = 0;
  813|     31|#if N > 4
  814|     31|            crc4 = 0;
  815|       |#if N > 5
  816|       |            crc5 = 0;
  817|       |#endif
  818|     31|#endif
  819|     31|#endif
  820|     31|#endif
  821|     31|#endif
  822|       |
  823|       |            /*
  824|       |              Process the first blks-1 blocks, computing the CRCs on each braid
  825|       |              independently.
  826|       |             */
  827|    159|            while (--blks) {
  828|       |                /* Load the word for each braid into registers. */
  829|    128|                word0 = crc0 ^ words[0];
  830|    128|#if N > 1
  831|    128|                word1 = crc1 ^ words[1];
  832|    128|#if N > 2
  833|    128|                word2 = crc2 ^ words[2];
  834|    128|#if N > 3
  835|    128|                word3 = crc3 ^ words[3];
  836|    128|#if N > 4
  837|    128|                word4 = crc4 ^ words[4];
  838|       |#if N > 5
  839|       |                word5 = crc5 ^ words[5];
  840|       |#endif
  841|    128|#endif
  842|    128|#endif
  843|    128|#endif
  844|    128|#endif
  845|    128|                words += N;
  846|       |
  847|       |                /* Compute and update the CRC for each word. The loop should
  848|       |                   get unrolled. */
  849|    128|                crc0 = crc_braid_table[0][word0 & 0xff];
  850|    128|#if N > 1
  851|    128|                crc1 = crc_braid_table[0][word1 & 0xff];
  852|    128|#if N > 2
  853|    128|                crc2 = crc_braid_table[0][word2 & 0xff];
  854|    128|#if N > 3
  855|    128|                crc3 = crc_braid_table[0][word3 & 0xff];
  856|    128|#if N > 4
  857|    128|                crc4 = crc_braid_table[0][word4 & 0xff];
  858|       |#if N > 5
  859|       |                crc5 = crc_braid_table[0][word5 & 0xff];
  860|       |#endif
  861|    128|#endif
  862|    128|#endif
  863|    128|#endif
  864|    128|#endif
  865|  1.02k|                for (k = 1; k < W; k++) {
  866|    896|                    crc0 ^= crc_braid_table[k][(word0 >> (k << 3)) & 0xff];
  867|    896|#if N > 1
  868|    896|                    crc1 ^= crc_braid_table[k][(word1 >> (k << 3)) & 0xff];
  869|    896|#if N > 2
  870|    896|                    crc2 ^= crc_braid_table[k][(word2 >> (k << 3)) & 0xff];
  871|    896|#if N > 3
  872|    896|                    crc3 ^= crc_braid_table[k][(word3 >> (k << 3)) & 0xff];
  873|    896|#if N > 4
  874|    896|                    crc4 ^= crc_braid_table[k][(word4 >> (k << 3)) & 0xff];
  875|       |#if N > 5
  876|       |                    crc5 ^= crc_braid_table[k][(word5 >> (k << 3)) & 0xff];
  877|       |#endif
  878|    896|#endif
  879|    896|#endif
  880|    896|#endif
  881|    896|#endif
  882|    896|                }
  883|    128|            }
  884|       |
  885|       |            /*
  886|       |              Process the last block, combining the CRCs of the N braids at the
  887|       |              same time.
  888|       |             */
  889|     31|            crc = crc_word(crc0 ^ words[0]);
  890|     31|#if N > 1
  891|     31|            crc = crc_word(crc1 ^ words[1] ^ crc);
  892|     31|#if N > 2
  893|     31|            crc = crc_word(crc2 ^ words[2] ^ crc);
  894|     31|#if N > 3
  895|     31|            crc = crc_word(crc3 ^ words[3] ^ crc);
  896|     31|#if N > 4
  897|     31|            crc = crc_word(crc4 ^ words[4] ^ crc);
  898|       |#if N > 5
  899|       |            crc = crc_word(crc5 ^ words[5] ^ crc);
  900|       |#endif
  901|     31|#endif
  902|     31|#endif
  903|     31|#endif
  904|     31|#endif
  905|     31|            words += N;
  906|     31|        }
  907|      0|        else {
  908|       |            /* Big endian. */
  909|       |
  910|      0|            z_word_t crc0, word0, comb;
  911|      0|#if N > 1
  912|      0|            z_word_t crc1, word1;
  913|      0|#if N > 2
  914|      0|            z_word_t crc2, word2;
  915|      0|#if N > 3
  916|      0|            z_word_t crc3, word3;
  917|      0|#if N > 4
  918|      0|            z_word_t crc4, word4;
  919|       |#if N > 5
  920|       |            z_word_t crc5, word5;
  921|       |#endif
  922|      0|#endif
  923|      0|#endif
  924|      0|#endif
  925|      0|#endif
  926|       |
  927|       |            /* Initialize the CRC for each braid. */
  928|      0|            crc0 = byte_swap(crc);
  929|      0|#if N > 1
  930|      0|            crc1 = 0;
  931|      0|#if N > 2
  932|      0|            crc2 = 0;
  933|      0|#if N > 3
  934|      0|            crc3 = 0;
  935|      0|#if N > 4
  936|      0|            crc4 = 0;
  937|       |#if N > 5
  938|       |            crc5 = 0;
  939|       |#endif
  940|      0|#endif
  941|      0|#endif
  942|      0|#endif
  943|      0|#endif
  944|       |
  945|       |            /*
  946|       |              Process the first blks-1 blocks, computing the CRCs on each braid
  947|       |              independently.
  948|       |             */
  949|      0|            while (--blks) {
  950|       |                /* Load the word for each braid into registers. */
  951|      0|                word0 = crc0 ^ words[0];
  952|      0|#if N > 1
  953|      0|                word1 = crc1 ^ words[1];
  954|      0|#if N > 2
  955|      0|                word2 = crc2 ^ words[2];
  956|      0|#if N > 3
  957|      0|                word3 = crc3 ^ words[3];
  958|      0|#if N > 4
  959|      0|                word4 = crc4 ^ words[4];
  960|       |#if N > 5
  961|       |                word5 = crc5 ^ words[5];
  962|       |#endif
  963|      0|#endif
  964|      0|#endif
  965|      0|#endif
  966|      0|#endif
  967|      0|                words += N;
  968|       |
  969|       |                /* Compute and update the CRC for each word. The loop should
  970|       |                   get unrolled. */
  971|      0|                crc0 = crc_braid_big_table[0][word0 & 0xff];
  972|      0|#if N > 1
  973|      0|                crc1 = crc_braid_big_table[0][word1 & 0xff];
  974|      0|#if N > 2
  975|      0|                crc2 = crc_braid_big_table[0][word2 & 0xff];
  976|      0|#if N > 3
  977|      0|                crc3 = crc_braid_big_table[0][word3 & 0xff];
  978|      0|#if N > 4
  979|      0|                crc4 = crc_braid_big_table[0][word4 & 0xff];
  980|       |#if N > 5
  981|       |                crc5 = crc_braid_big_table[0][word5 & 0xff];
  982|       |#endif
  983|      0|#endif
  984|      0|#endif
  985|      0|#endif
  986|      0|#endif
  987|      0|                for (k = 1; k < W; k++) {
  988|      0|                    crc0 ^= crc_braid_big_table[k][(word0 >> (k << 3)) & 0xff];
  989|      0|#if N > 1
  990|      0|                    crc1 ^= crc_braid_big_table[k][(word1 >> (k << 3)) & 0xff];
  991|      0|#if N > 2
  992|      0|                    crc2 ^= crc_braid_big_table[k][(word2 >> (k << 3)) & 0xff];
  993|      0|#if N > 3
  994|      0|                    crc3 ^= crc_braid_big_table[k][(word3 >> (k << 3)) & 0xff];
  995|      0|#if N > 4
  996|      0|                    crc4 ^= crc_braid_big_table[k][(word4 >> (k << 3)) & 0xff];
  997|       |#if N > 5
  998|       |                    crc5 ^= crc_braid_big_table[k][(word5 >> (k << 3)) & 0xff];
  999|       |#endif
 1000|      0|#endif
 1001|      0|#endif
 1002|      0|#endif
 1003|      0|#endif
 1004|      0|                }
 1005|      0|            }
 1006|       |
 1007|       |            /*
 1008|       |              Process the last block, combining the CRCs of the N braids at the
 1009|       |              same time.
 1010|       |             */
 1011|      0|            comb = crc_word_big(crc0 ^ words[0]);
 1012|      0|#if N > 1
 1013|      0|            comb = crc_word_big(crc1 ^ words[1] ^ comb);
 1014|      0|#if N > 2
 1015|      0|            comb = crc_word_big(crc2 ^ words[2] ^ comb);
 1016|      0|#if N > 3
 1017|      0|            comb = crc_word_big(crc3 ^ words[3] ^ comb);
 1018|      0|#if N > 4
 1019|      0|            comb = crc_word_big(crc4 ^ words[4] ^ comb);
 1020|       |#if N > 5
 1021|       |            comb = crc_word_big(crc5 ^ words[5] ^ comb);
 1022|       |#endif
 1023|      0|#endif
 1024|      0|#endif
 1025|      0|#endif
 1026|      0|#endif
 1027|      0|            words += N;
 1028|      0|            crc = byte_swap(comb);
 1029|      0|        }
 1030|       |
 1031|       |        /*
 1032|       |          Update the pointer to the remaining bytes to process.
 1033|       |         */
 1034|     31|        buf = (unsigned char const *)words;
 1035|     31|    }
 1036|       |
 1037|    179|#endif /* W */
 1038|       |
 1039|       |    /* Complete the computation of the CRC on any remaining bytes. */
 1040|    283|    while (len >= 8) {
 1041|    104|        len -= 8;
 1042|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1043|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1044|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1045|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1046|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1047|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1048|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1049|    104|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1050|    104|    }
 1051|    623|    while (len) {
 1052|    444|        len--;
 1053|    444|        crc = (crc >> 8) ^ crc_table[(crc ^ *buf++) & 0xff];
 1054|    444|    }
 1055|       |
 1056|       |    /* Return the CRC, post-conditioned. */
 1057|    179|    return crc ^ 0xffffffff;
 1058|    355|}
crc32:
 1067|    355|{
 1068|    355|    return crc32_z(crc, buf, len);
 1069|    355|}
crc32.c:crc_word:
  719|    155|{
  720|    155|    int k;
  721|  1.39k|    for (k = 0; k < W; k++)
  722|  1.24k|        data = (data >> 8) ^ crc_table[data & 0xff];
  723|    155|    return (z_crc_t)data;
  724|    155|}

inflate_fast:
   53|     92|{
   54|     92|    struct inflate_state FAR *state;
   55|     92|    z_const unsigned char FAR *in;      /* local strm->next_in */
   56|     92|    z_const unsigned char FAR *last;    /* have enough input while in < last */
   57|     92|    unsigned char FAR *out;     /* local strm->next_out */
   58|     92|    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
   59|     92|    unsigned char FAR *end;     /* while out < end, enough space available */
   60|       |#ifdef INFLATE_STRICT
   61|       |    unsigned dmax;              /* maximum distance from zlib header */
   62|       |#endif
   63|     92|    unsigned wsize;             /* window size or zero if not using window */
   64|     92|    unsigned whave;             /* valid bytes in the window */
   65|     92|    unsigned wnext;             /* window write index */
   66|     92|    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
   67|     92|    unsigned long hold;         /* local strm->hold */
   68|     92|    unsigned bits;              /* local strm->bits */
   69|     92|    code const FAR *lcode;      /* local strm->lencode */
   70|     92|    code const FAR *dcode;      /* local strm->distcode */
   71|     92|    unsigned lmask;             /* mask for first level of length codes */
   72|     92|    unsigned dmask;             /* mask for first level of distance codes */
   73|     92|    code const *here;           /* retrieved table entry */
   74|     92|    unsigned op;                /* code bits, operation, extra bits, or */
   75|       |                                /*  window position, window bytes to copy */
   76|     92|    unsigned len;               /* match length, unused bytes */
   77|     92|    unsigned dist;              /* match distance */
   78|     92|    unsigned char FAR *from;    /* where to copy match from */
   79|       |
   80|       |    /* copy state to local variables */
   81|     92|    state = (struct inflate_state FAR *)strm->state;
   82|     92|    in = strm->next_in;
   83|     92|    last = in + (strm->avail_in - 5);
   84|     92|    out = strm->next_out;
   85|     92|    beg = out - (start - strm->avail_out);
   86|     92|    end = out + (strm->avail_out - 257);
   87|       |#ifdef INFLATE_STRICT
   88|       |    dmax = state->dmax;
   89|       |#endif
   90|     92|    wsize = state->wsize;
   91|     92|    whave = state->whave;
   92|     92|    wnext = state->wnext;
   93|     92|    window = state->window;
   94|     92|    hold = state->hold;
   95|     92|    bits = state->bits;
   96|     92|    lcode = state->lencode;
   97|     92|    dcode = state->distcode;
   98|     92|    lmask = (1U << state->lenbits) - 1;
   99|     92|    dmask = (1U << state->distbits) - 1;
  100|       |
  101|       |    /* decode literals and length/distances until end-of-block or not enough
  102|       |       input data or output space */
  103|  1.60k|    do {
  104|  1.60k|        if (bits < 15) {
  105|    876|            hold += (unsigned long)(*in++) << bits;
  106|    876|            bits += 8;
  107|    876|            hold += (unsigned long)(*in++) << bits;
  108|    876|            bits += 8;
  109|    876|        }
  110|  1.60k|        here = lcode + (hold & lmask);
  111|  1.60k|      dolen:
  112|  1.60k|        op = (unsigned)(here->bits);
  113|  1.60k|        hold >>= op;
  114|  1.60k|        bits -= op;
  115|  1.60k|        op = (unsigned)(here->op);
  116|  1.60k|        if (op == 0) {                          /* literal */
  117|  1.37k|            Tracevv((stderr, here->val >= 0x20 && here->val < 0x7f ?
  118|  1.37k|                    "inflate:         literal '%c'\n" :
  119|  1.37k|                    "inflate:         literal 0x%02x\n", here->val));
  120|  1.37k|            *out++ = (unsigned char)(here->val);
  121|  1.37k|        }
  122|    228|        else if (op & 16) {                     /* length base */
  123|    194|            len = (unsigned)(here->val);
  124|    194|            op &= 15;                           /* number of extra bits */
  125|    194|            if (op) {
  126|     60|                if (bits < op) {
  127|      0|                    hold += (unsigned long)(*in++) << bits;
  128|      0|                    bits += 8;
  129|      0|                }
  130|     60|                len += (unsigned)hold & ((1U << op) - 1);
  131|     60|                hold >>= op;
  132|     60|                bits -= op;
  133|     60|            }
  134|    194|            Tracevv((stderr, "inflate:         length %u\n", len));
  135|    194|            if (bits < 15) {
  136|     88|                hold += (unsigned long)(*in++) << bits;
  137|     88|                bits += 8;
  138|     88|                hold += (unsigned long)(*in++) << bits;
  139|     88|                bits += 8;
  140|     88|            }
  141|    194|            here = dcode + (hold & dmask);
  142|    194|          dodist:
  143|    194|            op = (unsigned)(here->bits);
  144|    194|            hold >>= op;
  145|    194|            bits -= op;
  146|    194|            op = (unsigned)(here->op);
  147|    194|            if (op & 16) {                      /* distance base */
  148|    193|                dist = (unsigned)(here->val);
  149|    193|                op &= 15;                       /* number of extra bits */
  150|    193|                if (bits < op) {
  151|      1|                    hold += (unsigned long)(*in++) << bits;
  152|      1|                    bits += 8;
  153|      1|                    if (bits < op) {
  154|      0|                        hold += (unsigned long)(*in++) << bits;
  155|      0|                        bits += 8;
  156|      0|                    }
  157|      1|                }
  158|    193|                dist += (unsigned)hold & ((1U << op) - 1);
  159|       |#ifdef INFLATE_STRICT
  160|       |                if (dist > dmax) {
  161|       |                    strm->msg = (char *)"invalid distance too far back";
  162|       |                    state->mode = BAD;
  163|       |                    break;
  164|       |                }
  165|       |#endif
  166|    193|                hold >>= op;
  167|    193|                bits -= op;
  168|    193|                Tracevv((stderr, "inflate:         distance %u\n", dist));
  169|    193|                op = (unsigned)(out - beg);     /* max distance in output */
  170|    193|                if (dist > op) {                /* see if copy from window */
  171|     16|                    op = dist - op;             /* distance back in window */
  172|     16|                    if (op > whave) {
  173|      6|                        if (state->sane) {
  174|      6|                            strm->msg =
  175|      6|                                (char *)"invalid distance too far back";
  176|      6|                            state->mode = BAD;
  177|      6|                            break;
  178|      6|                        }
  179|       |#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
  180|       |                        if (len <= op - whave) {
  181|       |                            do {
  182|       |                                *out++ = 0;
  183|       |                            } while (--len);
  184|       |                            continue;
  185|       |                        }
  186|       |                        len -= op - whave;
  187|       |                        do {
  188|       |                            *out++ = 0;
  189|       |                        } while (--op > whave);
  190|       |                        if (op == 0) {
  191|       |                            from = out - dist;
  192|       |                            do {
  193|       |                                *out++ = *from++;
  194|       |                            } while (--len);
  195|       |                            continue;
  196|       |                        }
  197|       |#endif
  198|      6|                    }
  199|     10|                    from = window;
  200|     10|                    if (wnext == 0) {           /* very common case */
  201|      0|                        from += wsize - op;
  202|      0|                        if (op < len) {         /* some from window */
  203|      0|                            len -= op;
  204|      0|                            do {
  205|      0|                                *out++ = *from++;
  206|      0|                            } while (--op);
  207|      0|                            from = out - dist;  /* rest from output */
  208|      0|                        }
  209|      0|                    }
  210|     10|                    else if (wnext < op) {      /* wrap around window */
  211|      0|                        from += wsize + wnext - op;
  212|      0|                        op -= wnext;
  213|      0|                        if (op < len) {         /* some from end of window */
  214|      0|                            len -= op;
  215|      0|                            do {
  216|      0|                                *out++ = *from++;
  217|      0|                            } while (--op);
  218|      0|                            from = window;
  219|      0|                            if (wnext < len) {  /* some from start of window */
  220|      0|                                op = wnext;
  221|      0|                                len -= op;
  222|      0|                                do {
  223|      0|                                    *out++ = *from++;
  224|      0|                                } while (--op);
  225|      0|                                from = out - dist;      /* rest from output */
  226|      0|                            }
  227|      0|                        }
  228|      0|                    }
  229|     10|                    else {                      /* contiguous in window */
  230|     10|                        from += wnext - op;
  231|     10|                        if (op < len) {         /* some from window */
  232|      7|                            len -= op;
  233|     16|                            do {
  234|     16|                                *out++ = *from++;
  235|     16|                            } while (--op);
  236|      7|                            from = out - dist;  /* rest from output */
  237|      7|                        }
  238|     10|                    }
  239|     36|                    while (len > 2) {
  240|     26|                        *out++ = *from++;
  241|     26|                        *out++ = *from++;
  242|     26|                        *out++ = *from++;
  243|     26|                        len -= 3;
  244|     26|                    }
  245|     10|                    if (len) {
  246|      6|                        *out++ = *from++;
  247|      6|                        if (len > 1)
  248|      1|                            *out++ = *from++;
  249|      6|                    }
  250|     10|                }
  251|    177|                else {
  252|    177|                    from = out - dist;          /* copy direct from output */
  253|  1.51k|                    do {                        /* minimum length is three */
  254|  1.51k|                        *out++ = *from++;
  255|  1.51k|                        *out++ = *from++;
  256|  1.51k|                        *out++ = *from++;
  257|  1.51k|                        len -= 3;
  258|  1.51k|                    } while (len > 2);
  259|    177|                    if (len) {
  260|     99|                        *out++ = *from++;
  261|     99|                        if (len > 1)
  262|     39|                            *out++ = *from++;
  263|     99|                    }
  264|    177|                }
  265|    193|            }
  266|      1|            else if ((op & 64) == 0) {          /* 2nd level distance code */
  267|      0|                here = dcode + here->val + (hold & ((1U << op) - 1));
  268|      0|                goto dodist;
  269|      0|            }
  270|      1|            else {
  271|      1|                strm->msg = (char *)"invalid distance code";
  272|      1|                state->mode = BAD;
  273|      1|                break;
  274|      1|            }
  275|    194|        }
  276|     34|        else if ((op & 64) == 0) {              /* 2nd level length code */
  277|      0|            here = lcode + here->val + (hold & ((1U << op) - 1));
  278|      0|            goto dolen;
  279|      0|        }
  280|     34|        else if (op & 32) {                     /* end-of-block */
  281|     33|            Tracevv((stderr, "inflate:         end of block\n"));
  282|     33|            state->mode = TYPE;
  283|     33|            break;
  284|     33|        }
  285|      1|        else {
  286|      1|            strm->msg = (char *)"invalid literal/length code";
  287|      1|            state->mode = BAD;
  288|      1|            break;
  289|      1|        }
  290|  1.60k|    } while (in < last && out < end);
  291|       |
  292|       |    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  293|     92|    len = bits >> 3;
  294|     92|    in -= len;
  295|     92|    bits -= len << 3;
  296|     92|    hold &= (1U << bits) - 1;
  297|       |
  298|       |    /* update state and return */
  299|     92|    strm->next_in = in;
  300|     92|    strm->next_out = out;
  301|     92|    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
  302|     92|    strm->avail_out = (unsigned)(out < end ?
  303|     92|                                 257 + (end - out) : 257 - (out - end));
  304|     92|    state->hold = hold;
  305|     92|    state->bits = bits;
  306|     92|    return;
  307|     92|}

inflateResetKeep:
  121|    126|{
  122|    126|    struct inflate_state FAR *state;
  123|       |
  124|    126|    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  125|    126|    state = (struct inflate_state FAR *)strm->state;
  126|    126|    strm->total_in = strm->total_out = state->total = 0;
  127|    126|    strm->msg = Z_NULL;
  128|    126|    if (state->wrap)        /* to support ill-conceived Java test suite */
  129|    120|        strm->adler = state->wrap & 1;
  130|    126|    state->mode = HEAD;
  131|    126|    state->last = 0;
  132|    126|    state->havedict = 0;
  133|    126|    state->flags = -1;
  134|    126|    state->dmax = 32768U;
  135|    126|    state->head = Z_NULL;
  136|    126|    state->hold = 0;
  137|    126|    state->bits = 0;
  138|    126|    state->lencode = state->distcode = state->next = state->codes;
  139|    126|    state->sane = 1;
  140|    126|    state->back = -1;
  141|    126|    Tracev((stderr, "inflate: reset\n"));
  142|    126|    return Z_OK;
  143|    126|}
inflateReset:
  147|    126|{
  148|    126|    struct inflate_state FAR *state;
  149|       |
  150|    126|    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  151|    126|    state = (struct inflate_state FAR *)strm->state;
  152|    126|    state->wsize = 0;
  153|    126|    state->whave = 0;
  154|    126|    state->wnext = 0;
  155|    126|    return inflateResetKeep(strm);
  156|    126|}
inflateReset2:
  161|    126|{
  162|    126|    int wrap;
  163|    126|    struct inflate_state FAR *state;
  164|       |
  165|       |    /* get the state */
  166|    126|    if (inflateStateCheck(strm)) return Z_STREAM_ERROR;
  167|    126|    state = (struct inflate_state FAR *)strm->state;
  168|       |
  169|       |    /* extract wrap request from windowBits parameter */
  170|    126|    if (windowBits < 0) {
  171|      6|        wrap = 0;
  172|      6|        windowBits = -windowBits;
  173|      6|    }
  174|    120|    else {
  175|    120|        wrap = (windowBits >> 4) + 5;
  176|    120|#ifdef GUNZIP
  177|    120|        if (windowBits < 48)
  178|    120|            windowBits &= 15;
  179|    120|#endif
  180|    120|    }
  181|       |
  182|       |    /* set number of window bits, free window if different */
  183|    126|    if (windowBits && (windowBits < 8 || windowBits > 15))
  184|      0|        return Z_STREAM_ERROR;
  185|    126|    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
  186|      0|        ZFREE(strm, state->window);
  187|      0|        state->window = Z_NULL;
  188|      0|    }
  189|       |
  190|       |    /* update state and reset the rest of it */
  191|    126|    state->wrap = wrap;
  192|    126|    state->wbits = (unsigned)windowBits;
  193|    126|    return inflateReset(strm);
  194|    126|}
inflateInit2_:
  201|    126|{
  202|    126|    int ret;
  203|    126|    struct inflate_state FAR *state;
  204|       |
  205|    126|    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
  206|    126|        stream_size != (int)(sizeof(z_stream)))
  207|      0|        return Z_VERSION_ERROR;
  208|    126|    if (strm == Z_NULL) return Z_STREAM_ERROR;
  209|    126|    strm->msg = Z_NULL;                 /* in case we return an error */
  210|    126|    if (strm->zalloc == (alloc_func)0) {
  211|       |#ifdef Z_SOLO
  212|       |        return Z_STREAM_ERROR;
  213|       |#else
  214|      0|        strm->zalloc = zcalloc;
  215|      0|        strm->opaque = (voidpf)0;
  216|      0|#endif
  217|      0|    }
  218|    126|    if (strm->zfree == (free_func)0)
  219|       |#ifdef Z_SOLO
  220|       |        return Z_STREAM_ERROR;
  221|       |#else
  222|      0|        strm->zfree = zcfree;
  223|    126|#endif
  224|    126|    state = (struct inflate_state FAR *)
  225|    126|            ZALLOC(strm, 1, sizeof(struct inflate_state));
  226|    126|    if (state == Z_NULL) return Z_MEM_ERROR;
  227|    126|    Tracev((stderr, "inflate: allocated\n"));
  228|    126|    strm->state = (struct internal_state FAR *)state;
  229|    126|    state->strm = strm;
  230|    126|    state->window = Z_NULL;
  231|    126|    state->mode = HEAD;     /* to pass state test in inflateReset2() */
  232|    126|    ret = inflateReset2(strm, windowBits);
  233|    126|    if (ret != Z_OK) {
  234|      0|        ZFREE(strm, state);
  235|      0|        strm->state = Z_NULL;
  236|      0|    }
  237|    126|    return ret;
  238|    126|}
inflateInit_:
  244|     15|{
  245|     15|    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
  246|     15|}
inflate:
  626|    272|{
  627|    272|    struct inflate_state FAR *state;
  628|    272|    z_const unsigned char FAR *next;    /* next input */
  629|    272|    unsigned char FAR *put;     /* next output */
  630|    272|    unsigned have, left;        /* available input and output */
  631|    272|    unsigned long hold;         /* bit buffer */
  632|    272|    unsigned bits;              /* bits in bit buffer */
  633|    272|    unsigned in, out;           /* save starting available input and output */
  634|    272|    unsigned copy;              /* number of stored or match bytes to copy */
  635|    272|    unsigned char FAR *from;    /* where to copy match bytes from */
  636|    272|    code here;                  /* current decoding table entry */
  637|    272|    code last;                  /* parent table entry */
  638|    272|    unsigned len;               /* length to copy for repeats, bits to drop */
  639|    272|    int ret;                    /* return code */
  640|    272|#ifdef GUNZIP
  641|    272|    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
  642|    272|#endif
  643|    272|    static const unsigned short order[19] = /* permutation of code lengths */
  644|    272|        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
  645|       |
  646|    272|    if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||
  647|    272|        (strm->next_in == Z_NULL && strm->avail_in != 0))
  648|      0|        return Z_STREAM_ERROR;
  649|       |
  650|    272|    state = (struct inflate_state FAR *)strm->state;
  651|    272|    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
  652|    272|    LOAD();
  653|    272|    in = have;
  654|    272|    out = left;
  655|    272|    ret = Z_OK;
  656|    272|    for (;;)
  657|    829|        switch (state->mode) {
  658|    115|        case HEAD:
  659|    115|            if (state->wrap == 0) {
  660|      6|                state->mode = TYPEDO;
  661|      6|                break;
  662|      6|            }
  663|    109|            NEEDBITS(16);
  664|    107|#ifdef GUNZIP
  665|    107|            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
  666|     97|                if (state->wbits == 0)
  667|      0|                    state->wbits = 15;
  668|     97|                state->check = crc32(0L, Z_NULL, 0);
  669|     97|                CRC2(state->check, hold);
  670|     97|                INITBITS();
  671|     97|                state->mode = FLAGS;
  672|     97|                break;
  673|     97|            }
  674|     10|            if (state->head != Z_NULL)
  675|      0|                state->head->done = -1;
  676|     10|            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
  677|       |#else
  678|       |            if (
  679|       |#endif
  680|     10|                ((BITS(8) << 8) + (hold >> 8)) % 31) {
  681|      6|                strm->msg = (char *)"incorrect header check";
  682|      6|                state->mode = BAD;
  683|      6|                break;
  684|      6|            }
  685|      4|            if (BITS(4) != Z_DEFLATED) {
  686|      1|                strm->msg = (char *)"unknown compression method";
  687|      1|                state->mode = BAD;
  688|      1|                break;
  689|      1|            }
  690|      3|            DROPBITS(4);
  691|      3|            len = BITS(4) + 8;
  692|      3|            if (state->wbits == 0)
  693|      0|                state->wbits = len;
  694|      3|            if (len > 15 || len > state->wbits) {
  695|      0|                strm->msg = (char *)"invalid window size";
  696|      0|                state->mode = BAD;
  697|      0|                break;
  698|      0|            }
  699|      3|            state->dmax = 1U << len;
  700|      3|            state->flags = 0;               /* indicate zlib header */
  701|      3|            Tracev((stderr, "inflate:   zlib header ok\n"));
  702|      3|            strm->adler = state->check = adler32(0L, Z_NULL, 0);
  703|      3|            state->mode = hold & 0x200 ? DICTID : TYPE;
  704|      3|            INITBITS();
  705|      3|            break;
  706|      0|#ifdef GUNZIP
  707|     98|        case FLAGS:
  708|     98|            NEEDBITS(16);
  709|     96|            state->flags = (int)(hold);
  710|     96|            if ((state->flags & 0xff) != Z_DEFLATED) {
  711|      1|                strm->msg = (char *)"unknown compression method";
  712|      1|                state->mode = BAD;
  713|      1|                break;
  714|      1|            }
  715|     95|            if (state->flags & 0xe000) {
  716|      1|                strm->msg = (char *)"unknown header flags set";
  717|      1|                state->mode = BAD;
  718|      1|                break;
  719|      1|            }
  720|     94|            if (state->head != Z_NULL)
  721|      0|                state->head->text = (int)((hold >> 8) & 1);
  722|     94|            if ((state->flags & 0x0200) && (state->wrap & 4))
  723|      6|                CRC2(state->check, hold);
  724|     94|            INITBITS();
  725|     94|            state->mode = TIME;
  726|       |                /* fallthrough */
  727|     97|        case TIME:
  728|     97|            NEEDBITS(32);
  729|     91|            if (state->head != Z_NULL)
  730|      0|                state->head->time = hold;
  731|     91|            if ((state->flags & 0x0200) && (state->wrap & 4))
  732|      6|                CRC4(state->check, hold);
  733|     91|            INITBITS();
  734|     91|            state->mode = OS;
  735|       |                /* fallthrough */
  736|     92|        case OS:
  737|     92|            NEEDBITS(16);
  738|     90|            if (state->head != Z_NULL) {
  739|      0|                state->head->xflags = (int)(hold & 0xff);
  740|      0|                state->head->os = (int)(hold >> 8);
  741|      0|            }
  742|     90|            if ((state->flags & 0x0200) && (state->wrap & 4))
  743|      6|                CRC2(state->check, hold);
  744|     90|            INITBITS();
  745|     90|            state->mode = EXLEN;
  746|       |                /* fallthrough */
  747|     91|        case EXLEN:
  748|     91|            if (state->flags & 0x0400) {
  749|      7|                NEEDBITS(16);
  750|      5|                state->length = (unsigned)(hold);
  751|      5|                if (state->head != Z_NULL)
  752|      0|                    state->head->extra_len = (unsigned)hold;
  753|      5|                if ((state->flags & 0x0200) && (state->wrap & 4))
  754|      2|                    CRC2(state->check, hold);
  755|      5|                INITBITS();
  756|      5|            }
  757|     84|            else if (state->head != Z_NULL)
  758|      0|                state->head->extra = Z_NULL;
  759|     89|            state->mode = EXTRA;
  760|       |                /* fallthrough */
  761|     93|        case EXTRA:
  762|     93|            if (state->flags & 0x0400) {
  763|      9|                copy = state->length;
  764|      9|                if (copy > have) copy = have;
  765|      9|                if (copy) {
  766|      4|                    if (state->head != Z_NULL &&
  767|      4|                        state->head->extra != Z_NULL) {
  768|      0|                        len = state->head->extra_len - state->length;
  769|      0|                        zmemcpy(state->head->extra + len, next,
  770|      0|                                len + copy > state->head->extra_max ?
  771|      0|                                state->head->extra_max - len : copy);
  772|      0|                    }
  773|      4|                    if ((state->flags & 0x0200) && (state->wrap & 4))
  774|      2|                        state->check = crc32(state->check, next, copy);
  775|      4|                    have -= copy;
  776|      4|                    next += copy;
  777|      4|                    state->length -= copy;
  778|      4|                }
  779|      9|                if (state->length) goto inf_leave;
  780|      9|            }
  781|     85|            state->length = 0;
  782|     85|            state->mode = NAME;
  783|       |                /* fallthrough */
  784|     86|        case NAME:
  785|     86|            if (state->flags & 0x0800) {
  786|     13|                if (have == 0) goto inf_leave;
  787|     12|                copy = 0;
  788|    277|                do {
  789|    277|                    len = (unsigned)(next[copy++]);
  790|    277|                    if (state->head != Z_NULL &&
  791|    277|                            state->head->name != Z_NULL &&
  792|    277|                            state->length < state->head->name_max)
  793|      0|                        state->head->name[state->length++] = (Bytef)len;
  794|    277|                } while (len && copy < have);
  795|     12|                if ((state->flags & 0x0200) && (state->wrap & 4))
  796|      3|                    state->check = crc32(state->check, next, copy);
  797|     12|                have -= copy;
  798|     12|                next += copy;
  799|     12|                if (len) goto inf_leave;
  800|     12|            }
  801|     73|            else if (state->head != Z_NULL)
  802|      0|                state->head->name = Z_NULL;
  803|     84|            state->length = 0;
  804|     84|            state->mode = COMMENT;
  805|       |                /* fallthrough */
  806|     85|        case COMMENT:
  807|     85|            if (state->flags & 0x1000) {
  808|     13|                if (have == 0) goto inf_leave;
  809|     12|                copy = 0;
  810|    388|                do {
  811|    388|                    len = (unsigned)(next[copy++]);
  812|    388|                    if (state->head != Z_NULL &&
  813|    388|                            state->head->comment != Z_NULL &&
  814|    388|                            state->length < state->head->comm_max)
  815|      0|                        state->head->comment[state->length++] = (Bytef)len;
  816|    388|                } while (len && copy < have);
  817|     12|                if ((state->flags & 0x0200) && (state->wrap & 4))
  818|      1|                    state->check = crc32(state->check, next, copy);
  819|     12|                have -= copy;
  820|     12|                next += copy;
  821|     12|                if (len) goto inf_leave;
  822|     12|            }
  823|     72|            else if (state->head != Z_NULL)
  824|      0|                state->head->comment = Z_NULL;
  825|     83|            state->mode = HCRC;
  826|       |                /* fallthrough */
  827|     85|        case HCRC:
  828|     85|            if (state->flags & 0x0200) {
  829|      6|                NEEDBITS(16);
  830|      2|                if ((state->wrap & 4) && hold != (state->check & 0xffff)) {
  831|      2|                    strm->msg = (char *)"header crc mismatch";
  832|      2|                    state->mode = BAD;
  833|      2|                    break;
  834|      2|                }
  835|      0|                INITBITS();
  836|      0|            }
  837|     79|            if (state->head != Z_NULL) {
  838|      0|                state->head->hcrc = (int)((state->flags >> 9) & 1);
  839|      0|                state->head->done = 1;
  840|      0|            }
  841|     79|            strm->adler = state->check = crc32(0L, Z_NULL, 0);
  842|     79|            state->mode = TYPE;
  843|     79|            break;
  844|      0|#endif
  845|      5|        case DICTID:
  846|      5|            NEEDBITS(32);
  847|      1|            strm->adler = state->check = ZSWAP32(hold);
  848|      1|            INITBITS();
  849|      1|            state->mode = DICT;
  850|       |                /* fallthrough */
  851|      1|        case DICT:
  852|      1|            if (state->havedict == 0) {
  853|      1|                RESTORE();
  854|      1|                return Z_NEED_DICT;
  855|      1|            }
  856|      0|            strm->adler = state->check = adler32(0L, Z_NULL, 0);
  857|      0|            state->mode = TYPE;
  858|       |                /* fallthrough */
  859|    116|        case TYPE:
  860|    116|            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
  861|       |                /* fallthrough */
  862|    122|        case TYPEDO:
  863|    122|            if (state->last) {
  864|      9|                BYTEBITS();
  865|      9|                state->mode = CHECK;
  866|      9|                break;
  867|      9|            }
  868|    113|            NEEDBITS(3);
  869|    112|            state->last = BITS(1);
  870|    112|            DROPBITS(1);
  871|    112|            switch (BITS(2)) {
  872|     16|            case 0:                             /* stored block */
  873|     16|                Tracev((stderr, "inflate:     stored block%s\n",
  874|     16|                        state->last ? " (last)" : ""));
  875|     16|                state->mode = STORED;
  876|     16|                break;
  877|     63|            case 1:                             /* fixed block */
  878|     63|                fixedtables(state);
  879|     63|                Tracev((stderr, "inflate:     fixed codes block%s\n",
  880|     63|                        state->last ? " (last)" : ""));
  881|     63|                state->mode = LEN_;             /* decode codes */
  882|     63|                if (flush == Z_TREES) {
  883|      0|                    DROPBITS(2);
  884|      0|                    goto inf_leave;
  885|      0|                }
  886|     63|                break;
  887|     63|            case 2:                             /* dynamic block */
  888|     31|                Tracev((stderr, "inflate:     dynamic codes block%s\n",
  889|     31|                        state->last ? " (last)" : ""));
  890|     31|                state->mode = TABLE;
  891|     31|                break;
  892|      2|            case 3:
  893|      2|                strm->msg = (char *)"invalid block type";
  894|      2|                state->mode = BAD;
  895|    112|            }
  896|    112|            DROPBITS(2);
  897|    112|            break;
  898|     18|        case STORED:
  899|     18|            BYTEBITS();                         /* go to byte boundary */
  900|     18|            NEEDBITS(32);
  901|     13|            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
  902|     13|                strm->msg = (char *)"invalid stored block lengths";
  903|     13|                state->mode = BAD;
  904|     13|                break;
  905|     13|            }
  906|      0|            state->length = (unsigned)hold & 0xffff;
  907|      0|            Tracev((stderr, "inflate:       stored length %u\n",
  908|      0|                    state->length));
  909|      0|            INITBITS();
  910|      0|            state->mode = COPY_;
  911|      0|            if (flush == Z_TREES) goto inf_leave;
  912|       |                /* fallthrough */
  913|      0|        case COPY_:
  914|      0|            state->mode = COPY;
  915|       |                /* fallthrough */
  916|      0|        case COPY:
  917|      0|            copy = state->length;
  918|      0|            if (copy) {
  919|      0|                if (copy > have) copy = have;
  920|      0|                if (copy > left) copy = left;
  921|      0|                if (copy == 0) goto inf_leave;
  922|      0|                zmemcpy(put, next, copy);
  923|      0|                have -= copy;
  924|      0|                next += copy;
  925|      0|                left -= copy;
  926|      0|                put += copy;
  927|      0|                state->length -= copy;
  928|      0|                break;
  929|      0|            }
  930|      0|            Tracev((stderr, "inflate:       stored end\n"));
  931|      0|            state->mode = TYPE;
  932|      0|            break;
  933|     32|        case TABLE:
  934|     32|            NEEDBITS(14);
  935|     30|            state->nlen = BITS(5) + 257;
  936|     30|            DROPBITS(5);
  937|     30|            state->ndist = BITS(5) + 1;
  938|     30|            DROPBITS(5);
  939|     30|            state->ncode = BITS(4) + 4;
  940|     30|            DROPBITS(4);
  941|     30|#ifndef PKZIP_BUG_WORKAROUND
  942|     30|            if (state->nlen > 286 || state->ndist > 30) {
  943|      2|                strm->msg = (char *)"too many length or distance symbols";
  944|      2|                state->mode = BAD;
  945|      2|                break;
  946|      2|            }
  947|     28|#endif
  948|     28|            Tracev((stderr, "inflate:       table sizes ok\n"));
  949|     28|            state->have = 0;
  950|     28|            state->mode = LENLENS;
  951|       |                /* fallthrough */
  952|     29|        case LENLENS:
  953|    268|            while (state->have < state->ncode) {
  954|    241|                NEEDBITS(3);
  955|    239|                state->lens[order[state->have++]] = (unsigned short)BITS(3);
  956|    239|                DROPBITS(3);
  957|    239|            }
  958|    303|            while (state->have < 19)
  959|    276|                state->lens[order[state->have++]] = 0;
  960|     27|            state->next = state->codes;
  961|     27|            state->lencode = (const code FAR *)(state->next);
  962|     27|            state->lenbits = 7;
  963|     27|            ret = inflate_table(CODES, state->lens, 19, &(state->next),
  964|     27|                                &(state->lenbits), state->work);
  965|     27|            if (ret) {
  966|     14|                strm->msg = (char *)"invalid code lengths set";
  967|     14|                state->mode = BAD;
  968|     14|                break;
  969|     14|            }
  970|     13|            Tracev((stderr, "inflate:       code lengths ok\n"));
  971|     13|            state->have = 0;
  972|     13|            state->mode = CODELENS;
  973|       |                /* fallthrough */
  974|     18|        case CODELENS:
  975|    834|            while (state->have < state->nlen + state->ndist) {
  976|    940|                for (;;) {
  977|    940|                    here = state->lencode[BITS(state->lenbits)];
  978|    940|                    if ((unsigned)(here.bits) <= bits) break;
  979|    116|                    PULLBYTE();
  980|    116|                }
  981|    824|                if (here.val < 16) {
  982|    793|                    DROPBITS(here.bits);
  983|    793|                    state->lens[state->have++] = here.val;
  984|    793|                }
  985|     31|                else {
  986|     31|                    if (here.val == 16) {
  987|      0|                        NEEDBITS(here.bits + 2);
  988|      0|                        DROPBITS(here.bits);
  989|      0|                        if (state->have == 0) {
  990|      0|                            strm->msg = (char *)"invalid bit length repeat";
  991|      0|                            state->mode = BAD;
  992|      0|                            break;
  993|      0|                        }
  994|      0|                        len = state->lens[state->have - 1];
  995|      0|                        copy = 3 + BITS(2);
  996|      0|                        DROPBITS(2);
  997|      0|                    }
  998|     31|                    else if (here.val == 17) {
  999|      0|                        NEEDBITS(here.bits + 3);
 1000|      0|                        DROPBITS(here.bits);
 1001|      0|                        len = 0;
 1002|      0|                        copy = 3 + BITS(3);
 1003|      0|                        DROPBITS(3);
 1004|      0|                    }
 1005|     31|                    else {
 1006|     31|                        NEEDBITS(here.bits + 7);
 1007|     29|                        DROPBITS(here.bits);
 1008|     29|                        len = 0;
 1009|     29|                        copy = 11 + BITS(7);
 1010|     29|                        DROPBITS(7);
 1011|     29|                    }
 1012|     29|                    if (state->have + copy > state->nlen + state->ndist) {
 1013|      6|                        strm->msg = (char *)"invalid bit length repeat";
 1014|      6|                        state->mode = BAD;
 1015|      6|                        break;
 1016|      6|                    }
 1017|  1.75k|                    while (copy--)
 1018|  1.73k|                        state->lens[state->have++] = (unsigned short)len;
 1019|     23|                }
 1020|    824|            }
 1021|       |
 1022|       |            /* handle error breaks in while */
 1023|      8|            if (state->mode == BAD) break;
 1024|       |
 1025|       |            /* check for end-of-block code (better have one) */
 1026|      2|            if (state->lens[256] == 0) {
 1027|      1|                strm->msg = (char *)"invalid code -- missing end-of-block";
 1028|      1|                state->mode = BAD;
 1029|      1|                break;
 1030|      1|            }
 1031|       |
 1032|       |            /* build code tables -- note: do not change the lenbits or distbits
 1033|       |               values here (9 and 6) without reading the comments in inftrees.h
 1034|       |               concerning the ENOUGH constants, which depend on those values */
 1035|      1|            state->next = state->codes;
 1036|      1|            state->lencode = (const code FAR *)(state->next);
 1037|      1|            state->lenbits = 9;
 1038|      1|            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
 1039|      1|                                &(state->lenbits), state->work);
 1040|      1|            if (ret) {
 1041|      1|                strm->msg = (char *)"invalid literal/lengths set";
 1042|      1|                state->mode = BAD;
 1043|      1|                break;
 1044|      1|            }
 1045|      0|            state->distcode = (const code FAR *)(state->next);
 1046|      0|            state->distbits = 6;
 1047|      0|            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
 1048|      0|                            &(state->next), &(state->distbits), state->work);
 1049|      0|            if (ret) {
 1050|      0|                strm->msg = (char *)"invalid distances set";
 1051|      0|                state->mode = BAD;
 1052|      0|                break;
 1053|      0|            }
 1054|      0|            Tracev((stderr, "inflate:       codes ok\n"));
 1055|      0|            state->mode = LEN_;
 1056|      0|            if (flush == Z_TREES) goto inf_leave;
 1057|       |                /* fallthrough */
 1058|     63|        case LEN_:
 1059|     63|            state->mode = LEN;
 1060|       |                /* fallthrough */
 1061|    182|        case LEN:
 1062|    182|            if (have >= 6 && left >= 258) {
 1063|     92|                RESTORE();
 1064|     92|                inflate_fast(strm, out);
 1065|     92|                LOAD();
 1066|     92|                if (state->mode == TYPE)
 1067|     33|                    state->back = -1;
 1068|     92|                break;
 1069|     92|            }
 1070|     90|            state->back = 0;
 1071|    155|            for (;;) {
 1072|    155|                here = state->lencode[BITS(state->lenbits)];
 1073|    155|                if ((unsigned)(here.bits) <= bits) break;
 1074|     84|                PULLBYTE();
 1075|     84|            }
 1076|     71|            if (here.op && (here.op & 0xf0) == 0) {
 1077|      0|                last = here;
 1078|      0|                for (;;) {
 1079|      0|                    here = state->lencode[last.val +
 1080|      0|                            (BITS(last.bits + last.op) >> last.bits)];
 1081|      0|                    if ((unsigned)(last.bits + here.bits) <= bits) break;
 1082|      0|                    PULLBYTE();
 1083|      0|                }
 1084|      0|                DROPBITS(last.bits);
 1085|      0|                state->back += last.bits;
 1086|      0|            }
 1087|     71|            DROPBITS(here.bits);
 1088|     71|            state->back += here.bits;
 1089|     71|            state->length = (unsigned)here.val;
 1090|     71|            if ((int)(here.op) == 0) {
 1091|     40|                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
 1092|     40|                        "inflate:         literal '%c'\n" :
 1093|     40|                        "inflate:         literal 0x%02x\n", here.val));
 1094|     40|                state->mode = LIT;
 1095|     40|                break;
 1096|     40|            }
 1097|     31|            if (here.op & 32) {
 1098|      4|                Tracevv((stderr, "inflate:         end of block\n"));
 1099|      4|                state->back = -1;
 1100|      4|                state->mode = TYPE;
 1101|      4|                break;
 1102|      4|            }
 1103|     27|            if (here.op & 64) {
 1104|      1|                strm->msg = (char *)"invalid literal/length code";
 1105|      1|                state->mode = BAD;
 1106|      1|                break;
 1107|      1|            }
 1108|     26|            state->extra = (unsigned)(here.op) & 15;
 1109|     26|            state->mode = LENEXT;
 1110|       |                /* fallthrough */
 1111|     27|        case LENEXT:
 1112|     27|            if (state->extra) {
 1113|     17|                NEEDBITS(state->extra);
 1114|     15|                state->length += BITS(state->extra);
 1115|     15|                DROPBITS(state->extra);
 1116|     15|                state->back += state->extra;
 1117|     15|            }
 1118|     25|            Tracevv((stderr, "inflate:         length %u\n", state->length));
 1119|     25|            state->was = state->length;
 1120|     25|            state->mode = DIST;
 1121|       |                /* fallthrough */
 1122|     27|        case DIST:
 1123|     39|            for (;;) {
 1124|     39|                here = state->distcode[BITS(state->distbits)];
 1125|     39|                if ((unsigned)(here.bits) <= bits) break;
 1126|     16|                PULLBYTE();
 1127|     16|            }
 1128|     23|            if ((here.op & 0xf0) == 0) {
 1129|      0|                last = here;
 1130|      0|                for (;;) {
 1131|      0|                    here = state->distcode[last.val +
 1132|      0|                            (BITS(last.bits + last.op) >> last.bits)];
 1133|      0|                    if ((unsigned)(last.bits + here.bits) <= bits) break;
 1134|      0|                    PULLBYTE();
 1135|      0|                }
 1136|      0|                DROPBITS(last.bits);
 1137|      0|                state->back += last.bits;
 1138|      0|            }
 1139|     23|            DROPBITS(here.bits);
 1140|     23|            state->back += here.bits;
 1141|     23|            if (here.op & 64) {
 1142|      1|                strm->msg = (char *)"invalid distance code";
 1143|      1|                state->mode = BAD;
 1144|      1|                break;
 1145|      1|            }
 1146|     22|            state->offset = (unsigned)here.val;
 1147|     22|            state->extra = (unsigned)(here.op) & 15;
 1148|     22|            state->mode = DISTEXT;
 1149|       |                /* fallthrough */
 1150|     23|        case DISTEXT:
 1151|     23|            if (state->extra) {
 1152|     16|                NEEDBITS(state->extra);
 1153|     14|                state->offset += BITS(state->extra);
 1154|     14|                DROPBITS(state->extra);
 1155|     14|                state->back += state->extra;
 1156|     14|            }
 1157|       |#ifdef INFLATE_STRICT
 1158|       |            if (state->offset > state->dmax) {
 1159|       |                strm->msg = (char *)"invalid distance too far back";
 1160|       |                state->mode = BAD;
 1161|       |                break;
 1162|       |            }
 1163|       |#endif
 1164|     21|            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
 1165|     21|            state->mode = MATCH;
 1166|       |                /* fallthrough */
 1167|     21|        case MATCH:
 1168|     21|            if (left == 0) goto inf_leave;
 1169|     21|            copy = out - left;
 1170|     21|            if (state->offset > copy) {         /* copy from window */
 1171|      2|                copy = state->offset - copy;
 1172|      2|                if (copy > state->whave) {
 1173|      2|                    if (state->sane) {
 1174|      2|                        strm->msg = (char *)"invalid distance too far back";
 1175|      2|                        state->mode = BAD;
 1176|      2|                        break;
 1177|      2|                    }
 1178|       |#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
 1179|       |                    Trace((stderr, "inflate.c too far\n"));
 1180|       |                    copy -= state->whave;
 1181|       |                    if (copy > state->length) copy = state->length;
 1182|       |                    if (copy > left) copy = left;
 1183|       |                    left -= copy;
 1184|       |                    state->length -= copy;
 1185|       |                    do {
 1186|       |                        *put++ = 0;
 1187|       |                    } while (--copy);
 1188|       |                    if (state->length == 0) state->mode = LEN;
 1189|       |                    break;
 1190|       |#endif
 1191|      2|                }
 1192|      0|                if (copy > state->wnext) {
 1193|      0|                    copy -= state->wnext;
 1194|      0|                    from = state->window + (state->wsize - copy);
 1195|      0|                }
 1196|      0|                else
 1197|      0|                    from = state->window + (state->wnext - copy);
 1198|      0|                if (copy > state->length) copy = state->length;
 1199|      0|            }
 1200|     19|            else {                              /* copy from output */
 1201|     19|                from = put - state->offset;
 1202|     19|                copy = state->length;
 1203|     19|            }
 1204|     19|            if (copy > left) copy = left;
 1205|     19|            left -= copy;
 1206|     19|            state->length -= copy;
 1207|    915|            do {
 1208|    915|                *put++ = *from++;
 1209|    915|            } while (--copy);
 1210|     19|            if (state->length == 0) state->mode = LEN;
 1211|     19|            break;
 1212|     40|        case LIT:
 1213|     40|            if (left == 0) goto inf_leave;
 1214|     40|            *put++ = (unsigned char)(state->length);
 1215|     40|            left--;
 1216|     40|            state->mode = LEN;
 1217|     40|            break;
 1218|     11|        case CHECK:
 1219|     11|            if (state->wrap) {
 1220|     11|                NEEDBITS(32);
 1221|      6|                out -= left;
 1222|      6|                strm->total_out += out;
 1223|      6|                state->total += out;
 1224|      6|                if ((state->wrap & 4) && out)
 1225|      0|                    strm->adler = state->check =
 1226|      0|                        UPDATE_CHECK(state->check, put - out, out);
 1227|      6|                out = left;
 1228|      6|                if ((state->wrap & 4) && (
 1229|      6|#ifdef GUNZIP
 1230|      6|                     state->flags ? hold :
 1231|      6|#endif
 1232|      6|                     ZSWAP32(hold)) != state->check) {
 1233|      3|                    strm->msg = (char *)"incorrect data check";
 1234|      3|                    state->mode = BAD;
 1235|      3|                    break;
 1236|      3|                }
 1237|      3|                INITBITS();
 1238|      3|                Tracev((stderr, "inflate:   check matches trailer\n"));
 1239|      3|            }
 1240|      3|#ifdef GUNZIP
 1241|      3|            state->mode = LENGTH;
 1242|       |                /* fallthrough */
 1243|      4|        case LENGTH:
 1244|      4|            if (state->wrap && state->flags) {
 1245|      4|                NEEDBITS(32);
 1246|      2|                if ((state->wrap & 4) && hold != (state->total & 0xffffffff)) {
 1247|      1|                    strm->msg = (char *)"incorrect length check";
 1248|      1|                    state->mode = BAD;
 1249|      1|                    break;
 1250|      1|                }
 1251|      1|                INITBITS();
 1252|      1|                Tracev((stderr, "inflate:   length matches trailer\n"));
 1253|      1|            }
 1254|      1|#endif
 1255|      1|            state->mode = DONE;
 1256|       |                /* fallthrough */
 1257|      1|        case DONE:
 1258|      1|            ret = Z_STREAM_END;
 1259|      1|            goto inf_leave;
 1260|     66|        case BAD:
 1261|     66|            ret = Z_DATA_ERROR;
 1262|     66|            goto inf_leave;
 1263|      0|        case MEM:
 1264|      0|            return Z_MEM_ERROR;
 1265|      0|        case SYNC:
 1266|       |                /* fallthrough */
 1267|      0|        default:
 1268|      0|            return Z_STREAM_ERROR;
 1269|    829|        }
 1270|       |
 1271|       |    /*
 1272|       |       Return from inflate(), updating the total counts and the check value.
 1273|       |       If there was no progress during the inflate() call, return a buffer
 1274|       |       error.  Call updatewindow() to create and/or update the window state.
 1275|       |       Note: a memory error from inflate() is non-recoverable.
 1276|       |     */
 1277|    271|  inf_leave:
 1278|    271|    RESTORE();
 1279|    271|    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
 1280|    218|            (state->mode < CHECK || flush != Z_FINISH)))
 1281|     90|        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
 1282|      0|            state->mode = MEM;
 1283|      0|            return Z_MEM_ERROR;
 1284|      0|        }
 1285|    271|    in -= strm->avail_in;
 1286|    271|    out -= strm->avail_out;
 1287|    271|    strm->total_in += in;
 1288|    271|    strm->total_out += out;
 1289|    271|    state->total += out;
 1290|    271|    if ((state->wrap & 4) && out)
 1291|     56|        strm->adler = state->check =
 1292|     56|            UPDATE_CHECK(state->check, strm->next_out - out, out);
 1293|    271|    strm->data_type = (int)state->bits + (state->last ? 64 : 0) +
 1294|    271|                      (state->mode == TYPE ? 128 : 0) +
 1295|    271|                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
 1296|    271|    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
 1297|     45|        ret = Z_BUF_ERROR;
 1298|    271|    return ret;
 1299|    271|}
inflateEnd:
 1303|    126|{
 1304|    126|    struct inflate_state FAR *state;
 1305|    126|    if (inflateStateCheck(strm))
 1306|      0|        return Z_STREAM_ERROR;
 1307|    126|    state = (struct inflate_state FAR *)strm->state;
 1308|    126|    if (state->window != Z_NULL) ZFREE(strm, state->window);
 1309|    126|    ZFREE(strm, strm->state);
 1310|    126|    strm->state = Z_NULL;
 1311|    126|    Tracev((stderr, "inflate: end\n"));
 1312|    126|    return Z_OK;
 1313|    126|}
inflate.c:inflateStateCheck:
  107|    776|{
  108|    776|    struct inflate_state FAR *state;
  109|    776|    if (strm == Z_NULL ||
  110|    776|        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)
  111|      0|        return 1;
  112|    776|    state = (struct inflate_state FAR *)strm->state;
  113|    776|    if (state == Z_NULL || state->strm != strm ||
  114|    776|        state->mode < HEAD || state->mode > SYNC)
  115|      0|        return 1;
  116|    776|    return 0;
  117|    776|}
inflate.c:fixedtables:
  281|     63|{
  282|       |#ifdef BUILDFIXED
  283|       |    static int virgin = 1;
  284|       |    static code *lenfix, *distfix;
  285|       |    static code fixed[544];
  286|       |
  287|       |    /* build fixed huffman tables if first call (may not be thread safe) */
  288|       |    if (virgin) {
  289|       |        unsigned sym, bits;
  290|       |        static code *next;
  291|       |
  292|       |        /* literal/length table */
  293|       |        sym = 0;
  294|       |        while (sym < 144) state->lens[sym++] = 8;
  295|       |        while (sym < 256) state->lens[sym++] = 9;
  296|       |        while (sym < 280) state->lens[sym++] = 7;
  297|       |        while (sym < 288) state->lens[sym++] = 8;
  298|       |        next = fixed;
  299|       |        lenfix = next;
  300|       |        bits = 9;
  301|       |        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
  302|       |
  303|       |        /* distance table */
  304|       |        sym = 0;
  305|       |        while (sym < 32) state->lens[sym++] = 5;
  306|       |        distfix = next;
  307|       |        bits = 5;
  308|       |        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
  309|       |
  310|       |        /* do this just once */
  311|       |        virgin = 0;
  312|       |    }
  313|       |#else /* !BUILDFIXED */
  314|     63|#   include "inffixed.h"
  315|     63|#endif /* BUILDFIXED */
  316|     63|    state->lencode = lenfix;
  317|     63|    state->lenbits = 9;
  318|     63|    state->distcode = distfix;
  319|     63|    state->distbits = 5;
  320|     63|}
inflate.c:updatewindow:
  401|     90|{
  402|     90|    struct inflate_state FAR *state;
  403|     90|    unsigned dist;
  404|       |
  405|     90|    state = (struct inflate_state FAR *)strm->state;
  406|       |
  407|       |    /* if it hasn't been done already, allocate space for the window */
  408|     90|    if (state->window == Z_NULL) {
  409|     37|        state->window = (unsigned char FAR *)
  410|     37|                        ZALLOC(strm, 1U << state->wbits,
  411|     37|                               sizeof(unsigned char));
  412|     37|        if (state->window == Z_NULL) return 1;
  413|     37|    }
  414|       |
  415|       |    /* if window not in use yet, initialize */
  416|     90|    if (state->wsize == 0) {
  417|     37|        state->wsize = 1U << state->wbits;
  418|     37|        state->wnext = 0;
  419|     37|        state->whave = 0;
  420|     37|    }
  421|       |
  422|       |    /* copy state->wsize or less output bytes into the circular window */
  423|     90|    if (copy >= state->wsize) {
  424|      0|        zmemcpy(state->window, end - state->wsize, state->wsize);
  425|      0|        state->wnext = 0;
  426|      0|        state->whave = state->wsize;
  427|      0|    }
  428|     90|    else {
  429|     90|        dist = state->wsize - state->wnext;
  430|     90|        if (dist > copy) dist = copy;
  431|     90|        zmemcpy(state->window + state->wnext, end - copy, dist);
  432|     90|        copy -= dist;
  433|     90|        if (copy) {
  434|      0|            zmemcpy(state->window, end - copy, copy);
  435|      0|            state->wnext = copy;
  436|      0|            state->whave = state->wsize;
  437|      0|        }
  438|     90|        else {
  439|     90|            state->wnext += dist;
  440|     90|            if (state->wnext == state->wsize) state->wnext = 0;
  441|     90|            if (state->whave < state->wsize) state->whave += dist;
  442|     90|        }
  443|     90|    }
  444|     90|    return 0;
  445|     90|}

inflate_table:
   39|     28|{
   40|     28|    unsigned len;               /* a code's length in bits */
   41|     28|    unsigned sym;               /* index of code symbols */
   42|     28|    unsigned min, max;          /* minimum and maximum code lengths */
   43|     28|    unsigned root;              /* number of index bits for root table */
   44|     28|    unsigned curr;              /* number of index bits for current table */
   45|     28|    unsigned drop;              /* code bits to drop for sub-table */
   46|     28|    int left;                   /* number of prefix codes available */
   47|     28|    unsigned used;              /* code entries in table used */
   48|     28|    unsigned huff;              /* Huffman code */
   49|     28|    unsigned incr;              /* for incrementing code, index */
   50|     28|    unsigned fill;              /* index for replicating entries */
   51|     28|    unsigned low;               /* low bits for current root entry */
   52|     28|    unsigned mask;              /* mask for low root bits */
   53|     28|    code here;                  /* table entry for duplication */
   54|     28|    code FAR *next;             /* next available space in table */
   55|     28|    const unsigned short FAR *base;     /* base value table to use */
   56|     28|    const unsigned short FAR *extra;    /* extra bits table to use */
   57|     28|    unsigned match;             /* use base and extra for symbol >= match */
   58|     28|    unsigned short count[MAXBITS+1];    /* number of codes of each length */
   59|     28|    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
   60|     28|    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
   61|     28|        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
   62|     28|        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
   63|     28|    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
   64|     28|        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
   65|     28|        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 199, 202};
   66|     28|    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
   67|     28|        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
   68|     28|        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
   69|     28|        8193, 12289, 16385, 24577, 0, 0};
   70|     28|    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
   71|     28|        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
   72|     28|        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
   73|     28|        28, 28, 29, 29, 64, 64};
   74|       |
   75|       |    /*
   76|       |       Process a set of code lengths to create a canonical Huffman code.  The
   77|       |       code lengths are lens[0..codes-1].  Each length corresponds to the
   78|       |       symbols 0..codes-1.  The Huffman code is generated by first sorting the
   79|       |       symbols by length from short to long, and retaining the symbol order
   80|       |       for codes with equal lengths.  Then the code starts with all zero bits
   81|       |       for the first code of the shortest length, and the codes are integer
   82|       |       increments for the same length, and zeros are appended as the length
   83|       |       increases.  For the deflate format, these bits are stored backwards
   84|       |       from their more natural integer increment ordering, and so when the
   85|       |       decoding tables are built in the large loop below, the integer codes
   86|       |       are incremented backwards.
   87|       |
   88|       |       This routine assumes, but does not check, that all of the entries in
   89|       |       lens[] are in the range 0..MAXBITS.  The caller must assure this.
   90|       |       1..MAXBITS is interpreted as that code length.  zero means that that
   91|       |       symbol does not occur in this code.
   92|       |
   93|       |       The codes are sorted by computing a count of codes for each length,
   94|       |       creating from that a table of starting indices for each length in the
   95|       |       sorted table, and then entering the symbols in order in the sorted
   96|       |       table.  The sorted table is work[], with that space being provided by
   97|       |       the caller.
   98|       |
   99|       |       The length counts are used for other purposes as well, i.e. finding
  100|       |       the minimum and maximum length codes, determining if there are any
  101|       |       codes at all, checking for a valid set of lengths, and looking ahead
  102|       |       at length counts to determine sub-table sizes when building the
  103|       |       decoding tables.
  104|       |     */
  105|       |
  106|       |    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  107|    476|    for (len = 0; len <= MAXBITS; len++)
  108|    448|        count[len] = 0;
  109|    806|    for (sym = 0; sym < codes; sym++)
  110|    778|        count[lens[sym]]++;
  111|       |
  112|       |    /* bound code lengths, force root to be within code lengths */
  113|     28|    root = *bits;
  114|    318|    for (max = MAXBITS; max >= 1; max--)
  115|    314|        if (count[max] != 0) break;
  116|     28|    if (root > max) root = max;
  117|     28|    if (max == 0) {                     /* no symbols to code at all */
  118|      4|        here.op = (unsigned char)64;    /* invalid code marker */
  119|      4|        here.bits = (unsigned char)1;
  120|      4|        here.val = (unsigned short)0;
  121|      4|        *(*table)++ = here;             /* make a table to force an error */
  122|      4|        *(*table)++ = here;
  123|      4|        *bits = 1;
  124|      4|        return 0;     /* no symbols, but wait for decoding to report error */
  125|      4|    }
  126|     41|    for (min = 1; min < max; min++)
  127|     39|        if (count[min] != 0) break;
  128|     24|    if (root < min) root = min;
  129|       |
  130|       |    /* check for an over-subscribed or incomplete set of lengths */
  131|     24|    left = 1;
  132|    259|    for (len = 1; len <= MAXBITS; len++) {
  133|    244|        left <<= 1;
  134|    244|        left -= count[len];
  135|    244|        if (left < 0) return -1;        /* over-subscribed */
  136|    244|    }
  137|     15|    if (left > 0 && (type == CODES || max != 1))
  138|      6|        return -1;                      /* incomplete set */
  139|       |
  140|       |    /* generate offsets into symbol table for each length for sorting */
  141|      9|    offs[1] = 0;
  142|    135|    for (len = 1; len < MAXBITS; len++)
  143|    126|        offs[len + 1] = offs[len] + count[len];
  144|       |
  145|       |    /* sort symbols by length, by symbol order within each length */
  146|    180|    for (sym = 0; sym < codes; sym++)
  147|    171|        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
  148|       |
  149|       |    /*
  150|       |       Create and fill in decoding tables.  In this loop, the table being
  151|       |       filled is at next and has curr index bits.  The code being used is huff
  152|       |       with length len.  That code is converted to an index by dropping drop
  153|       |       bits off of the bottom.  For codes where len is less than drop + curr,
  154|       |       those top drop + curr - len bits are incremented through all values to
  155|       |       fill the table with replicated entries.
  156|       |
  157|       |       root is the number of index bits for the root table.  When len exceeds
  158|       |       root, sub-tables are created pointed to by the root entry with an index
  159|       |       of the low root bits of huff.  This is saved in low to check for when a
  160|       |       new sub-table should be started.  drop is zero when the root table is
  161|       |       being filled, and drop is root when sub-tables are being filled.
  162|       |
  163|       |       When a new sub-table is needed, it is necessary to look ahead in the
  164|       |       code lengths to determine what size sub-table is needed.  The length
  165|       |       counts are used for this, and so count[] is decremented as codes are
  166|       |       entered in the tables.
  167|       |
  168|       |       used keeps track of how many table entries have been allocated from the
  169|       |       provided *table space.  It is checked for LENS and DIST tables against
  170|       |       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
  171|       |       the initial root table size constants.  See the comments in inftrees.h
  172|       |       for more information.
  173|       |
  174|       |       sym increments through all symbols, and the loop terminates when
  175|       |       all codes of length max, i.e. all codes, have been processed.  This
  176|       |       routine permits incomplete codes, so another loop after this one fills
  177|       |       in the rest of the decoding tables with invalid code markers.
  178|       |     */
  179|       |
  180|       |    /* set up for code type */
  181|      9|    switch (type) {
  182|      9|    case CODES:
  183|      9|        base = extra = work;    /* dummy value--not used */
  184|      9|        match = 20;
  185|      9|        break;
  186|      0|    case LENS:
  187|      0|        base = lbase;
  188|      0|        extra = lext;
  189|      0|        match = 257;
  190|      0|        break;
  191|      0|    default:    /* DISTS */
  192|      0|        base = dbase;
  193|      0|        extra = dext;
  194|      0|        match = 0;
  195|      9|    }
  196|       |
  197|       |    /* initialize state for loop */
  198|      9|    huff = 0;                   /* starting code */
  199|      9|    sym = 0;                    /* starting code symbol */
  200|      9|    len = min;                  /* starting code length */
  201|      9|    next = *table;              /* current table to fill in */
  202|      9|    curr = root;                /* current table index bits */
  203|      9|    drop = 0;                   /* current bits to drop from code for index */
  204|      9|    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
  205|      9|    used = 1U << root;          /* use root table entries */
  206|      9|    mask = used - 1;            /* mask for comparing low */
  207|       |
  208|       |    /* check available table space */
  209|      9|    if ((type == LENS && used > ENOUGH_LENS) ||
  210|      9|        (type == DISTS && used > ENOUGH_DISTS))
  211|      0|        return 1;
  212|       |
  213|       |    /* process all codes and make table entries */
  214|     44|    for (;;) {
  215|       |        /* create table entry */
  216|     44|        here.bits = (unsigned char)(len - drop);
  217|     44|        if (work[sym] + 1U < match) {
  218|     44|            here.op = (unsigned char)0;
  219|     44|            here.val = work[sym];
  220|     44|        }
  221|      0|        else if (work[sym] >= match) {
  222|      0|            here.op = (unsigned char)(extra[work[sym] - match]);
  223|      0|            here.val = base[work[sym] - match];
  224|      0|        }
  225|      0|        else {
  226|      0|            here.op = (unsigned char)(32 + 64);         /* end of block */
  227|      0|            here.val = 0;
  228|      0|        }
  229|       |
  230|       |        /* replicate for those indices with low len bits equal to huff */
  231|     44|        incr = 1U << (len - drop);
  232|     44|        fill = 1U << curr;
  233|     44|        min = fill;                 /* save offset to next table */
  234|    136|        do {
  235|    136|            fill -= incr;
  236|    136|            next[(huff >> drop) + fill] = here;
  237|    136|        } while (fill != 0);
  238|       |
  239|       |        /* backwards increment the len-bit code huff */
  240|     44|        incr = 1U << (len - 1);
  241|     79|        while (huff & incr)
  242|     35|            incr >>= 1;
  243|     44|        if (incr != 0) {
  244|     35|            huff &= incr - 1;
  245|     35|            huff += incr;
  246|     35|        }
  247|      9|        else
  248|      9|            huff = 0;
  249|       |
  250|       |        /* go to next symbol, update count, len */
  251|     44|        sym++;
  252|     44|        if (--(count[len]) == 0) {
  253|     35|            if (len == max) break;
  254|     26|            len = lens[work[sym]];
  255|     26|        }
  256|       |
  257|       |        /* create new sub-table if needed */
  258|     35|        if (len > root && (huff & mask) != low) {
  259|       |            /* if first time, transition to sub-tables */
  260|      0|            if (drop == 0)
  261|      0|                drop = root;
  262|       |
  263|       |            /* increment past last table */
  264|      0|            next += min;            /* here min is 1 << curr */
  265|       |
  266|       |            /* determine length of next table */
  267|      0|            curr = len - drop;
  268|      0|            left = (int)(1 << curr);
  269|      0|            while (curr + drop < max) {
  270|      0|                left -= count[curr + drop];
  271|      0|                if (left <= 0) break;
  272|      0|                curr++;
  273|      0|                left <<= 1;
  274|      0|            }
  275|       |
  276|       |            /* check for enough space */
  277|      0|            used += 1U << curr;
  278|      0|            if ((type == LENS && used > ENOUGH_LENS) ||
  279|      0|                (type == DISTS && used > ENOUGH_DISTS))
  280|      0|                return 1;
  281|       |
  282|       |            /* point entry in root table to sub-table */
  283|      0|            low = huff & mask;
  284|      0|            (*table)[low].op = (unsigned char)curr;
  285|      0|            (*table)[low].bits = (unsigned char)root;
  286|      0|            (*table)[low].val = (unsigned short)(next - *table);
  287|      0|        }
  288|     35|    }
  289|       |
  290|       |    /* fill in remaining table entry if code is incomplete (guaranteed to have
  291|       |       at most one remaining entry, since if the code is incomplete, the
  292|       |       maximum code length that was allowed to get this far is one bit) */
  293|      9|    if (huff != 0) {
  294|      0|        here.op = (unsigned char)64;            /* invalid code marker */
  295|      0|        here.bits = (unsigned char)(len - drop);
  296|      0|        here.val = (unsigned short)0;
  297|      0|        next[huff] = here;
  298|      0|    }
  299|       |
  300|       |    /* set return parameters */
  301|      9|    *table += used;
  302|      9|    *bits = root;
  303|      9|    return 0;
  304|      9|}

zlibVersion:
   28|    105|{
   29|    105|    return ZLIB_VERSION;
   30|    105|}

