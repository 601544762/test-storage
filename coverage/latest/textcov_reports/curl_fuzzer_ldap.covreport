easy.c:sigpipe_ignore:
   44|    597|{
   45|       |  /* get a local copy of no_signal because the Curl_easy might not be
   46|       |     around when we restore */
   47|    597|  ig->no_signal = data->set.no_signal;
   48|    597|  if(!data->set.no_signal) {
   49|    597|    struct sigaction action;
   50|       |    /* first, extract the existing situation */
   51|    597|    memset(&ig->old_pipe_act, 0, sizeof(struct sigaction));
   52|    597|    sigaction(SIGPIPE, NULL, &ig->old_pipe_act);
   53|    597|    action = ig->old_pipe_act;
   54|       |    /* ignore this signal */
   55|    597|    action.sa_handler = SIG_IGN;
   56|    597|    sigaction(SIGPIPE, &action, NULL);
   57|    597|  }
   58|    597|}
easy.c:sigpipe_restore:
   66|    597|{
   67|    597|  if(!ig->no_signal)
   68|       |    /* restore the outside state */
   69|    597|    sigaction(SIGPIPE, &ig->old_pipe_act, NULL);
   70|    597|}
multi.c:sigpipe_ignore:
   44|    462|{
   45|       |  /* get a local copy of no_signal because the Curl_easy might not be
   46|       |     around when we restore */
   47|    462|  ig->no_signal = data->set.no_signal;
   48|    462|  if(!data->set.no_signal) {
   49|    462|    struct sigaction action;
   50|       |    /* first, extract the existing situation */
   51|    462|    memset(&ig->old_pipe_act, 0, sizeof(struct sigaction));
   52|    462|    sigaction(SIGPIPE, NULL, &ig->old_pipe_act);
   53|    462|    action = ig->old_pipe_act;
   54|       |    /* ignore this signal */
   55|    462|    action.sa_handler = SIG_IGN;
   56|    462|    sigaction(SIGPIPE, &action, NULL);
   57|    462|  }
   58|    462|}
multi.c:sigpipe_restore:
   66|    462|{
   67|    462|  if(!ig->no_signal)
   68|       |    /* restore the outside state */
   69|    462|    sigaction(SIGPIPE, &ig->old_pipe_act, NULL);
   70|    462|}
conncache.c:sigpipe_ignore:
   44|    462|{
   45|       |  /* get a local copy of no_signal because the Curl_easy might not be
   46|       |     around when we restore */
   47|    462|  ig->no_signal = data->set.no_signal;
   48|    462|  if(!data->set.no_signal) {
   49|    462|    struct sigaction action;
   50|       |    /* first, extract the existing situation */
   51|    462|    memset(&ig->old_pipe_act, 0, sizeof(struct sigaction));
   52|    462|    sigaction(SIGPIPE, NULL, &ig->old_pipe_act);
   53|    462|    action = ig->old_pipe_act;
   54|       |    /* ignore this signal */
   55|    462|    action.sa_handler = SIG_IGN;
   56|    462|    sigaction(SIGPIPE, &action, NULL);
   57|    462|  }
   58|    462|}
conncache.c:sigpipe_restore:
   66|    462|{
   67|    462|  if(!ig->no_signal)
   68|       |    /* restore the outside state */
   69|    462|    sigaction(SIGPIPE, &ig->old_pipe_act, NULL);
   70|    462|}

Curl_altsvc_cleanup:
  306|  1.05k|{
  307|  1.05k|  struct Curl_llist_element *e;
  308|  1.05k|  struct Curl_llist_element *n;
  309|  1.05k|  if(*altsvcp) {
  310|      0|    struct altsvcinfo *altsvc = *altsvcp;
  311|      0|    for(e = altsvc->list.head; e; e = n) {
  312|      0|      struct altsvc *as = e->ptr;
  313|      0|      n = e->next;
  314|      0|      altsvc_free(as);
  315|      0|    }
  316|      0|    free(altsvc->filename);
  317|      0|    free(altsvc);
  318|      0|    *altsvcp = NULL; /* clear the pointer */
  319|      0|  }
  320|  1.05k|}
Curl_altsvc_save:
  327|  1.05k|{
  328|  1.05k|  struct Curl_llist_element *e;
  329|  1.05k|  struct Curl_llist_element *n;
  330|  1.05k|  CURLcode result = CURLE_OK;
  331|  1.05k|  FILE *out;
  332|  1.05k|  char *tempstore;
  333|  1.05k|  unsigned char randsuffix[9];
  334|       |
  335|  1.05k|  if(!altsvc)
  336|       |    /* no cache activated */
  337|  1.05k|    return CURLE_OK;
  338|       |
  339|       |  /* if not new name is given, use the one we stored from the load */
  340|      0|  if(!file && altsvc->filename)
  341|      0|    file = altsvc->filename;
  342|       |
  343|      0|  if((altsvc->flags & CURLALTSVC_READONLYFILE) || !file || !file[0])
  344|       |    /* marked as read-only, no file or zero length file name */
  345|      0|    return CURLE_OK;
  346|       |
  347|      0|  if(Curl_rand_hex(data, randsuffix, sizeof(randsuffix)))
  348|      0|    return CURLE_FAILED_INIT;
  349|       |
  350|      0|  tempstore = aprintf("%s.%s.tmp", file, randsuffix);
  351|      0|  if(!tempstore)
  352|      0|    return CURLE_OUT_OF_MEMORY;
  353|       |
  354|      0|  out = fopen(tempstore, FOPEN_WRITETEXT);
  355|      0|  if(!out)
  356|      0|    result = CURLE_WRITE_ERROR;
  357|      0|  else {
  358|      0|    fputs("# Your alt-svc cache. https://curl.se/docs/alt-svc.html\n"
  359|      0|          "# This file was generated by libcurl! Edit at your own risk.\n",
  360|      0|          out);
  361|      0|    for(e = altsvc->list.head; e; e = n) {
  362|      0|      struct altsvc *as = e->ptr;
  363|      0|      n = e->next;
  364|      0|      result = altsvc_out(as, out);
  365|      0|      if(result)
  366|      0|        break;
  367|      0|    }
  368|      0|    fclose(out);
  369|      0|    if(!result && Curl_rename(tempstore, file))
  370|      0|      result = CURLE_WRITE_ERROR;
  371|       |
  372|      0|    if(result)
  373|      0|      unlink(tempstore);
  374|      0|  }
  375|      0|  free(tempstore);
  376|      0|  return result;
  377|      0|}

Curl_resolver_global_init:
   92|      1|{
   93|      1|  return CURLE_OK;
   94|      1|}
Curl_resolver_init:
  112|  1.05k|{
  113|  1.05k|  (void)easy;
  114|  1.05k|  *resolver = calloc(1, sizeof(struct resdata));
  115|  1.05k|  if(!*resolver)
  116|      0|    return CURLE_OUT_OF_MEMORY;
  117|  1.05k|  return CURLE_OK;
  118|  1.05k|}
Curl_resolver_cleanup:
  127|  1.05k|{
  128|  1.05k|  free(resolver);
  129|  1.05k|}
Curl_resolver_cancel:
  148|    253|{
  149|    253|  destroy_async_data(&data->state.async);
  150|    253|}
asyn-thread.c:destroy_async_data:
  380|    253|{
  381|    253|  if(async->tdata) {
  382|      0|    struct thread_data *td = async->tdata;
  383|      0|    int done;
  384|      0|#ifndef CURL_DISABLE_SOCKETPAIR
  385|      0|    curl_socket_t sock_rd = td->tsd.sock_pair[0];
  386|      0|    struct Curl_easy *data = td->tsd.data;
  387|      0|#endif
  388|       |
  389|       |    /*
  390|       |     * if the thread is still blocking in the resolve syscall, detach it and
  391|       |     * let the thread do the cleanup...
  392|       |     */
  393|      0|    Curl_mutex_acquire(td->tsd.mtx);
  394|      0|    done = td->tsd.done;
  395|      0|    td->tsd.done = 1;
  396|      0|    Curl_mutex_release(td->tsd.mtx);
  397|       |
  398|      0|    if(!done) {
  399|      0|      Curl_thread_destroy(td->thread_hnd);
  400|      0|    }
  401|      0|    else {
  402|      0|      if(td->thread_hnd != curl_thread_t_null)
  403|      0|        Curl_thread_join(&td->thread_hnd);
  404|       |
  405|      0|      destroy_thread_sync_data(&td->tsd);
  406|       |
  407|      0|      free(async->tdata);
  408|      0|    }
  409|      0|#ifndef CURL_DISABLE_SOCKETPAIR
  410|       |    /*
  411|       |     * ensure CURLMOPT_SOCKETFUNCTION fires CURL_POLL_REMOVE
  412|       |     * before the FD is invalidated to avoid EBADF on EPOLL_CTL_DEL
  413|       |     */
  414|      0|    Curl_multi_closed(data, sock_rd);
  415|      0|    sclose(sock_rd);
  416|      0|#endif
  417|      0|  }
  418|    253|  async->tdata = NULL;
  419|       |
  420|    253|  free(async->hostname);
  421|    253|  async->hostname = NULL;
  422|    253|}

Curl_conncache_init:
  115|    462|{
  116|    462|  int rc;
  117|       |
  118|       |  /* allocate a new easy handle to use when closing cached connections */
  119|    462|  connc->closure_handle = curl_easy_init();
  120|    462|  if(!connc->closure_handle)
  121|      0|    return 1; /* bad */
  122|       |
  123|    462|  rc = Curl_hash_init(&connc->hash, size, Curl_hash_str,
  124|    462|                      Curl_str_key_compare, free_bundle_hash_entry);
  125|    462|  if(rc)
  126|      0|    Curl_close(&connc->closure_handle);
  127|    462|  else
  128|    462|    connc->closure_handle->state.conn_cache = connc;
  129|       |
  130|    462|  return rc;
  131|    462|}
Curl_conncache_destroy:
  134|    462|{
  135|    462|  if(connc)
  136|    462|    Curl_hash_destroy(&connc->hash);
  137|    462|}
Curl_conncache_remove_conn:
  287|    253|{
  288|    253|  struct connectbundle *bundle = conn->bundle;
  289|    253|  struct conncache *connc = data->state.conn_cache;
  290|       |
  291|       |  /* The bundle pointer can be NULL, since this function can be called
  292|       |     due to a failed connection attempt, before being added to a bundle */
  293|    253|  if(bundle) {
  294|      0|    if(lock) {
  295|      0|      CONNCACHE_LOCK(data);
  296|      0|    }
  297|      0|    bundle_remove_conn(bundle, conn);
  298|      0|    if(bundle->num_connections == 0)
  299|      0|      conncache_remove_bundle(connc, bundle);
  300|      0|    conn->bundle = NULL; /* removed from it */
  301|      0|    if(connc) {
  302|      0|      connc->num_conn--;
  303|      0|      DEBUGF(infof(data, "The cache now contains %zu members",
  304|      0|                   connc->num_conn));
  305|      0|    }
  306|      0|    if(lock) {
  307|      0|      CONNCACHE_UNLOCK(data);
  308|      0|    }
  309|      0|  }
  310|    253|}
Curl_conncache_close_all_connections:
  540|    462|{
  541|    462|  struct connectdata *conn;
  542|    462|  char buffer[READBUFFER_MIN + 1];
  543|    462|  if(!connc->closure_handle)
  544|      0|    return;
  545|    462|  connc->closure_handle->state.buffer = buffer;
  546|    462|  connc->closure_handle->set.buffer_size = READBUFFER_MIN;
  547|       |
  548|    462|  conn = conncache_find_first_connection(connc);
  549|    462|  while(conn) {
  550|      0|    SIGPIPE_VARIABLE(pipe_st);
  551|      0|    sigpipe_ignore(connc->closure_handle, &pipe_st);
  552|       |    /* This will remove the connection from the cache */
  553|      0|    connclose(conn, "kill all");
  554|      0|    Curl_conncache_remove_conn(connc->closure_handle, conn, TRUE);
  555|      0|    (void)Curl_disconnect(connc->closure_handle, conn, FALSE);
  556|      0|    sigpipe_restore(&pipe_st);
  557|       |
  558|      0|    conn = conncache_find_first_connection(connc);
  559|      0|  }
  560|       |
  561|    462|  connc->closure_handle->state.buffer = NULL;
  562|    462|  if(connc->closure_handle) {
  563|    462|    SIGPIPE_VARIABLE(pipe_st);
  564|    462|    sigpipe_ignore(connc->closure_handle, &pipe_st);
  565|       |
  566|    462|    Curl_hostcache_clean(connc->closure_handle,
  567|    462|                         connc->closure_handle->dns.hostcache);
  568|    462|    Curl_close(&connc->closure_handle);
  569|    462|    sigpipe_restore(&pipe_st);
  570|    462|  }
  571|    462|}
conncache.c:conncache_find_first_connection:
  372|    462|{
  373|    462|  struct Curl_hash_iterator iter;
  374|    462|  struct Curl_hash_element *he;
  375|    462|  struct connectbundle *bundle;
  376|       |
  377|    462|  Curl_hash_start_iterate(&connc->hash, &iter);
  378|       |
  379|    462|  he = Curl_hash_next_element(&iter);
  380|    462|  while(he) {
  381|      0|    struct Curl_llist_element *curr;
  382|      0|    bundle = he->ptr;
  383|       |
  384|      0|    curr = bundle->conn_list.head;
  385|      0|    if(curr) {
  386|      0|      return curr->ptr;
  387|      0|    }
  388|       |
  389|      0|    he = Curl_hash_next_element(&iter);
  390|      0|  }
  391|       |
  392|    462|  return NULL;
  393|    462|}

Curl_conncontrol:
 1645|    253|{
 1646|       |  /* close if a connection, or a stream that isn't multiplexed. */
 1647|       |  /* This function will be called both before and after this connection is
 1648|       |     associated with a transfer. */
 1649|    253|  bool closeit;
 1650|    253|  DEBUGASSERT(conn);
 1651|    253|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
 1652|    253|  (void)reason; /* useful for debugging */
 1653|    253|#endif
 1654|    253|  closeit = (ctrl == CONNCTRL_CONNECTION) ||
 1655|    253|    ((ctrl == CONNCTRL_STREAM) && !(conn->handler->flags & PROTOPT_STREAM));
 1656|    253|  if((ctrl == CONNCTRL_STREAM) &&
 1657|    253|     (conn->handler->flags & PROTOPT_STREAM))
 1658|      0|    ;
 1659|    253|  else if((bit)closeit != conn->bits.close) {
 1660|    253|    conn->bits.close = closeit; /* the only place in the source code that
 1661|       |                                   should assign this bit */
 1662|    253|  }
 1663|    253|}

Curl_all_content_encodings:
  853|      7|{
  854|      7|  size_t len = 0;
  855|      7|  const struct content_encoding * const *cep;
  856|      7|  const struct content_encoding *ce;
  857|      7|  char *ace;
  858|       |
  859|     28|  for(cep = encodings; *cep; cep++) {
  860|     21|    ce = *cep;
  861|     21|    if(!strcasecompare(ce->name, CONTENT_ENCODING_DEFAULT))
  862|     14|      len += strlen(ce->name) + 2;
  863|     21|  }
  864|       |
  865|      7|  if(!len)
  866|      0|    return strdup(CONTENT_ENCODING_DEFAULT);
  867|       |
  868|      7|  ace = malloc(len);
  869|      7|  if(ace) {
  870|      7|    char *p = ace;
  871|     28|    for(cep = encodings; *cep; cep++) {
  872|     21|      ce = *cep;
  873|     21|      if(!strcasecompare(ce->name, CONTENT_ENCODING_DEFAULT)) {
  874|     14|        strcpy(p, ce->name);
  875|     14|        p += strlen(p);
  876|     14|        *p++ = ',';
  877|     14|        *p++ = ' ';
  878|     14|      }
  879|     21|    }
  880|      7|    p[-2] = '\0';
  881|      7|  }
  882|       |
  883|      7|  return ace;
  884|      7|}

Curl_cookie_init:
 1161|    462|{
 1162|    462|  struct CookieInfo *c;
 1163|    462|  FILE *fp = NULL;
 1164|    462|  bool fromfile = TRUE;
 1165|    462|  char *line = NULL;
 1166|       |
 1167|    462|  if(NULL == inc) {
 1168|       |    /* we didn't get a struct, create one */
 1169|    462|    c = calloc(1, sizeof(struct CookieInfo));
 1170|    462|    if(!c)
 1171|      0|      return NULL; /* failed to get memory */
 1172|    462|    c->filename = strdup(file?file:"none"); /* copy the name just in case */
 1173|    462|    if(!c->filename)
 1174|      0|      goto fail; /* failed to get memory */
 1175|       |    /*
 1176|       |     * Initialize the next_expiration time to signal that we don't have enough
 1177|       |     * information yet.
 1178|       |     */
 1179|    462|    c->next_expiration = CURL_OFF_T_MAX;
 1180|    462|  }
 1181|      0|  else {
 1182|       |    /* we got an already existing one, use that */
 1183|      0|    c = inc;
 1184|      0|  }
 1185|    462|  c->running = FALSE; /* this is not running, this is init */
 1186|       |
 1187|    462|  if(file && !strcmp(file, "-")) {
 1188|      0|    fp = stdin;
 1189|      0|    fromfile = FALSE;
 1190|      0|  }
 1191|    462|  else if(file && !*file) {
 1192|       |    /* points to a "" string */
 1193|      0|    fp = NULL;
 1194|      0|  }
 1195|    462|  else
 1196|    462|    fp = file?fopen(file, FOPEN_READTEXT):NULL;
 1197|       |
 1198|    462|  c->newsession = newsession; /* new session? */
 1199|       |
 1200|    462|  if(fp) {
 1201|      0|    char *lineptr;
 1202|      0|    bool headerline;
 1203|       |
 1204|      0|    line = malloc(MAX_COOKIE_LINE);
 1205|      0|    if(!line)
 1206|      0|      goto fail;
 1207|      0|    while(Curl_get_line(line, MAX_COOKIE_LINE, fp)) {
 1208|      0|      if(checkprefix("Set-Cookie:", line)) {
 1209|       |        /* This is a cookie line, get it! */
 1210|      0|        lineptr = &line[11];
 1211|      0|        headerline = TRUE;
 1212|      0|      }
 1213|      0|      else {
 1214|      0|        lineptr = line;
 1215|      0|        headerline = FALSE;
 1216|      0|      }
 1217|      0|      while(*lineptr && ISBLANK(*lineptr))
 1218|      0|        lineptr++;
 1219|       |
 1220|      0|      Curl_cookie_add(data, c, headerline, TRUE, lineptr, NULL, NULL, TRUE);
 1221|      0|    }
 1222|      0|    free(line); /* free the line buffer */
 1223|       |
 1224|       |    /*
 1225|       |     * Remove expired cookies from the hash. We must make sure to run this
 1226|       |     * after reading the file, and not on every cookie.
 1227|       |     */
 1228|      0|    remove_expired(c);
 1229|       |
 1230|      0|    if(fromfile)
 1231|      0|      fclose(fp);
 1232|      0|  }
 1233|       |
 1234|    462|  c->running = TRUE;          /* now, we're running */
 1235|    462|  if(data)
 1236|    462|    data->state.cookie_engine = TRUE;
 1237|       |
 1238|    462|  return c;
 1239|       |
 1240|      0|fail:
 1241|      0|  free(line);
 1242|       |  /*
 1243|       |   * Only clean up if we allocated it here, as the original could still be in
 1244|       |   * use by a share handle.
 1245|       |   */
 1246|      0|  if(!inc)
 1247|      0|    Curl_cookie_cleanup(c);
 1248|      0|  if(fromfile && fp)
 1249|      0|    fclose(fp);
 1250|      0|  return NULL; /* out of memory */
 1251|    462|}
Curl_cookie_freelist:
 1476|   118k|{
 1477|   118k|  struct Cookie *next;
 1478|   118k|  while(co) {
 1479|      0|    next = co->next;
 1480|      0|    freecookie(co);
 1481|      0|    co = next;
 1482|      0|  }
 1483|   118k|}
Curl_cookie_cleanup:
 1532|  1.05k|{
 1533|  1.05k|  if(c) {
 1534|    462|    unsigned int i;
 1535|    462|    free(c->filename);
 1536|   118k|    for(i = 0; i < COOKIE_HASH_SIZE; i++)
 1537|   118k|      Curl_cookie_freelist(c->cookies[i]);
 1538|    462|    free(c); /* free the base struct as well */
 1539|    462|  }
 1540|  1.05k|}
Curl_flush_cookies:
 1730|  1.05k|{
 1731|  1.05k|  CURLcode res;
 1732|       |
 1733|  1.05k|  if(data->set.str[STRING_COOKIEJAR]) {
 1734|    462|    if(data->state.cookielist) {
 1735|       |      /* If there is a list of cookie files to read, do it first so that
 1736|       |         we have all the told files read before we write the new jar.
 1737|       |         Curl_cookie_loadfiles() LOCKS and UNLOCKS the share itself! */
 1738|      0|      Curl_cookie_loadfiles(data);
 1739|      0|    }
 1740|       |
 1741|    462|    Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
 1742|       |
 1743|       |    /* if we have a destination file for all the cookies to get dumped to */
 1744|    462|    res = cookie_output(data, data->cookies, data->set.str[STRING_COOKIEJAR]);
 1745|    462|    if(res)
 1746|      0|      infof(data, "WARNING: failed to save cookies in %s: %s",
 1747|      0|            data->set.str[STRING_COOKIEJAR], curl_easy_strerror(res));
 1748|    462|  }
 1749|    597|  else {
 1750|    597|    if(cleanup && data->state.cookielist) {
 1751|       |      /* since nothing is written, we can just free the list of cookie file
 1752|       |         names */
 1753|      0|      curl_slist_free_all(data->state.cookielist); /* clean up list */
 1754|      0|      data->state.cookielist = NULL;
 1755|      0|    }
 1756|    597|    Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
 1757|    597|  }
 1758|       |
 1759|  1.05k|  if(cleanup && (!data->share || (data->cookies != data->share->cookies))) {
 1760|  1.05k|    Curl_cookie_cleanup(data->cookies);
 1761|  1.05k|    data->cookies = NULL;
 1762|  1.05k|  }
 1763|  1.05k|  Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
 1764|  1.05k|}
cookie.c:remove_expired:
  379|    462|{
  380|    462|  struct Cookie *co, *nx;
  381|    462|  curl_off_t now = (curl_off_t)time(NULL);
  382|    462|  unsigned int i;
  383|       |
  384|       |  /*
  385|       |   * If the earliest expiration timestamp in the jar is in the future we can
  386|       |   * skip scanning the whole jar and instead exit early as there won't be any
  387|       |   * cookies to evict.  If we need to evict however, reset the next_expiration
  388|       |   * counter in order to track the next one. In case the recorded first
  389|       |   * expiration is the max offset, then perform the safe fallback of checking
  390|       |   * all cookies.
  391|       |   */
  392|    462|  if(now < cookies->next_expiration &&
  393|    462|      cookies->next_expiration != CURL_OFF_T_MAX)
  394|      0|    return;
  395|    462|  else
  396|    462|    cookies->next_expiration = CURL_OFF_T_MAX;
  397|       |
  398|   118k|  for(i = 0; i < COOKIE_HASH_SIZE; i++) {
  399|   118k|    struct Cookie *pv = NULL;
  400|   118k|    co = cookies->cookies[i];
  401|   118k|    while(co) {
  402|      0|      nx = co->next;
  403|      0|      if(co->expires && co->expires < now) {
  404|      0|        if(!pv) {
  405|      0|          cookies->cookies[i] = co->next;
  406|      0|        }
  407|      0|        else {
  408|      0|          pv->next = co->next;
  409|      0|        }
  410|      0|        cookies->numcookies--;
  411|      0|        freecookie(co);
  412|      0|      }
  413|      0|      else {
  414|       |        /*
  415|       |         * If this cookie has an expiration timestamp earlier than what we've
  416|       |         * seen so far then record it for the next round of expirations.
  417|       |         */
  418|      0|        if(co->expires && co->expires < cookies->next_expiration)
  419|      0|          cookies->next_expiration = co->expires;
  420|      0|        pv = co;
  421|      0|      }
  422|      0|      co = nx;
  423|      0|    }
  424|   118k|  }
  425|    462|}
cookie.c:cookie_output:
 1585|    462|{
 1586|    462|  struct Cookie *co;
 1587|    462|  FILE *out = NULL;
 1588|    462|  bool use_stdout = FALSE;
 1589|    462|  char *tempstore = NULL;
 1590|    462|  CURLcode error = CURLE_OK;
 1591|       |
 1592|    462|  if(!c)
 1593|       |    /* no cookie engine alive */
 1594|      0|    return CURLE_OK;
 1595|       |
 1596|       |  /* at first, remove expired cookies */
 1597|    462|  remove_expired(c);
 1598|       |
 1599|    462|  if(!strcmp("-", filename)) {
 1600|       |    /* use stdout */
 1601|      0|    out = stdout;
 1602|      0|    use_stdout = TRUE;
 1603|      0|  }
 1604|    462|  else {
 1605|    462|    unsigned char randsuffix[9];
 1606|       |
 1607|    462|    if(Curl_rand_hex(data, randsuffix, sizeof(randsuffix)))
 1608|      0|      return 2;
 1609|       |
 1610|    462|    tempstore = aprintf("%s.%s.tmp", filename, randsuffix);
 1611|    462|    if(!tempstore)
 1612|      0|      return CURLE_OUT_OF_MEMORY;
 1613|       |
 1614|    462|    out = fopen(tempstore, FOPEN_WRITETEXT);
 1615|    462|    if(!out) {
 1616|      0|      error = CURLE_WRITE_ERROR;
 1617|      0|      goto error;
 1618|      0|    }
 1619|    462|  }
 1620|       |
 1621|    462|  fputs("# Netscape HTTP Cookie File\n"
 1622|    462|        "# https://curl.se/docs/http-cookies.html\n"
 1623|    462|        "# This file was generated by libcurl! Edit at your own risk.\n\n",
 1624|    462|        out);
 1625|       |
 1626|    462|  if(c->numcookies) {
 1627|      0|    unsigned int i;
 1628|      0|    size_t nvalid = 0;
 1629|      0|    struct Cookie **array;
 1630|       |
 1631|      0|    array = calloc(1, sizeof(struct Cookie *) * c->numcookies);
 1632|      0|    if(!array) {
 1633|      0|      error = CURLE_OUT_OF_MEMORY;
 1634|      0|      goto error;
 1635|      0|    }
 1636|       |
 1637|       |    /* only sort the cookies with a domain property */
 1638|      0|    for(i = 0; i < COOKIE_HASH_SIZE; i++) {
 1639|      0|      for(co = c->cookies[i]; co; co = co->next) {
 1640|      0|        if(!co->domain)
 1641|      0|          continue;
 1642|      0|        array[nvalid++] = co;
 1643|      0|      }
 1644|      0|    }
 1645|       |
 1646|      0|    qsort(array, nvalid, sizeof(struct Cookie *), cookie_sort_ct);
 1647|       |
 1648|      0|    for(i = 0; i < nvalid; i++) {
 1649|      0|      char *format_ptr = get_netscape_format(array[i]);
 1650|      0|      if(!format_ptr) {
 1651|      0|        free(array);
 1652|      0|        error = CURLE_OUT_OF_MEMORY;
 1653|      0|        goto error;
 1654|      0|      }
 1655|      0|      fprintf(out, "%s\n", format_ptr);
 1656|      0|      free(format_ptr);
 1657|      0|    }
 1658|       |
 1659|      0|    free(array);
 1660|      0|  }
 1661|       |
 1662|    462|  if(!use_stdout) {
 1663|    462|    fclose(out);
 1664|    462|    out = NULL;
 1665|    462|    if(Curl_rename(tempstore, filename)) {
 1666|      0|      unlink(tempstore);
 1667|      0|      error = CURLE_WRITE_ERROR;
 1668|      0|      goto error;
 1669|      0|    }
 1670|    462|  }
 1671|       |
 1672|       |  /*
 1673|       |   * If we reach here we have successfully written a cookie file so theree is
 1674|       |   * no need to inspect the error, any error case should have jumped into the
 1675|       |   * error block below.
 1676|       |   */
 1677|    462|  free(tempstore);
 1678|    462|  return CURLE_OK;
 1679|       |
 1680|      0|error:
 1681|      0|  if(out && !use_stdout)
 1682|      0|    fclose(out);
 1683|      0|  free(tempstore);
 1684|      0|  return error;
 1685|    462|}

Curl_isdigit:
   71|  7.22k|{
   72|  7.22k|  if((c < 0) || (c >= 0x80))
   73|      2|    return FALSE;
   74|  7.22k|  return (ascii[c] & _N);
   75|  7.22k|}
Curl_isalnum:
   78|  1.96k|{
   79|  1.96k|  if((c < 0) || (c >= 0x80))
   80|     96|    return FALSE;
   81|  1.86k|  return (ascii[c] & (_N|_U|_L));
   82|  1.96k|}
Curl_isxdigit:
   85|    365|{
   86|    365|  if((c < 0) || (c >= 0x80))
   87|     14|    return FALSE;
   88|    351|  return (ascii[c] & (_N|_X));
   89|    365|}

Curl_http_auth_cleanup_ntlm_wb:
  493|    253|{
  494|    253|  ntlm_wb_cleanup(&conn->ntlm);
  495|    253|  ntlm_wb_cleanup(&conn->proxyntlm);
  496|    253|}
curl_ntlm_wb.c:ntlm_wb_cleanup:
   80|    506|{
   81|    506|  if(ntlm->ntlm_auth_hlpr_socket != CURL_SOCKET_BAD) {
   82|      0|    sclose(ntlm->ntlm_auth_hlpr_socket);
   83|      0|    ntlm->ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;
   84|      0|  }
   85|       |
   86|    506|  if(ntlm->ntlm_auth_hlpr_pid) {
   87|      0|    int i;
   88|      0|    for(i = 0; i < 4; i++) {
   89|      0|      pid_t ret = waitpid(ntlm->ntlm_auth_hlpr_pid, NULL, WNOHANG);
   90|      0|      if(ret == ntlm->ntlm_auth_hlpr_pid || errno == ECHILD)
   91|      0|        break;
   92|      0|      switch(i) {
   93|      0|      case 0:
   94|      0|        kill(ntlm->ntlm_auth_hlpr_pid, SIGTERM);
   95|      0|        break;
   96|      0|      case 1:
   97|       |        /* Give the process another moment to shut down cleanly before
   98|       |           bringing down the axe */
   99|      0|        Curl_wait_ms(1);
  100|      0|        break;
  101|      0|      case 2:
  102|      0|        kill(ntlm->ntlm_auth_hlpr_pid, SIGKILL);
  103|      0|        break;
  104|      0|      case 3:
  105|      0|        break;
  106|      0|      }
  107|      0|    }
  108|      0|    ntlm->ntlm_auth_hlpr_pid = 0;
  109|      0|  }
  110|       |
  111|    506|  Curl_safefree(ntlm->challenge);
  112|    506|  Curl_safefree(ntlm->response);
  113|    506|}

Curl_dedotdotify:
   54|     84|{
   55|     84|  size_t inlen = strlen(input);
   56|     84|  char *clone;
   57|     84|  size_t clen = inlen; /* the length of the cloned input */
   58|     84|  char *out = malloc(inlen + 1);
   59|     84|  char *outptr;
   60|     84|  char *orgclone;
   61|     84|  char *queryp;
   62|     84|  if(!out)
   63|      0|    return NULL; /* out of memory */
   64|       |
   65|     84|  *out = 0; /* null-terminates, for inputs like "./" */
   66|       |
   67|       |  /* get a cloned copy of the input */
   68|     84|  clone = strdup(input);
   69|     84|  if(!clone) {
   70|      0|    free(out);
   71|      0|    return NULL;
   72|      0|  }
   73|     84|  orgclone = clone;
   74|     84|  outptr = out;
   75|       |
   76|     84|  if(!*clone) {
   77|       |    /* zero length string, return that */
   78|      0|    free(out);
   79|      0|    return clone;
   80|      0|  }
   81|       |
   82|       |  /*
   83|       |   * To handle query-parts properly, we must find it and remove it during the
   84|       |   * dotdot-operation and then append it again at the end to the output
   85|       |   * string.
   86|       |   */
   87|     84|  queryp = strchr(clone, '?');
   88|     84|  if(queryp)
   89|      0|    *queryp = 0;
   90|       |
   91|    713|  do {
   92|       |
   93|       |    /*  A.  If the input buffer begins with a prefix of "../" or "./", then
   94|       |        remove that prefix from the input buffer; otherwise, */
   95|       |
   96|    713|    if(!strncmp("./", clone, 2)) {
   97|      0|      clone += 2;
   98|      0|      clen -= 2;
   99|      0|    }
  100|    713|    else if(!strncmp("../", clone, 3)) {
  101|      0|      clone += 3;
  102|      0|      clen -= 3;
  103|      0|    }
  104|       |
  105|       |    /*  B.  if the input buffer begins with a prefix of "/./" or "/.", where
  106|       |        "."  is a complete path segment, then replace that prefix with "/" in
  107|       |        the input buffer; otherwise, */
  108|    713|    else if(!strncmp("/./", clone, 3)) {
  109|     25|      clone += 2;
  110|     25|      clen -= 2;
  111|     25|    }
  112|    688|    else if(!strcmp("/.", clone)) {
  113|      3|      clone[1]='/';
  114|      3|      clone++;
  115|      3|      clen -= 1;
  116|      3|    }
  117|       |
  118|       |    /*  C.  if the input buffer begins with a prefix of "/../" or "/..", where
  119|       |        ".." is a complete path segment, then replace that prefix with "/" in
  120|       |        the input buffer and remove the last segment and its preceding "/" (if
  121|       |        any) from the output buffer; otherwise, */
  122|       |
  123|    685|    else if(!strncmp("/../", clone, 4)) {
  124|     65|      clone += 3;
  125|     65|      clen -= 3;
  126|       |      /* remove the last segment from the output buffer */
  127|    337|      while(outptr > out) {
  128|    327|        outptr--;
  129|    327|        if(*outptr == '/')
  130|     55|          break;
  131|    327|      }
  132|     65|      *outptr = 0; /* null-terminate where it stops */
  133|     65|    }
  134|    620|    else if(!strcmp("/..", clone)) {
  135|     18|      clone[2]='/';
  136|     18|      clone += 2;
  137|     18|      clen -= 2;
  138|       |      /* remove the last segment from the output buffer */
  139|  1.02k|      while(outptr > out) {
  140|  1.01k|        outptr--;
  141|  1.01k|        if(*outptr == '/')
  142|     17|          break;
  143|  1.01k|      }
  144|     18|      *outptr = 0; /* null-terminate where it stops */
  145|     18|    }
  146|       |
  147|       |    /*  D.  if the input buffer consists only of "." or "..", then remove
  148|       |        that from the input buffer; otherwise, */
  149|       |
  150|    602|    else if(!strcmp(".", clone) || !strcmp("..", clone)) {
  151|      0|      *clone = 0;
  152|      0|      *out = 0;
  153|      0|    }
  154|       |
  155|    602|    else {
  156|       |      /*  E.  move the first path segment in the input buffer to the end of
  157|       |          the output buffer, including the initial "/" character (if any) and
  158|       |          any subsequent characters up to, but not including, the next "/"
  159|       |          character or the end of the input buffer. */
  160|       |
  161|  3.26k|      do {
  162|  3.26k|        *outptr++ = *clone++;
  163|  3.26k|        clen--;
  164|  3.26k|      } while(*clone && (*clone != '/'));
  165|    602|      *outptr = 0;
  166|    602|    }
  167|       |
  168|    713|  } while(*clone);
  169|       |
  170|     84|  if(queryp) {
  171|      0|    size_t qlen;
  172|       |    /* There was a query part, append that to the output. The 'clone' string
  173|       |       may now have been altered so we copy from the original input string
  174|       |       from the correct index. */
  175|      0|    size_t oindex = queryp - orgclone;
  176|      0|    qlen = strlen(&input[oindex]);
  177|      0|    memcpy(outptr, &input[oindex], qlen + 1); /* include the end zero byte */
  178|      0|  }
  179|       |
  180|     84|  free(orgclone);
  181|     84|  return out;
  182|     84|}

Curl_dyn_init:
   39|  1.68k|{
   40|  1.68k|  DEBUGASSERT(s);
   41|  1.68k|  DEBUGASSERT(toobig);
   42|  1.68k|  s->bufr = NULL;
   43|  1.68k|  s->leng = 0;
   44|  1.68k|  s->allc = 0;
   45|  1.68k|  s->toobig = toobig;
   46|  1.68k|#ifdef DEBUGBUILD
   47|  1.68k|  s->init = DYNINIT;
   48|  1.68k|#endif
   49|  1.68k|}
Curl_dyn_free:
   56|  1.31k|{
   57|  1.31k|  DEBUGASSERT(s);
   58|  1.31k|  Curl_safefree(s->bufr);
   59|  1.31k|  s->leng = s->allc = 0;
   60|  1.31k|}
Curl_dyn_addn:
  160|  17.5k|{
  161|  17.5k|  DEBUGASSERT(s);
  162|  17.5k|  DEBUGASSERT(s->init == DYNINIT);
  163|  17.5k|  DEBUGASSERT(!s->leng || s->bufr);
  164|  17.5k|  return dyn_nappend(s, mem, len);
  165|  17.5k|}
Curl_dyn_ptr:
  228|    630|{
  229|    630|  DEBUGASSERT(s);
  230|    630|  DEBUGASSERT(s->init == DYNINIT);
  231|    630|  DEBUGASSERT(!s->leng || s->bufr);
  232|    630|  return s->bufr;
  233|    630|}
Curl_dyn_len:
  250|    630|{
  251|    630|  DEBUGASSERT(s);
  252|    630|  DEBUGASSERT(s->init == DYNINIT);
  253|    630|  DEBUGASSERT(!s->leng || s->bufr);
  254|    630|  return s->leng;
  255|    630|}
dynbuf.c:dyn_nappend:
   67|  17.5k|{
   68|  17.5k|  size_t indx = s->leng;
   69|  17.5k|  size_t a = s->allc;
   70|  17.5k|  size_t fit = len + indx + 1; /* new string + old string + zero byte */
   71|       |
   72|       |  /* try to detect if there's rubbish in the struct */
   73|  17.5k|  DEBUGASSERT(s->init == DYNINIT);
   74|  17.5k|  DEBUGASSERT(s->toobig);
   75|  17.5k|  DEBUGASSERT(indx < s->toobig);
   76|  17.5k|  DEBUGASSERT(!s->leng || s->bufr);
   77|       |
   78|  17.5k|  if(fit > s->toobig) {
   79|      0|    Curl_dyn_free(s);
   80|      0|    return CURLE_OUT_OF_MEMORY;
   81|      0|  }
   82|  17.5k|  else if(!a) {
   83|    630|    DEBUGASSERT(!indx);
   84|       |    /* first invoke */
   85|    630|    if(fit < MIN_FIRST_ALLOC)
   86|    630|      a = MIN_FIRST_ALLOC;
   87|      0|    else
   88|      0|      a = fit;
   89|    630|  }
   90|  16.9k|  else {
   91|  17.0k|    while(a < fit)
   92|     91|      a *= 2;
   93|  16.9k|  }
   94|       |
   95|  17.5k|  if(a != s->allc) {
   96|       |    /* this logic is not using Curl_saferealloc() to make the tool not have to
   97|       |       include that as well when it uses this code */
   98|    721|    void *p = realloc(s->bufr, a);
   99|    721|    if(!p) {
  100|      0|      Curl_safefree(s->bufr);
  101|      0|      s->leng = s->allc = 0;
  102|      0|      return CURLE_OUT_OF_MEMORY;
  103|      0|    }
  104|    721|    s->bufr = p;
  105|    721|    s->allc = a;
  106|    721|  }
  107|       |
  108|  17.5k|  if(len)
  109|  17.5k|    memcpy(&s->bufr[indx], mem, len);
  110|  17.5k|  s->leng = indx + len;
  111|  17.5k|  s->bufr[s->leng] = 0;
  112|  17.5k|  return CURLE_OK;
  113|  17.5k|}

curl_global_init:
  216|      1|{
  217|      1|  return global_init(flags, TRUE);
  218|      1|}
curl_easy_init:
  290|  1.05k|{
  291|  1.05k|  CURLcode result;
  292|  1.05k|  struct Curl_easy *data;
  293|       |
  294|       |  /* Make sure we inited the global SSL stuff */
  295|  1.05k|  if(!initialized) {
  296|      1|    result = curl_global_init(CURL_GLOBAL_DEFAULT);
  297|      1|    if(result) {
  298|       |      /* something in the global init failed, return nothing */
  299|      0|      DEBUGF(fprintf(stderr, "Error: curl_global_init failed\n"));
  300|      0|      return NULL;
  301|      0|    }
  302|      1|  }
  303|       |
  304|       |  /* We use curl_open() with undefined URL so far */
  305|  1.05k|  result = Curl_open(&data);
  306|  1.05k|  if(result) {
  307|      0|    DEBUGF(fprintf(stderr, "Error: Curl_open failed\n"));
  308|      0|    return NULL;
  309|      0|  }
  310|       |
  311|  1.05k|  return data;
  312|  1.05k|}
curl_easy_cleanup:
  735|    597|{
  736|    597|  SIGPIPE_VARIABLE(pipe_st);
  737|       |
  738|    597|  if(!data)
  739|      0|    return;
  740|       |
  741|    597|  sigpipe_ignore(data, &pipe_st);
  742|    597|  Curl_close(&data);
  743|    597|  sigpipe_restore(&pipe_st);
  744|    597|}
easy.c:global_init:
  136|      1|{
  137|      1|  if(initialized++)
  138|      0|    return CURLE_OK;
  139|       |
  140|      1|  if(memoryfuncs) {
  141|       |    /* Setup the default memory functions here (again) */
  142|      1|    Curl_cmalloc = (curl_malloc_callback)malloc;
  143|      1|    Curl_cfree = (curl_free_callback)free;
  144|      1|    Curl_crealloc = (curl_realloc_callback)realloc;
  145|      1|    Curl_cstrdup = (curl_strdup_callback)system_strdup;
  146|      1|    Curl_ccalloc = (curl_calloc_callback)calloc;
  147|       |#if defined(WIN32) && defined(UNICODE)
  148|       |    Curl_cwcsdup = (curl_wcsdup_callback)_wcsdup;
  149|       |#endif
  150|      1|  }
  151|       |
  152|      1|  if(!Curl_ssl_init()) {
  153|      0|    DEBUGF(fprintf(stderr, "Error: Curl_ssl_init failed\n"));
  154|      0|    goto fail;
  155|      0|  }
  156|       |
  157|       |#ifdef WIN32
  158|       |  if(Curl_win32_init(flags)) {
  159|       |    DEBUGF(fprintf(stderr, "Error: win32_init failed\n"));
  160|       |    goto fail;
  161|       |  }
  162|       |#endif
  163|       |
  164|       |#ifdef __AMIGA__
  165|       |  if(!Curl_amiga_init()) {
  166|       |    DEBUGF(fprintf(stderr, "Error: Curl_amiga_init failed\n"));
  167|       |    goto fail;
  168|       |  }
  169|       |#endif
  170|       |
  171|       |#ifdef NETWARE
  172|       |  if(netware_init()) {
  173|       |    DEBUGF(fprintf(stderr, "Warning: LONG namespace not available\n"));
  174|       |  }
  175|       |#endif
  176|       |
  177|      1|  if(Curl_resolver_global_init()) {
  178|      0|    DEBUGF(fprintf(stderr, "Error: resolver_global_init failed\n"));
  179|      0|    goto fail;
  180|      0|  }
  181|       |
  182|       |#if defined(USE_SSH)
  183|       |  if(Curl_ssh_init()) {
  184|       |    goto fail;
  185|       |  }
  186|       |#endif
  187|       |
  188|       |#ifdef USE_WOLFSSH
  189|       |  if(WS_SUCCESS != wolfSSH_Init()) {
  190|       |    DEBUGF(fprintf(stderr, "Error: wolfSSH_Init failed\n"));
  191|       |    return CURLE_FAILED_INIT;
  192|       |  }
  193|       |#endif
  194|       |
  195|      1|  init_flags = flags;
  196|       |
  197|      1|#ifdef DEBUGBUILD
  198|      1|  if(getenv("CURL_GLOBAL_INIT"))
  199|       |    /* alloc data that will leak if *cleanup() is not called! */
  200|      0|    leakpointer = malloc(1);
  201|      1|#endif
  202|       |
  203|      1|  return CURLE_OK;
  204|       |
  205|      0|  fail:
  206|      0|  initialized--; /* undo the increase */
  207|      0|  return CURLE_FAILED_INIT;
  208|      1|}

Curl_urldecode:
  146|     36|{
  147|     36|  size_t alloc;
  148|     36|  char *ns;
  149|     36|  size_t strindex = 0;
  150|     36|  unsigned long hex;
  151|     36|  CURLcode result = CURLE_OK;
  152|       |
  153|     36|  DEBUGASSERT(string);
  154|     36|  DEBUGASSERT(ctrl >= REJECT_NADA); /* crash on TRUE/FALSE */
  155|       |
  156|     36|  alloc = (length?length:strlen(string)) + 1;
  157|     36|  ns = malloc(alloc);
  158|       |
  159|     36|  if(!ns)
  160|      0|    return CURLE_OUT_OF_MEMORY;
  161|       |
  162|  1.04k|  while(--alloc > 0) {
  163|  1.00k|    unsigned char in = *string;
  164|  1.00k|    if(('%' == in) && (alloc > 2) &&
  165|  1.00k|       ISXDIGIT(string[1]) && ISXDIGIT(string[2])) {
  166|       |      /* this is two hexadecimal digits following a '%' */
  167|     54|      char hexstr[3];
  168|     54|      char *ptr;
  169|     54|      hexstr[0] = string[1];
  170|     54|      hexstr[1] = string[2];
  171|     54|      hexstr[2] = 0;
  172|       |
  173|     54|      hex = strtoul(hexstr, &ptr, 16);
  174|       |
  175|     54|      in = curlx_ultouc(hex); /* this long is never bigger than 255 anyway */
  176|       |
  177|     54|      if(data) {
  178|      0|        result = Curl_convert_from_network(data, (char *)&in, 1);
  179|      0|        if(result) {
  180|       |          /* Curl_convert_from_network calls failf if unsuccessful */
  181|      0|          free(ns);
  182|      0|          return result;
  183|      0|        }
  184|      0|      }
  185|       |
  186|     54|      string += 2;
  187|     54|      alloc -= 2;
  188|     54|    }
  189|       |
  190|  1.00k|    if(((ctrl == REJECT_CTRL) && (in < 0x20)) ||
  191|  1.00k|       ((ctrl == REJECT_ZERO) && (in == 0))) {
  192|      2|      free(ns);
  193|      2|      return CURLE_URL_MALFORMAT;
  194|      2|    }
  195|       |
  196|  1.00k|    ns[strindex++] = in;
  197|  1.00k|    string++;
  198|  1.00k|  }
  199|     34|  ns[strindex] = 0; /* terminate it */
  200|       |
  201|     34|  if(olen)
  202|       |    /* store output size */
  203|     34|    *olen = strindex;
  204|       |
  205|       |  /* store output string */
  206|     34|  *ostring = ns;
  207|       |
  208|     34|  return CURLE_OK;
  209|     36|}

curl_getenv:
   75|      1|{
   76|      1|  return GetEnv(v);
   77|      1|}
getenv.c:GetEnv:
   31|      1|{
   32|       |#if defined(_WIN32_WCE) || defined(CURL_WINDOWS_APP)
   33|       |  (void)variable;
   34|       |  return NULL;
   35|       |#elif defined(WIN32)
   36|       |  /* This uses Windows API instead of C runtime getenv() to get the environment
   37|       |     variable since some changes aren't always visible to the latter. #4774 */
   38|       |  char *buf = NULL;
   39|       |  char *tmp;
   40|       |  DWORD bufsize;
   41|       |  DWORD rc = 1;
   42|       |  const DWORD max = 32768; /* max env var size from MSCRT source */
   43|       |
   44|       |  for(;;) {
   45|       |    tmp = realloc(buf, rc);
   46|       |    if(!tmp) {
   47|       |      free(buf);
   48|       |      return NULL;
   49|       |    }
   50|       |
   51|       |    buf = tmp;
   52|       |    bufsize = rc;
   53|       |
   54|       |    /* It's possible for rc to be 0 if the variable was found but empty.
   55|       |       Since getenv doesn't make that distinction we ignore it as well. */
   56|       |    rc = GetEnvironmentVariableA(variable, buf, bufsize);
   57|       |    if(!rc || rc == bufsize || rc > max) {
   58|       |      free(buf);
   59|       |      return NULL;
   60|       |    }
   61|       |
   62|       |    /* if rc < bufsize then rc is bytes written not including null */
   63|       |    if(rc < bufsize)
   64|       |      return buf;
   65|       |
   66|       |    /* else rc is bytes needed, try again */
   67|       |  }
   68|       |#else
   69|      1|  char *env = getenv(variable);
   70|      1|  return (env && env[0])?strdup(env):NULL;
   71|      1|#endif
   72|      1|}

Curl_initinfo:
   46|  1.31k|{
   47|  1.31k|  struct Progress *pro = &data->progress;
   48|  1.31k|  struct PureInfo *info = &data->info;
   49|       |
   50|  1.31k|  pro->t_nslookup = 0;
   51|  1.31k|  pro->t_connect = 0;
   52|  1.31k|  pro->t_appconnect = 0;
   53|  1.31k|  pro->t_pretransfer = 0;
   54|  1.31k|  pro->t_starttransfer = 0;
   55|  1.31k|  pro->timespent = 0;
   56|  1.31k|  pro->t_redirect = 0;
   57|  1.31k|  pro->is_t_startransfer_set = false;
   58|       |
   59|  1.31k|  info->httpcode = 0;
   60|  1.31k|  info->httpproxycode = 0;
   61|  1.31k|  info->httpversion = 0;
   62|  1.31k|  info->filetime = -1; /* -1 is an illegal time and thus means unknown */
   63|  1.31k|  info->timecond = FALSE;
   64|       |
   65|  1.31k|  info->header_size = 0;
   66|  1.31k|  info->request_size = 0;
   67|  1.31k|  info->proxyauthavail = 0;
   68|  1.31k|  info->httpauthavail = 0;
   69|  1.31k|  info->numconnects = 0;
   70|       |
   71|  1.31k|  free(info->contenttype);
   72|  1.31k|  info->contenttype = NULL;
   73|       |
   74|  1.31k|  free(info->wouldredirect);
   75|  1.31k|  info->wouldredirect = NULL;
   76|       |
   77|  1.31k|  info->conn_primary_ip[0] = '\0';
   78|  1.31k|  info->conn_local_ip[0] = '\0';
   79|  1.31k|  info->conn_primary_port = 0;
   80|  1.31k|  info->conn_local_port = 0;
   81|  1.31k|  info->retry_after = 0;
   82|       |
   83|  1.31k|  info->conn_scheme = 0;
   84|  1.31k|  info->conn_protocol = 0;
   85|       |
   86|  1.31k|#ifdef USE_SSL
   87|  1.31k|  Curl_ssl_free_certinfo(data);
   88|  1.31k|#endif
   89|  1.31k|  return CURLE_OK;
   90|  1.31k|}

Curl_hash_init:
   62|  1.38k|{
   63|  1.38k|  if(!slots || !hfunc || !comparator ||!dtor) {
   64|      0|    return 1; /* failure */
   65|      0|  }
   66|       |
   67|  1.38k|  h->hash_func = hfunc;
   68|  1.38k|  h->comp_func = comparator;
   69|  1.38k|  h->dtor = dtor;
   70|  1.38k|  h->size = 0;
   71|  1.38k|  h->slots = slots;
   72|       |
   73|  1.38k|  h->table = malloc(slots * sizeof(struct Curl_llist));
   74|  1.38k|  if(h->table) {
   75|  1.38k|    int i;
   76|   470k|    for(i = 0; i < slots; ++i)
   77|   468k|      Curl_llist_init(&h->table[i], (Curl_llist_dtor) hash_element_dtor);
   78|  1.38k|    return 0; /* fine */
   79|  1.38k|  }
   80|      0|  h->slots = 0;
   81|      0|  return 1; /* failure */
   82|  1.38k|}
Curl_hash_destroy:
  206|  1.38k|{
  207|  1.38k|  int i;
  208|       |
  209|   470k|  for(i = 0; i < h->slots; ++i) {
  210|   468k|    Curl_llist_destroy(&h->table[i], (void *) h);
  211|   468k|  }
  212|       |
  213|  1.38k|  Curl_safefree(h->table);
  214|  1.38k|  h->size = 0;
  215|  1.38k|  h->slots = 0;
  216|  1.38k|}
Curl_hash_clean:
  224|    462|{
  225|    462|  Curl_hash_clean_with_criterium(h, NULL, NULL);
  226|    462|}
Curl_hash_clean_with_criterium:
  232|    462|{
  233|    462|  struct Curl_llist_element *le;
  234|    462|  struct Curl_llist_element *lnext;
  235|    462|  struct Curl_llist *list;
  236|    462|  int i;
  237|       |
  238|    462|  if(!h)
  239|    462|    return;
  240|       |
  241|      0|  for(i = 0; i < h->slots; ++i) {
  242|      0|    list = &h->table[i];
  243|      0|    le = list->head; /* get first list entry */
  244|      0|    while(le) {
  245|      0|      struct Curl_hash_element *he = le->ptr;
  246|      0|      lnext = le->next;
  247|       |      /* ask the callback function if we shall remove this entry or not */
  248|      0|      if(!comp || comp(user, he->ptr)) {
  249|      0|        Curl_llist_remove(list, le, (void *) h);
  250|      0|        --h->size; /* one less entry in the hash now */
  251|      0|      }
  252|      0|      le = lnext;
  253|      0|    }
  254|      0|  }
  255|      0|}
Curl_hash_start_iterate:
  282|    462|{
  283|    462|  iter->hash = hash;
  284|    462|  iter->slot_index = 0;
  285|    462|  iter->current_element = NULL;
  286|    462|}
Curl_hash_next_element:
  290|    462|{
  291|    462|  struct Curl_hash *h = iter->hash;
  292|       |
  293|       |  /* Get the next element in the current list, if any */
  294|    462|  if(iter->current_element)
  295|      0|    iter->current_element = iter->current_element->next;
  296|       |
  297|       |  /* If we have reached the end of the list, find the next one */
  298|    462|  if(!iter->current_element) {
  299|    462|    int i;
  300|  45.2k|    for(i = iter->slot_index; i < h->slots; i++) {
  301|  44.8k|      if(h->table[i].head) {
  302|      0|        iter->current_element = h->table[i].head;
  303|      0|        iter->slot_index = i + 1;
  304|      0|        break;
  305|      0|      }
  306|  44.8k|    }
  307|    462|  }
  308|       |
  309|    462|  if(iter->current_element) {
  310|      0|    struct Curl_hash_element *he = iter->current_element->ptr;
  311|      0|    return he;
  312|      0|  }
  313|    462|  iter->current_element = NULL;
  314|    462|  return NULL;
  315|    462|}

Curl_ipv6works:
  540|    462|{
  541|    462|  if(data) {
  542|       |    /* the nature of most system is that IPv6 status doesn't come and go
  543|       |       during a program's lifetime so we only probe the first time and then we
  544|       |       have the info kept for fast re-use */
  545|      0|    DEBUGASSERT(data);
  546|      0|    DEBUGASSERT(data->multi);
  547|      0|    return data->multi->ipv6_works;
  548|      0|  }
  549|    462|  else {
  550|    462|    int ipv6_works = -1;
  551|       |    /* probe to see if we have a working IPv6 stack */
  552|    462|    curl_socket_t s = socket(PF_INET6, SOCK_DGRAM, 0);
  553|    462|    if(s == CURL_SOCKET_BAD)
  554|       |      /* an IPv6 address was requested but we can't get/use one */
  555|      0|      ipv6_works = 0;
  556|    462|    else {
  557|    462|      ipv6_works = 1;
  558|    462|      sclose(s);
  559|    462|    }
  560|    462|    return (ipv6_works>0)?TRUE:FALSE;
  561|    462|  }
  562|    462|}
Curl_mk_dnscache:
  983|    462|{
  984|    462|  return Curl_hash_init(hash, 7, Curl_hash_str, Curl_str_key_compare,
  985|    462|                        freednsentry);
  986|    462|}
Curl_hostcache_clean:
  997|    462|{
  998|    462|  if(data && data->share)
  999|      0|    Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
 1000|       |
 1001|    462|  Curl_hash_clean(hash);
 1002|       |
 1003|    462|  if(data && data->share)
 1004|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_DNS);
 1005|    462|}

Curl_hsts_cleanup:
   90|  1.05k|{
   91|  1.05k|  struct hsts *h = *hp;
   92|  1.05k|  if(h) {
   93|      0|    struct Curl_llist_element *e;
   94|      0|    struct Curl_llist_element *n;
   95|      0|    for(e = h->list.head; e; e = n) {
   96|      0|      struct stsentry *sts = e->ptr;
   97|      0|      n = e->next;
   98|      0|      hsts_free(sts);
   99|      0|    }
  100|      0|    free(h->filename);
  101|      0|    free(h);
  102|      0|    *hp = NULL;
  103|      0|  }
  104|  1.05k|}
Curl_hsts_save:
  332|  1.05k|{
  333|  1.05k|  struct Curl_llist_element *e;
  334|  1.05k|  struct Curl_llist_element *n;
  335|  1.05k|  CURLcode result = CURLE_OK;
  336|  1.05k|  FILE *out;
  337|  1.05k|  char *tempstore;
  338|  1.05k|  unsigned char randsuffix[9];
  339|       |
  340|  1.05k|  if(!h)
  341|       |    /* no cache activated */
  342|  1.05k|    return CURLE_OK;
  343|       |
  344|       |  /* if no new name is given, use the one we stored from the load */
  345|      0|  if(!file && h->filename)
  346|      0|    file = h->filename;
  347|       |
  348|      0|  if((h->flags & CURLHSTS_READONLYFILE) || !file || !file[0])
  349|       |    /* marked as read-only, no file or zero length file name */
  350|      0|    goto skipsave;
  351|       |
  352|      0|  if(Curl_rand_hex(data, randsuffix, sizeof(randsuffix)))
  353|      0|    return CURLE_FAILED_INIT;
  354|       |
  355|      0|  tempstore = aprintf("%s.%s.tmp", file, randsuffix);
  356|      0|  if(!tempstore)
  357|      0|    return CURLE_OUT_OF_MEMORY;
  358|       |
  359|      0|  out = fopen(tempstore, FOPEN_WRITETEXT);
  360|      0|  if(!out)
  361|      0|    result = CURLE_WRITE_ERROR;
  362|      0|  else {
  363|      0|    fputs("# Your HSTS cache. https://curl.se/docs/hsts.html\n"
  364|      0|          "# This file was generated by libcurl! Edit at your own risk.\n",
  365|      0|          out);
  366|      0|    for(e = h->list.head; e; e = n) {
  367|      0|      struct stsentry *sts = e->ptr;
  368|      0|      n = e->next;
  369|      0|      result = hsts_out(sts, out);
  370|      0|      if(result)
  371|      0|        break;
  372|      0|    }
  373|      0|    fclose(out);
  374|      0|    if(!result && Curl_rename(tempstore, file))
  375|      0|      result = CURLE_WRITE_ERROR;
  376|       |
  377|      0|    if(result)
  378|      0|      unlink(tempstore);
  379|      0|  }
  380|      0|  free(tempstore);
  381|      0|  skipsave:
  382|      0|  if(data->set.hsts_write) {
  383|       |    /* if there's a write callback */
  384|      0|    struct curl_index i; /* count */
  385|      0|    i.total = h->list.size;
  386|      0|    i.index = 0;
  387|      0|    for(e = h->list.head; e; e = n) {
  388|      0|      struct stsentry *sts = e->ptr;
  389|      0|      bool stop;
  390|      0|      n = e->next;
  391|      0|      result = hsts_push(data, &i, sts, &stop);
  392|      0|      if(result || stop)
  393|      0|        break;
  394|      0|      i.index++;
  395|      0|    }
  396|      0|  }
  397|      0|  return result;
  398|      0|}
Curl_hsts_loadcb:
  538|    253|{
  539|    253|  if(h)
  540|      0|    return hsts_pull(data, h);
  541|    253|  return CURLE_OK;
  542|    253|}

Curl_http2_init_state:
   83|    253|{
   84|    253|  state->stream_weight = NGHTTP2_DEFAULT_WEIGHT;
   85|    253|}
Curl_http2_init_userset:
   92|  1.05k|{
   93|  1.05k|  set->stream_weight = NGHTTP2_DEFAULT_WEIGHT;
   94|  1.05k|}
Curl_http2_cleanup_dependencies:
 2482|  1.05k|{
 2483|  1.05k|  while(data->set.stream_dependents) {
 2484|      0|    struct Curl_easy *tmp = data->set.stream_dependents->data;
 2485|      0|    Curl_http2_remove_child(data, tmp);
 2486|      0|    if(data->set.stream_depends_on)
 2487|      0|      Curl_http2_add_child(data->set.stream_depends_on, tmp, FALSE);
 2488|      0|  }
 2489|       |
 2490|  1.05k|  if(data->set.stream_depends_on)
 2491|      0|    Curl_http2_remove_child(data->set.stream_depends_on, data);
 2492|  1.05k|}

Curl_http_auth_cleanup_digest:
  178|  1.05k|{
  179|  1.05k|  Curl_auth_digest_cleanup(&data->state.digest);
  180|  1.05k|  Curl_auth_digest_cleanup(&data->state.proxydigest);
  181|  1.05k|}

Curl_http_auth_cleanup_ntlm:
  266|    253|{
  267|    253|  Curl_auth_cleanup_ntlm(&conn->ntlm);
  268|    253|  Curl_auth_cleanup_ntlm(&conn->proxyntlm);
  269|       |
  270|    253|#if defined(NTLM_WB_ENABLED)
  271|    253|  Curl_http_auth_cleanup_ntlm_wb(conn);
  272|    253|#endif
  273|    253|}

Curl_llist_init:
   38|   470k|{
   39|   470k|  l->size = 0;
   40|   470k|  l->dtor = dtor;
   41|   470k|  l->head = NULL;
   42|   470k|  l->tail = NULL;
   43|   470k|}
Curl_llist_insert_next:
   60|  1.43k|{
   61|  1.43k|  ne->ptr = (void *) p;
   62|  1.43k|  if(list->size == 0) {
   63|  1.17k|    list->head = ne;
   64|  1.17k|    list->head->prev = NULL;
   65|  1.17k|    list->head->next = NULL;
   66|  1.17k|    list->tail = ne;
   67|  1.17k|  }
   68|    253|  else {
   69|       |    /* if 'e' is NULL here, we insert the new element first in the list */
   70|    253|    ne->next = e?e->next:list->head;
   71|    253|    ne->prev = e;
   72|    253|    if(!e) {
   73|      0|      list->head->prev = ne;
   74|      0|      list->head = ne;
   75|      0|    }
   76|    253|    else if(e->next) {
   77|      0|      e->next->prev = ne;
   78|      0|    }
   79|    253|    else {
   80|    253|      list->tail = ne;
   81|    253|    }
   82|    253|    if(e)
   83|    253|      e->next = ne;
   84|    253|  }
   85|       |
   86|  1.43k|  ++list->size;
   87|  1.43k|}
Curl_llist_remove:
   95|  1.43k|{
   96|  1.43k|  void *ptr;
   97|  1.43k|  if(!e || list->size == 0)
   98|      0|    return;
   99|       |
  100|  1.43k|  if(e == list->head) {
  101|  1.17k|    list->head = e->next;
  102|       |
  103|  1.17k|    if(!list->head)
  104|  1.17k|      list->tail = NULL;
  105|      0|    else
  106|      0|      e->next->prev = NULL;
  107|  1.17k|  }
  108|    253|  else {
  109|    253|    if(e->prev)
  110|    253|      e->prev->next = e->next;
  111|       |
  112|    253|    if(!e->next)
  113|    253|      list->tail = e->prev;
  114|      0|    else
  115|      0|      e->next->prev = e->prev;
  116|    253|  }
  117|       |
  118|  1.43k|  ptr = e->ptr;
  119|       |
  120|  1.43k|  e->ptr  = NULL;
  121|  1.43k|  e->prev = NULL;
  122|  1.43k|  e->next = NULL;
  123|       |
  124|  1.43k|  --list->size;
  125|       |
  126|       |  /* call the dtor() last for when it actually frees the 'e' memory itself */
  127|  1.43k|  if(list->dtor)
  128|      0|    list->dtor(user, ptr);
  129|  1.43k|}
Curl_llist_destroy:
  133|   473k|{
  134|   473k|  if(list) {
  135|   473k|    while(list->size > 0)
  136|      0|      Curl_llist_remove(list, list->tail, user);
  137|   473k|  }
  138|   473k|}
Curl_llist_count:
  142|    715|{
  143|    715|  return list->size;
  144|    715|}

curl_dbg_malloc:
  131|  14.3k|{
  132|  14.3k|  struct memdebug *mem;
  133|  14.3k|  size_t size;
  134|       |
  135|  14.3k|  DEBUGASSERT(wantedsize != 0);
  136|       |
  137|  14.3k|  if(countcheck("malloc", line, source))
  138|      0|    return NULL;
  139|       |
  140|       |  /* alloc at least 64 bytes */
  141|  14.3k|  size = sizeof(struct memdebug) + wantedsize;
  142|       |
  143|  14.3k|  mem = (Curl_cmalloc)(size);
  144|  14.3k|  if(mem) {
  145|  14.3k|    mem->size = wantedsize;
  146|  14.3k|  }
  147|       |
  148|  14.3k|  if(source)
  149|  8.19k|    curl_dbg_log("MEM %s:%d malloc(%zu) = %p\n",
  150|  8.19k|                 source, line, wantedsize,
  151|  8.19k|                 mem ? (void *)mem->mem : (void *)0);
  152|       |
  153|  14.3k|  return (mem ? mem->mem : NULL);
  154|  14.3k|}
curl_dbg_calloc:
  158|  4.30k|{
  159|  4.30k|  struct memdebug *mem;
  160|  4.30k|  size_t size, user_size;
  161|       |
  162|  4.30k|  DEBUGASSERT(wanted_elements != 0);
  163|  4.30k|  DEBUGASSERT(wanted_size != 0);
  164|       |
  165|  4.30k|  if(countcheck("calloc", line, source))
  166|      0|    return NULL;
  167|       |
  168|       |  /* alloc at least 64 bytes */
  169|  4.30k|  user_size = wanted_size * wanted_elements;
  170|  4.30k|  size = sizeof(struct memdebug) + user_size;
  171|       |
  172|  4.30k|  mem = (Curl_ccalloc)(1, size);
  173|  4.30k|  if(mem)
  174|  4.30k|    mem->size = user_size;
  175|       |
  176|  4.30k|  if(source)
  177|  4.30k|    curl_dbg_log("MEM %s:%d calloc(%zu,%zu) = %p\n",
  178|  4.30k|                 source, line, wanted_elements, wanted_size,
  179|  4.30k|                 mem ? (void *)mem->mem : (void *)0);
  180|       |
  181|  4.30k|  return (mem ? mem->mem : NULL);
  182|  4.30k|}
curl_dbg_strdup:
  185|  6.20k|{
  186|  6.20k|  char *mem;
  187|  6.20k|  size_t len;
  188|       |
  189|  6.20k|  DEBUGASSERT(str != NULL);
  190|       |
  191|  6.20k|  if(countcheck("strdup", line, source))
  192|      0|    return NULL;
  193|       |
  194|  6.20k|  len = strlen(str) + 1;
  195|       |
  196|  6.20k|  mem = curl_dbg_malloc(len, 0, NULL); /* NULL prevents logging */
  197|  6.20k|  if(mem)
  198|  6.20k|    memcpy(mem, str, len);
  199|       |
  200|  6.20k|  if(source)
  201|  6.20k|    curl_dbg_log("MEM %s:%d strdup(%p) (%zu) = %p\n",
  202|  6.20k|                 source, line, (const void *)str, len, (const void *)mem);
  203|       |
  204|  6.20k|  return mem;
  205|  6.20k|}
curl_dbg_realloc:
  237|    721|{
  238|    721|  struct memdebug *mem = NULL;
  239|       |
  240|    721|  size_t size = sizeof(struct memdebug) + wantedsize;
  241|       |
  242|    721|  DEBUGASSERT(wantedsize != 0);
  243|       |
  244|    721|  if(countcheck("realloc", line, source))
  245|      0|    return NULL;
  246|       |
  247|       |#ifdef __INTEL_COMPILER
  248|       |#  pragma warning(push)
  249|       |#  pragma warning(disable:1684)
  250|       |   /* 1684: conversion from pointer to same-sized integral type */
  251|       |#endif
  252|       |
  253|    721|  if(ptr)
  254|     91|    mem = (void *)((char *)ptr - offsetof(struct memdebug, mem));
  255|       |
  256|       |#ifdef __INTEL_COMPILER
  257|       |#  pragma warning(pop)
  258|       |#endif
  259|       |
  260|    721|  mem = (Curl_crealloc)(mem, size);
  261|    721|  if(source)
  262|    721|    curl_dbg_log("MEM %s:%d realloc(%p, %zu) = %p\n",
  263|    721|                source, line, (void *)ptr, wantedsize,
  264|    721|                mem ? (void *)mem->mem : (void *)0);
  265|       |
  266|    721|  if(mem) {
  267|    721|    mem->size = wantedsize;
  268|    721|    return mem->mem;
  269|    721|  }
  270|       |
  271|      0|  return NULL;
  272|    721|}
curl_dbg_free:
  275|   202k|{
  276|   202k|  if(ptr) {
  277|  19.3k|    struct memdebug *mem;
  278|       |
  279|       |#ifdef __INTEL_COMPILER
  280|       |#  pragma warning(push)
  281|       |#  pragma warning(disable:1684)
  282|       |   /* 1684: conversion from pointer to same-sized integral type */
  283|       |#endif
  284|       |
  285|  19.3k|    mem = (void *)((char *)ptr - offsetof(struct memdebug, mem));
  286|       |
  287|       |#ifdef __INTEL_COMPILER
  288|       |#  pragma warning(pop)
  289|       |#endif
  290|       |
  291|       |    /* free for real */
  292|  19.3k|    (Curl_cfree)(mem);
  293|  19.3k|  }
  294|       |
  295|   202k|  if(source && ptr)
  296|  19.3k|    curl_dbg_log("MEM %s:%d free(%p)\n", source, line, (void *)ptr);
  297|   202k|}
curl_dbg_socket:
  301|    462|{
  302|    462|  const char *fmt = (sizeof(curl_socket_t) == sizeof(int)) ?
  303|    462|    "FD %s:%d socket() = %d\n" :
  304|    462|    (sizeof(curl_socket_t) == sizeof(long)) ?
  305|      0|    "FD %s:%d socket() = %ld\n" :
  306|      0|    "FD %s:%d socket() = %zd\n";
  307|       |
  308|    462|  curl_socket_t sockfd;
  309|       |
  310|    462|  if(countcheck("socket", line, source))
  311|      0|    return CURL_SOCKET_BAD;
  312|       |
  313|    462|  sockfd = socket(domain, type, protocol);
  314|       |
  315|    462|  if(source && (sockfd != CURL_SOCKET_BAD))
  316|    462|    curl_dbg_log(fmt, source, line, sockfd);
  317|       |
  318|    462|  return sockfd;
  319|    462|}
curl_dbg_socketpair:
  354|    462|{
  355|    462|  const char *fmt = (sizeof(curl_socket_t) == sizeof(int)) ?
  356|    462|    "FD %s:%d socketpair() = %d %d\n" :
  357|    462|    (sizeof(curl_socket_t) == sizeof(long)) ?
  358|      0|    "FD %s:%d socketpair() = %ld %ld\n" :
  359|      0|    "FD %s:%d socketpair() = %zd %zd\n";
  360|       |
  361|    462|  int res = socketpair(domain, type, protocol, socket_vector);
  362|       |
  363|    462|  if(source && (0 == res))
  364|    462|    curl_dbg_log(fmt, source, line, socket_vector[0], socket_vector[1]);
  365|       |
  366|    462|  return res;
  367|    462|}
curl_dbg_mark_sclose:
  392|  1.38k|{
  393|  1.38k|  const char *fmt = (sizeof(curl_socket_t) == sizeof(int)) ?
  394|  1.38k|    "FD %s:%d sclose(%d)\n":
  395|  1.38k|    (sizeof(curl_socket_t) == sizeof(long)) ?
  396|      0|    "FD %s:%d sclose(%ld)\n":
  397|      0|    "FD %s:%d sclose(%zd)\n";
  398|       |
  399|  1.38k|  if(source)
  400|  1.38k|    curl_dbg_log(fmt, source, line, sockfd);
  401|  1.38k|}
curl_dbg_sclose:
  405|  1.38k|{
  406|  1.38k|  int res = sclose(sockfd);
  407|  1.38k|  curl_dbg_mark_sclose(sockfd, line, source);
  408|  1.38k|  return res;
  409|  1.38k|}
curl_dbg_fopen:
  413|    462|{
  414|    462|  FILE *res = fopen(file, mode);
  415|       |
  416|    462|  if(source)
  417|    462|    curl_dbg_log("FILE %s:%d fopen(\"%s\",\"%s\") = %p\n",
  418|    462|                source, line, file, mode, (void *)res);
  419|       |
  420|    462|  return res;
  421|    462|}
curl_dbg_fclose:
  434|    462|{
  435|    462|  int res;
  436|       |
  437|    462|  DEBUGASSERT(file != NULL);
  438|       |
  439|    462|  if(source)
  440|    462|    curl_dbg_log("FILE %s:%d fclose(%p)\n",
  441|    462|                 source, line, (void *)file);
  442|       |
  443|    462|  res = fclose(file);
  444|       |
  445|    462|  return res;
  446|    462|}
curl_dbg_log:
  452|  41.9k|{
  453|  41.9k|  char *buf;
  454|  41.9k|  int nchars;
  455|  41.9k|  va_list ap;
  456|       |
  457|  41.9k|  if(!curl_dbg_logfile)
  458|  41.9k|    return;
  459|       |
  460|      0|  buf = (Curl_cmalloc)(LOGLINE_BUFSIZE);
  461|      0|  if(!buf)
  462|      0|    return;
  463|       |
  464|      0|  va_start(ap, format);
  465|      0|  nchars = mvsnprintf(buf, LOGLINE_BUFSIZE, format, ap);
  466|      0|  va_end(ap);
  467|       |
  468|      0|  if(nchars > LOGLINE_BUFSIZE - 1)
  469|      0|    nchars = LOGLINE_BUFSIZE - 1;
  470|       |
  471|      0|  if(nchars > 0)
  472|      0|    fwrite(buf, 1, (size_t)nchars, curl_dbg_logfile);
  473|       |
  474|      0|  (Curl_cfree)(buf);
  475|      0|}
memdebug.c:countcheck:
  106|  26.0k|{
  107|       |  /* if source is NULL, then the call is made internally and this check
  108|       |     should not be made */
  109|  26.0k|  if(memlimit && source) {
  110|      0|    if(!memsize) {
  111|       |      /* log to file */
  112|      0|      curl_dbg_log("LIMIT %s:%d %s reached memlimit\n",
  113|      0|                   source, line, func);
  114|       |      /* log to stderr also */
  115|      0|      fprintf(stderr, "LIMIT %s:%d %s reached memlimit\n",
  116|      0|              source, line, func);
  117|      0|      fflush(curl_dbg_logfile); /* because it might crash now */
  118|      0|      errno = ENOMEM;
  119|      0|      return TRUE; /* RETURN ERROR! */
  120|      0|    }
  121|      0|    else
  122|      0|      memsize--; /* countdown */
  123|       |
  124|       |
  125|      0|  }
  126|       |
  127|  26.0k|  return FALSE; /* allow this */
  128|  26.0k|}

Curl_mime_cleanpart:
 1200|  4.42k|{
 1201|  4.42k|  cleanup_part_content(part);
 1202|  4.42k|  curl_slist_free_all(part->curlheaders);
 1203|  4.42k|  if(part->flags & MIME_USERHEADERS_OWNER)
 1204|      0|    curl_slist_free_all(part->userheaders);
 1205|  4.42k|  Curl_safefree(part->mimetype);
 1206|  4.42k|  Curl_safefree(part->name);
 1207|  4.42k|  Curl_safefree(part->filename);
 1208|  4.42k|  Curl_mime_initpart(part, part->easy);
 1209|  4.42k|}
curl_mime_free:
 1213|    158|{
 1214|    158|  curl_mimepart *part;
 1215|       |
 1216|    158|  if(mime) {
 1217|    158|    mime_subparts_unbind(mime);  /* Be sure it's not referenced anymore. */
 1218|  3.52k|    while(mime->firstpart) {
 1219|  3.36k|      part = mime->firstpart;
 1220|  3.36k|      mime->firstpart = part->nextpart;
 1221|  3.36k|      Curl_mime_cleanpart(part);
 1222|  3.36k|      free(part);
 1223|  3.36k|    }
 1224|    158|    free(mime);
 1225|    158|  }
 1226|    158|}
curl_mime_init:
 1309|    158|{
 1310|    158|  curl_mime *mime;
 1311|       |
 1312|    158|  mime = (curl_mime *) malloc(sizeof(*mime));
 1313|       |
 1314|    158|  if(mime) {
 1315|    158|    mime->easy = easy;
 1316|    158|    mime->parent = NULL;
 1317|    158|    mime->firstpart = NULL;
 1318|    158|    mime->lastpart = NULL;
 1319|       |
 1320|    158|    memset(mime->boundary, '-', 24);
 1321|    158|    if(Curl_rand_hex(easy, (unsigned char *) &mime->boundary[24],
 1322|    158|                     MIME_RAND_BOUNDARY_CHARS + 1)) {
 1323|       |      /* failed to get random separator, bail out */
 1324|      0|      free(mime);
 1325|      0|      return NULL;
 1326|      0|    }
 1327|    158|    mimesetstate(&mime->state, MIMESTATE_BEGIN, NULL);
 1328|    158|  }
 1329|       |
 1330|    158|  return mime;
 1331|    158|}
Curl_mime_initpart:
 1335|  8.84k|{
 1336|  8.84k|  memset((char *) part, 0, sizeof(*part));
 1337|  8.84k|  part->easy = easy;
 1338|  8.84k|  part->lastreadstatus = 1; /* Successful read status. */
 1339|  8.84k|  mimesetstate(&part->state, MIMESTATE_BEGIN, NULL);
 1340|  8.84k|}
curl_mime_addpart:
 1344|  3.36k|{
 1345|  3.36k|  curl_mimepart *part;
 1346|       |
 1347|  3.36k|  if(!mime)
 1348|      0|    return NULL;
 1349|       |
 1350|  3.36k|  part = (curl_mimepart *) malloc(sizeof(*part));
 1351|       |
 1352|  3.36k|  if(part) {
 1353|  3.36k|    Curl_mime_initpart(part, mime->easy);
 1354|  3.36k|    part->parent = mime;
 1355|       |
 1356|  3.36k|    if(mime->lastpart)
 1357|  3.20k|      mime->lastpart->nextpart = part;
 1358|    158|    else
 1359|    158|      mime->firstpart = part;
 1360|       |
 1361|  3.36k|    mime->lastpart = part;
 1362|  3.36k|  }
 1363|       |
 1364|  3.36k|  return part;
 1365|  3.36k|}
curl_mime_name:
 1369|     23|{
 1370|     23|  if(!part)
 1371|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1372|       |
 1373|     23|  Curl_safefree(part->name);
 1374|     23|  part->name = NULL;
 1375|       |
 1376|     23|  if(name) {
 1377|     23|    part->name = strdup(name);
 1378|     23|    if(!part->name)
 1379|      0|      return CURLE_OUT_OF_MEMORY;
 1380|     23|  }
 1381|       |
 1382|     23|  return CURLE_OK;
 1383|     23|}
curl_mime_data:
 1406|    602|{
 1407|    602|  if(!part)
 1408|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1409|       |
 1410|    602|  cleanup_part_content(part);
 1411|       |
 1412|    602|  if(data) {
 1413|    602|    if(datasize == CURL_ZERO_TERMINATED)
 1414|      0|      datasize = strlen(data);
 1415|       |
 1416|    602|    part->data = malloc(datasize + 1);
 1417|    602|    if(!part->data)
 1418|      0|      return CURLE_OUT_OF_MEMORY;
 1419|       |
 1420|    602|    part->datasize = datasize;
 1421|       |
 1422|    602|    if(datasize)
 1423|     41|      memcpy(part->data, data, datasize);
 1424|    602|    part->data[datasize] = '\0';    /* Set a null terminator as sentinel. */
 1425|       |
 1426|    602|    part->readfunc = mime_mem_read;
 1427|    602|    part->seekfunc = mime_mem_seek;
 1428|    602|    part->freefunc = mime_mem_free;
 1429|    602|    part->flags |= MIME_FAST_READ;
 1430|    602|    part->kind = MIMEKIND_DATA;
 1431|    602|  }
 1432|       |
 1433|    602|  return CURLE_OK;
 1434|    602|}
Curl_mime_set_subparts:
 1570|     68|{
 1571|     68|  curl_mime *root;
 1572|       |
 1573|     68|  if(!part)
 1574|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 1575|       |
 1576|       |  /* Accept setting twice the same subparts. */
 1577|     68|  if(part->kind == MIMEKIND_MULTIPART && part->arg == subparts)
 1578|      0|    return CURLE_OK;
 1579|       |
 1580|     68|  cleanup_part_content(part);
 1581|       |
 1582|     68|  if(subparts) {
 1583|       |    /* Must belong to the same data handle. */
 1584|     68|    if(part->easy && subparts->easy && part->easy != subparts->easy)
 1585|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1586|       |
 1587|       |    /* Should not have been attached already. */
 1588|     68|    if(subparts->parent)
 1589|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1590|       |
 1591|       |    /* Should not be the part's root. */
 1592|     68|    root = part->parent;
 1593|     68|    if(root) {
 1594|      0|      while(root->parent && root->parent->parent)
 1595|      0|        root = root->parent->parent;
 1596|      0|      if(subparts == root) {
 1597|      0|        if(part->easy)
 1598|      0|          failf(part->easy, "Can't add itself as a subpart!");
 1599|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
 1600|      0|      }
 1601|      0|    }
 1602|       |
 1603|     68|    subparts->parent = part;
 1604|       |    /* Subparts are processed internally: no read callback. */
 1605|     68|    part->seekfunc = mime_subparts_seek;
 1606|     68|    part->freefunc = take_ownership? mime_subparts_free: mime_subparts_unbind;
 1607|     68|    part->arg = subparts;
 1608|     68|    part->datasize = -1;
 1609|     68|    part->kind = MIMEKIND_MULTIPART;
 1610|     68|  }
 1611|       |
 1612|     68|  return CURLE_OK;
 1613|     68|}
mime.c:cleanup_part_content:
 1157|  5.16k|{
 1158|  5.16k|  if(part->freefunc)
 1159|    602|    part->freefunc(part->arg);
 1160|       |
 1161|  5.16k|  part->readfunc = NULL;
 1162|  5.16k|  part->seekfunc = NULL;
 1163|  5.16k|  part->freefunc = NULL;
 1164|  5.16k|  part->arg = (void *) part;          /* Defaults to part itself. */
 1165|  5.16k|  part->data = NULL;
 1166|  5.16k|  part->fp = NULL;
 1167|  5.16k|  part->datasize = (curl_off_t) 0;    /* No size yet. */
 1168|  5.16k|  cleanup_encoder_state(&part->encstate);
 1169|  5.16k|  part->kind = MIMEKIND_NONE;
 1170|  5.16k|  part->flags &= ~MIME_FAST_READ;
 1171|  5.16k|  part->lastreadstatus = 1; /* Successful read status. */
 1172|  5.16k|  part->state.state = MIMESTATE_BEGIN;
 1173|  5.16k|}
mime.c:cleanup_encoder_state:
  347|  5.16k|{
  348|  5.16k|  p->pos = 0;
  349|  5.16k|  p->bufbeg = 0;
  350|  5.16k|  p->bufend = 0;
  351|  5.16k|}
mime.c:mime_subparts_unbind:
 1188|    158|{
 1189|    158|  curl_mime *mime = (curl_mime *) ptr;
 1190|       |
 1191|    158|  if(mime && mime->parent) {
 1192|     68|    mime->parent->freefunc = NULL;  /* Be sure we won't be called again. */
 1193|     68|    cleanup_part_content(mime->parent);  /* Avoid dangling pointer in part. */
 1194|     68|    mime->parent = NULL;
 1195|     68|  }
 1196|    158|}
mime.c:mimesetstate:
  274|  9.00k|{
  275|  9.00k|  state->state = tok;
  276|  9.00k|  state->ptr = ptr;
  277|  9.00k|  state->offset = 0;
  278|  9.00k|}
mime.c:mime_mem_free:
  682|    602|{
  683|    602|  Curl_safefree(((curl_mimepart *) ptr)->data);
  684|    602|}

curl_mvsnprintf:
 1009|     21|{
 1010|     21|  int retcode;
 1011|     21|  struct nsprintf info;
 1012|       |
 1013|     21|  info.buffer = buffer;
 1014|     21|  info.length = 0;
 1015|     21|  info.max = maxlength;
 1016|       |
 1017|     21|  retcode = dprintf_formatf(&info, addbyter, format, ap_save);
 1018|     21|  if((retcode != -1) && info.max) {
 1019|       |    /* we terminate this with a zero byte */
 1020|     21|    if(info.max == info.length) {
 1021|       |      /* we're at maximum, scrap the last letter */
 1022|      0|      info.buffer[-1] = 0;
 1023|      0|      retcode--; /* don't count the nul byte */
 1024|      0|    }
 1025|     21|    else
 1026|     21|      info.buffer[0] = 0;
 1027|     21|  }
 1028|     21|  return retcode;
 1029|     21|}
curl_msnprintf:
 1032|     21|{
 1033|     21|  int retcode;
 1034|     21|  va_list ap_save; /* argument pointer */
 1035|     21|  va_start(ap_save, format);
 1036|     21|  retcode = curl_mvsnprintf(buffer, maxlength, format, ap_save);
 1037|     21|  va_end(ap_save);
 1038|     21|  return retcode;
 1039|     21|}
curl_mvaprintf:
 1074|    630|{
 1075|    630|  int retcode;
 1076|    630|  struct asprintf info;
 1077|    630|  struct dynbuf dyn;
 1078|    630|  info.b = &dyn;
 1079|    630|  Curl_dyn_init(info.b, DYN_APRINTF);
 1080|    630|  info.fail = 0;
 1081|       |
 1082|    630|  retcode = dprintf_formatf(&info, alloc_addbyter, format, ap_save);
 1083|    630|  if((-1 == retcode) || info.fail) {
 1084|      0|    Curl_dyn_free(info.b);
 1085|      0|    return NULL;
 1086|      0|  }
 1087|    630|  if(Curl_dyn_len(info.b))
 1088|    630|    return Curl_dyn_ptr(info.b);
 1089|      0|  return strdup("");
 1090|    630|}
curl_maprintf:
 1093|    630|{
 1094|    630|  va_list ap_save;
 1095|    630|  char *s;
 1096|    630|  va_start(ap_save, format);
 1097|    630|  s = curl_mvaprintf(format, ap_save);
 1098|    630|  va_end(ap_save);
 1099|    630|  return s;
 1100|    630|}
mprintf.c:dprintf_formatf:
  570|    651|{
  571|       |  /* Base-36 digits for numbers.  */
  572|    651|  const char *digits = lower_digits;
  573|       |
  574|       |  /* Pointer into the format string.  */
  575|    651|  char *f;
  576|       |
  577|       |  /* Number of characters written.  */
  578|    651|  int done = 0;
  579|       |
  580|    651|  long param; /* current parameter to read */
  581|    651|  long param_num = 0; /* parameter counter */
  582|       |
  583|    651|  struct va_stack vto[MAX_PARAMETERS];
  584|    651|  char *endpos[MAX_PARAMETERS];
  585|    651|  char **end;
  586|    651|  char work[BUFFSIZE];
  587|    651|  struct va_stack *p;
  588|       |
  589|       |  /* 'workend' points to the final buffer byte position, but with an extra
  590|       |     byte as margin to avoid the (false?) warning Coverity gives us
  591|       |     otherwise */
  592|    651|  char *workend = &work[sizeof(work) - 2];
  593|       |
  594|       |  /* Do the actual %-code parsing */
  595|    651|  if(dprintf_Pass1(format, vto, endpos, ap_save))
  596|      0|    return -1;
  597|       |
  598|    651|  end = &endpos[0]; /* the initial end-position from the list dprintf_Pass1()
  599|       |                       created for us */
  600|       |
  601|    651|  f = (char *)format;
  602|  5.38k|  while(*f != '\0') {
  603|       |    /* Format spec modifiers.  */
  604|  4.73k|    int is_alt;
  605|       |
  606|       |    /* Width of a field.  */
  607|  4.73k|    long width;
  608|       |
  609|       |    /* Precision of a field.  */
  610|  4.73k|    long prec;
  611|       |
  612|       |    /* Decimal integer is negative.  */
  613|  4.73k|    int is_neg;
  614|       |
  615|       |    /* Base of a number to be written.  */
  616|  4.73k|    unsigned long base;
  617|       |
  618|       |    /* Integral values to be written.  */
  619|  4.73k|    mp_uintmax_t num;
  620|       |
  621|       |    /* Used to convert negative in positive.  */
  622|  4.73k|    mp_intmax_t signed_num;
  623|       |
  624|  4.73k|    char *w;
  625|       |
  626|  4.73k|    if(*f != '%') {
  627|       |      /* This isn't a format spec, so write everything out until the next one
  628|       |         OR end of string is reached.  */
  629|  2.87k|      do {
  630|  2.87k|        OUTCHAR(*f);
  631|  2.87k|      } while(*++f && ('%' != *f));
  632|  1.12k|      continue;
  633|  1.12k|    }
  634|       |
  635|  3.60k|    ++f;
  636|       |
  637|       |    /* Check for "%%".  Note that although the ANSI standard lists
  638|       |       '%' as a conversion specifier, it says "The complete format
  639|       |       specification shall be `%%'," so we can avoid all the width
  640|       |       and precision processing.  */
  641|  3.60k|    if(*f == '%') {
  642|      0|      ++f;
  643|      0|      OUTCHAR('%');
  644|      0|      continue;
  645|      0|    }
  646|       |
  647|       |    /* If this is a positional parameter, the position must follow immediately
  648|       |       after the %, thus create a %<num>$ sequence */
  649|  3.60k|    param = dprintf_DollarString(f, &f);
  650|       |
  651|  3.60k|    if(!param)
  652|  3.60k|      param = param_num;
  653|      0|    else
  654|      0|      --param;
  655|       |
  656|  3.60k|    param_num++; /* increase this always to allow "%2$s %1$s %s" and then the
  657|       |                    third %s will pick the 3rd argument */
  658|       |
  659|  3.60k|    p = &vto[param];
  660|       |
  661|       |    /* pick up the specified width */
  662|  3.60k|    if(p->flags & FLAGS_WIDTHPARAM) {
  663|      0|      width = (long)vto[p->width].data.num.as_signed;
  664|      0|      param_num++; /* since the width is extracted from a parameter, we
  665|       |                      must skip that to get to the next one properly */
  666|      0|      if(width < 0) {
  667|       |        /* "A negative field width is taken as a '-' flag followed by a
  668|       |           positive field width." */
  669|      0|        width = -width;
  670|      0|        p->flags |= FLAGS_LEFT;
  671|      0|        p->flags &= ~FLAGS_PAD_NIL;
  672|      0|      }
  673|      0|    }
  674|  3.60k|    else
  675|  3.60k|      width = p->width;
  676|       |
  677|       |    /* pick up the specified precision */
  678|  3.60k|    if(p->flags & FLAGS_PRECPARAM) {
  679|      0|      prec = (long)vto[p->precision].data.num.as_signed;
  680|      0|      param_num++; /* since the precision is extracted from a parameter, we
  681|       |                      must skip that to get to the next one properly */
  682|      0|      if(prec < 0)
  683|       |        /* "A negative precision is taken as if the precision were
  684|       |           omitted." */
  685|      0|        prec = -1;
  686|      0|    }
  687|  3.60k|    else if(p->flags & FLAGS_PREC)
  688|      0|      prec = p->precision;
  689|  3.60k|    else
  690|  3.60k|      prec = -1;
  691|       |
  692|  3.60k|    is_alt = (p->flags & FLAGS_ALT) ? 1 : 0;
  693|       |
  694|  3.60k|    switch(p->type) {
  695|     57|    case FORMAT_INT:
  696|     57|      num = p->data.num.as_unsigned;
  697|     57|      if(p->flags & FLAGS_CHAR) {
  698|       |        /* Character.  */
  699|      0|        if(!(p->flags & FLAGS_LEFT))
  700|      0|          while(--width > 0)
  701|      0|            OUTCHAR(' ');
  702|      0|        OUTCHAR((char) num);
  703|      0|        if(p->flags & FLAGS_LEFT)
  704|      0|          while(--width > 0)
  705|      0|            OUTCHAR(' ');
  706|      0|        break;
  707|      0|      }
  708|     57|      if(p->flags & FLAGS_OCTAL) {
  709|       |        /* Octal unsigned integer.  */
  710|      0|        base = 8;
  711|      0|        goto unsigned_number;
  712|      0|      }
  713|     57|      else if(p->flags & FLAGS_HEX) {
  714|       |        /* Hexadecimal unsigned integer.  */
  715|       |
  716|      0|        digits = (p->flags & FLAGS_UPPER)? upper_digits : lower_digits;
  717|      0|        base = 16;
  718|      0|        goto unsigned_number;
  719|      0|      }
  720|     57|      else if(p->flags & FLAGS_UNSIGNED) {
  721|       |        /* Decimal unsigned integer.  */
  722|     48|        base = 10;
  723|     48|        goto unsigned_number;
  724|     48|      }
  725|       |
  726|       |      /* Decimal integer.  */
  727|      9|      base = 10;
  728|       |
  729|      9|      is_neg = (p->data.num.as_signed < (mp_intmax_t)0) ? 1 : 0;
  730|      9|      if(is_neg) {
  731|       |        /* signed_num might fail to hold absolute negative minimum by 1 */
  732|      0|        signed_num = p->data.num.as_signed + (mp_intmax_t)1;
  733|      0|        signed_num = -signed_num;
  734|      0|        num = (mp_uintmax_t)signed_num;
  735|      0|        num += (mp_uintmax_t)1;
  736|      0|      }
  737|       |
  738|      9|      goto number;
  739|       |
  740|     48|      unsigned_number:
  741|       |      /* Unsigned number of base BASE.  */
  742|     48|      is_neg = 0;
  743|       |
  744|     57|      number:
  745|       |      /* Number of base BASE.  */
  746|       |
  747|       |      /* Supply a default precision if none was given.  */
  748|     57|      if(prec == -1)
  749|     57|        prec = 1;
  750|       |
  751|       |      /* Put the number in WORK.  */
  752|     57|      w = workend;
  753|    110|      while(num > 0) {
  754|     53|        *w-- = digits[num % base];
  755|     53|        num /= base;
  756|     53|      }
  757|     57|      width -= (long)(workend - w);
  758|     57|      prec -= (long)(workend - w);
  759|       |
  760|     57|      if(is_alt && base == 8 && prec <= 0) {
  761|      0|        *w-- = '0';
  762|      0|        --width;
  763|      0|      }
  764|       |
  765|     57|      if(prec > 0) {
  766|     32|        width -= prec;
  767|     64|        while(prec-- > 0 && w >= work)
  768|     32|          *w-- = '0';
  769|     32|      }
  770|       |
  771|     57|      if(is_alt && base == 16)
  772|      0|        width -= 2;
  773|       |
  774|     57|      if(is_neg || (p->flags & FLAGS_SHOWSIGN) || (p->flags & FLAGS_SPACE))
  775|      0|        --width;
  776|       |
  777|     57|      if(!(p->flags & FLAGS_LEFT) && !(p->flags & FLAGS_PAD_NIL))
  778|     57|        while(width-- > 0)
  779|      0|          OUTCHAR(' ');
  780|       |
  781|     57|      if(is_neg)
  782|      0|        OUTCHAR('-');
  783|     57|      else if(p->flags & FLAGS_SHOWSIGN)
  784|      0|        OUTCHAR('+');
  785|     57|      else if(p->flags & FLAGS_SPACE)
  786|      0|        OUTCHAR(' ');
  787|       |
  788|     57|      if(is_alt && base == 16) {
  789|      0|        OUTCHAR('0');
  790|      0|        if(p->flags & FLAGS_UPPER)
  791|      0|          OUTCHAR('X');
  792|      0|        else
  793|      0|          OUTCHAR('x');
  794|      0|      }
  795|       |
  796|     57|      if(!(p->flags & FLAGS_LEFT) && (p->flags & FLAGS_PAD_NIL))
  797|      0|        while(width-- > 0)
  798|      0|          OUTCHAR('0');
  799|       |
  800|       |      /* Write the number.  */
  801|    142|      while(++w <= workend) {
  802|     85|        OUTCHAR(*w);
  803|     85|      }
  804|       |
  805|     57|      if(p->flags & FLAGS_LEFT)
  806|      0|        while(width-- > 0)
  807|      0|          OUTCHAR(' ');
  808|     57|      break;
  809|       |
  810|  3.54k|    case FORMAT_STRING:
  811|       |            /* String.  */
  812|  3.54k|      {
  813|  3.54k|        static const char null[] = "(nil)";
  814|  3.54k|        const char *str;
  815|  3.54k|        size_t len;
  816|       |
  817|  3.54k|        str = (char *) p->data.str;
  818|  3.54k|        if(!str) {
  819|       |          /* Write null[] if there's space.  */
  820|      0|          if(prec == -1 || prec >= (long) sizeof(null) - 1) {
  821|      0|            str = null;
  822|      0|            len = sizeof(null) - 1;
  823|       |            /* Disable quotes around (nil) */
  824|      0|            p->flags &= (~FLAGS_ALT);
  825|      0|          }
  826|      0|          else {
  827|      0|            str = "";
  828|      0|            len = 0;
  829|      0|          }
  830|      0|        }
  831|  3.54k|        else if(prec != -1)
  832|      0|          len = (size_t)prec;
  833|  3.54k|        else
  834|  3.54k|          len = strlen(str);
  835|       |
  836|  3.54k|        width -= (len > LONG_MAX) ? LONG_MAX : (long)len;
  837|       |
  838|  3.54k|        if(p->flags & FLAGS_ALT)
  839|      0|          OUTCHAR('"');
  840|       |
  841|  3.54k|        if(!(p->flags&FLAGS_LEFT))
  842|  3.54k|          while(width-- > 0)
  843|      0|            OUTCHAR(' ');
  844|       |
  845|  18.2k|        for(; len && *str; len--)
  846|  14.7k|          OUTCHAR(*str++);
  847|  3.54k|        if(p->flags&FLAGS_LEFT)
  848|      0|          while(width-- > 0)
  849|      0|            OUTCHAR(' ');
  850|       |
  851|  3.54k|        if(p->flags & FLAGS_ALT)
  852|      0|          OUTCHAR('"');
  853|  3.54k|      }
  854|  3.54k|      break;
  855|       |
  856|  3.54k|    case FORMAT_PTR:
  857|       |      /* Generic pointer.  */
  858|      0|      {
  859|      0|        void *ptr;
  860|      0|        ptr = (void *) p->data.ptr;
  861|      0|        if(ptr != NULL) {
  862|       |          /* If the pointer is not NULL, write it as a %#x spec.  */
  863|      0|          base = 16;
  864|      0|          digits = (p->flags & FLAGS_UPPER)? upper_digits : lower_digits;
  865|      0|          is_alt = 1;
  866|      0|          num = (size_t) ptr;
  867|      0|          is_neg = 0;
  868|      0|          goto number;
  869|      0|        }
  870|      0|        else {
  871|       |          /* Write "(nil)" for a nil pointer.  */
  872|      0|          static const char strnil[] = "(nil)";
  873|      0|          const char *point;
  874|       |
  875|      0|          width -= (long)(sizeof(strnil) - 1);
  876|      0|          if(p->flags & FLAGS_LEFT)
  877|      0|            while(width-- > 0)
  878|      0|              OUTCHAR(' ');
  879|      0|          for(point = strnil; *point != '\0'; ++point)
  880|      0|            OUTCHAR(*point);
  881|      0|          if(!(p->flags & FLAGS_LEFT))
  882|      0|            while(width-- > 0)
  883|      0|              OUTCHAR(' ');
  884|      0|        }
  885|      0|      }
  886|      0|      break;
  887|       |
  888|      0|    case FORMAT_DOUBLE:
  889|      0|      {
  890|      0|        char formatbuf[32]="%";
  891|      0|        char *fptr = &formatbuf[1];
  892|      0|        size_t left = sizeof(formatbuf)-strlen(formatbuf);
  893|      0|        int len;
  894|       |
  895|      0|        width = -1;
  896|      0|        if(p->flags & FLAGS_WIDTH)
  897|      0|          width = p->width;
  898|      0|        else if(p->flags & FLAGS_WIDTHPARAM)
  899|      0|          width = (long)vto[p->width].data.num.as_signed;
  900|       |
  901|      0|        prec = -1;
  902|      0|        if(p->flags & FLAGS_PREC)
  903|      0|          prec = p->precision;
  904|      0|        else if(p->flags & FLAGS_PRECPARAM)
  905|      0|          prec = (long)vto[p->precision].data.num.as_signed;
  906|       |
  907|      0|        if(p->flags & FLAGS_LEFT)
  908|      0|          *fptr++ = '-';
  909|      0|        if(p->flags & FLAGS_SHOWSIGN)
  910|      0|          *fptr++ = '+';
  911|      0|        if(p->flags & FLAGS_SPACE)
  912|      0|          *fptr++ = ' ';
  913|      0|        if(p->flags & FLAGS_ALT)
  914|      0|          *fptr++ = '#';
  915|       |
  916|      0|        *fptr = 0;
  917|       |
  918|      0|        if(width >= 0) {
  919|      0|          if(width >= (long)sizeof(work))
  920|      0|            width = sizeof(work)-1;
  921|       |          /* RECURSIVE USAGE */
  922|      0|          len = curl_msnprintf(fptr, left, "%ld", width);
  923|      0|          fptr += len;
  924|      0|          left -= len;
  925|      0|        }
  926|      0|        if(prec >= 0) {
  927|       |          /* for each digit in the integer part, we can have one less
  928|       |             precision */
  929|      0|          size_t maxprec = sizeof(work) - 2;
  930|      0|          double val = p->data.dnum;
  931|      0|          if(width > 0 && prec <= width)
  932|      0|            maxprec -= width;
  933|      0|          while(val >= 10.0) {
  934|      0|            val /= 10;
  935|      0|            maxprec--;
  936|      0|          }
  937|       |
  938|      0|          if(prec > (long)maxprec)
  939|      0|            prec = (long)maxprec-1;
  940|      0|          if(prec < 0)
  941|      0|            prec = 0;
  942|       |          /* RECURSIVE USAGE */
  943|      0|          len = curl_msnprintf(fptr, left, ".%ld", prec);
  944|      0|          fptr += len;
  945|      0|        }
  946|      0|        if(p->flags & FLAGS_LONG)
  947|      0|          *fptr++ = 'l';
  948|       |
  949|      0|        if(p->flags & FLAGS_FLOATE)
  950|      0|          *fptr++ = (char)((p->flags & FLAGS_UPPER) ? 'E':'e');
  951|      0|        else if(p->flags & FLAGS_FLOATG)
  952|      0|          *fptr++ = (char)((p->flags & FLAGS_UPPER) ? 'G' : 'g');
  953|      0|        else
  954|      0|          *fptr++ = 'f';
  955|       |
  956|      0|        *fptr = 0; /* and a final zero termination */
  957|       |
  958|       |        /* NOTE NOTE NOTE!! Not all sprintf implementations return number of
  959|       |           output characters */
  960|      0|        (sprintf)(work, formatbuf, p->data.dnum);
  961|      0|        DEBUGASSERT(strlen(work) <= sizeof(work));
  962|      0|        for(fptr = work; *fptr; fptr++)
  963|      0|          OUTCHAR(*fptr);
  964|      0|      }
  965|      0|      break;
  966|       |
  967|      0|    case FORMAT_INTPTR:
  968|       |      /* Answer the count of characters written.  */
  969|      0|#ifdef HAVE_LONG_LONG_TYPE
  970|      0|      if(p->flags & FLAGS_LONGLONG)
  971|      0|        *(LONG_LONG_TYPE *) p->data.ptr = (LONG_LONG_TYPE)done;
  972|      0|      else
  973|      0|#endif
  974|      0|        if(p->flags & FLAGS_LONG)
  975|      0|          *(long *) p->data.ptr = (long)done;
  976|      0|      else if(!(p->flags & FLAGS_SHORT))
  977|      0|        *(int *) p->data.ptr = (int)done;
  978|      0|      else
  979|      0|        *(short *) p->data.ptr = (short)done;
  980|      0|      break;
  981|       |
  982|      0|    default:
  983|      0|      break;
  984|  3.60k|    }
  985|  3.60k|    f = *end++; /* goto end of %-code */
  986|       |
  987|  3.60k|  }
  988|    651|  return done;
  989|    651|}
mprintf.c:dprintf_Pass1:
  230|    651|{
  231|    651|  char *fmt = (char *)format;
  232|    651|  int param_num = 0;
  233|    651|  long this_param;
  234|    651|  long width;
  235|    651|  long precision;
  236|    651|  int flags;
  237|    651|  long max_param = 0;
  238|    651|  long i;
  239|       |
  240|  10.7k|  while(*fmt) {
  241|  10.0k|    if(*fmt++ == '%') {
  242|  3.60k|      if(*fmt == '%') {
  243|      0|        fmt++;
  244|      0|        continue; /* while */
  245|      0|      }
  246|       |
  247|  3.60k|      flags = FLAGS_NEW;
  248|       |
  249|       |      /* Handle the positional case (N$) */
  250|       |
  251|  3.60k|      param_num++;
  252|       |
  253|  3.60k|      this_param = dprintf_DollarString(fmt, &fmt);
  254|  3.60k|      if(0 == this_param)
  255|       |        /* we got no positional, get the next counter */
  256|  3.60k|        this_param = param_num;
  257|       |
  258|  3.60k|      if(this_param > max_param)
  259|  3.60k|        max_param = this_param;
  260|       |
  261|       |      /*
  262|       |       * The parameter with number 'i' should be used. Next, we need
  263|       |       * to get SIZE and TYPE of the parameter. Add the information
  264|       |       * to our array.
  265|       |       */
  266|       |
  267|  3.60k|      width = 0;
  268|  3.60k|      precision = 0;
  269|       |
  270|       |      /* Handle the flags */
  271|       |
  272|  3.61k|      while(dprintf_IsQualifierNoDollar(fmt)) {
  273|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  274|       |        if(!strncmp(fmt, "I32", 3)) {
  275|       |          flags |= FLAGS_LONG;
  276|       |          fmt += 3;
  277|       |        }
  278|       |        else if(!strncmp(fmt, "I64", 3)) {
  279|       |          flags |= FLAGS_LONGLONG;
  280|       |          fmt += 3;
  281|       |        }
  282|       |        else
  283|       |#endif
  284|       |
  285|      9|        switch(*fmt++) {
  286|      0|        case ' ':
  287|      0|          flags |= FLAGS_SPACE;
  288|      0|          break;
  289|      0|        case '+':
  290|      0|          flags |= FLAGS_SHOWSIGN;
  291|      0|          break;
  292|      0|        case '-':
  293|      0|          flags |= FLAGS_LEFT;
  294|      0|          flags &= ~FLAGS_PAD_NIL;
  295|      0|          break;
  296|      0|        case '#':
  297|      0|          flags |= FLAGS_ALT;
  298|      0|          break;
  299|      0|        case '.':
  300|      0|          if('*' == *fmt) {
  301|       |            /* The precision is picked from a specified parameter */
  302|       |
  303|      0|            flags |= FLAGS_PRECPARAM;
  304|      0|            fmt++;
  305|      0|            param_num++;
  306|       |
  307|      0|            i = dprintf_DollarString(fmt, &fmt);
  308|      0|            if(i)
  309|      0|              precision = i;
  310|      0|            else
  311|      0|              precision = param_num;
  312|       |
  313|      0|            if(precision > max_param)
  314|      0|              max_param = precision;
  315|      0|          }
  316|      0|          else {
  317|      0|            flags |= FLAGS_PREC;
  318|      0|            precision = strtol(fmt, &fmt, 10);
  319|      0|          }
  320|      0|          break;
  321|      0|        case 'h':
  322|      0|          flags |= FLAGS_SHORT;
  323|      0|          break;
  324|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  325|       |        case 'I':
  326|       |#if (SIZEOF_CURL_OFF_T > SIZEOF_LONG)
  327|       |          flags |= FLAGS_LONGLONG;
  328|       |#else
  329|       |          flags |= FLAGS_LONG;
  330|       |#endif
  331|       |          break;
  332|       |#endif
  333|      9|        case 'l':
  334|      9|          if(flags & FLAGS_LONG)
  335|      0|            flags |= FLAGS_LONGLONG;
  336|      9|          else
  337|      9|            flags |= FLAGS_LONG;
  338|      9|          break;
  339|      0|        case 'L':
  340|      0|          flags |= FLAGS_LONGDOUBLE;
  341|      0|          break;
  342|      0|        case 'q':
  343|      0|          flags |= FLAGS_LONGLONG;
  344|      0|          break;
  345|      0|        case 'z':
  346|       |          /* the code below generates a warning if -Wunreachable-code is
  347|       |             used */
  348|       |#if (SIZEOF_SIZE_T > SIZEOF_LONG)
  349|       |          flags |= FLAGS_LONGLONG;
  350|       |#else
  351|      0|          flags |= FLAGS_LONG;
  352|      0|#endif
  353|      0|          break;
  354|      0|        case 'O':
  355|       |#if (SIZEOF_CURL_OFF_T > SIZEOF_LONG)
  356|       |          flags |= FLAGS_LONGLONG;
  357|       |#else
  358|      0|          flags |= FLAGS_LONG;
  359|      0|#endif
  360|      0|          break;
  361|      0|        case '0':
  362|      0|          if(!(flags & FLAGS_LEFT))
  363|      0|            flags |= FLAGS_PAD_NIL;
  364|       |          /* FALLTHROUGH */
  365|      0|        case '1': case '2': case '3': case '4':
  366|      0|        case '5': case '6': case '7': case '8': case '9':
  367|      0|          flags |= FLAGS_WIDTH;
  368|      0|          width = strtol(fmt-1, &fmt, 10);
  369|      0|          break;
  370|      0|        case '*':  /* Special case */
  371|      0|          flags |= FLAGS_WIDTHPARAM;
  372|      0|          param_num++;
  373|       |
  374|      0|          i = dprintf_DollarString(fmt, &fmt);
  375|      0|          if(i)
  376|      0|            width = i;
  377|      0|          else
  378|      0|            width = param_num;
  379|      0|          if(width > max_param)
  380|      0|            max_param = width;
  381|      0|          break;
  382|      0|        case '\0':
  383|      0|          fmt--;
  384|      0|        default:
  385|      0|          break;
  386|      9|        }
  387|      9|      } /* switch */
  388|       |
  389|       |      /* Handle the specifier */
  390|       |
  391|  3.60k|      i = this_param - 1;
  392|       |
  393|  3.60k|      if((i < 0) || (i >= MAX_PARAMETERS))
  394|       |        /* out of allowed range */
  395|      0|        return 1;
  396|       |
  397|  3.60k|      switch (*fmt) {
  398|      0|      case 'S':
  399|      0|        flags |= FLAGS_ALT;
  400|       |        /* FALLTHROUGH */
  401|  3.54k|      case 's':
  402|  3.54k|        vto[i].type = FORMAT_STRING;
  403|  3.54k|        break;
  404|      0|      case 'n':
  405|      0|        vto[i].type = FORMAT_INTPTR;
  406|      0|        break;
  407|      0|      case 'p':
  408|      0|        vto[i].type = FORMAT_PTR;
  409|      0|        break;
  410|      9|      case 'd': case 'i':
  411|      9|        vto[i].type = FORMAT_INT;
  412|      9|        break;
  413|     48|      case 'u':
  414|     48|        vto[i].type = FORMAT_INT;
  415|     48|        flags |= FLAGS_UNSIGNED;
  416|     48|        break;
  417|      0|      case 'o':
  418|      0|        vto[i].type = FORMAT_INT;
  419|      0|        flags |= FLAGS_OCTAL;
  420|      0|        break;
  421|      0|      case 'x':
  422|      0|        vto[i].type = FORMAT_INT;
  423|      0|        flags |= FLAGS_HEX|FLAGS_UNSIGNED;
  424|      0|        break;
  425|      0|      case 'X':
  426|      0|        vto[i].type = FORMAT_INT;
  427|      0|        flags |= FLAGS_HEX|FLAGS_UPPER|FLAGS_UNSIGNED;
  428|      0|        break;
  429|      0|      case 'c':
  430|      0|        vto[i].type = FORMAT_INT;
  431|      0|        flags |= FLAGS_CHAR;
  432|      0|        break;
  433|      0|      case 'f':
  434|      0|        vto[i].type = FORMAT_DOUBLE;
  435|      0|        break;
  436|      0|      case 'e':
  437|      0|        vto[i].type = FORMAT_DOUBLE;
  438|      0|        flags |= FLAGS_FLOATE;
  439|      0|        break;
  440|      0|      case 'E':
  441|      0|        vto[i].type = FORMAT_DOUBLE;
  442|      0|        flags |= FLAGS_FLOATE|FLAGS_UPPER;
  443|      0|        break;
  444|      0|      case 'g':
  445|      0|        vto[i].type = FORMAT_DOUBLE;
  446|      0|        flags |= FLAGS_FLOATG;
  447|      0|        break;
  448|      0|      case 'G':
  449|      0|        vto[i].type = FORMAT_DOUBLE;
  450|      0|        flags |= FLAGS_FLOATG|FLAGS_UPPER;
  451|      0|        break;
  452|      0|      default:
  453|      0|        vto[i].type = FORMAT_UNKNOWN;
  454|      0|        break;
  455|  3.60k|      } /* switch */
  456|       |
  457|  3.60k|      vto[i].flags = flags;
  458|  3.60k|      vto[i].width = width;
  459|  3.60k|      vto[i].precision = precision;
  460|       |
  461|  3.60k|      if(flags & FLAGS_WIDTHPARAM) {
  462|       |        /* we have the width specified from a parameter, so we make that
  463|       |           parameter's info setup properly */
  464|      0|        long k = width - 1;
  465|      0|        if((k < 0) || (k >= MAX_PARAMETERS))
  466|       |          /* out of allowed range */
  467|      0|          return 1;
  468|      0|        vto[i].width = k;
  469|      0|        vto[k].type = FORMAT_WIDTH;
  470|      0|        vto[k].flags = FLAGS_NEW;
  471|       |        /* can't use width or precision of width! */
  472|      0|        vto[k].width = 0;
  473|      0|        vto[k].precision = 0;
  474|      0|      }
  475|  3.60k|      if(flags & FLAGS_PRECPARAM) {
  476|       |        /* we have the precision specified from a parameter, so we make that
  477|       |           parameter's info setup properly */
  478|      0|        long k = precision - 1;
  479|      0|        if((k < 0) || (k >= MAX_PARAMETERS))
  480|       |          /* out of allowed range */
  481|      0|          return 1;
  482|      0|        vto[i].precision = k;
  483|      0|        vto[k].type = FORMAT_WIDTH;
  484|      0|        vto[k].flags = FLAGS_NEW;
  485|       |        /* can't use width or precision of width! */
  486|      0|        vto[k].width = 0;
  487|      0|        vto[k].precision = 0;
  488|      0|      }
  489|  3.60k|      *endpos++ = fmt + ((*fmt == '\0') ? 0 : 1); /* end of this sequence */
  490|  3.60k|    }
  491|  10.0k|  }
  492|       |
  493|       |  /* Read the arg list parameters into our data list */
  494|  4.25k|  for(i = 0; i<max_param; i++) {
  495|       |    /* Width/precision arguments must be read before the main argument
  496|       |       they are attached to */
  497|  3.60k|    if(vto[i].flags & FLAGS_WIDTHPARAM) {
  498|      0|      vto[vto[i].width].data.num.as_signed =
  499|      0|        (mp_intmax_t)va_arg(arglist, int);
  500|      0|    }
  501|  3.60k|    if(vto[i].flags & FLAGS_PRECPARAM) {
  502|      0|      vto[vto[i].precision].data.num.as_signed =
  503|      0|        (mp_intmax_t)va_arg(arglist, int);
  504|      0|    }
  505|       |
  506|  3.60k|    switch(vto[i].type) {
  507|  3.54k|    case FORMAT_STRING:
  508|  3.54k|      vto[i].data.str = va_arg(arglist, char *);
  509|  3.54k|      break;
  510|       |
  511|      0|    case FORMAT_INTPTR:
  512|      0|    case FORMAT_UNKNOWN:
  513|      0|    case FORMAT_PTR:
  514|      0|      vto[i].data.ptr = va_arg(arglist, void *);
  515|      0|      break;
  516|       |
  517|     57|    case FORMAT_INT:
  518|     57|#ifdef HAVE_LONG_LONG_TYPE
  519|     57|      if((vto[i].flags & FLAGS_LONGLONG) && (vto[i].flags & FLAGS_UNSIGNED))
  520|      0|        vto[i].data.num.as_unsigned =
  521|      0|          (mp_uintmax_t)va_arg(arglist, mp_uintmax_t);
  522|     57|      else if(vto[i].flags & FLAGS_LONGLONG)
  523|      0|        vto[i].data.num.as_signed =
  524|      0|          (mp_intmax_t)va_arg(arglist, mp_intmax_t);
  525|     57|      else
  526|     57|#endif
  527|     57|      {
  528|     57|        if((vto[i].flags & FLAGS_LONG) && (vto[i].flags & FLAGS_UNSIGNED))
  529|      0|          vto[i].data.num.as_unsigned =
  530|      0|            (mp_uintmax_t)va_arg(arglist, unsigned long);
  531|     57|        else if(vto[i].flags & FLAGS_LONG)
  532|      9|          vto[i].data.num.as_signed =
  533|      9|            (mp_intmax_t)va_arg(arglist, long);
  534|     48|        else if(vto[i].flags & FLAGS_UNSIGNED)
  535|     48|          vto[i].data.num.as_unsigned =
  536|     48|            (mp_uintmax_t)va_arg(arglist, unsigned int);
  537|      0|        else
  538|      0|          vto[i].data.num.as_signed =
  539|      0|            (mp_intmax_t)va_arg(arglist, int);
  540|     57|      }
  541|     57|      break;
  542|       |
  543|      0|    case FORMAT_DOUBLE:
  544|      0|      vto[i].data.dnum = va_arg(arglist, double);
  545|      0|      break;
  546|       |
  547|      0|    case FORMAT_WIDTH:
  548|       |      /* Argument has been read. Silently convert it into an integer
  549|       |       * for later use
  550|       |       */
  551|      0|      vto[i].type = FORMAT_INT;
  552|      0|      break;
  553|       |
  554|      0|    default:
  555|      0|      break;
  556|  3.60k|    }
  557|  3.60k|  }
  558|       |
  559|    651|  return 0;
  560|       |
  561|    651|}
mprintf.c:dprintf_IsQualifierNoDollar:
  195|  3.61k|{
  196|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  197|       |  if(!strncmp(fmt, "I32", 3) || !strncmp(fmt, "I64", 3)) {
  198|       |    return TRUE;
  199|       |  }
  200|       |#endif
  201|       |
  202|  3.61k|  switch(*fmt) {
  203|      0|  case '-': case '+': case ' ': case '#': case '.':
  204|      0|  case '0': case '1': case '2': case '3': case '4':
  205|      0|  case '5': case '6': case '7': case '8': case '9':
  206|      9|  case 'h': case 'l': case 'L': case 'z': case 'q':
  207|      9|  case '*': case 'O':
  208|       |#if defined(MP_HAVE_INT_EXTENSIONS)
  209|       |  case 'I':
  210|       |#endif
  211|      9|    return TRUE;
  212|       |
  213|  3.60k|  default:
  214|  3.60k|    return FALSE;
  215|  3.61k|  }
  216|  3.61k|}
mprintf.c:dprintf_DollarString:
  178|  7.20k|{
  179|  7.20k|  int number = 0;
  180|  7.20k|  while(ISDIGIT(*input)) {
  181|      0|    if(number < MAX_PARAMETERS) {
  182|      0|      number *= 10;
  183|      0|      number += *input - '0';
  184|      0|    }
  185|      0|    input++;
  186|      0|  }
  187|  7.20k|  if(number <= MAX_PARAMETERS && ('$' == *input)) {
  188|      0|    *end = ++input;
  189|      0|    return number;
  190|      0|  }
  191|  7.20k|  return 0;
  192|  7.20k|}
mprintf.c:addbyter:
  993|    121|{
  994|    121|  struct nsprintf *infop = (struct nsprintf *)data;
  995|    121|  unsigned char outc = (unsigned char)output;
  996|       |
  997|    121|  if(infop->length < infop->max) {
  998|       |    /* only do this if we haven't reached max length yet */
  999|    121|    infop->buffer[0] = outc; /* store */
 1000|    121|    infop->buffer++; /* increase pointer */
 1001|    121|    infop->length++; /* we are now one byte larger */
 1002|    121|    return outc;     /* fputc() returns like this on success */
 1003|    121|  }
 1004|      0|  return -1;
 1005|    121|}
mprintf.c:alloc_addbyter:
 1043|  17.5k|{
 1044|  17.5k|  struct asprintf *infop = (struct asprintf *)data;
 1045|  17.5k|  unsigned char outc = (unsigned char)output;
 1046|       |
 1047|  17.5k|  if(Curl_dyn_addn(infop->b, &outc, 1)) {
 1048|      0|    infop->fail = 1;
 1049|      0|    return -1; /* fail */
 1050|      0|  }
 1051|  17.5k|  return outc; /* fputc() returns like this on success */
 1052|  17.5k|}

Curl_multi_handle:
  357|    462|{
  358|    462|  struct Curl_multi *multi = calloc(1, sizeof(struct Curl_multi));
  359|       |
  360|    462|  if(!multi)
  361|      0|    return NULL;
  362|       |
  363|    462|  multi->magic = CURL_MULTI_HANDLE;
  364|       |
  365|    462|  if(Curl_mk_dnscache(&multi->hostcache))
  366|      0|    goto error;
  367|       |
  368|    462|  if(sh_init(&multi->sockhash, hashsize))
  369|      0|    goto error;
  370|       |
  371|    462|  if(Curl_conncache_init(&multi->conn_cache, chashsize))
  372|      0|    goto error;
  373|       |
  374|    462|  Curl_llist_init(&multi->msglist, NULL);
  375|    462|  Curl_llist_init(&multi->pending, NULL);
  376|       |
  377|    462|  multi->multiplexing = TRUE;
  378|       |
  379|       |  /* -1 means it not set by user, use the default value */
  380|    462|  multi->maxconnects = -1;
  381|    462|  multi->max_concurrent_streams = 100;
  382|    462|  multi->ipv6_works = Curl_ipv6works(NULL);
  383|       |
  384|       |#ifdef USE_WINSOCK
  385|       |  multi->wsa_event = WSACreateEvent();
  386|       |  if(multi->wsa_event == WSA_INVALID_EVENT)
  387|       |    goto error;
  388|       |#else
  389|    462|#ifdef ENABLE_WAKEUP
  390|    462|  if(Curl_socketpair(AF_UNIX, SOCK_STREAM, 0, multi->wakeup_pair) < 0) {
  391|      0|    multi->wakeup_pair[0] = CURL_SOCKET_BAD;
  392|      0|    multi->wakeup_pair[1] = CURL_SOCKET_BAD;
  393|      0|  }
  394|    462|  else if(curlx_nonblock(multi->wakeup_pair[0], TRUE) < 0 ||
  395|    462|          curlx_nonblock(multi->wakeup_pair[1], TRUE) < 0) {
  396|      0|    sclose(multi->wakeup_pair[0]);
  397|      0|    sclose(multi->wakeup_pair[1]);
  398|      0|    multi->wakeup_pair[0] = CURL_SOCKET_BAD;
  399|      0|    multi->wakeup_pair[1] = CURL_SOCKET_BAD;
  400|      0|  }
  401|    462|#endif
  402|    462|#endif
  403|       |
  404|    462|  return multi;
  405|       |
  406|      0|  error:
  407|       |
  408|      0|  Curl_hash_destroy(&multi->sockhash);
  409|      0|  Curl_hash_destroy(&multi->hostcache);
  410|      0|  Curl_conncache_destroy(&multi->conn_cache);
  411|      0|  Curl_llist_destroy(&multi->msglist, NULL);
  412|      0|  Curl_llist_destroy(&multi->pending, NULL);
  413|       |
  414|      0|  free(multi);
  415|      0|  return NULL;
  416|    462|}
curl_multi_init:
  419|    462|{
  420|    462|  return Curl_multi_handle(CURL_SOCKET_HASH_TABLE_SIZE,
  421|    462|                           CURL_CONNECTION_HASH_SIZE);
  422|    462|}
curl_multi_add_handle:
  426|    462|{
  427|       |  /* First, make some basic checks that the CURLM handle is a good handle */
  428|    462|  if(!GOOD_MULTI_HANDLE(multi))
  429|      0|    return CURLM_BAD_HANDLE;
  430|       |
  431|       |  /* Verify that we got a somewhat good easy handle too */
  432|    462|  if(!GOOD_EASY_HANDLE(data))
  433|      0|    return CURLM_BAD_EASY_HANDLE;
  434|       |
  435|       |  /* Prevent users from adding same easy handle more than once and prevent
  436|       |     adding to more than one multi stack */
  437|    462|  if(data->multi)
  438|      0|    return CURLM_ADDED_ALREADY;
  439|       |
  440|    462|  if(multi->in_callback)
  441|      0|    return CURLM_RECURSIVE_API_CALL;
  442|       |
  443|       |  /* Initialize timeout list for this handle */
  444|    462|  Curl_llist_init(&data->state.timeoutlist, NULL);
  445|       |
  446|       |  /*
  447|       |   * No failure allowed in this function beyond this point. And no
  448|       |   * modification of easy nor multi handle allowed before this except for
  449|       |   * potential multi's connection cache growing which won't be undone in this
  450|       |   * function no matter what.
  451|       |   */
  452|    462|  if(data->set.errorbuffer)
  453|      0|    data->set.errorbuffer[0] = 0;
  454|       |
  455|       |  /* set the easy handle */
  456|    462|  multistate(data, MSTATE_INIT);
  457|       |
  458|       |  /* for multi interface connections, we share DNS cache automatically if the
  459|       |     easy handle's one is currently not set. */
  460|    462|  if(!data->dns.hostcache ||
  461|    462|     (data->dns.hostcachetype == HCACHE_NONE)) {
  462|    462|    data->dns.hostcache = &multi->hostcache;
  463|    462|    data->dns.hostcachetype = HCACHE_MULTI;
  464|    462|  }
  465|       |
  466|       |  /* Point to the shared or multi handle connection cache */
  467|    462|  if(data->share && (data->share->specifier & (1<< CURL_LOCK_DATA_CONNECT)))
  468|      0|    data->state.conn_cache = &data->share->conn_cache;
  469|    462|  else
  470|    462|    data->state.conn_cache = &multi->conn_cache;
  471|    462|  data->state.lastconnect_id = -1;
  472|       |
  473|       |#ifdef USE_LIBPSL
  474|       |  /* Do the same for PSL. */
  475|       |  if(data->share && (data->share->specifier & (1 << CURL_LOCK_DATA_PSL)))
  476|       |    data->psl = &data->share->psl;
  477|       |  else
  478|       |    data->psl = &multi->psl;
  479|       |#endif
  480|       |
  481|       |  /* We add the new entry last in the list. */
  482|    462|  data->next = NULL; /* end of the line */
  483|    462|  if(multi->easyp) {
  484|      0|    struct Curl_easy *last = multi->easylp;
  485|      0|    last->next = data;
  486|      0|    data->prev = last;
  487|      0|    multi->easylp = data; /* the new last node */
  488|      0|  }
  489|    462|  else {
  490|       |    /* first node, make prev NULL! */
  491|    462|    data->prev = NULL;
  492|    462|    multi->easylp = multi->easyp = data; /* both first and last */
  493|    462|  }
  494|       |
  495|       |  /* make the Curl_easy refer back to this multi handle */
  496|    462|  data->multi = multi;
  497|       |
  498|       |  /* Set the timeout for this handle to expire really soon so that it will
  499|       |     be taken care of even when this handle is added in the midst of operation
  500|       |     when only the curl_multi_socket() API is used. During that flow, only
  501|       |     sockets that time-out or have actions will be dealt with. Since this
  502|       |     handle has no action yet, we make sure it times out to get things to
  503|       |     happen. */
  504|    462|  Curl_expire(data, 0, EXPIRE_RUN_NOW);
  505|       |
  506|       |  /* increase the node-counter */
  507|    462|  multi->num_easy++;
  508|       |
  509|       |  /* increase the alive-counter */
  510|    462|  multi->num_alive++;
  511|       |
  512|       |  /* A somewhat crude work-around for a little glitch in Curl_update_timer()
  513|       |     that happens if the lastcall time is set to the same time when the handle
  514|       |     is removed as when the next handle is added, as then the check in
  515|       |     Curl_update_timer() that prevents calling the application multiple times
  516|       |     with the same timer info will not trigger and then the new handle's
  517|       |     timeout will not be notified to the app.
  518|       |
  519|       |     The work-around is thus simply to clear the 'lastcall' variable to force
  520|       |     Curl_update_timer() to always trigger a callback to the app when a new
  521|       |     easy handle is added */
  522|    462|  memset(&multi->timer_lastcall, 0, sizeof(multi->timer_lastcall));
  523|       |
  524|    462|  CONNCACHE_LOCK(data);
  525|       |  /* The closure handle only ever has default timeouts set. To improve the
  526|       |     state somewhat we clone the timeouts from each added handle so that the
  527|       |     closure handle always has the same timeouts as the most recently added
  528|       |     easy handle. */
  529|    462|  data->state.conn_cache->closure_handle->set.timeout = data->set.timeout;
  530|    462|  data->state.conn_cache->closure_handle->set.server_response_timeout =
  531|    462|    data->set.server_response_timeout;
  532|    462|  data->state.conn_cache->closure_handle->set.no_signal =
  533|    462|    data->set.no_signal;
  534|    462|  CONNCACHE_UNLOCK(data);
  535|       |
  536|    462|  Curl_update_timer(multi);
  537|    462|  return CURLM_OK;
  538|    462|}
curl_multi_remove_handle:
  718|    462|{
  719|    462|  struct Curl_easy *easy = data;
  720|    462|  bool premature;
  721|    462|  struct Curl_llist_element *e;
  722|       |
  723|       |  /* First, make some basic checks that the CURLM handle is a good handle */
  724|    462|  if(!GOOD_MULTI_HANDLE(multi))
  725|      0|    return CURLM_BAD_HANDLE;
  726|       |
  727|       |  /* Verify that we got a somewhat good easy handle too */
  728|    462|  if(!GOOD_EASY_HANDLE(data))
  729|      0|    return CURLM_BAD_EASY_HANDLE;
  730|       |
  731|       |  /* Prevent users from trying to remove same easy handle more than once */
  732|    462|  if(!data->multi)
  733|      0|    return CURLM_OK; /* it is already removed so let's say it is fine! */
  734|       |
  735|       |  /* Prevent users from trying to remove an easy handle from the wrong multi */
  736|    462|  if(data->multi != multi)
  737|      0|    return CURLM_BAD_EASY_HANDLE;
  738|       |
  739|    462|  if(multi->in_callback)
  740|      0|    return CURLM_RECURSIVE_API_CALL;
  741|       |
  742|    462|  premature = (data->mstate < MSTATE_COMPLETED) ? TRUE : FALSE;
  743|       |
  744|       |  /* If the 'state' is not INIT or COMPLETED, we might need to do something
  745|       |     nice to put the easy_handle in a good known state when this returns. */
  746|    462|  if(premature) {
  747|       |    /* this handle is "alive" so we need to count down the total number of
  748|       |       alive connections when this is removed */
  749|      0|    multi->num_alive--;
  750|      0|  }
  751|       |
  752|    462|  if(data->conn &&
  753|    462|     data->mstate > MSTATE_DO &&
  754|    462|     data->mstate < MSTATE_COMPLETED) {
  755|       |    /* Set connection owner so that the DONE function closes it.  We can
  756|       |       safely do this here since connection is killed. */
  757|      0|    streamclose(data->conn, "Removed with partial response");
  758|      0|  }
  759|       |
  760|    462|  if(data->conn) {
  761|       |    /* multi_done() clears the association between the easy handle and the
  762|       |       connection.
  763|       |
  764|       |       Note that this ignores the return code simply because there's
  765|       |       nothing really useful to do with it anyway! */
  766|      0|    (void)multi_done(data, data->result, premature);
  767|      0|  }
  768|       |
  769|       |  /* The timer must be shut down before data->multi is set to NULL, else the
  770|       |     timenode will remain in the splay tree after curl_easy_cleanup is
  771|       |     called. Do it after multi_done() in case that sets another time! */
  772|    462|  Curl_expire_clear(data);
  773|       |
  774|    462|  if(data->connect_queue.ptr)
  775|       |    /* the handle was in the pending list waiting for an available connection,
  776|       |       so go ahead and remove it */
  777|      0|    Curl_llist_remove(&multi->pending, &data->connect_queue, NULL);
  778|       |
  779|    462|  if(data->dns.hostcachetype == HCACHE_MULTI) {
  780|       |    /* stop using the multi handle's DNS cache, *after* the possible
  781|       |       multi_done() call above */
  782|    462|    data->dns.hostcache = NULL;
  783|    462|    data->dns.hostcachetype = HCACHE_NONE;
  784|    462|  }
  785|       |
  786|    462|  Curl_wildcard_dtor(&data->wildcard);
  787|       |
  788|       |  /* destroy the timeout list that is held in the easy handle, do this *after*
  789|       |     multi_done() as that may actually call Curl_expire that uses this */
  790|    462|  Curl_llist_destroy(&data->state.timeoutlist, NULL);
  791|       |
  792|       |  /* change state without using multistate(), only to make singlesocket() do
  793|       |     what we want */
  794|    462|  data->mstate = MSTATE_COMPLETED;
  795|    462|  singlesocket(multi, easy); /* to let the application know what sockets that
  796|       |                                vanish with this handle */
  797|       |
  798|       |  /* Remove the association between the connection and the handle */
  799|    462|  Curl_detach_connnection(data);
  800|       |
  801|    462|  if(data->state.lastconnect_id != -1) {
  802|       |    /* Mark any connect-only connection for closure */
  803|      0|    Curl_conncache_foreach(data, data->state.conn_cache,
  804|      0|                           NULL, close_connect_only);
  805|      0|  }
  806|       |
  807|       |#ifdef USE_LIBPSL
  808|       |  /* Remove the PSL association. */
  809|       |  if(data->psl == &multi->psl)
  810|       |    data->psl = NULL;
  811|       |#endif
  812|       |
  813|       |  /* as this was using a shared connection cache we clear the pointer to that
  814|       |     since we're not part of that multi handle anymore */
  815|    462|  data->state.conn_cache = NULL;
  816|       |
  817|    462|  data->multi = NULL; /* clear the association to this multi handle */
  818|       |
  819|       |  /* make sure there's no pending message in the queue sent from this easy
  820|       |     handle */
  821|       |
  822|    462|  for(e = multi->msglist.head; e; e = e->next) {
  823|    462|    struct Curl_message *msg = e->ptr;
  824|       |
  825|    462|    if(msg->extmsg.easy_handle == easy) {
  826|    462|      Curl_llist_remove(&multi->msglist, e, NULL);
  827|       |      /* there can only be one from this specific handle */
  828|    462|      break;
  829|    462|    }
  830|    462|  }
  831|       |
  832|       |  /* Remove from the pending list if it is there. Otherwise this will
  833|       |     remain on the pending list forever due to the state change. */
  834|    462|  for(e = multi->pending.head; e; e = e->next) {
  835|      0|    struct Curl_easy *curr_data = e->ptr;
  836|       |
  837|      0|    if(curr_data == data) {
  838|      0|      Curl_llist_remove(&multi->pending, e, NULL);
  839|      0|      break;
  840|      0|    }
  841|      0|  }
  842|       |
  843|       |  /* make the previous node point to our next */
  844|    462|  if(data->prev)
  845|      0|    data->prev->next = data->next;
  846|    462|  else
  847|    462|    multi->easyp = data->next; /* point to first node */
  848|       |
  849|       |  /* make our next point to our previous node */
  850|    462|  if(data->next)
  851|      0|    data->next->prev = data->prev;
  852|    462|  else
  853|    462|    multi->easylp = data->prev; /* point to last node */
  854|       |
  855|       |  /* NOTE NOTE NOTE
  856|       |     We do not touch the easy handle here! */
  857|    462|  multi->num_easy--; /* one less to care about now */
  858|       |
  859|    462|  process_pending_handles(multi);
  860|       |
  861|    462|  Curl_update_timer(multi);
  862|    462|  return CURLM_OK;
  863|    462|}
Curl_detach_connnection:
  878|  2.48k|{
  879|  2.48k|  struct connectdata *conn = data->conn;
  880|  2.48k|  if(conn) {
  881|    253|    Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL);
  882|    253|    Curl_ssl_detach_conn(data, conn);
  883|    253|  }
  884|  2.48k|  data->conn = NULL;
  885|  2.48k|}
Curl_attach_connnection:
  894|    253|{
  895|    253|  DEBUGASSERT(!data->conn);
  896|    253|  DEBUGASSERT(conn);
  897|    253|  data->conn = conn;
  898|    253|  Curl_llist_insert_next(&conn->easyq, conn->easyq.tail, data,
  899|    253|                         &data->conn_queue);
  900|    253|  if(conn->handler->attach)
  901|      0|    conn->handler->attach(data, conn);
  902|    253|  Curl_ssl_associate_conn(data, conn);
  903|    253|}
Curl_preconnect:
 1716|    253|{
 1717|    253|  if(!data->state.buffer) {
 1718|    253|    data->state.buffer = malloc(data->set.buffer_size + 1);
 1719|    253|    if(!data->state.buffer)
 1720|      0|      return CURLE_OUT_OF_MEMORY;
 1721|    253|  }
 1722|    253|  return CURLE_OK;
 1723|    253|}
curl_multi_perform:
 2572|    462|{
 2573|    462|  struct Curl_easy *data;
 2574|    462|  CURLMcode returncode = CURLM_OK;
 2575|    462|  struct Curl_tree *t;
 2576|    462|  struct curltime now = Curl_now();
 2577|       |
 2578|    462|  if(!GOOD_MULTI_HANDLE(multi))
 2579|      0|    return CURLM_BAD_HANDLE;
 2580|       |
 2581|    462|  if(multi->in_callback)
 2582|      0|    return CURLM_RECURSIVE_API_CALL;
 2583|       |
 2584|    462|  data = multi->easyp;
 2585|    924|  while(data) {
 2586|    462|    CURLMcode result;
 2587|    462|    SIGPIPE_VARIABLE(pipe_st);
 2588|       |
 2589|    462|    sigpipe_ignore(data, &pipe_st);
 2590|    462|    result = multi_runsingle(multi, &now, data);
 2591|    462|    sigpipe_restore(&pipe_st);
 2592|       |
 2593|    462|    if(result)
 2594|      0|      returncode = result;
 2595|       |
 2596|    462|    data = data->next; /* operate on next handle */
 2597|    462|  }
 2598|       |
 2599|       |  /*
 2600|       |   * Simply remove all expired timers from the splay since handles are dealt
 2601|       |   * with unconditionally by this function and curl_multi_timeout() requires
 2602|       |   * that already passed/handled expire times are removed from the splay.
 2603|       |   *
 2604|       |   * It is important that the 'now' value is set at the entry of this function
 2605|       |   * and not for the current time as it may have ticked a little while since
 2606|       |   * then and then we risk this loop to remove timers that actually have not
 2607|       |   * been handled!
 2608|       |   */
 2609|    462|  do {
 2610|    462|    multi->timetree = Curl_splaygetbest(now, multi->timetree, &t);
 2611|    462|    if(t)
 2612|       |      /* the removed may have another timeout in queue */
 2613|      0|      (void)add_next_timeout(now, multi, t->payload);
 2614|       |
 2615|    462|  } while(t);
 2616|       |
 2617|    462|  *running_handles = multi->num_alive;
 2618|       |
 2619|    462|  if(CURLM_OK >= returncode)
 2620|    462|    Curl_update_timer(multi);
 2621|       |
 2622|    462|  return returncode;
 2623|    462|}
curl_multi_cleanup:
 2626|    462|{
 2627|    462|  struct Curl_easy *data;
 2628|    462|  struct Curl_easy *nextdata;
 2629|       |
 2630|    462|  if(GOOD_MULTI_HANDLE(multi)) {
 2631|    462|    if(multi->in_callback)
 2632|      0|      return CURLM_RECURSIVE_API_CALL;
 2633|       |
 2634|    462|    multi->magic = 0; /* not good anymore */
 2635|       |
 2636|       |    /* First remove all remaining easy handles */
 2637|    462|    data = multi->easyp;
 2638|    462|    while(data) {
 2639|      0|      nextdata = data->next;
 2640|      0|      if(!data->state.done && data->conn)
 2641|       |        /* if DONE was never called for this handle */
 2642|      0|        (void)multi_done(data, CURLE_OK, TRUE);
 2643|      0|      if(data->dns.hostcachetype == HCACHE_MULTI) {
 2644|       |        /* clear out the usage of the shared DNS cache */
 2645|      0|        Curl_hostcache_clean(data, data->dns.hostcache);
 2646|      0|        data->dns.hostcache = NULL;
 2647|      0|        data->dns.hostcachetype = HCACHE_NONE;
 2648|      0|      }
 2649|       |
 2650|       |      /* Clear the pointer to the connection cache */
 2651|      0|      data->state.conn_cache = NULL;
 2652|      0|      data->multi = NULL; /* clear the association */
 2653|       |
 2654|       |#ifdef USE_LIBPSL
 2655|       |      if(data->psl == &multi->psl)
 2656|       |        data->psl = NULL;
 2657|       |#endif
 2658|       |
 2659|      0|      data = nextdata;
 2660|      0|    }
 2661|       |
 2662|       |    /* Close all the connections in the connection cache */
 2663|    462|    Curl_conncache_close_all_connections(&multi->conn_cache);
 2664|       |
 2665|    462|    Curl_hash_destroy(&multi->sockhash);
 2666|    462|    Curl_conncache_destroy(&multi->conn_cache);
 2667|    462|    Curl_llist_destroy(&multi->msglist, NULL);
 2668|    462|    Curl_llist_destroy(&multi->pending, NULL);
 2669|       |
 2670|    462|    Curl_hash_destroy(&multi->hostcache);
 2671|    462|    Curl_psl_destroy(&multi->psl);
 2672|       |
 2673|       |#ifdef USE_WINSOCK
 2674|       |    WSACloseEvent(multi->wsa_event);
 2675|       |#else
 2676|    462|#ifdef ENABLE_WAKEUP
 2677|    462|    sclose(multi->wakeup_pair[0]);
 2678|    462|    sclose(multi->wakeup_pair[1]);
 2679|    462|#endif
 2680|    462|#endif
 2681|    462|    free(multi);
 2682|       |
 2683|    462|    return CURLM_OK;
 2684|    462|  }
 2685|      0|  return CURLM_BAD_HANDLE;
 2686|    462|}
Curl_update_timer:
 3259|  1.38k|{
 3260|  1.38k|  long timeout_ms;
 3261|       |
 3262|  1.38k|  if(!multi->timer_cb)
 3263|  1.38k|    return;
 3264|      0|  if(multi_timeout(multi, &timeout_ms)) {
 3265|      0|    return;
 3266|      0|  }
 3267|      0|  if(timeout_ms < 0) {
 3268|      0|    static const struct curltime none = {0, 0};
 3269|      0|    if(Curl_splaycomparekeys(none, multi->timer_lastcall)) {
 3270|      0|      multi->timer_lastcall = none;
 3271|       |      /* there's no timeout now but there was one previously, tell the app to
 3272|       |         disable it */
 3273|      0|      multi->timer_cb(multi, -1, multi->timer_userp);
 3274|      0|      return;
 3275|      0|    }
 3276|      0|    return;
 3277|      0|  }
 3278|       |
 3279|       |  /* When multi_timeout() is done, multi->timetree points to the node with the
 3280|       |   * timeout we got the (relative) time-out time for. We can thus easily check
 3281|       |   * if this is the same (fixed) time as we got in a previous call and then
 3282|       |   * avoid calling the callback again. */
 3283|      0|  if(Curl_splaycomparekeys(multi->timetree->key, multi->timer_lastcall) == 0)
 3284|      0|    return;
 3285|       |
 3286|      0|  multi->timer_lastcall = multi->timetree->key;
 3287|       |
 3288|      0|  multi->timer_cb(multi, timeout_ms, multi->timer_userp);
 3289|      0|}
Curl_expire:
 3366|    715|{
 3367|    715|  struct Curl_multi *multi = data->multi;
 3368|    715|  struct curltime *nowp = &data->state.expiretime;
 3369|    715|  struct curltime set;
 3370|       |
 3371|       |  /* this is only interesting while there is still an associated multi struct
 3372|       |     remaining! */
 3373|    715|  if(!multi)
 3374|      0|    return;
 3375|       |
 3376|    715|  DEBUGASSERT(id < EXPIRE_LAST);
 3377|       |
 3378|    715|  set = Curl_now();
 3379|    715|  set.tv_sec += (time_t)(milli/1000); /* might be a 64 to 32 bit conversion */
 3380|    715|  set.tv_usec += (unsigned int)(milli%1000)*1000;
 3381|       |
 3382|    715|  if(set.tv_usec >= 1000000) {
 3383|      0|    set.tv_sec++;
 3384|      0|    set.tv_usec -= 1000000;
 3385|      0|  }
 3386|       |
 3387|       |  /* Remove any timer with the same id just in case. */
 3388|    715|  multi_deltimeout(data, id);
 3389|       |
 3390|       |  /* Add it to the timer list.  It must stay in the list until it has expired
 3391|       |     in case we need to recompute the minimum timer later. */
 3392|    715|  multi_addtimeout(data, &set, id);
 3393|       |
 3394|    715|  if(nowp->tv_sec || nowp->tv_usec) {
 3395|       |    /* This means that the struct is added as a node in the splay tree.
 3396|       |       Compare if the new time is earlier, and only remove-old/add-new if it
 3397|       |       is. */
 3398|    253|    timediff_t diff = Curl_timediff(set, *nowp);
 3399|    253|    int rc;
 3400|       |
 3401|    253|    if(diff > 0) {
 3402|       |      /* The current splay tree entry is sooner than this new expiry time.
 3403|       |         We don't need to update our splay tree entry. */
 3404|    253|      return;
 3405|    253|    }
 3406|       |
 3407|       |    /* Since this is an updated time, we must remove the previous entry from
 3408|       |       the splay tree first and then re-add the new value */
 3409|      0|    rc = Curl_splayremove(multi->timetree, &data->state.timenode,
 3410|      0|                          &multi->timetree);
 3411|      0|    if(rc)
 3412|      0|      infof(data, "Internal error removing splay node = %d", rc);
 3413|      0|  }
 3414|       |
 3415|       |  /* Indicate that we are in the splay tree and insert the new timer expiry
 3416|       |     value since it is our local minimum. */
 3417|    462|  *nowp = set;
 3418|    462|  data->state.timenode.payload = data;
 3419|    462|  multi->timetree = Curl_splayinsert(*nowp, multi->timetree,
 3420|    462|                                     &data->state.timenode);
 3421|    462|}
Curl_expire_clear:
 3441|  1.98k|{
 3442|  1.98k|  struct Curl_multi *multi = data->multi;
 3443|  1.98k|  struct curltime *nowp = &data->state.expiretime;
 3444|       |
 3445|       |  /* this is only interesting while there is still an associated multi struct
 3446|       |     remaining! */
 3447|  1.98k|  if(!multi)
 3448|  1.05k|    return;
 3449|       |
 3450|    924|  if(nowp->tv_sec || nowp->tv_usec) {
 3451|       |    /* Since this is an cleared time, we must remove the previous entry from
 3452|       |       the splay tree */
 3453|    462|    struct Curl_llist *list = &data->state.timeoutlist;
 3454|    462|    int rc;
 3455|       |
 3456|    462|    rc = Curl_splayremove(multi->timetree, &data->state.timenode,
 3457|    462|                          &multi->timetree);
 3458|    462|    if(rc)
 3459|      0|      infof(data, "Internal error clearing splay node = %d", rc);
 3460|       |
 3461|       |    /* flush the timeout list too */
 3462|  1.17k|    while(list->size > 0) {
 3463|    715|      Curl_llist_remove(list, list->tail, NULL);
 3464|    715|    }
 3465|       |
 3466|    462|#ifdef DEBUGBUILD
 3467|    462|    infof(data, "Expire cleared (transfer %p)", data);
 3468|    462|#endif
 3469|    462|    nowp->tv_sec = 0;
 3470|    462|    nowp->tv_usec = 0;
 3471|    462|  }
 3472|    924|}
Curl_multi_max_host_connections:
 3496|    253|{
 3497|    253|  return multi ? multi->max_host_connections : 0;
 3498|    253|}
Curl_multi_max_total_connections:
 3501|    253|{
 3502|    253|  return multi ? multi->max_total_connections : 0;
 3503|    253|}
multi.c:sh_init:
  336|    462|{
  337|    462|  return Curl_hash_init(hash, hashsize, hash_fd, fd_key_compare,
  338|    462|                        sh_freeentry);
  339|    462|}
multi.c:mstate:
  131|  1.63k|{
  132|  1.63k|  CURLMstate oldstate = data->mstate;
  133|  1.63k|  static const init_multistate_func finit[MSTATE_LAST] = {
  134|  1.63k|    NULL,              /* INIT */
  135|  1.63k|    NULL,              /* PENDING */
  136|  1.63k|    Curl_init_CONNECT, /* CONNECT */
  137|  1.63k|    NULL,              /* RESOLVING */
  138|  1.63k|    NULL,              /* CONNECTING */
  139|  1.63k|    NULL,              /* TUNNELING */
  140|  1.63k|    NULL,              /* PROTOCONNECT */
  141|  1.63k|    NULL,              /* PROTOCONNECTING */
  142|  1.63k|    Curl_connect_free, /* DO */
  143|  1.63k|    NULL,              /* DOING */
  144|  1.63k|    NULL,              /* DOING_MORE */
  145|  1.63k|    before_perform,    /* DID */
  146|  1.63k|    NULL,              /* PERFORMING */
  147|  1.63k|    NULL,              /* RATELIMITING */
  148|  1.63k|    NULL,              /* DONE */
  149|  1.63k|    init_completed,    /* COMPLETED */
  150|       |    NULL               /* MSGSENT */
  151|  1.63k|  };
  152|       |
  153|       |#if defined(DEBUGBUILD) && defined(CURL_DISABLE_VERBOSE_STRINGS)
  154|       |  (void) lineno;
  155|       |#endif
  156|       |
  157|  1.63k|  if(oldstate == state)
  158|       |    /* don't bother when the new state is the same as the old state */
  159|    462|    return;
  160|       |
  161|  1.17k|  data->mstate = state;
  162|       |
  163|  1.17k|#if defined(DEBUGBUILD) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
  164|  1.17k|  if(data->mstate >= MSTATE_PENDING &&
  165|  1.17k|     data->mstate < MSTATE_COMPLETED) {
  166|    253|    long connection_id = -5000;
  167|       |
  168|    253|    if(data->conn)
  169|      0|      connection_id = data->conn->connection_id;
  170|       |
  171|    253|    infof(data,
  172|    253|          "STATE: %s => %s handle %p; line %d (connection #%ld)",
  173|    253|          statename[oldstate], statename[data->mstate],
  174|    253|          (void *)data, lineno, connection_id);
  175|    253|  }
  176|  1.17k|#endif
  177|       |
  178|  1.17k|  if(state == MSTATE_COMPLETED) {
  179|       |    /* changing to COMPLETED means there's one less easy handle 'alive' */
  180|    462|    DEBUGASSERT(data->multi->num_alive > 0);
  181|    462|    data->multi->num_alive--;
  182|    462|  }
  183|       |
  184|       |  /* if this state has an init-function, run it */
  185|  1.17k|  if(finit[state])
  186|    715|    finit[state](data);
  187|  1.17k|}
multi.c:init_completed:
  116|    462|{
  117|       |  /* this is a completed transfer */
  118|       |
  119|       |  /* Important: reset the conn pointer so that we don't point to memory
  120|       |     that could be freed anytime */
  121|    462|  Curl_detach_connnection(data);
  122|    462|  Curl_expire_clear(data); /* stop all timers */
  123|    462|}
multi.c:multi_getsock:
  984|    462|{
  985|    462|  struct connectdata *conn = data->conn;
  986|       |  /* The no connection case can happen when this is called from
  987|       |     curl_multi_remove_handle() => singlesocket() => multi_getsock().
  988|       |  */
  989|    462|  if(!conn)
  990|    462|    return 0;
  991|       |
  992|      0|  switch(data->mstate) {
  993|      0|  default:
  994|      0|    return 0;
  995|       |
  996|      0|  case MSTATE_RESOLVING:
  997|      0|    return Curl_resolv_getsock(data, socks);
  998|       |
  999|      0|  case MSTATE_PROTOCONNECTING:
 1000|      0|  case MSTATE_PROTOCONNECT:
 1001|      0|    return protocol_getsock(data, conn, socks);
 1002|       |
 1003|      0|  case MSTATE_DO:
 1004|      0|  case MSTATE_DOING:
 1005|      0|    return doing_getsock(data, conn, socks);
 1006|       |
 1007|      0|  case MSTATE_TUNNELING:
 1008|      0|    return waitproxyconnect_getsock(conn, socks);
 1009|       |
 1010|      0|  case MSTATE_CONNECTING:
 1011|      0|    return waitconnect_getsock(conn, socks);
 1012|       |
 1013|      0|  case MSTATE_DOING_MORE:
 1014|      0|    return domore_getsock(data, conn, socks);
 1015|       |
 1016|      0|  case MSTATE_DID: /* since is set after DO is completed, we switch to
 1017|       |                        waiting for the same as the PERFORMING state */
 1018|      0|  case MSTATE_PERFORMING:
 1019|      0|    return Curl_single_getsock(data, conn, socks);
 1020|      0|  }
 1021|       |
 1022|      0|}
multi.c:multi_runsingle:
 1729|    462|{
 1730|    462|  struct Curl_message *msg = NULL;
 1731|    462|  bool connected;
 1732|    462|  bool async;
 1733|    462|  bool protocol_connected = FALSE;
 1734|    462|  bool dophase_done = FALSE;
 1735|    462|  bool done = FALSE;
 1736|    462|  CURLMcode rc;
 1737|    462|  CURLcode result = CURLE_OK;
 1738|    462|  timediff_t recv_timeout_ms;
 1739|    462|  timediff_t send_timeout_ms;
 1740|    462|  int control;
 1741|       |
 1742|    462|  if(!GOOD_EASY_HANDLE(data))
 1743|      0|    return CURLM_BAD_EASY_HANDLE;
 1744|       |
 1745|    715|  do {
 1746|       |    /* A "stream" here is a logical stream if the protocol can handle that
 1747|       |       (HTTP/2), or the full connection for older protocols */
 1748|    715|    bool stream_error = FALSE;
 1749|    715|    rc = CURLM_OK;
 1750|       |
 1751|    715|    if(multi_ischanged(multi, TRUE)) {
 1752|      0|      DEBUGF(infof(data, "multi changed, check CONNECT_PEND queue!"));
 1753|      0|      process_pending_handles(multi); /* multiplexed */
 1754|      0|    }
 1755|       |
 1756|    715|    if(data->mstate > MSTATE_CONNECT &&
 1757|    715|       data->mstate < MSTATE_COMPLETED) {
 1758|       |      /* Make sure we set the connection's current owner */
 1759|      0|      DEBUGASSERT(data->conn);
 1760|      0|      if(!data->conn)
 1761|      0|        return CURLM_INTERNAL_ERROR;
 1762|      0|    }
 1763|       |
 1764|    715|    if(data->conn &&
 1765|    715|       (data->mstate >= MSTATE_CONNECT) &&
 1766|    715|       (data->mstate < MSTATE_COMPLETED)) {
 1767|       |      /* Check for overall operation timeout here but defer handling the
 1768|       |       * connection timeout to later, to allow for a connection to be set up
 1769|       |       * in the window since we last checked timeout. This prevents us
 1770|       |       * tearing down a completed connection in the case where we were slow
 1771|       |       * to check the timeout (e.g. process descheduled during this loop).
 1772|       |       * We set connect_timeout=FALSE to do this. */
 1773|       |
 1774|       |      /* we need to wait for the connect state as only then is the start time
 1775|       |         stored, but we must not check already completed handles */
 1776|      0|      if(multi_handle_timeout(data, nowp, &stream_error, &result, FALSE)) {
 1777|       |        /* Skip the statemachine and go directly to error handling section. */
 1778|      0|        goto statemachine_end;
 1779|      0|      }
 1780|      0|    }
 1781|       |
 1782|    715|    switch(data->mstate) {
 1783|    462|    case MSTATE_INIT:
 1784|       |      /* init this transfer. */
 1785|    462|      result = Curl_pretransfer(data);
 1786|       |
 1787|    462|      if(!result) {
 1788|       |        /* after init, go CONNECT */
 1789|    253|        multistate(data, MSTATE_CONNECT);
 1790|    253|        *nowp = Curl_pgrsTime(data, TIMER_STARTOP);
 1791|    253|        rc = CURLM_CALL_MULTI_PERFORM;
 1792|    253|      }
 1793|    462|      break;
 1794|       |
 1795|      0|    case MSTATE_PENDING:
 1796|       |      /* We will stay here until there is a connection available. Then
 1797|       |         we try again in the MSTATE_CONNECT state. */
 1798|      0|      break;
 1799|       |
 1800|    253|    case MSTATE_CONNECT:
 1801|       |      /* Connect. We want to get a connection identifier filled in. */
 1802|       |      /* init this transfer. */
 1803|    253|      result = Curl_preconnect(data);
 1804|    253|      if(result)
 1805|      0|        break;
 1806|       |
 1807|    253|      *nowp = Curl_pgrsTime(data, TIMER_STARTSINGLE);
 1808|    253|      if(data->set.timeout)
 1809|    253|        Curl_expire(data, data->set.timeout, EXPIRE_TIMEOUT);
 1810|       |
 1811|    253|      if(data->set.connecttimeout)
 1812|      0|        Curl_expire(data, data->set.connecttimeout, EXPIRE_CONNECTTIMEOUT);
 1813|       |
 1814|    253|      result = Curl_connect(data, &async, &protocol_connected);
 1815|    253|      if(CURLE_NO_CONNECTION_AVAILABLE == result) {
 1816|       |        /* There was no connection available. We will go to the pending
 1817|       |           state and wait for an available connection. */
 1818|      0|        multistate(data, MSTATE_PENDING);
 1819|       |
 1820|       |        /* add this handle to the list of connect-pending handles */
 1821|      0|        Curl_llist_insert_next(&multi->pending, multi->pending.tail, data,
 1822|      0|                               &data->connect_queue);
 1823|      0|        result = CURLE_OK;
 1824|      0|        break;
 1825|      0|      }
 1826|    253|      else if(data->state.previouslypending) {
 1827|       |        /* this transfer comes from the pending queue so try move another */
 1828|      0|        infof(data, "Transfer was pending, now try another");
 1829|      0|        process_pending_handles(data->multi);
 1830|      0|      }
 1831|       |
 1832|    253|      if(!result) {
 1833|      0|        if(async)
 1834|       |          /* We're now waiting for an asynchronous name lookup */
 1835|      0|          multistate(data, MSTATE_RESOLVING);
 1836|      0|        else {
 1837|       |          /* after the connect has been sent off, go WAITCONNECT unless the
 1838|       |             protocol connect is already done and we can go directly to
 1839|       |             WAITDO or DO! */
 1840|      0|          rc = CURLM_CALL_MULTI_PERFORM;
 1841|       |
 1842|      0|          if(protocol_connected)
 1843|      0|            multistate(data, MSTATE_DO);
 1844|      0|          else {
 1845|      0|#ifndef CURL_DISABLE_HTTP
 1846|      0|            if(Curl_connect_ongoing(data->conn))
 1847|      0|              multistate(data, MSTATE_TUNNELING);
 1848|      0|            else
 1849|      0|#endif
 1850|      0|              multistate(data, MSTATE_CONNECTING);
 1851|      0|          }
 1852|      0|        }
 1853|      0|      }
 1854|    253|      break;
 1855|       |
 1856|      0|    case MSTATE_RESOLVING:
 1857|       |      /* awaiting an asynch name resolve to complete */
 1858|      0|    {
 1859|      0|      struct Curl_dns_entry *dns = NULL;
 1860|      0|      struct connectdata *conn = data->conn;
 1861|      0|      const char *hostname;
 1862|       |
 1863|      0|      DEBUGASSERT(conn);
 1864|      0|#ifndef CURL_DISABLE_PROXY
 1865|      0|      if(conn->bits.httpproxy)
 1866|      0|        hostname = conn->http_proxy.host.name;
 1867|      0|      else
 1868|      0|#endif
 1869|      0|        if(conn->bits.conn_to_host)
 1870|      0|        hostname = conn->conn_to_host.name;
 1871|      0|      else
 1872|      0|        hostname = conn->host.name;
 1873|       |
 1874|       |      /* check if we have the name resolved by now */
 1875|      0|      dns = Curl_fetch_addr(data, hostname, (int)conn->port);
 1876|       |
 1877|      0|      if(dns) {
 1878|      0|#ifdef CURLRES_ASYNCH
 1879|      0|        data->state.async.dns = dns;
 1880|      0|        data->state.async.done = TRUE;
 1881|      0|#endif
 1882|      0|        result = CURLE_OK;
 1883|      0|        infof(data, "Hostname '%s' was found in DNS cache", hostname);
 1884|      0|      }
 1885|       |
 1886|      0|      if(!dns)
 1887|      0|        result = Curl_resolv_check(data, &dns);
 1888|       |
 1889|       |      /* Update sockets here, because the socket(s) may have been
 1890|       |         closed and the application thus needs to be told, even if it
 1891|       |         is likely that the same socket(s) will again be used further
 1892|       |         down.  If the name has not yet been resolved, it is likely
 1893|       |         that new sockets have been opened in an attempt to contact
 1894|       |         another resolver. */
 1895|      0|      singlesocket(multi, data);
 1896|       |
 1897|      0|      if(dns) {
 1898|       |        /* Perform the next step in the connection phase, and then move on
 1899|       |           to the WAITCONNECT state */
 1900|      0|        result = Curl_once_resolved(data, &protocol_connected);
 1901|       |
 1902|      0|        if(result)
 1903|       |          /* if Curl_once_resolved() returns failure, the connection struct
 1904|       |             is already freed and gone */
 1905|      0|          data->conn = NULL; /* no more connection */
 1906|      0|        else {
 1907|       |          /* call again please so that we get the next socket setup */
 1908|      0|          rc = CURLM_CALL_MULTI_PERFORM;
 1909|      0|          if(protocol_connected)
 1910|      0|            multistate(data, MSTATE_DO);
 1911|      0|          else {
 1912|      0|#ifndef CURL_DISABLE_HTTP
 1913|      0|            if(Curl_connect_ongoing(data->conn))
 1914|      0|              multistate(data, MSTATE_TUNNELING);
 1915|      0|            else
 1916|      0|#endif
 1917|      0|              multistate(data, MSTATE_CONNECTING);
 1918|      0|          }
 1919|      0|        }
 1920|      0|      }
 1921|       |
 1922|      0|      if(result) {
 1923|       |        /* failure detected */
 1924|      0|        stream_error = TRUE;
 1925|      0|        break;
 1926|      0|      }
 1927|      0|    }
 1928|      0|    break;
 1929|       |
 1930|      0|#ifndef CURL_DISABLE_HTTP
 1931|      0|    case MSTATE_TUNNELING:
 1932|       |      /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */
 1933|      0|      DEBUGASSERT(data->conn);
 1934|      0|      result = Curl_http_connect(data, &protocol_connected);
 1935|      0|#ifndef CURL_DISABLE_PROXY
 1936|      0|      if(data->conn->bits.proxy_connect_closed) {
 1937|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 1938|       |        /* connect back to proxy again */
 1939|      0|        result = CURLE_OK;
 1940|      0|        multi_done(data, CURLE_OK, FALSE);
 1941|      0|        multistate(data, MSTATE_CONNECT);
 1942|      0|      }
 1943|      0|      else
 1944|      0|#endif
 1945|      0|        if(!result) {
 1946|      0|          if(
 1947|      0|#ifndef CURL_DISABLE_PROXY
 1948|      0|            (data->conn->http_proxy.proxytype != CURLPROXY_HTTPS ||
 1949|      0|             data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) &&
 1950|      0|#endif
 1951|      0|            Curl_connect_complete(data->conn)) {
 1952|      0|            rc = CURLM_CALL_MULTI_PERFORM;
 1953|       |            /* initiate protocol connect phase */
 1954|      0|            multistate(data, MSTATE_PROTOCONNECT);
 1955|      0|          }
 1956|      0|        }
 1957|      0|      else
 1958|      0|        stream_error = TRUE;
 1959|      0|      break;
 1960|      0|#endif
 1961|       |
 1962|      0|    case MSTATE_CONNECTING:
 1963|       |      /* awaiting a completion of an asynch TCP connect */
 1964|      0|      DEBUGASSERT(data->conn);
 1965|      0|      result = Curl_is_connected(data, data->conn, FIRSTSOCKET, &connected);
 1966|      0|      if(connected && !result) {
 1967|      0|#ifndef CURL_DISABLE_HTTP
 1968|      0|        if(
 1969|      0|#ifndef CURL_DISABLE_PROXY
 1970|      0|          (data->conn->http_proxy.proxytype == CURLPROXY_HTTPS &&
 1971|      0|           !data->conn->bits.proxy_ssl_connected[FIRSTSOCKET]) ||
 1972|      0|#endif
 1973|      0|          Curl_connect_ongoing(data->conn)) {
 1974|      0|          multistate(data, MSTATE_TUNNELING);
 1975|      0|          break;
 1976|      0|        }
 1977|      0|#endif
 1978|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 1979|      0|#ifndef CURL_DISABLE_PROXY
 1980|      0|        multistate(data,
 1981|      0|                   data->conn->bits.tunnel_proxy?
 1982|      0|                   MSTATE_TUNNELING : MSTATE_PROTOCONNECT);
 1983|       |#else
 1984|       |        multistate(data, MSTATE_PROTOCONNECT);
 1985|       |#endif
 1986|      0|      }
 1987|      0|      else if(result) {
 1988|       |        /* failure detected */
 1989|      0|        Curl_posttransfer(data);
 1990|      0|        multi_done(data, result, TRUE);
 1991|      0|        stream_error = TRUE;
 1992|      0|        break;
 1993|      0|      }
 1994|      0|      break;
 1995|       |
 1996|      0|    case MSTATE_PROTOCONNECT:
 1997|      0|      result = protocol_connect(data, &protocol_connected);
 1998|      0|      if(!result && !protocol_connected)
 1999|       |        /* switch to waiting state */
 2000|      0|        multistate(data, MSTATE_PROTOCONNECTING);
 2001|      0|      else if(!result) {
 2002|       |        /* protocol connect has completed, go WAITDO or DO */
 2003|      0|        multistate(data, MSTATE_DO);
 2004|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 2005|      0|      }
 2006|      0|      else {
 2007|       |        /* failure detected */
 2008|      0|        Curl_posttransfer(data);
 2009|      0|        multi_done(data, result, TRUE);
 2010|      0|        stream_error = TRUE;
 2011|      0|      }
 2012|      0|      break;
 2013|       |
 2014|      0|    case MSTATE_PROTOCONNECTING:
 2015|       |      /* protocol-specific connect phase */
 2016|      0|      result = protocol_connecting(data, &protocol_connected);
 2017|      0|      if(!result && protocol_connected) {
 2018|       |        /* after the connect has completed, go WAITDO or DO */
 2019|      0|        multistate(data, MSTATE_DO);
 2020|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 2021|      0|      }
 2022|      0|      else if(result) {
 2023|       |        /* failure detected */
 2024|      0|        Curl_posttransfer(data);
 2025|      0|        multi_done(data, result, TRUE);
 2026|      0|        stream_error = TRUE;
 2027|      0|      }
 2028|      0|      break;
 2029|       |
 2030|      0|    case MSTATE_DO:
 2031|      0|      if(data->set.fprereq) {
 2032|      0|        int prereq_rc;
 2033|       |
 2034|       |        /* call the prerequest callback function */
 2035|      0|        Curl_set_in_callback(data, true);
 2036|      0|        prereq_rc = data->set.fprereq(data->set.prereq_userp,
 2037|      0|                                      data->info.conn_primary_ip,
 2038|      0|                                      data->info.conn_local_ip,
 2039|      0|                                      data->info.conn_primary_port,
 2040|      0|                                      data->info.conn_local_port);
 2041|      0|        Curl_set_in_callback(data, false);
 2042|      0|        if(prereq_rc != CURL_PREREQFUNC_OK) {
 2043|      0|          failf(data, "operation aborted by pre-request callback");
 2044|       |          /* failure in pre-request callback - don't do any other processing */
 2045|      0|          result = CURLE_ABORTED_BY_CALLBACK;
 2046|      0|          Curl_posttransfer(data);
 2047|      0|          multi_done(data, result, FALSE);
 2048|      0|          stream_error = TRUE;
 2049|      0|          break;
 2050|      0|        }
 2051|      0|      }
 2052|       |
 2053|      0|      if(data->set.connect_only) {
 2054|       |        /* keep connection open for application to use the socket */
 2055|      0|        connkeep(data->conn, "CONNECT_ONLY");
 2056|      0|        multistate(data, MSTATE_DONE);
 2057|      0|        result = CURLE_OK;
 2058|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 2059|      0|      }
 2060|      0|      else {
 2061|       |        /* Perform the protocol's DO action */
 2062|      0|        result = multi_do(data, &dophase_done);
 2063|       |
 2064|       |        /* When multi_do() returns failure, data->conn might be NULL! */
 2065|       |
 2066|      0|        if(!result) {
 2067|      0|          if(!dophase_done) {
 2068|      0|#ifndef CURL_DISABLE_FTP
 2069|       |            /* some steps needed for wildcard matching */
 2070|      0|            if(data->state.wildcardmatch) {
 2071|      0|              struct WildcardData *wc = &data->wildcard;
 2072|      0|              if(wc->state == CURLWC_DONE || wc->state == CURLWC_SKIP) {
 2073|       |                /* skip some states if it is important */
 2074|      0|                multi_done(data, CURLE_OK, FALSE);
 2075|       |
 2076|       |                /* if there's no connection left, skip the DONE state */
 2077|      0|                multistate(data, data->conn ?
 2078|      0|                           MSTATE_DONE : MSTATE_COMPLETED);
 2079|      0|                rc = CURLM_CALL_MULTI_PERFORM;
 2080|      0|                break;
 2081|      0|              }
 2082|      0|            }
 2083|      0|#endif
 2084|       |            /* DO was not completed in one function call, we must continue
 2085|       |               DOING... */
 2086|      0|            multistate(data, MSTATE_DOING);
 2087|      0|            rc = CURLM_OK;
 2088|      0|          }
 2089|       |
 2090|       |          /* after DO, go DO_DONE... or DO_MORE */
 2091|      0|          else if(data->conn->bits.do_more) {
 2092|       |            /* we're supposed to do more, but we need to sit down, relax
 2093|       |               and wait a little while first */
 2094|      0|            multistate(data, MSTATE_DOING_MORE);
 2095|      0|            rc = CURLM_OK;
 2096|      0|          }
 2097|      0|          else {
 2098|       |            /* we're done with the DO, now DID */
 2099|      0|            multistate(data, MSTATE_DID);
 2100|      0|            rc = CURLM_CALL_MULTI_PERFORM;
 2101|      0|          }
 2102|      0|        }
 2103|      0|        else if((CURLE_SEND_ERROR == result) &&
 2104|      0|                data->conn->bits.reuse) {
 2105|       |          /*
 2106|       |           * In this situation, a connection that we were trying to use
 2107|       |           * may have unexpectedly died.  If possible, send the connection
 2108|       |           * back to the CONNECT phase so we can try again.
 2109|       |           */
 2110|      0|          char *newurl = NULL;
 2111|      0|          followtype follow = FOLLOW_NONE;
 2112|      0|          CURLcode drc;
 2113|       |
 2114|      0|          drc = Curl_retry_request(data, &newurl);
 2115|      0|          if(drc) {
 2116|       |            /* a failure here pretty much implies an out of memory */
 2117|      0|            result = drc;
 2118|      0|            stream_error = TRUE;
 2119|      0|          }
 2120|       |
 2121|      0|          Curl_posttransfer(data);
 2122|      0|          drc = multi_done(data, result, FALSE);
 2123|       |
 2124|       |          /* When set to retry the connection, we must to go back to
 2125|       |           * the CONNECT state */
 2126|      0|          if(newurl) {
 2127|      0|            if(!drc || (drc == CURLE_SEND_ERROR)) {
 2128|      0|              follow = FOLLOW_RETRY;
 2129|      0|              drc = Curl_follow(data, newurl, follow);
 2130|      0|              if(!drc) {
 2131|      0|                multistate(data, MSTATE_CONNECT);
 2132|      0|                rc = CURLM_CALL_MULTI_PERFORM;
 2133|      0|                result = CURLE_OK;
 2134|      0|              }
 2135|      0|              else {
 2136|       |                /* Follow failed */
 2137|      0|                result = drc;
 2138|      0|              }
 2139|      0|            }
 2140|      0|            else {
 2141|       |              /* done didn't return OK or SEND_ERROR */
 2142|      0|              result = drc;
 2143|      0|            }
 2144|      0|          }
 2145|      0|          else {
 2146|       |            /* Have error handler disconnect conn if we can't retry */
 2147|      0|            stream_error = TRUE;
 2148|      0|          }
 2149|      0|          free(newurl);
 2150|      0|        }
 2151|      0|        else {
 2152|       |          /* failure detected */
 2153|      0|          Curl_posttransfer(data);
 2154|      0|          if(data->conn)
 2155|      0|            multi_done(data, result, FALSE);
 2156|      0|          stream_error = TRUE;
 2157|      0|        }
 2158|      0|      }
 2159|      0|      break;
 2160|       |
 2161|      0|    case MSTATE_DOING:
 2162|       |      /* we continue DOING until the DO phase is complete */
 2163|      0|      DEBUGASSERT(data->conn);
 2164|      0|      result = protocol_doing(data, &dophase_done);
 2165|      0|      if(!result) {
 2166|      0|        if(dophase_done) {
 2167|       |          /* after DO, go DO_DONE or DO_MORE */
 2168|      0|          multistate(data, data->conn->bits.do_more?
 2169|      0|                     MSTATE_DOING_MORE : MSTATE_DID);
 2170|      0|          rc = CURLM_CALL_MULTI_PERFORM;
 2171|      0|        } /* dophase_done */
 2172|      0|      }
 2173|      0|      else {
 2174|       |        /* failure detected */
 2175|      0|        Curl_posttransfer(data);
 2176|      0|        multi_done(data, result, FALSE);
 2177|      0|        stream_error = TRUE;
 2178|      0|      }
 2179|      0|      break;
 2180|       |
 2181|      0|    case MSTATE_DOING_MORE:
 2182|       |      /*
 2183|       |       * When we are connected, DOING MORE and then go DID
 2184|       |       */
 2185|      0|      DEBUGASSERT(data->conn);
 2186|      0|      result = multi_do_more(data, &control);
 2187|       |
 2188|      0|      if(!result) {
 2189|      0|        if(control) {
 2190|       |          /* if positive, advance to DO_DONE
 2191|       |             if negative, go back to DOING */
 2192|      0|          multistate(data, control == 1?
 2193|      0|                     MSTATE_DID : MSTATE_DOING);
 2194|      0|          rc = CURLM_CALL_MULTI_PERFORM;
 2195|      0|        }
 2196|      0|        else
 2197|       |          /* stay in DO_MORE */
 2198|      0|          rc = CURLM_OK;
 2199|      0|      }
 2200|      0|      else {
 2201|       |        /* failure detected */
 2202|      0|        Curl_posttransfer(data);
 2203|      0|        multi_done(data, result, FALSE);
 2204|      0|        stream_error = TRUE;
 2205|      0|      }
 2206|      0|      break;
 2207|       |
 2208|      0|    case MSTATE_DID:
 2209|      0|      DEBUGASSERT(data->conn);
 2210|      0|      if(data->conn->bits.multiplex)
 2211|       |        /* Check if we can move pending requests to send pipe */
 2212|      0|        process_pending_handles(multi); /*  multiplexed */
 2213|       |
 2214|       |      /* Only perform the transfer if there's a good socket to work with.
 2215|       |         Having both BAD is a signal to skip immediately to DONE */
 2216|      0|      if((data->conn->sockfd != CURL_SOCKET_BAD) ||
 2217|      0|         (data->conn->writesockfd != CURL_SOCKET_BAD))
 2218|      0|        multistate(data, MSTATE_PERFORMING);
 2219|      0|      else {
 2220|      0|#ifndef CURL_DISABLE_FTP
 2221|      0|        if(data->state.wildcardmatch &&
 2222|      0|           ((data->conn->handler->flags & PROTOPT_WILDCARD) == 0)) {
 2223|      0|          data->wildcard.state = CURLWC_DONE;
 2224|      0|        }
 2225|      0|#endif
 2226|      0|        multistate(data, MSTATE_DONE);
 2227|      0|      }
 2228|      0|      rc = CURLM_CALL_MULTI_PERFORM;
 2229|      0|      break;
 2230|       |
 2231|      0|    case MSTATE_RATELIMITING: /* limit-rate exceeded in either direction */
 2232|      0|      DEBUGASSERT(data->conn);
 2233|       |      /* if both rates are within spec, resume transfer */
 2234|      0|      if(Curl_pgrsUpdate(data))
 2235|      0|        result = CURLE_ABORTED_BY_CALLBACK;
 2236|      0|      else
 2237|      0|        result = Curl_speedcheck(data, *nowp);
 2238|       |
 2239|      0|      if(result) {
 2240|      0|        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&
 2241|      0|           result != CURLE_HTTP2_STREAM)
 2242|      0|          streamclose(data->conn, "Transfer returned error");
 2243|       |
 2244|      0|        Curl_posttransfer(data);
 2245|      0|        multi_done(data, result, TRUE);
 2246|      0|      }
 2247|      0|      else {
 2248|      0|        send_timeout_ms = 0;
 2249|      0|        if(data->set.max_send_speed)
 2250|      0|          send_timeout_ms =
 2251|      0|            Curl_pgrsLimitWaitTime(data->progress.uploaded,
 2252|      0|                                   data->progress.ul_limit_size,
 2253|      0|                                   data->set.max_send_speed,
 2254|      0|                                   data->progress.ul_limit_start,
 2255|      0|                                   *nowp);
 2256|       |
 2257|      0|        recv_timeout_ms = 0;
 2258|      0|        if(data->set.max_recv_speed)
 2259|      0|          recv_timeout_ms =
 2260|      0|            Curl_pgrsLimitWaitTime(data->progress.downloaded,
 2261|      0|                                   data->progress.dl_limit_size,
 2262|      0|                                   data->set.max_recv_speed,
 2263|      0|                                   data->progress.dl_limit_start,
 2264|      0|                                   *nowp);
 2265|       |
 2266|      0|        if(!send_timeout_ms && !recv_timeout_ms) {
 2267|      0|          multistate(data, MSTATE_PERFORMING);
 2268|      0|          Curl_ratelimit(data, *nowp);
 2269|      0|        }
 2270|      0|        else if(send_timeout_ms >= recv_timeout_ms)
 2271|      0|          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);
 2272|      0|        else
 2273|      0|          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);
 2274|      0|      }
 2275|      0|      break;
 2276|       |
 2277|      0|    case MSTATE_PERFORMING:
 2278|      0|    {
 2279|      0|      char *newurl = NULL;
 2280|      0|      bool retry = FALSE;
 2281|      0|      bool comeback = FALSE;
 2282|      0|      DEBUGASSERT(data->state.buffer);
 2283|       |      /* check if over send speed */
 2284|      0|      send_timeout_ms = 0;
 2285|      0|      if(data->set.max_send_speed)
 2286|      0|        send_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.uploaded,
 2287|      0|                                                 data->progress.ul_limit_size,
 2288|      0|                                                 data->set.max_send_speed,
 2289|      0|                                                 data->progress.ul_limit_start,
 2290|      0|                                                 *nowp);
 2291|       |
 2292|       |      /* check if over recv speed */
 2293|      0|      recv_timeout_ms = 0;
 2294|      0|      if(data->set.max_recv_speed)
 2295|      0|        recv_timeout_ms = Curl_pgrsLimitWaitTime(data->progress.downloaded,
 2296|      0|                                                 data->progress.dl_limit_size,
 2297|      0|                                                 data->set.max_recv_speed,
 2298|      0|                                                 data->progress.dl_limit_start,
 2299|      0|                                                 *nowp);
 2300|       |
 2301|      0|      if(send_timeout_ms || recv_timeout_ms) {
 2302|      0|        Curl_ratelimit(data, *nowp);
 2303|      0|        multistate(data, MSTATE_RATELIMITING);
 2304|      0|        if(send_timeout_ms >= recv_timeout_ms)
 2305|      0|          Curl_expire(data, send_timeout_ms, EXPIRE_TOOFAST);
 2306|      0|        else
 2307|      0|          Curl_expire(data, recv_timeout_ms, EXPIRE_TOOFAST);
 2308|      0|        break;
 2309|      0|      }
 2310|       |
 2311|       |      /* read/write data if it is ready to do so */
 2312|      0|      result = Curl_readwrite(data->conn, data, &done, &comeback);
 2313|       |
 2314|      0|      if(done || (result == CURLE_RECV_ERROR)) {
 2315|       |        /* If CURLE_RECV_ERROR happens early enough, we assume it was a race
 2316|       |         * condition and the server closed the re-used connection exactly when
 2317|       |         * we wanted to use it, so figure out if that is indeed the case.
 2318|       |         */
 2319|      0|        CURLcode ret = Curl_retry_request(data, &newurl);
 2320|      0|        if(!ret)
 2321|      0|          retry = (newurl)?TRUE:FALSE;
 2322|      0|        else if(!result)
 2323|      0|          result = ret;
 2324|       |
 2325|      0|        if(retry) {
 2326|       |          /* if we are to retry, set the result to OK and consider the
 2327|       |             request as done */
 2328|      0|          result = CURLE_OK;
 2329|      0|          done = TRUE;
 2330|      0|        }
 2331|      0|      }
 2332|      0|      else if((CURLE_HTTP2_STREAM == result) &&
 2333|      0|              Curl_h2_http_1_1_error(data)) {
 2334|      0|        CURLcode ret = Curl_retry_request(data, &newurl);
 2335|       |
 2336|      0|        if(!ret) {
 2337|      0|          infof(data, "Downgrades to HTTP/1.1!");
 2338|      0|          streamclose(data->conn, "Disconnect HTTP/2 for HTTP/1");
 2339|      0|          data->state.httpwant = CURL_HTTP_VERSION_1_1;
 2340|       |          /* clear the error message bit too as we ignore the one we got */
 2341|      0|          data->state.errorbuf = FALSE;
 2342|      0|          if(!newurl)
 2343|       |            /* typically for HTTP_1_1_REQUIRED error on first flight */
 2344|      0|            newurl = strdup(data->state.url);
 2345|       |          /* if we are to retry, set the result to OK and consider the request
 2346|       |             as done */
 2347|      0|          retry = TRUE;
 2348|      0|          result = CURLE_OK;
 2349|      0|          done = TRUE;
 2350|      0|        }
 2351|      0|        else
 2352|      0|          result = ret;
 2353|      0|      }
 2354|       |
 2355|      0|      if(result) {
 2356|       |        /*
 2357|       |         * The transfer phase returned error, we mark the connection to get
 2358|       |         * closed to prevent being re-used. This is because we can't possibly
 2359|       |         * know if the connection is in a good shape or not now.  Unless it is
 2360|       |         * a protocol which uses two "channels" like FTP, as then the error
 2361|       |         * happened in the data connection.
 2362|       |         */
 2363|       |
 2364|      0|        if(!(data->conn->handler->flags & PROTOPT_DUAL) &&
 2365|      0|           result != CURLE_HTTP2_STREAM)
 2366|      0|          streamclose(data->conn, "Transfer returned error");
 2367|       |
 2368|      0|        Curl_posttransfer(data);
 2369|      0|        multi_done(data, result, TRUE);
 2370|      0|      }
 2371|      0|      else if(done) {
 2372|       |
 2373|       |        /* call this even if the readwrite function returned error */
 2374|      0|        Curl_posttransfer(data);
 2375|       |
 2376|       |        /* When we follow redirects or is set to retry the connection, we must
 2377|       |           to go back to the CONNECT state */
 2378|      0|        if(data->req.newurl || retry) {
 2379|      0|          followtype follow = FOLLOW_NONE;
 2380|      0|          if(!retry) {
 2381|       |            /* if the URL is a follow-location and not just a retried request
 2382|       |               then figure out the URL here */
 2383|      0|            free(newurl);
 2384|      0|            newurl = data->req.newurl;
 2385|      0|            data->req.newurl = NULL;
 2386|      0|            follow = FOLLOW_REDIR;
 2387|      0|          }
 2388|      0|          else
 2389|      0|            follow = FOLLOW_RETRY;
 2390|      0|          (void)multi_done(data, CURLE_OK, FALSE);
 2391|       |          /* multi_done() might return CURLE_GOT_NOTHING */
 2392|      0|          result = Curl_follow(data, newurl, follow);
 2393|      0|          if(!result) {
 2394|      0|            multistate(data, MSTATE_CONNECT);
 2395|      0|            rc = CURLM_CALL_MULTI_PERFORM;
 2396|      0|          }
 2397|      0|          free(newurl);
 2398|      0|        }
 2399|      0|        else {
 2400|       |          /* after the transfer is done, go DONE */
 2401|       |
 2402|       |          /* but first check to see if we got a location info even though we're
 2403|       |             not following redirects */
 2404|      0|          if(data->req.location) {
 2405|      0|            free(newurl);
 2406|      0|            newurl = data->req.location;
 2407|      0|            data->req.location = NULL;
 2408|      0|            result = Curl_follow(data, newurl, FOLLOW_FAKE);
 2409|      0|            free(newurl);
 2410|      0|            if(result) {
 2411|      0|              stream_error = TRUE;
 2412|      0|              result = multi_done(data, result, TRUE);
 2413|      0|            }
 2414|      0|          }
 2415|       |
 2416|      0|          if(!result) {
 2417|      0|            multistate(data, MSTATE_DONE);
 2418|      0|            rc = CURLM_CALL_MULTI_PERFORM;
 2419|      0|          }
 2420|      0|        }
 2421|      0|      }
 2422|      0|      else if(comeback) {
 2423|       |        /* This avoids CURLM_CALL_MULTI_PERFORM so that a very fast transfer
 2424|       |           won't get stuck on this transfer at the expense of other concurrent
 2425|       |           transfers */
 2426|      0|        Curl_expire(data, 0, EXPIRE_RUN_NOW);
 2427|      0|        rc = CURLM_OK;
 2428|      0|      }
 2429|      0|      break;
 2430|      0|    }
 2431|       |
 2432|      0|    case MSTATE_DONE:
 2433|       |      /* this state is highly transient, so run another loop after this */
 2434|      0|      rc = CURLM_CALL_MULTI_PERFORM;
 2435|       |
 2436|      0|      if(data->conn) {
 2437|      0|        CURLcode res;
 2438|       |
 2439|      0|        if(data->conn->bits.multiplex)
 2440|       |          /* Check if we can move pending requests to connection */
 2441|      0|          process_pending_handles(multi); /* multiplexing */
 2442|       |
 2443|       |        /* post-transfer command */
 2444|      0|        res = multi_done(data, result, FALSE);
 2445|       |
 2446|       |        /* allow a previously set error code take precedence */
 2447|      0|        if(!result)
 2448|      0|          result = res;
 2449|      0|      }
 2450|       |
 2451|      0|#ifndef CURL_DISABLE_FTP
 2452|      0|      if(data->state.wildcardmatch) {
 2453|      0|        if(data->wildcard.state != CURLWC_DONE) {
 2454|       |          /* if a wildcard is set and we are not ending -> lets start again
 2455|       |             with MSTATE_INIT */
 2456|      0|          multistate(data, MSTATE_INIT);
 2457|      0|          break;
 2458|      0|        }
 2459|      0|      }
 2460|      0|#endif
 2461|       |      /* after we have DONE what we're supposed to do, go COMPLETED, and
 2462|       |         it doesn't matter what the multi_done() returned! */
 2463|      0|      multistate(data, MSTATE_COMPLETED);
 2464|      0|      break;
 2465|       |
 2466|      0|    case MSTATE_COMPLETED:
 2467|      0|      break;
 2468|       |
 2469|      0|    case MSTATE_MSGSENT:
 2470|      0|      data->result = result;
 2471|      0|      return CURLM_OK; /* do nothing */
 2472|       |
 2473|      0|    default:
 2474|      0|      return CURLM_INTERNAL_ERROR;
 2475|    715|    }
 2476|       |
 2477|    715|    if(data->conn &&
 2478|    715|       data->mstate >= MSTATE_CONNECT &&
 2479|    715|       data->mstate < MSTATE_DO &&
 2480|    715|       rc != CURLM_CALL_MULTI_PERFORM &&
 2481|    715|       !multi_ischanged(multi, false)) {
 2482|       |      /* We now handle stream timeouts if and only if this will be the last
 2483|       |       * loop iteration. We only check this on the last iteration to ensure
 2484|       |       * that if we know we have additional work to do immediately
 2485|       |       * (i.e. CURLM_CALL_MULTI_PERFORM == TRUE) then we should do that before
 2486|       |       * declaring the connection timed out as we may almost have a completed
 2487|       |       * connection. */
 2488|      0|      multi_handle_timeout(data, nowp, &stream_error, &result, TRUE);
 2489|      0|    }
 2490|       |
 2491|    715|    statemachine_end:
 2492|       |
 2493|    715|    if(data->mstate < MSTATE_COMPLETED) {
 2494|    715|      if(result) {
 2495|       |        /*
 2496|       |         * If an error was returned, and we aren't in completed state now,
 2497|       |         * then we go to completed and consider this transfer aborted.
 2498|       |         */
 2499|       |
 2500|       |        /* NOTE: no attempt to disconnect connections must be made
 2501|       |           in the case blocks above - cleanup happens only here */
 2502|       |
 2503|       |        /* Check if we can move pending requests to send pipe */
 2504|    462|        process_pending_handles(multi); /* connection */
 2505|       |
 2506|    462|        if(data->conn) {
 2507|      0|          if(stream_error) {
 2508|       |            /* Don't attempt to send data over a connection that timed out */
 2509|      0|            bool dead_connection = result == CURLE_OPERATION_TIMEDOUT;
 2510|      0|            struct connectdata *conn = data->conn;
 2511|       |
 2512|       |            /* This is where we make sure that the conn pointer is reset.
 2513|       |               We don't have to do this in every case block above where a
 2514|       |               failure is detected */
 2515|      0|            Curl_detach_connnection(data);
 2516|       |
 2517|       |            /* remove connection from cache */
 2518|      0|            Curl_conncache_remove_conn(data, conn, TRUE);
 2519|       |
 2520|       |            /* disconnect properly */
 2521|      0|            Curl_disconnect(data, conn, dead_connection);
 2522|      0|          }
 2523|      0|        }
 2524|    462|        else if(data->mstate == MSTATE_CONNECT) {
 2525|       |          /* Curl_connect() failed */
 2526|    253|          (void)Curl_posttransfer(data);
 2527|    253|        }
 2528|       |
 2529|    462|        multistate(data, MSTATE_COMPLETED);
 2530|    462|        rc = CURLM_CALL_MULTI_PERFORM;
 2531|    462|      }
 2532|       |      /* if there's still a connection to use, call the progress function */
 2533|    253|      else if(data->conn && Curl_pgrsUpdate(data)) {
 2534|       |        /* aborted due to progress callback return code must close the
 2535|       |           connection */
 2536|      0|        result = CURLE_ABORTED_BY_CALLBACK;
 2537|      0|        streamclose(data->conn, "Aborted by callback");
 2538|       |
 2539|       |        /* if not yet in DONE state, go there, otherwise COMPLETED */
 2540|      0|        multistate(data, (data->mstate < MSTATE_DONE)?
 2541|      0|                   MSTATE_DONE: MSTATE_COMPLETED);
 2542|      0|        rc = CURLM_CALL_MULTI_PERFORM;
 2543|      0|      }
 2544|    715|    }
 2545|       |
 2546|    715|    if(MSTATE_COMPLETED == data->mstate) {
 2547|    462|      if(data->set.fmultidone) {
 2548|       |        /* signal via callback instead */
 2549|      0|        data->set.fmultidone(data, result);
 2550|      0|      }
 2551|    462|      else {
 2552|       |        /* now fill in the Curl_message with this info */
 2553|    462|        msg = &data->msg;
 2554|       |
 2555|    462|        msg->extmsg.msg = CURLMSG_DONE;
 2556|    462|        msg->extmsg.easy_handle = data;
 2557|    462|        msg->extmsg.data.result = result;
 2558|       |
 2559|    462|        rc = multi_addmsg(multi, msg);
 2560|    462|        DEBUGASSERT(!data->conn);
 2561|    462|      }
 2562|    462|      multistate(data, MSTATE_MSGSENT);
 2563|    462|    }
 2564|    715|  } while((rc == CURLM_CALL_MULTI_PERFORM) || multi_ischanged(multi, FALSE));
 2565|       |
 2566|    462|  data->result = result;
 2567|    462|  return rc;
 2568|    462|}
multi.c:multi_ischanged:
 1486|  1.17k|{
 1487|  1.17k|  bool retval = multi->recheckstate;
 1488|  1.17k|  if(clear)
 1489|    715|    multi->recheckstate = FALSE;
 1490|  1.17k|  return retval;
 1491|  1.17k|}
multi.c:multi_addmsg:
  349|    462|{
  350|    462|  Curl_llist_insert_next(&multi->msglist, multi->msglist.tail, msg,
  351|    462|                         &msg->list);
  352|    462|  return CURLM_OK;
  353|    462|}
multi.c:singlesocket:
 2732|    462|{
 2733|    462|  curl_socket_t socks[MAX_SOCKSPEREASYHANDLE];
 2734|    462|  int i;
 2735|    462|  struct Curl_sh_entry *entry;
 2736|    462|  curl_socket_t s;
 2737|    462|  int num;
 2738|    462|  unsigned int curraction;
 2739|    462|  unsigned char actions[MAX_SOCKSPEREASYHANDLE];
 2740|       |
 2741|  2.77k|  for(i = 0; i< MAX_SOCKSPEREASYHANDLE; i++)
 2742|  2.31k|    socks[i] = CURL_SOCKET_BAD;
 2743|       |
 2744|       |  /* Fill in the 'current' struct with the state as it is now: what sockets to
 2745|       |     supervise and for what actions */
 2746|    462|  curraction = multi_getsock(data, socks);
 2747|       |
 2748|       |  /* We have 0 .. N sockets already and we get to know about the 0 .. M
 2749|       |     sockets we should have from now on. Detect the differences, remove no
 2750|       |     longer supervised ones and add new ones */
 2751|       |
 2752|       |  /* walk over the sockets we got right now */
 2753|    462|  for(i = 0; (i< MAX_SOCKSPEREASYHANDLE) &&
 2754|    462|        (curraction & (GETSOCK_READSOCK(i) | GETSOCK_WRITESOCK(i)));
 2755|    462|      i++) {
 2756|      0|    unsigned char action = CURL_POLL_NONE;
 2757|      0|    unsigned char prevaction = 0;
 2758|      0|    int comboaction;
 2759|      0|    bool sincebefore = FALSE;
 2760|       |
 2761|      0|    s = socks[i];
 2762|       |
 2763|       |    /* get it from the hash */
 2764|      0|    entry = sh_getentry(&multi->sockhash, s);
 2765|       |
 2766|      0|    if(curraction & GETSOCK_READSOCK(i))
 2767|      0|      action |= CURL_POLL_IN;
 2768|      0|    if(curraction & GETSOCK_WRITESOCK(i))
 2769|      0|      action |= CURL_POLL_OUT;
 2770|       |
 2771|      0|    actions[i] = action;
 2772|      0|    if(entry) {
 2773|       |      /* check if new for this transfer */
 2774|      0|      int j;
 2775|      0|      for(j = 0; j< data->numsocks; j++) {
 2776|      0|        if(s == data->sockets[j]) {
 2777|      0|          prevaction = data->actions[j];
 2778|      0|          sincebefore = TRUE;
 2779|      0|          break;
 2780|      0|        }
 2781|      0|      }
 2782|      0|    }
 2783|      0|    else {
 2784|       |      /* this is a socket we didn't have before, add it to the hash! */
 2785|      0|      entry = sh_addentry(&multi->sockhash, s);
 2786|      0|      if(!entry)
 2787|       |        /* fatal */
 2788|      0|        return CURLM_OUT_OF_MEMORY;
 2789|      0|    }
 2790|      0|    if(sincebefore && (prevaction != action)) {
 2791|       |      /* Socket was used already, but different action now */
 2792|      0|      if(prevaction & CURL_POLL_IN)
 2793|      0|        entry->readers--;
 2794|      0|      if(prevaction & CURL_POLL_OUT)
 2795|      0|        entry->writers--;
 2796|      0|      if(action & CURL_POLL_IN)
 2797|      0|        entry->readers++;
 2798|      0|      if(action & CURL_POLL_OUT)
 2799|      0|        entry->writers++;
 2800|      0|    }
 2801|      0|    else if(!sincebefore) {
 2802|       |      /* a new user */
 2803|      0|      entry->users++;
 2804|      0|      if(action & CURL_POLL_IN)
 2805|      0|        entry->readers++;
 2806|      0|      if(action & CURL_POLL_OUT)
 2807|      0|        entry->writers++;
 2808|       |
 2809|       |      /* add 'data' to the transfer hash on this socket! */
 2810|      0|      if(!Curl_hash_add(&entry->transfers, (char *)&data, /* hash key */
 2811|      0|                        sizeof(struct Curl_easy *), data))
 2812|      0|        return CURLM_OUT_OF_MEMORY;
 2813|      0|    }
 2814|       |
 2815|      0|    comboaction = (entry->writers? CURL_POLL_OUT : 0) |
 2816|      0|                   (entry->readers ? CURL_POLL_IN : 0);
 2817|       |
 2818|       |    /* socket existed before and has the same action set as before */
 2819|      0|    if(sincebefore && ((int)entry->action == comboaction))
 2820|       |      /* same, continue */
 2821|      0|      continue;
 2822|       |
 2823|      0|    if(multi->socket_cb)
 2824|      0|      multi->socket_cb(data, s, comboaction, multi->socket_userp,
 2825|      0|                       entry->socketp);
 2826|       |
 2827|      0|    entry->action = comboaction; /* store the current action state */
 2828|      0|  }
 2829|       |
 2830|    462|  num = i; /* number of sockets */
 2831|       |
 2832|       |  /* when we've walked over all the sockets we should have right now, we must
 2833|       |     make sure to detect sockets that are removed */
 2834|    462|  for(i = 0; i< data->numsocks; i++) {
 2835|      0|    int j;
 2836|      0|    bool stillused = FALSE;
 2837|      0|    s = data->sockets[i];
 2838|      0|    for(j = 0; j < num; j++) {
 2839|      0|      if(s == socks[j]) {
 2840|       |        /* this is still supervised */
 2841|      0|        stillused = TRUE;
 2842|      0|        break;
 2843|      0|      }
 2844|      0|    }
 2845|      0|    if(stillused)
 2846|      0|      continue;
 2847|       |
 2848|      0|    entry = sh_getentry(&multi->sockhash, s);
 2849|       |    /* if this is NULL here, the socket has been closed and notified so
 2850|       |       already by Curl_multi_closed() */
 2851|      0|    if(entry) {
 2852|      0|      unsigned char oldactions = data->actions[i];
 2853|       |      /* this socket has been removed. Decrease user count */
 2854|      0|      entry->users--;
 2855|      0|      if(oldactions & CURL_POLL_OUT)
 2856|      0|        entry->writers--;
 2857|      0|      if(oldactions & CURL_POLL_IN)
 2858|      0|        entry->readers--;
 2859|      0|      if(!entry->users) {
 2860|      0|        if(multi->socket_cb)
 2861|      0|          multi->socket_cb(data, s, CURL_POLL_REMOVE,
 2862|      0|                           multi->socket_userp,
 2863|      0|                           entry->socketp);
 2864|      0|        sh_delentry(entry, &multi->sockhash, s);
 2865|      0|      }
 2866|      0|      else {
 2867|       |        /* still users, but remove this handle as a user of this socket */
 2868|      0|        if(Curl_hash_delete(&entry->transfers, (char *)&data,
 2869|      0|                            sizeof(struct Curl_easy *))) {
 2870|      0|          DEBUGASSERT(NULL);
 2871|      0|        }
 2872|      0|      }
 2873|      0|    }
 2874|      0|  } /* for loop over numsocks */
 2875|       |
 2876|    462|  memcpy(data->sockets, socks, num*sizeof(curl_socket_t));
 2877|    462|  memcpy(data->actions, actions, num*sizeof(char));
 2878|    462|  data->numsocks = num;
 2879|    462|  return CURLM_OK;
 2880|    462|}
multi.c:multi_deltimeout:
 3298|    715|{
 3299|    715|  struct Curl_llist_element *e;
 3300|    715|  struct Curl_llist *timeoutlist = &data->state.timeoutlist;
 3301|       |  /* find and remove the specific node from the list */
 3302|    968|  for(e = timeoutlist->head; e; e = e->next) {
 3303|    253|    struct time_node *n = (struct time_node *)e->ptr;
 3304|    253|    if(n->eid == eid) {
 3305|      0|      Curl_llist_remove(timeoutlist, e, NULL);
 3306|      0|      return;
 3307|      0|    }
 3308|    253|  }
 3309|    715|}
multi.c:multi_addtimeout:
 3322|    715|{
 3323|    715|  struct Curl_llist_element *e;
 3324|    715|  struct time_node *node;
 3325|    715|  struct Curl_llist_element *prev = NULL;
 3326|    715|  size_t n;
 3327|    715|  struct Curl_llist *timeoutlist = &data->state.timeoutlist;
 3328|       |
 3329|    715|  node = &data->state.expires[eid];
 3330|       |
 3331|       |  /* copy the timestamp and id */
 3332|    715|  memcpy(&node->time, stamp, sizeof(*stamp));
 3333|    715|  node->eid = eid; /* also marks it as in use */
 3334|       |
 3335|    715|  n = Curl_llist_count(timeoutlist);
 3336|    715|  if(n) {
 3337|       |    /* find the correct spot in the list */
 3338|    506|    for(e = timeoutlist->head; e; e = e->next) {
 3339|    253|      struct time_node *check = (struct time_node *)e->ptr;
 3340|    253|      timediff_t diff = Curl_timediff(check->time, node->time);
 3341|    253|      if(diff > 0)
 3342|      0|        break;
 3343|    253|      prev = e;
 3344|    253|    }
 3345|       |
 3346|    253|  }
 3347|       |  /* else
 3348|       |     this is the first timeout on the list */
 3349|       |
 3350|    715|  Curl_llist_insert_next(timeoutlist, prev, node, &node->list);
 3351|    715|  return CURLM_OK;
 3352|    715|}
multi.c:process_pending_handles:
 3524|    924|{
 3525|    924|  struct Curl_llist_element *e = multi->pending.head;
 3526|    924|  if(e) {
 3527|      0|    struct Curl_easy *data = e->ptr;
 3528|       |
 3529|      0|    DEBUGASSERT(data->mstate == MSTATE_PENDING);
 3530|       |
 3531|      0|    multistate(data, MSTATE_CONNECT);
 3532|       |
 3533|       |    /* Remove this node from the list */
 3534|      0|    Curl_llist_remove(&multi->pending, e, NULL);
 3535|       |
 3536|       |    /* Make sure that the handle will be processed soonish. */
 3537|      0|    Curl_expire(data, 0, EXPIRE_RUN_NOW);
 3538|       |
 3539|       |    /* mark this as having been in the pending queue */
 3540|      0|    data->state.previouslypending = TRUE;
 3541|      0|  }
 3542|    924|}

curlx_nonblock:
   49|    924|{
   50|    924|#if defined(HAVE_FCNTL_O_NONBLOCK)
   51|       |  /* most recent unix versions */
   52|    924|  int flags;
   53|    924|  flags = sfcntl(sockfd, F_GETFL, 0);
   54|    924|  if(nonblock)
   55|    924|    return sfcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
   56|      0|  return sfcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));
   57|       |
   58|       |#elif defined(HAVE_IOCTL_FIONBIO)
   59|       |
   60|       |  /* older unix versions */
   61|       |  int flags = nonblock ? 1 : 0;
   62|       |  return ioctl(sockfd, FIONBIO, &flags);
   63|       |
   64|       |#elif defined(HAVE_IOCTLSOCKET_FIONBIO)
   65|       |
   66|       |  /* Windows */
   67|       |  unsigned long flags = nonblock ? 1UL : 0UL;
   68|       |  return ioctlsocket(sockfd, FIONBIO, &flags);
   69|       |
   70|       |#elif defined(HAVE_IOCTLSOCKET_CAMEL_FIONBIO)
   71|       |
   72|       |  /* Amiga */
   73|       |  long flags = nonblock ? 1L : 0L;
   74|       |  return IoctlSocket(sockfd, FIONBIO, (char *)&flags);
   75|       |
   76|       |#elif defined(HAVE_SETSOCKOPT_SO_NONBLOCK)
   77|       |
   78|       |  /* BeOS */
   79|       |  long b = nonblock ? 1L : 0L;
   80|       |  return setsockopt(sockfd, SOL_SOCKET, SO_NONBLOCK, &b, sizeof(b));
   81|       |
   82|       |#else
   83|       |#  error "no non-blocking method was found/used/set"
   84|       |#endif
   85|    924|}

Curl_pgrsResetTransferSizes:
  160|    253|{
  161|    253|  Curl_pgrsSetDownloadSize(data, -1);
  162|    253|  Curl_pgrsSetUploadSize(data, -1);
  163|    253|}
Curl_pgrsTime:
  173|    506|{
  174|    506|  struct curltime now = Curl_now();
  175|    506|  timediff_t *delta = NULL;
  176|       |
  177|    506|  switch(timer) {
  178|      0|  default:
  179|      0|  case TIMER_NONE:
  180|       |    /* mistake filter */
  181|      0|    break;
  182|    253|  case TIMER_STARTOP:
  183|       |    /* This is set at the start of a transfer */
  184|    253|    data->progress.t_startop = now;
  185|    253|    break;
  186|    253|  case TIMER_STARTSINGLE:
  187|       |    /* This is set at the start of each single fetch */
  188|    253|    data->progress.t_startsingle = now;
  189|    253|    data->progress.is_t_startransfer_set = false;
  190|    253|    break;
  191|      0|  case TIMER_STARTACCEPT:
  192|      0|    data->progress.t_acceptdata = now;
  193|      0|    break;
  194|      0|  case TIMER_NAMELOOKUP:
  195|      0|    delta = &data->progress.t_nslookup;
  196|      0|    break;
  197|      0|  case TIMER_CONNECT:
  198|      0|    delta = &data->progress.t_connect;
  199|      0|    break;
  200|      0|  case TIMER_APPCONNECT:
  201|      0|    delta = &data->progress.t_appconnect;
  202|      0|    break;
  203|      0|  case TIMER_PRETRANSFER:
  204|      0|    delta = &data->progress.t_pretransfer;
  205|      0|    break;
  206|      0|  case TIMER_STARTTRANSFER:
  207|      0|    delta = &data->progress.t_starttransfer;
  208|       |    /* prevent updating t_starttransfer unless:
  209|       |     *   1) this is the first time we're setting t_starttransfer
  210|       |     *   2) a redirect has occurred since the last time t_starttransfer was set
  211|       |     * This prevents repeated invocations of the function from incorrectly
  212|       |     * changing the t_starttransfer time.
  213|       |     */
  214|      0|    if(data->progress.is_t_startransfer_set) {
  215|      0|      return now;
  216|      0|    }
  217|      0|    else {
  218|      0|      data->progress.is_t_startransfer_set = true;
  219|      0|      break;
  220|      0|    }
  221|      0|  case TIMER_POSTRANSFER:
  222|       |    /* this is the normal end-of-transfer thing */
  223|      0|    break;
  224|      0|  case TIMER_REDIRECT:
  225|      0|    data->progress.t_redirect = Curl_timediff_us(now, data->progress.start);
  226|      0|    break;
  227|    506|  }
  228|    506|  if(delta) {
  229|      0|    timediff_t us = Curl_timediff_us(now, data->progress.t_startsingle);
  230|      0|    if(us < 1)
  231|      0|      us = 1; /* make sure at least one microsecond passed */
  232|      0|    *delta += us;
  233|      0|  }
  234|    506|  return now;
  235|    506|}
Curl_pgrsStartNow:
  238|    253|{
  239|    253|  data->progress.speeder_c = 0; /* reset the progress meter display */
  240|    253|  data->progress.start = Curl_now();
  241|    253|  data->progress.is_t_startransfer_set = false;
  242|    253|  data->progress.ul_limit_start = data->progress.start;
  243|    253|  data->progress.dl_limit_start = data->progress.start;
  244|    253|  data->progress.ul_limit_size = 0;
  245|    253|  data->progress.dl_limit_size = 0;
  246|    253|  data->progress.downloaded = 0;
  247|    253|  data->progress.uploaded = 0;
  248|       |  /* clear all bits except HIDE and HEADERS_OUT */
  249|    253|  data->progress.flags &= PGRS_HIDE|PGRS_HEADERS_OUT;
  250|    253|  Curl_ratelimit(data, data->progress.start);
  251|    253|}
Curl_ratelimit:
  324|    253|{
  325|       |  /* don't set a new stamp unless the time since last update is long enough */
  326|    253|  if(data->set.max_recv_speed) {
  327|      0|    if(Curl_timediff(now, data->progress.dl_limit_start) >=
  328|      0|       MIN_RATE_LIMIT_PERIOD) {
  329|      0|      data->progress.dl_limit_start = now;
  330|      0|      data->progress.dl_limit_size = data->progress.downloaded;
  331|      0|    }
  332|      0|  }
  333|    253|  if(data->set.max_send_speed) {
  334|      0|    if(Curl_timediff(now, data->progress.ul_limit_start) >=
  335|      0|       MIN_RATE_LIMIT_PERIOD) {
  336|      0|      data->progress.ul_limit_start = now;
  337|      0|      data->progress.ul_limit_size = data->progress.uploaded;
  338|      0|    }
  339|      0|  }
  340|    253|}
Curl_pgrsSetDownloadSize:
  351|    253|{
  352|    253|  if(size >= 0) {
  353|      0|    data->progress.size_dl = size;
  354|      0|    data->progress.flags |= PGRS_DL_SIZE_KNOWN;
  355|      0|  }
  356|    253|  else {
  357|    253|    data->progress.size_dl = 0;
  358|    253|    data->progress.flags &= ~PGRS_DL_SIZE_KNOWN;
  359|    253|  }
  360|    253|}
Curl_pgrsSetUploadSize:
  363|    253|{
  364|    253|  if(size >= 0) {
  365|      0|    data->progress.size_ul = size;
  366|      0|    data->progress.flags |= PGRS_UL_SIZE_KNOWN;
  367|      0|  }
  368|    253|  else {
  369|    253|    data->progress.size_ul = 0;
  370|    253|    data->progress.flags &= ~PGRS_UL_SIZE_KNOWN;
  371|    253|  }
  372|    253|}

Curl_rand:
  120|    620|{
  121|    620|  CURLcode result = CURLE_BAD_FUNCTION_ARGUMENT;
  122|       |
  123|    620|  DEBUGASSERT(num > 0);
  124|       |
  125|  1.39k|  while(num) {
  126|    778|    unsigned int r;
  127|    778|    size_t left = num < sizeof(unsigned int) ? num : sizeof(unsigned int);
  128|       |
  129|    778|    result = randit(data, &r);
  130|    778|    if(result)
  131|      0|      return result;
  132|       |
  133|  3.89k|    while(left) {
  134|  3.11k|      *rnd++ = (unsigned char)(r & 0xFF);
  135|  3.11k|      r >>= 8;
  136|  3.11k|      --num;
  137|  3.11k|      --left;
  138|  3.11k|    }
  139|    778|  }
  140|       |
  141|    620|  return result;
  142|    620|}
Curl_rand_hex:
  152|    620|{
  153|    620|  CURLcode result = CURLE_BAD_FUNCTION_ARGUMENT;
  154|    620|  const char *hex = "0123456789abcdef";
  155|    620|  unsigned char buffer[128];
  156|    620|  unsigned char *bufp = buffer;
  157|    620|  DEBUGASSERT(num > 1);
  158|       |
  159|       |#ifdef __clang_analyzer__
  160|       |  /* This silences a scan-build warning about accessing this buffer with
  161|       |     uninitialized memory. */
  162|       |  memset(buffer, 0, sizeof(buffer));
  163|       |#endif
  164|       |
  165|    620|  if((num/2 >= sizeof(buffer)) || !(num&1))
  166|       |    /* make sure it fits in the local buffer and that it is an odd number! */
  167|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
  168|       |
  169|    620|  num--; /* save one for zero termination */
  170|       |
  171|    620|  result = Curl_rand(data, buffer, num/2);
  172|    620|  if(result)
  173|      0|    return result;
  174|       |
  175|  3.73k|  while(num) {
  176|       |    /* clang-tidy warns on this line without this comment: */
  177|       |    /* NOLINTNEXTLINE(clang-analyzer-core.UndefinedBinaryOperatorResult) */
  178|  3.11k|    *rnd++ = hex[(*bufp & 0xF0)>>4];
  179|  3.11k|    *rnd++ = hex[*bufp & 0x0F];
  180|  3.11k|    bufp++;
  181|  3.11k|    num -= 2;
  182|  3.11k|  }
  183|    620|  *rnd = 0;
  184|       |
  185|    620|  return result;
  186|    620|}
rand.c:randit:
   40|    778|{
   41|    778|  unsigned int r;
   42|    778|  CURLcode result = CURLE_OK;
   43|    778|  static unsigned int randseed;
   44|    778|  static bool seeded = FALSE;
   45|       |
   46|    778|#ifdef CURLDEBUG
   47|    778|  char *force_entropy = getenv("CURL_ENTROPY");
   48|    778|  if(force_entropy) {
   49|      0|    if(!seeded) {
   50|      0|      unsigned int seed = 0;
   51|      0|      size_t elen = strlen(force_entropy);
   52|      0|      size_t clen = sizeof(seed);
   53|      0|      size_t min = elen < clen ? elen : clen;
   54|      0|      memcpy((char *)&seed, force_entropy, min);
   55|      0|      randseed = ntohl(seed);
   56|      0|      seeded = TRUE;
   57|      0|    }
   58|      0|    else
   59|      0|      randseed++;
   60|      0|    *rnd = randseed;
   61|      0|    return CURLE_OK;
   62|      0|  }
   63|    778|#endif
   64|       |
   65|       |  /* data may be NULL! */
   66|    778|  result = Curl_ssl_random(data, (unsigned char *)rnd, sizeof(*rnd));
   67|    778|  if(result != CURLE_NOT_BUILT_IN)
   68|       |    /* only if there is no random function in the TLS backend do the non crypto
   69|       |       version, otherwise return result */
   70|    778|    return result;
   71|       |
   72|       |  /* ---- non-cryptographic version following ---- */
   73|       |
   74|      0|#ifdef RANDOM_FILE
   75|      0|  if(!seeded) {
   76|       |    /* if there's a random file to read a seed from, use it */
   77|      0|    int fd = open(RANDOM_FILE, O_RDONLY);
   78|      0|    if(fd > -1) {
   79|       |      /* read random data into the randseed variable */
   80|      0|      ssize_t nread = read(fd, &randseed, sizeof(randseed));
   81|      0|      if(nread == sizeof(randseed))
   82|      0|        seeded = TRUE;
   83|      0|      close(fd);
   84|      0|    }
   85|      0|  }
   86|      0|#endif
   87|       |
   88|      0|  if(!seeded) {
   89|      0|    struct curltime now = Curl_now();
   90|      0|    infof(data, "WARNING: Using weak random seed");
   91|      0|    randseed += (unsigned int)now.tv_usec + (unsigned int)now.tv_sec;
   92|      0|    randseed = randseed * 1103515245 + 12345;
   93|      0|    randseed = randseed * 1103515245 + 12345;
   94|      0|    randseed = randseed * 1103515245 + 12345;
   95|      0|    seeded = TRUE;
   96|      0|  }
   97|       |
   98|       |  /* Return an unsigned 32-bit pseudo-random number. */
   99|      0|  r = randseed = randseed * 1103515245 + 12345;
  100|      0|  *rnd = (r << 16) | ((r >> 16) & 0xFFFF);
  101|      0|  return CURLE_OK;
  102|    778|}

Curl_rename:
   40|    462|{
   41|       |#ifdef WIN32
   42|       |  /* rename() on Windows doesn't overwrite, so we can't use it here.
   43|       |     MoveFileEx() will overwrite and is usually atomic, however it fails
   44|       |     when there are open handles to the file. */
   45|       |  const int max_wait_ms = 1000;
   46|       |  struct curltime start = Curl_now();
   47|       |  TCHAR *tchar_oldpath = curlx_convert_UTF8_to_tchar((char *)oldpath);
   48|       |  TCHAR *tchar_newpath = curlx_convert_UTF8_to_tchar((char *)newpath);
   49|       |  for(;;) {
   50|       |    timediff_t diff;
   51|       |    if(MoveFileEx(tchar_oldpath, tchar_newpath, MOVEFILE_REPLACE_EXISTING)) {
   52|       |      curlx_unicodefree(tchar_oldpath);
   53|       |      curlx_unicodefree(tchar_newpath);
   54|       |      break;
   55|       |    }
   56|       |    diff = Curl_timediff(Curl_now(), start);
   57|       |    if(diff < 0 || diff > max_wait_ms) {
   58|       |      curlx_unicodefree(tchar_oldpath);
   59|       |      curlx_unicodefree(tchar_newpath);
   60|       |      return 1;
   61|       |    }
   62|       |    Sleep(1);
   63|       |  }
   64|       |#else
   65|    462|  if(rename(oldpath, newpath))
   66|      0|    return 1;
   67|    462|#endif
   68|    462|  return 0;
   69|    462|}

Curl_infof:
  242|  1.05k|{
  243|  1.05k|  DEBUGASSERT(!strchr(fmt, '\n'));
  244|  1.05k|  if(data && data->set.verbose) {
  245|      0|    va_list ap;
  246|      0|    size_t len;
  247|      0|    char buffer[MAXINFO + 2];
  248|      0|    va_start(ap, fmt);
  249|      0|    len = mvsnprintf(buffer, MAXINFO, fmt, ap);
  250|      0|    va_end(ap);
  251|      0|    buffer[len++] = '\n';
  252|      0|    buffer[len] = '\0';
  253|      0|    Curl_debug(data, CURLINFO_TEXT, buffer, len);
  254|      0|  }
  255|  1.05k|}
Curl_failf:
  262|    377|{
  263|    377|  DEBUGASSERT(!strchr(fmt, '\n'));
  264|    377|  if(data->set.verbose || data->set.errorbuffer) {
  265|      0|    va_list ap;
  266|      0|    size_t len;
  267|      0|    char error[CURL_ERROR_SIZE + 2];
  268|      0|    va_start(ap, fmt);
  269|      0|    len = mvsnprintf(error, CURL_ERROR_SIZE, fmt, ap);
  270|       |
  271|      0|    if(data->set.errorbuffer && !data->state.errorbuf) {
  272|      0|      strcpy(data->set.errorbuffer, error);
  273|      0|      data->state.errorbuf = TRUE; /* wrote error string */
  274|      0|    }
  275|      0|    error[len++] = '\n';
  276|      0|    error[len] = '\0';
  277|      0|    Curl_debug(data, CURLINFO_TEXT, error, len);
  278|      0|    va_end(ap);
  279|      0|  }
  280|    377|}

Curl_setstropt:
   58|  3.90k|{
   59|       |  /* Release the previous storage at `charp' and replace by a dynamic storage
   60|       |     copy of `s'. Return CURLE_OK or CURLE_OUT_OF_MEMORY. */
   61|       |
   62|  3.90k|  Curl_safefree(*charp);
   63|       |
   64|  3.90k|  if(s) {
   65|  2.88k|    char *str = strdup(s);
   66|       |
   67|  2.88k|    if(str) {
   68|  2.88k|      size_t len = strlen(str);
   69|  2.88k|      if(len > CURL_MAX_INPUT_LENGTH) {
   70|      0|        free(str);
   71|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
   72|      0|      }
   73|  2.88k|    }
   74|  2.88k|    if(!str)
   75|      0|      return CURLE_OUT_OF_MEMORY;
   76|       |
   77|  2.88k|    *charp = str;
   78|  2.88k|  }
   79|       |
   80|  3.90k|  return CURLE_OK;
   81|  3.90k|}
Curl_vsetopt:
  161|  6.00k|{
  162|  6.00k|  char *argptr;
  163|  6.00k|  CURLcode result = CURLE_OK;
  164|  6.00k|  long arg;
  165|  6.00k|  unsigned long uarg;
  166|  6.00k|  curl_off_t bigsize;
  167|       |
  168|  6.00k|  switch(option) {
  169|      0|  case CURLOPT_DNS_CACHE_TIMEOUT:
  170|      0|    arg = va_arg(param, long);
  171|      0|    if(arg < -1)
  172|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  173|      0|    data->set.dns_cache_timeout = arg;
  174|      0|    break;
  175|      0|  case CURLOPT_DNS_USE_GLOBAL_CACHE:
  176|       |    /* deprecated */
  177|      0|    break;
  178|      0|  case CURLOPT_SSL_CIPHER_LIST:
  179|       |    /* set a list of cipher we want to use in the SSL connection */
  180|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER_LIST],
  181|      0|                            va_arg(param, char *));
  182|      0|    break;
  183|      0|#ifndef CURL_DISABLE_PROXY
  184|      0|  case CURLOPT_PROXY_SSL_CIPHER_LIST:
  185|       |    /* set a list of cipher we want to use in the SSL connection for proxy */
  186|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER_LIST_PROXY],
  187|      0|                            va_arg(param, char *));
  188|      0|    break;
  189|      0|#endif
  190|      0|  case CURLOPT_TLS13_CIPHERS:
  191|      0|    if(Curl_ssl_tls13_ciphersuites()) {
  192|       |      /* set preferred list of TLS 1.3 cipher suites */
  193|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER13_LIST],
  194|      0|                              va_arg(param, char *));
  195|      0|    }
  196|      0|    else
  197|      0|      return CURLE_NOT_BUILT_IN;
  198|      0|    break;
  199|      0|#ifndef CURL_DISABLE_PROXY
  200|      0|  case CURLOPT_PROXY_TLS13_CIPHERS:
  201|      0|    if(Curl_ssl_tls13_ciphersuites()) {
  202|       |      /* set preferred list of TLS 1.3 cipher suites for proxy */
  203|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER13_LIST_PROXY],
  204|      0|                              va_arg(param, char *));
  205|      0|    }
  206|      0|    else
  207|      0|      return CURLE_NOT_BUILT_IN;
  208|      0|    break;
  209|      0|#endif
  210|      0|  case CURLOPT_RANDOM_FILE:
  211|       |    /*
  212|       |     * This is the path name to a file that contains random data to seed
  213|       |     * the random SSL stuff with. The file is only used for reading.
  214|       |     */
  215|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_RANDOM_FILE],
  216|      0|                            va_arg(param, char *));
  217|      0|    break;
  218|      0|  case CURLOPT_EGDSOCKET:
  219|       |    /*
  220|       |     * The Entropy Gathering Daemon socket pathname
  221|       |     */
  222|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_EGDSOCKET],
  223|      0|                            va_arg(param, char *));
  224|      0|    break;
  225|      0|  case CURLOPT_MAXCONNECTS:
  226|       |    /*
  227|       |     * Set the absolute number of maximum simultaneous alive connection that
  228|       |     * libcurl is allowed to have.
  229|       |     */
  230|      0|    arg = va_arg(param, long);
  231|      0|    if(arg < 0)
  232|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  233|      0|    data->set.maxconnects = arg;
  234|      0|    break;
  235|      0|  case CURLOPT_FORBID_REUSE:
  236|       |    /*
  237|       |     * When this transfer is done, it must not be left to be reused by a
  238|       |     * subsequent transfer but shall be closed immediately.
  239|       |     */
  240|      0|    data->set.reuse_forbid = (0 != va_arg(param, long)) ? TRUE : FALSE;
  241|      0|    break;
  242|      0|  case CURLOPT_FRESH_CONNECT:
  243|       |    /*
  244|       |     * This transfer shall not use a previously cached connection but
  245|       |     * should be made with a fresh new connect!
  246|       |     */
  247|      0|    data->set.reuse_fresh = (0 != va_arg(param, long)) ? TRUE : FALSE;
  248|      0|    break;
  249|      0|  case CURLOPT_VERBOSE:
  250|       |    /*
  251|       |     * Verbose means infof() calls that give a lot of information about
  252|       |     * the connection and transfer procedures as well as internal choices.
  253|       |     */
  254|      0|    data->set.verbose = (0 != va_arg(param, long)) ? TRUE : FALSE;
  255|      0|    break;
  256|      2|  case CURLOPT_HEADER:
  257|       |    /*
  258|       |     * Set to include the header in the general data output stream.
  259|       |     */
  260|      2|    data->set.include_header = (0 != va_arg(param, long)) ? TRUE : FALSE;
  261|      2|    break;
  262|      0|  case CURLOPT_NOPROGRESS:
  263|       |    /*
  264|       |     * Shut off the internal supported progress meter
  265|       |     */
  266|      0|    data->set.hide_progress = (0 != va_arg(param, long)) ? TRUE : FALSE;
  267|      0|    if(data->set.hide_progress)
  268|      0|      data->progress.flags |= PGRS_HIDE;
  269|      0|    else
  270|      0|      data->progress.flags &= ~PGRS_HIDE;
  271|      0|    break;
  272|      4|  case CURLOPT_NOBODY:
  273|       |    /*
  274|       |     * Do not include the body part in the output data stream.
  275|       |     */
  276|      4|    data->set.opt_no_body = (0 != va_arg(param, long)) ? TRUE : FALSE;
  277|      4|#ifndef CURL_DISABLE_HTTP
  278|      4|    if(data->set.opt_no_body)
  279|       |      /* in HTTP lingo, no body means using the HEAD request... */
  280|      3|      data->set.method = HTTPREQ_HEAD;
  281|      1|    else if(data->set.method == HTTPREQ_HEAD)
  282|      0|      data->set.method = HTTPREQ_GET;
  283|      4|#endif
  284|      4|    break;
  285|      0|  case CURLOPT_FAILONERROR:
  286|       |    /*
  287|       |     * Don't output the >=400 error code HTML-page, but instead only
  288|       |     * return error.
  289|       |     */
  290|      0|    data->set.http_fail_on_error = (0 != va_arg(param, long)) ? TRUE : FALSE;
  291|      0|    break;
  292|      0|  case CURLOPT_KEEP_SENDING_ON_ERROR:
  293|      0|    data->set.http_keep_sending_on_error = (0 != va_arg(param, long)) ?
  294|      0|      TRUE : FALSE;
  295|      0|    break;
  296|      6|  case CURLOPT_UPLOAD:
  297|      6|  case CURLOPT_PUT:
  298|       |    /*
  299|       |     * We want to sent data to the remote host. If this is HTTP, that equals
  300|       |     * using the PUT request.
  301|       |     */
  302|      6|    data->set.upload = (0 != va_arg(param, long)) ? TRUE : FALSE;
  303|      6|    if(data->set.upload) {
  304|       |      /* If this is HTTP, PUT is what's needed to "upload" */
  305|      6|      data->set.method = HTTPREQ_PUT;
  306|      6|      data->set.opt_no_body = FALSE; /* this is implied */
  307|      6|    }
  308|      0|    else
  309|       |      /* In HTTP, the opposite of upload is GET (unless NOBODY is true as
  310|       |         then this can be changed to HEAD later on) */
  311|      0|      data->set.method = HTTPREQ_GET;
  312|      6|    break;
  313|      0|  case CURLOPT_REQUEST_TARGET:
  314|      0|    result = Curl_setstropt(&data->set.str[STRING_TARGET],
  315|      0|                            va_arg(param, char *));
  316|      0|    break;
  317|      0|  case CURLOPT_FILETIME:
  318|       |    /*
  319|       |     * Try to get the file time of the remote document. The time will
  320|       |     * later (possibly) become available using curl_easy_getinfo().
  321|       |     */
  322|      0|    data->set.get_filetime = (0 != va_arg(param, long)) ? TRUE : FALSE;
  323|      0|    break;
  324|    462|  case CURLOPT_SERVER_RESPONSE_TIMEOUT:
  325|       |    /*
  326|       |     * Option that specifies how quickly an server response must be obtained
  327|       |     * before it is considered failure. For pingpong protocols.
  328|       |     */
  329|    462|    arg = va_arg(param, long);
  330|    462|    if((arg >= 0) && (arg <= (INT_MAX/1000)))
  331|    462|      data->set.server_response_timeout = arg * 1000;
  332|      0|    else
  333|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  334|    462|    break;
  335|    462|#ifndef CURL_DISABLE_TFTP
  336|    462|  case CURLOPT_TFTP_NO_OPTIONS:
  337|       |    /*
  338|       |     * Option that prevents libcurl from sending TFTP option requests to the
  339|       |     * server.
  340|       |     */
  341|      0|    data->set.tftp_no_options = va_arg(param, long) != 0;
  342|      0|    break;
  343|      0|  case CURLOPT_TFTP_BLKSIZE:
  344|       |    /*
  345|       |     * TFTP option that specifies the block size to use for data transmission.
  346|       |     */
  347|      0|    arg = va_arg(param, long);
  348|      0|    if(arg < 0)
  349|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  350|      0|    data->set.tftp_blksize = arg;
  351|      0|    break;
  352|      0|#endif
  353|      0|#ifndef CURL_DISABLE_NETRC
  354|      0|  case CURLOPT_NETRC:
  355|       |    /*
  356|       |     * Parse the $HOME/.netrc file
  357|       |     */
  358|      0|    arg = va_arg(param, long);
  359|      0|    if((arg < CURL_NETRC_IGNORED) || (arg >= CURL_NETRC_LAST))
  360|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  361|      0|    data->set.use_netrc = (enum CURL_NETRC_OPTION)arg;
  362|      0|    break;
  363|      0|  case CURLOPT_NETRC_FILE:
  364|       |    /*
  365|       |     * Use this file instead of the $HOME/.netrc file
  366|       |     */
  367|      0|    result = Curl_setstropt(&data->set.str[STRING_NETRC_FILE],
  368|      0|                            va_arg(param, char *));
  369|      0|    break;
  370|      0|#endif
  371|      0|  case CURLOPT_TRANSFERTEXT:
  372|       |    /*
  373|       |     * This option was previously named 'FTPASCII'. Renamed to work with
  374|       |     * more protocols than merely FTP.
  375|       |     *
  376|       |     * Transfer using ASCII (instead of BINARY).
  377|       |     */
  378|      0|    data->set.prefer_ascii = (0 != va_arg(param, long)) ? TRUE : FALSE;
  379|      0|    break;
  380|      0|  case CURLOPT_TIMECONDITION:
  381|       |    /*
  382|       |     * Set HTTP time condition. This must be one of the defines in the
  383|       |     * curl/curl.h header file.
  384|       |     */
  385|      0|    arg = va_arg(param, long);
  386|      0|    if((arg < CURL_TIMECOND_NONE) || (arg >= CURL_TIMECOND_LAST))
  387|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  388|      0|    data->set.timecondition = (curl_TimeCond)arg;
  389|      0|    break;
  390|      0|  case CURLOPT_TIMEVALUE:
  391|       |    /*
  392|       |     * This is the value to compare with the remote document with the
  393|       |     * method set with CURLOPT_TIMECONDITION
  394|       |     */
  395|      0|    data->set.timevalue = (time_t)va_arg(param, long);
  396|      0|    break;
  397|       |
  398|      0|  case CURLOPT_TIMEVALUE_LARGE:
  399|       |    /*
  400|       |     * This is the value to compare with the remote document with the
  401|       |     * method set with CURLOPT_TIMECONDITION
  402|       |     */
  403|      0|    data->set.timevalue = (time_t)va_arg(param, curl_off_t);
  404|      0|    break;
  405|       |
  406|      0|  case CURLOPT_SSLVERSION:
  407|      0|#ifndef CURL_DISABLE_PROXY
  408|      0|  case CURLOPT_PROXY_SSLVERSION:
  409|      0|#endif
  410|       |    /*
  411|       |     * Set explicit SSL version to try to connect with, as some SSL
  412|       |     * implementations are lame.
  413|       |     */
  414|      0|#ifdef USE_SSL
  415|      0|    {
  416|      0|      long version, version_max;
  417|      0|      struct ssl_primary_config *primary = &data->set.ssl.primary;
  418|      0|#ifndef CURL_DISABLE_PROXY
  419|      0|      if(option != CURLOPT_SSLVERSION)
  420|      0|        primary = &data->set.proxy_ssl.primary;
  421|      0|#endif
  422|       |
  423|      0|      arg = va_arg(param, long);
  424|       |
  425|      0|      version = C_SSLVERSION_VALUE(arg);
  426|      0|      version_max = C_SSLVERSION_MAX_VALUE(arg);
  427|       |
  428|      0|      if(version < CURL_SSLVERSION_DEFAULT ||
  429|      0|         version == CURL_SSLVERSION_SSLv2 ||
  430|      0|         version == CURL_SSLVERSION_SSLv3 ||
  431|      0|         version >= CURL_SSLVERSION_LAST ||
  432|      0|         version_max < CURL_SSLVERSION_MAX_NONE ||
  433|      0|         version_max >= CURL_SSLVERSION_MAX_LAST)
  434|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
  435|       |
  436|      0|      primary->version = version;
  437|      0|      primary->version_max = version_max;
  438|      0|    }
  439|       |#else
  440|       |    result = CURLE_NOT_BUILT_IN;
  441|       |#endif
  442|      0|    break;
  443|       |
  444|       |    /* MQTT "borrows" some of the HTTP options */
  445|      0|#if !defined(CURL_DISABLE_HTTP) || !defined(CURL_DISABLE_MQTT)
  446|      0|  case CURLOPT_COPYPOSTFIELDS:
  447|       |    /*
  448|       |     * A string with POST data. Makes curl HTTP POST. Even if it is NULL.
  449|       |     * If needed, CURLOPT_POSTFIELDSIZE must have been set prior to
  450|       |     *  CURLOPT_COPYPOSTFIELDS and not altered later.
  451|       |     */
  452|      0|    argptr = va_arg(param, char *);
  453|       |
  454|      0|    if(!argptr || data->set.postfieldsize == -1)
  455|      0|      result = Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], argptr);
  456|      0|    else {
  457|       |      /*
  458|       |       *  Check that requested length does not overflow the size_t type.
  459|       |       */
  460|       |
  461|      0|      if((data->set.postfieldsize < 0) ||
  462|      0|         ((sizeof(curl_off_t) != sizeof(size_t)) &&
  463|      0|          (data->set.postfieldsize > (curl_off_t)((size_t)-1))))
  464|      0|        result = CURLE_OUT_OF_MEMORY;
  465|      0|      else {
  466|      0|        char *p;
  467|       |
  468|      0|        (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  469|       |
  470|       |        /* Allocate even when size == 0. This satisfies the need of possible
  471|       |           later address compare to detect the COPYPOSTFIELDS mode, and
  472|       |           to mark that postfields is used rather than read function or
  473|       |           form data.
  474|       |        */
  475|      0|        p = malloc((size_t)(data->set.postfieldsize?
  476|      0|                            data->set.postfieldsize:1));
  477|       |
  478|      0|        if(!p)
  479|      0|          result = CURLE_OUT_OF_MEMORY;
  480|      0|        else {
  481|      0|          if(data->set.postfieldsize)
  482|      0|            memcpy(p, argptr, (size_t)data->set.postfieldsize);
  483|       |
  484|      0|          data->set.str[STRING_COPYPOSTFIELDS] = p;
  485|      0|        }
  486|      0|      }
  487|      0|    }
  488|       |
  489|      0|    data->set.postfields = data->set.str[STRING_COPYPOSTFIELDS];
  490|      0|    data->set.method = HTTPREQ_POST;
  491|      0|    break;
  492|       |
  493|      7|  case CURLOPT_POSTFIELDS:
  494|       |    /*
  495|       |     * Like above, but use static data instead of copying it.
  496|       |     */
  497|      7|    data->set.postfields = va_arg(param, void *);
  498|       |    /* Release old copied data. */
  499|      7|    (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  500|      7|    data->set.method = HTTPREQ_POST;
  501|      7|    break;
  502|       |
  503|      0|  case CURLOPT_POSTFIELDSIZE:
  504|       |    /*
  505|       |     * The size of the POSTFIELD data to prevent libcurl to do strlen() to
  506|       |     * figure it out. Enables binary posts.
  507|       |     */
  508|      0|    bigsize = va_arg(param, long);
  509|      0|    if(bigsize < -1)
  510|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  511|       |
  512|      0|    if(data->set.postfieldsize < bigsize &&
  513|      0|       data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {
  514|       |      /* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */
  515|      0|      (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  516|      0|      data->set.postfields = NULL;
  517|      0|    }
  518|       |
  519|      0|    data->set.postfieldsize = bigsize;
  520|      0|    break;
  521|       |
  522|      0|  case CURLOPT_POSTFIELDSIZE_LARGE:
  523|       |    /*
  524|       |     * The size of the POSTFIELD data to prevent libcurl to do strlen() to
  525|       |     * figure it out. Enables binary posts.
  526|       |     */
  527|      0|    bigsize = va_arg(param, curl_off_t);
  528|      0|    if(bigsize < -1)
  529|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  530|       |
  531|      0|    if(data->set.postfieldsize < bigsize &&
  532|      0|       data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {
  533|       |      /* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */
  534|      0|      (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
  535|      0|      data->set.postfields = NULL;
  536|      0|    }
  537|       |
  538|      0|    data->set.postfieldsize = bigsize;
  539|      0|    break;
  540|      0|#endif
  541|      0|#ifndef CURL_DISABLE_HTTP
  542|      0|  case CURLOPT_AUTOREFERER:
  543|       |    /*
  544|       |     * Switch on automatic referer that gets set if curl follows locations.
  545|       |     */
  546|      0|    data->set.http_auto_referer = (0 != va_arg(param, long)) ? TRUE : FALSE;
  547|      0|    break;
  548|       |
  549|      8|  case CURLOPT_ACCEPT_ENCODING:
  550|       |    /*
  551|       |     * String to use at the value of Accept-Encoding header.
  552|       |     *
  553|       |     * If the encoding is set to "" we use an Accept-Encoding header that
  554|       |     * encompasses all the encodings we support.
  555|       |     * If the encoding is set to NULL we don't send an Accept-Encoding header
  556|       |     * and ignore an received Content-Encoding header.
  557|       |     *
  558|       |     */
  559|      8|    argptr = va_arg(param, char *);
  560|      8|    if(argptr && !*argptr) {
  561|      7|      argptr = Curl_all_content_encodings();
  562|      7|      if(!argptr)
  563|      0|        result = CURLE_OUT_OF_MEMORY;
  564|      7|      else {
  565|      7|        result = Curl_setstropt(&data->set.str[STRING_ENCODING], argptr);
  566|      7|        free(argptr);
  567|      7|      }
  568|      7|    }
  569|      1|    else
  570|      1|      result = Curl_setstropt(&data->set.str[STRING_ENCODING], argptr);
  571|      8|    break;
  572|       |
  573|      0|  case CURLOPT_TRANSFER_ENCODING:
  574|      0|    data->set.http_transfer_encoding = (0 != va_arg(param, long)) ?
  575|      0|      TRUE : FALSE;
  576|      0|    break;
  577|       |
  578|      2|  case CURLOPT_FOLLOWLOCATION:
  579|       |    /*
  580|       |     * Follow Location: header hints on a HTTP-server.
  581|       |     */
  582|      2|    data->set.http_follow_location = (0 != va_arg(param, long)) ? TRUE : FALSE;
  583|      2|    break;
  584|       |
  585|      0|  case CURLOPT_UNRESTRICTED_AUTH:
  586|       |    /*
  587|       |     * Send authentication (user+password) when following locations, even when
  588|       |     * hostname changed.
  589|       |     */
  590|      0|    data->set.allow_auth_to_other_hosts =
  591|      0|      (0 != va_arg(param, long)) ? TRUE : FALSE;
  592|      0|    break;
  593|       |
  594|      0|  case CURLOPT_MAXREDIRS:
  595|       |    /*
  596|       |     * The maximum amount of hops you allow curl to follow Location:
  597|       |     * headers. This should mostly be used to detect never-ending loops.
  598|       |     */
  599|      0|    arg = va_arg(param, long);
  600|      0|    if(arg < -1)
  601|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  602|      0|    data->set.maxredirs = arg;
  603|      0|    break;
  604|       |
  605|      0|  case CURLOPT_POSTREDIR:
  606|       |    /*
  607|       |     * Set the behavior of POST when redirecting
  608|       |     * CURL_REDIR_GET_ALL - POST is changed to GET after 301 and 302
  609|       |     * CURL_REDIR_POST_301 - POST is kept as POST after 301
  610|       |     * CURL_REDIR_POST_302 - POST is kept as POST after 302
  611|       |     * CURL_REDIR_POST_303 - POST is kept as POST after 303
  612|       |     * CURL_REDIR_POST_ALL - POST is kept as POST after 301, 302 and 303
  613|       |     * other - POST is kept as POST after 301 and 302
  614|       |     */
  615|      0|    arg = va_arg(param, long);
  616|      0|    if(arg < CURL_REDIR_GET_ALL)
  617|       |      /* no return error on too high numbers since the bitmask could be
  618|       |         extended in a future */
  619|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  620|      0|    data->set.keep_post = arg & CURL_REDIR_POST_ALL;
  621|      0|    break;
  622|       |
  623|      0|  case CURLOPT_POST:
  624|       |    /* Does this option serve a purpose anymore? Yes it does, when
  625|       |       CURLOPT_POSTFIELDS isn't used and the POST data is read off the
  626|       |       callback! */
  627|      0|    if(va_arg(param, long)) {
  628|      0|      data->set.method = HTTPREQ_POST;
  629|      0|      data->set.opt_no_body = FALSE; /* this is implied */
  630|      0|    }
  631|      0|    else
  632|      0|      data->set.method = HTTPREQ_GET;
  633|      0|    break;
  634|       |
  635|      0|  case CURLOPT_HTTPPOST:
  636|       |    /*
  637|       |     * Set to make us do HTTP POST
  638|       |     */
  639|      0|    data->set.httppost = va_arg(param, struct curl_httppost *);
  640|      0|    data->set.method = HTTPREQ_POST_FORM;
  641|      0|    data->set.opt_no_body = FALSE; /* this is implied */
  642|      0|    break;
  643|       |
  644|      0|  case CURLOPT_AWS_SIGV4:
  645|       |    /*
  646|       |     * String that is merged to some authentication
  647|       |     * parameters are used by the algorithm.
  648|       |     */
  649|      0|    result = Curl_setstropt(&data->set.str[STRING_AWS_SIGV4],
  650|      0|                            va_arg(param, char *));
  651|       |    /*
  652|       |     * Basic been set by default it need to be unset here
  653|       |     */
  654|      0|    if(data->set.str[STRING_AWS_SIGV4])
  655|      0|      data->set.httpauth = CURLAUTH_AWS_SIGV4;
  656|      0|    break;
  657|       |
  658|     68|  case CURLOPT_MIMEPOST:
  659|       |    /*
  660|       |     * Set to make us do MIME/form POST
  661|       |     */
  662|     68|    result = Curl_mime_set_subparts(&data->set.mimepost,
  663|     68|                                    va_arg(param, curl_mime *), FALSE);
  664|     68|    if(!result) {
  665|     68|      data->set.method = HTTPREQ_POST_MIME;
  666|     68|      data->set.opt_no_body = FALSE; /* this is implied */
  667|     68|    }
  668|     68|    break;
  669|       |
  670|      0|  case CURLOPT_REFERER:
  671|       |    /*
  672|       |     * String to set in the HTTP Referer: field.
  673|       |     */
  674|      0|    if(data->state.referer_alloc) {
  675|      0|      Curl_safefree(data->state.referer);
  676|      0|      data->state.referer_alloc = FALSE;
  677|      0|    }
  678|      0|    result = Curl_setstropt(&data->set.str[STRING_SET_REFERER],
  679|      0|                            va_arg(param, char *));
  680|      0|    data->state.referer = data->set.str[STRING_SET_REFERER];
  681|      0|    break;
  682|       |
  683|      0|  case CURLOPT_USERAGENT:
  684|       |    /*
  685|       |     * String to use in the HTTP User-Agent field
  686|       |     */
  687|      0|    result = Curl_setstropt(&data->set.str[STRING_USERAGENT],
  688|      0|                            va_arg(param, char *));
  689|      0|    break;
  690|       |
  691|     13|  case CURLOPT_HTTPHEADER:
  692|       |    /*
  693|       |     * Set a list with HTTP headers to use (or replace internals with)
  694|       |     */
  695|     13|    data->set.headers = va_arg(param, struct curl_slist *);
  696|     13|    break;
  697|       |
  698|      0|#ifndef CURL_DISABLE_PROXY
  699|      0|  case CURLOPT_PROXYHEADER:
  700|       |    /*
  701|       |     * Set a list with proxy headers to use (or replace internals with)
  702|       |     *
  703|       |     * Since CURLOPT_HTTPHEADER was the only way to set HTTP headers for a
  704|       |     * long time we remain doing it this way until CURLOPT_PROXYHEADER is
  705|       |     * used. As soon as this option has been used, if set to anything but
  706|       |     * NULL, custom headers for proxies are only picked from this list.
  707|       |     *
  708|       |     * Set this option to NULL to restore the previous behavior.
  709|       |     */
  710|      0|    data->set.proxyheaders = va_arg(param, struct curl_slist *);
  711|      0|    break;
  712|      0|#endif
  713|      0|  case CURLOPT_HEADEROPT:
  714|       |    /*
  715|       |     * Set header option.
  716|       |     */
  717|      0|    arg = va_arg(param, long);
  718|      0|    data->set.sep_headers = (bool)((arg & CURLHEADER_SEPARATE)? TRUE: FALSE);
  719|      0|    break;
  720|       |
  721|      0|  case CURLOPT_HTTP200ALIASES:
  722|       |    /*
  723|       |     * Set a list of aliases for HTTP 200 in response header
  724|       |     */
  725|      0|    data->set.http200aliases = va_arg(param, struct curl_slist *);
  726|      0|    break;
  727|       |
  728|      0|#if !defined(CURL_DISABLE_COOKIES)
  729|      2|  case CURLOPT_COOKIE:
  730|       |    /*
  731|       |     * Cookie string to send to the remote server in the request.
  732|       |     */
  733|      2|    result = Curl_setstropt(&data->set.str[STRING_COOKIE],
  734|      2|                            va_arg(param, char *));
  735|      2|    break;
  736|       |
  737|      0|  case CURLOPT_COOKIEFILE:
  738|       |    /*
  739|       |     * Set cookie file to read and parse. Can be used multiple times.
  740|       |     */
  741|      0|    argptr = (char *)va_arg(param, void *);
  742|      0|    if(argptr) {
  743|      0|      struct curl_slist *cl;
  744|       |      /* general protection against mistakes and abuse */
  745|      0|      if(strlen(argptr) > CURL_MAX_INPUT_LENGTH)
  746|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
  747|       |      /* append the cookie file name to the list of file names, and deal with
  748|       |         them later */
  749|      0|      cl = curl_slist_append(data->state.cookielist, argptr);
  750|      0|      if(!cl) {
  751|      0|        curl_slist_free_all(data->state.cookielist);
  752|      0|        data->state.cookielist = NULL;
  753|      0|        return CURLE_OUT_OF_MEMORY;
  754|      0|      }
  755|      0|      data->state.cookielist = cl; /* store the list for later use */
  756|      0|    }
  757|      0|    else {
  758|       |      /* clear the list of cookie files */
  759|      0|      curl_slist_free_all(data->state.cookielist);
  760|      0|      data->state.cookielist = NULL;
  761|       |
  762|      0|      if(!data->share || !data->share->cookies) {
  763|       |        /* throw away all existing cookies if this isn't a shared cookie
  764|       |           container */
  765|      0|        Curl_cookie_clearall(data->cookies);
  766|      0|        Curl_cookie_cleanup(data->cookies);
  767|      0|      }
  768|       |      /* disable the cookie engine */
  769|      0|      data->cookies = NULL;
  770|      0|    }
  771|      0|    break;
  772|       |
  773|    462|  case CURLOPT_COOKIEJAR:
  774|       |    /*
  775|       |     * Set cookie file name to dump all cookies to when we're done.
  776|       |     */
  777|    462|  {
  778|    462|    struct CookieInfo *newcookies;
  779|    462|    result = Curl_setstropt(&data->set.str[STRING_COOKIEJAR],
  780|    462|                            va_arg(param, char *));
  781|       |
  782|       |    /*
  783|       |     * Activate the cookie parser. This may or may not already
  784|       |     * have been made.
  785|       |     */
  786|    462|    newcookies = Curl_cookie_init(data, NULL, data->cookies,
  787|    462|                                  data->set.cookiesession);
  788|    462|    if(!newcookies)
  789|      0|      result = CURLE_OUT_OF_MEMORY;
  790|    462|    data->cookies = newcookies;
  791|    462|  }
  792|    462|  break;
  793|       |
  794|      0|  case CURLOPT_COOKIESESSION:
  795|       |    /*
  796|       |     * Set this option to TRUE to start a new "cookie session". It will
  797|       |     * prevent the forthcoming read-cookies-from-file actions to accept
  798|       |     * cookies that are marked as being session cookies, as they belong to a
  799|       |     * previous session.
  800|       |     *
  801|       |     * In the original Netscape cookie spec, "session cookies" are cookies
  802|       |     * with no expire date set. RFC2109 describes the same action if no
  803|       |     * 'Max-Age' is set and RFC2965 includes the RFC2109 description and adds
  804|       |     * a 'Discard' action that can enforce the discard even for cookies that
  805|       |     * have a Max-Age.
  806|       |     *
  807|       |     * We run mostly with the original cookie spec, as hardly anyone implements
  808|       |     * anything else.
  809|       |     */
  810|      0|    data->set.cookiesession = (0 != va_arg(param, long)) ? TRUE : FALSE;
  811|      0|    break;
  812|       |
  813|      0|  case CURLOPT_COOKIELIST:
  814|      0|    argptr = va_arg(param, char *);
  815|       |
  816|      0|    if(!argptr)
  817|      0|      break;
  818|       |
  819|      0|    if(strcasecompare(argptr, "ALL")) {
  820|       |      /* clear all cookies */
  821|      0|      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
  822|      0|      Curl_cookie_clearall(data->cookies);
  823|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
  824|      0|    }
  825|      0|    else if(strcasecompare(argptr, "SESS")) {
  826|       |      /* clear session cookies */
  827|      0|      Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
  828|      0|      Curl_cookie_clearsess(data->cookies);
  829|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
  830|      0|    }
  831|      0|    else if(strcasecompare(argptr, "FLUSH")) {
  832|       |      /* flush cookies to file, takes care of the locking */
  833|      0|      Curl_flush_cookies(data, FALSE);
  834|      0|    }
  835|      0|    else if(strcasecompare(argptr, "RELOAD")) {
  836|       |      /* reload cookies from file */
  837|      0|      Curl_cookie_loadfiles(data);
  838|      0|      break;
  839|      0|    }
  840|      0|    else {
  841|      0|      if(!data->cookies)
  842|       |        /* if cookie engine was not running, activate it */
  843|      0|        data->cookies = Curl_cookie_init(data, NULL, NULL, TRUE);
  844|       |
  845|       |      /* general protection against mistakes and abuse */
  846|      0|      if(strlen(argptr) > CURL_MAX_INPUT_LENGTH)
  847|      0|        return CURLE_BAD_FUNCTION_ARGUMENT;
  848|      0|      argptr = strdup(argptr);
  849|      0|      if(!argptr || !data->cookies) {
  850|      0|        result = CURLE_OUT_OF_MEMORY;
  851|      0|        free(argptr);
  852|      0|      }
  853|      0|      else {
  854|      0|        Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
  855|       |
  856|      0|        if(checkprefix("Set-Cookie:", argptr))
  857|       |          /* HTTP Header format line */
  858|      0|          Curl_cookie_add(data, data->cookies, TRUE, FALSE, argptr + 11, NULL,
  859|      0|                          NULL, TRUE);
  860|       |
  861|      0|        else
  862|       |          /* Netscape format line */
  863|      0|          Curl_cookie_add(data, data->cookies, FALSE, FALSE, argptr, NULL,
  864|      0|                          NULL, TRUE);
  865|       |
  866|      0|        Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
  867|      0|        free(argptr);
  868|      0|      }
  869|      0|    }
  870|       |
  871|      0|    break;
  872|      0|#endif /* !CURL_DISABLE_COOKIES */
  873|       |
  874|      0|  case CURLOPT_HTTPGET:
  875|       |    /*
  876|       |     * Set to force us do HTTP GET
  877|       |     */
  878|      0|    if(va_arg(param, long)) {
  879|      0|      data->set.method = HTTPREQ_GET;
  880|      0|      data->set.upload = FALSE; /* switch off upload */
  881|      0|      data->set.opt_no_body = FALSE; /* this is implied */
  882|      0|    }
  883|      0|    break;
  884|       |
  885|      4|  case CURLOPT_HTTP_VERSION:
  886|       |    /*
  887|       |     * This sets a requested HTTP version to be used. The value is one of
  888|       |     * the listed enums in curl/curl.h.
  889|       |     */
  890|      4|    arg = va_arg(param, long);
  891|      4|    if(arg < CURL_HTTP_VERSION_NONE)
  892|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  893|       |#ifdef ENABLE_QUIC
  894|       |    if(arg == CURL_HTTP_VERSION_3)
  895|       |      ;
  896|       |    else
  897|       |#endif
  898|       |#if !defined(USE_NGHTTP2) && !defined(USE_HYPER)
  899|       |    if(arg >= CURL_HTTP_VERSION_2)
  900|       |      return CURLE_UNSUPPORTED_PROTOCOL;
  901|       |#else
  902|      4|    if(arg >= CURL_HTTP_VERSION_LAST)
  903|      1|      return CURLE_UNSUPPORTED_PROTOCOL;
  904|      3|    if(arg == CURL_HTTP_VERSION_NONE)
  905|      1|      arg = CURL_HTTP_VERSION_2TLS;
  906|      3|#endif
  907|      3|    data->set.httpwant = (unsigned char)arg;
  908|      3|    break;
  909|       |
  910|      0|  case CURLOPT_EXPECT_100_TIMEOUT_MS:
  911|       |    /*
  912|       |     * Time to wait for a response to a HTTP request containing an
  913|       |     * Expect: 100-continue header before sending the data anyway.
  914|       |     */
  915|      0|    arg = va_arg(param, long);
  916|      0|    if(arg < 0)
  917|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  918|      0|    data->set.expect_100_timeout = arg;
  919|      0|    break;
  920|       |
  921|      0|  case CURLOPT_HTTP09_ALLOWED:
  922|      0|    arg = va_arg(param, unsigned long);
  923|      0|    if(arg > 1L)
  924|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
  925|       |#ifdef USE_HYPER
  926|       |    /* Hyper does not support HTTP/0.9 */
  927|       |    if(arg)
  928|       |      return CURLE_BAD_FUNCTION_ARGUMENT;
  929|       |#else
  930|      0|    data->set.http09_allowed = arg ? TRUE : FALSE;
  931|      0|#endif
  932|      0|    break;
  933|      0|#endif   /* CURL_DISABLE_HTTP */
  934|       |
  935|      7|  case CURLOPT_HTTPAUTH:
  936|       |    /*
  937|       |     * Set HTTP Authentication type BITMASK.
  938|       |     */
  939|      7|  {
  940|      7|    int bitcheck;
  941|      7|    bool authbits;
  942|      7|    unsigned long auth = va_arg(param, unsigned long);
  943|       |
  944|      7|    if(auth == CURLAUTH_NONE) {
  945|      1|      data->set.httpauth = auth;
  946|      1|      break;
  947|      1|    }
  948|       |
  949|       |    /* the DIGEST_IE bit is only used to set a special marker, for all the
  950|       |       rest we need to handle it as normal DIGEST */
  951|      6|    data->state.authhost.iestyle =
  952|      6|      (bool)((auth & CURLAUTH_DIGEST_IE) ? TRUE : FALSE);
  953|       |
  954|      6|    if(auth & CURLAUTH_DIGEST_IE) {
  955|      1|      auth |= CURLAUTH_DIGEST; /* set standard digest bit */
  956|      1|      auth &= ~CURLAUTH_DIGEST_IE; /* unset ie digest bit */
  957|      1|    }
  958|       |
  959|       |    /* switch off bits we can't support */
  960|       |#ifndef USE_NTLM
  961|       |    auth &= ~CURLAUTH_NTLM;    /* no NTLM support */
  962|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
  963|       |#elif !defined(NTLM_WB_ENABLED)
  964|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
  965|       |#endif
  966|      6|#ifndef USE_SPNEGO
  967|      6|    auth &= ~CURLAUTH_NEGOTIATE; /* no Negotiate (SPNEGO) auth without
  968|       |                                    GSS-API or SSPI */
  969|      6|#endif
  970|       |
  971|       |    /* check if any auth bit lower than CURLAUTH_ONLY is still set */
  972|      6|    bitcheck = 0;
  973|      6|    authbits = FALSE;
  974|     80|    while(bitcheck < 31) {
  975|     79|      if(auth & (1UL << bitcheck++)) {
  976|      5|        authbits = TRUE;
  977|      5|        break;
  978|      5|      }
  979|     79|    }
  980|      6|    if(!authbits)
  981|      1|      return CURLE_NOT_BUILT_IN; /* no supported types left! */
  982|       |
  983|      5|    data->set.httpauth = auth;
  984|      5|  }
  985|      0|  break;
  986|       |
  987|      5|  case CURLOPT_CUSTOMREQUEST:
  988|       |    /*
  989|       |     * Set a custom string to use as request
  990|       |     */
  991|      5|    result = Curl_setstropt(&data->set.str[STRING_CUSTOMREQUEST],
  992|      5|                            va_arg(param, char *));
  993|       |
  994|       |    /* we don't set
  995|       |       data->set.method = HTTPREQ_CUSTOM;
  996|       |       here, we continue as if we were using the already set type
  997|       |       and this just changes the actual request keyword */
  998|      5|    break;
  999|       |
 1000|      0|#ifndef CURL_DISABLE_PROXY
 1001|      0|  case CURLOPT_HTTPPROXYTUNNEL:
 1002|       |    /*
 1003|       |     * Tunnel operations through the proxy instead of normal proxy use
 1004|       |     */
 1005|      0|    data->set.tunnel_thru_httpproxy = (0 != va_arg(param, long)) ?
 1006|      0|      TRUE : FALSE;
 1007|      0|    break;
 1008|       |
 1009|      0|  case CURLOPT_PROXYPORT:
 1010|       |    /*
 1011|       |     * Explicitly set HTTP proxy port number.
 1012|       |     */
 1013|      0|    arg = va_arg(param, long);
 1014|      0|    if((arg < 0) || (arg > 65535))
 1015|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1016|      0|    data->set.proxyport = arg;
 1017|      0|    break;
 1018|       |
 1019|      0|  case CURLOPT_PROXYAUTH:
 1020|       |    /*
 1021|       |     * Set HTTP Authentication type BITMASK.
 1022|       |     */
 1023|      0|  {
 1024|      0|    int bitcheck;
 1025|      0|    bool authbits;
 1026|      0|    unsigned long auth = va_arg(param, unsigned long);
 1027|       |
 1028|      0|    if(auth == CURLAUTH_NONE) {
 1029|      0|      data->set.proxyauth = auth;
 1030|      0|      break;
 1031|      0|    }
 1032|       |
 1033|       |    /* the DIGEST_IE bit is only used to set a special marker, for all the
 1034|       |       rest we need to handle it as normal DIGEST */
 1035|      0|    data->state.authproxy.iestyle =
 1036|      0|      (bool)((auth & CURLAUTH_DIGEST_IE) ? TRUE : FALSE);
 1037|       |
 1038|      0|    if(auth & CURLAUTH_DIGEST_IE) {
 1039|      0|      auth |= CURLAUTH_DIGEST; /* set standard digest bit */
 1040|      0|      auth &= ~CURLAUTH_DIGEST_IE; /* unset ie digest bit */
 1041|      0|    }
 1042|       |    /* switch off bits we can't support */
 1043|       |#ifndef USE_NTLM
 1044|       |    auth &= ~CURLAUTH_NTLM;    /* no NTLM support */
 1045|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
 1046|       |#elif !defined(NTLM_WB_ENABLED)
 1047|       |    auth &= ~CURLAUTH_NTLM_WB; /* no NTLM_WB support */
 1048|       |#endif
 1049|      0|#ifndef USE_SPNEGO
 1050|      0|    auth &= ~CURLAUTH_NEGOTIATE; /* no Negotiate (SPNEGO) auth without
 1051|       |                                    GSS-API or SSPI */
 1052|      0|#endif
 1053|       |
 1054|       |    /* check if any auth bit lower than CURLAUTH_ONLY is still set */
 1055|      0|    bitcheck = 0;
 1056|      0|    authbits = FALSE;
 1057|      0|    while(bitcheck < 31) {
 1058|      0|      if(auth & (1UL << bitcheck++)) {
 1059|      0|        authbits = TRUE;
 1060|      0|        break;
 1061|      0|      }
 1062|      0|    }
 1063|      0|    if(!authbits)
 1064|      0|      return CURLE_NOT_BUILT_IN; /* no supported types left! */
 1065|       |
 1066|      0|    data->set.proxyauth = auth;
 1067|      0|  }
 1068|      0|  break;
 1069|       |
 1070|      0|  case CURLOPT_PROXY:
 1071|       |    /*
 1072|       |     * Set proxy server:port to use as proxy.
 1073|       |     *
 1074|       |     * If the proxy is set to "" (and CURLOPT_SOCKS_PROXY is set to "" or NULL)
 1075|       |     * we explicitly say that we don't want to use a proxy
 1076|       |     * (even though there might be environment variables saying so).
 1077|       |     *
 1078|       |     * Setting it to NULL, means no proxy but allows the environment variables
 1079|       |     * to decide for us (if CURLOPT_SOCKS_PROXY setting it to NULL).
 1080|       |     */
 1081|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXY],
 1082|      0|                            va_arg(param, char *));
 1083|      0|    break;
 1084|       |
 1085|      0|  case CURLOPT_PRE_PROXY:
 1086|       |    /*
 1087|       |     * Set proxy server:port to use as SOCKS proxy.
 1088|       |     *
 1089|       |     * If the proxy is set to "" or NULL we explicitly say that we don't want
 1090|       |     * to use the socks proxy.
 1091|       |     */
 1092|      0|    result = Curl_setstropt(&data->set.str[STRING_PRE_PROXY],
 1093|      0|                            va_arg(param, char *));
 1094|      0|    break;
 1095|       |
 1096|      0|  case CURLOPT_PROXYTYPE:
 1097|       |    /*
 1098|       |     * Set proxy type. HTTP/HTTP_1_0/SOCKS4/SOCKS4a/SOCKS5/SOCKS5_HOSTNAME
 1099|       |     */
 1100|      0|    arg = va_arg(param, long);
 1101|      0|    if((arg < CURLPROXY_HTTP) || (arg > CURLPROXY_SOCKS5_HOSTNAME))
 1102|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1103|      0|    data->set.proxytype = (curl_proxytype)arg;
 1104|      0|    break;
 1105|       |
 1106|      0|  case CURLOPT_PROXY_TRANSFER_MODE:
 1107|       |    /*
 1108|       |     * set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy
 1109|       |     */
 1110|      0|    switch(va_arg(param, long)) {
 1111|      0|    case 0:
 1112|      0|      data->set.proxy_transfer_mode = FALSE;
 1113|      0|      break;
 1114|      0|    case 1:
 1115|      0|      data->set.proxy_transfer_mode = TRUE;
 1116|      0|      break;
 1117|      0|    default:
 1118|       |      /* reserve other values for future use */
 1119|      0|      result = CURLE_BAD_FUNCTION_ARGUMENT;
 1120|      0|      break;
 1121|      0|    }
 1122|      0|    break;
 1123|      0|#endif   /* CURL_DISABLE_PROXY */
 1124|       |
 1125|      0|  case CURLOPT_SOCKS5_AUTH:
 1126|      0|    data->set.socks5auth = va_arg(param, unsigned long);
 1127|      0|    if(data->set.socks5auth & ~(CURLAUTH_BASIC | CURLAUTH_GSSAPI))
 1128|      0|      result = CURLE_NOT_BUILT_IN;
 1129|      0|    break;
 1130|       |#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
 1131|       |  case CURLOPT_SOCKS5_GSSAPI_NEC:
 1132|       |    /*
 1133|       |     * Set flag for NEC SOCK5 support
 1134|       |     */
 1135|       |    data->set.socks5_gssapi_nec = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1136|       |    break;
 1137|       |#endif
 1138|      0|#ifndef CURL_DISABLE_PROXY
 1139|      0|  case CURLOPT_SOCKS5_GSSAPI_SERVICE:
 1140|      0|  case CURLOPT_PROXY_SERVICE_NAME:
 1141|       |    /*
 1142|       |     * Set proxy authentication service name for Kerberos 5 and SPNEGO
 1143|       |     */
 1144|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXY_SERVICE_NAME],
 1145|      0|                            va_arg(param, char *));
 1146|      0|    break;
 1147|      0|#endif
 1148|      0|  case CURLOPT_SERVICE_NAME:
 1149|       |    /*
 1150|       |     * Set authentication service name for DIGEST-MD5, Kerberos 5 and SPNEGO
 1151|       |     */
 1152|      0|    result = Curl_setstropt(&data->set.str[STRING_SERVICE_NAME],
 1153|      0|                            va_arg(param, char *));
 1154|      0|    break;
 1155|       |
 1156|      0|  case CURLOPT_HEADERDATA:
 1157|       |    /*
 1158|       |     * Custom pointer to pass the header write callback function
 1159|       |     */
 1160|      0|    data->set.writeheader = (void *)va_arg(param, void *);
 1161|      0|    break;
 1162|      0|  case CURLOPT_ERRORBUFFER:
 1163|       |    /*
 1164|       |     * Error buffer provided by the caller to get the human readable
 1165|       |     * error string in.
 1166|       |     */
 1167|      0|    data->set.errorbuffer = va_arg(param, char *);
 1168|      0|    break;
 1169|    462|  case CURLOPT_WRITEDATA:
 1170|       |    /*
 1171|       |     * FILE pointer to write to. Or possibly
 1172|       |     * used as argument to the write callback.
 1173|       |     */
 1174|    462|    data->set.out = va_arg(param, void *);
 1175|    462|    break;
 1176|       |
 1177|      0|  case CURLOPT_DIRLISTONLY:
 1178|       |    /*
 1179|       |     * An option that changes the command to one that asks for a list only, no
 1180|       |     * file info details. Used for FTP, POP3 and SFTP.
 1181|       |     */
 1182|      0|    data->set.list_only = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1183|      0|    break;
 1184|       |
 1185|      0|  case CURLOPT_APPEND:
 1186|       |    /*
 1187|       |     * We want to upload and append to an existing file. Used for FTP and
 1188|       |     * SFTP.
 1189|       |     */
 1190|      0|    data->set.remote_append = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1191|      0|    break;
 1192|       |
 1193|      0|#ifndef CURL_DISABLE_FTP
 1194|      0|  case CURLOPT_FTP_FILEMETHOD:
 1195|       |    /*
 1196|       |     * How do access files over FTP.
 1197|       |     */
 1198|      0|    arg = va_arg(param, long);
 1199|      0|    if((arg < CURLFTPMETHOD_DEFAULT) || (arg >= CURLFTPMETHOD_LAST))
 1200|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1201|      0|    data->set.ftp_filemethod = (curl_ftpfile)arg;
 1202|      0|    break;
 1203|      0|  case CURLOPT_FTPPORT:
 1204|       |    /*
 1205|       |     * Use FTP PORT, this also specifies which IP address to use
 1206|       |     */
 1207|      0|    result = Curl_setstropt(&data->set.str[STRING_FTPPORT],
 1208|      0|                            va_arg(param, char *));
 1209|      0|    data->set.ftp_use_port = (data->set.str[STRING_FTPPORT]) ? TRUE : FALSE;
 1210|      0|    break;
 1211|       |
 1212|      0|  case CURLOPT_FTP_USE_EPRT:
 1213|      0|    data->set.ftp_use_eprt = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1214|      0|    break;
 1215|       |
 1216|      0|  case CURLOPT_FTP_USE_EPSV:
 1217|      0|    data->set.ftp_use_epsv = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1218|      0|    break;
 1219|       |
 1220|      0|  case CURLOPT_FTP_USE_PRET:
 1221|      0|    data->set.ftp_use_pret = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1222|      0|    break;
 1223|       |
 1224|      0|  case CURLOPT_FTP_SSL_CCC:
 1225|      0|    arg = va_arg(param, long);
 1226|      0|    if((arg < CURLFTPSSL_CCC_NONE) || (arg >= CURLFTPSSL_CCC_LAST))
 1227|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1228|      0|    data->set.ftp_ccc = (curl_ftpccc)arg;
 1229|      0|    break;
 1230|       |
 1231|      0|  case CURLOPT_FTP_SKIP_PASV_IP:
 1232|       |    /*
 1233|       |     * Enable or disable FTP_SKIP_PASV_IP, which will disable/enable the
 1234|       |     * bypass of the IP address in PASV responses.
 1235|       |     */
 1236|      0|    data->set.ftp_skip_ip = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1237|      0|    break;
 1238|       |
 1239|      0|  case CURLOPT_FTP_ACCOUNT:
 1240|      0|    result = Curl_setstropt(&data->set.str[STRING_FTP_ACCOUNT],
 1241|      0|                            va_arg(param, char *));
 1242|      0|    break;
 1243|       |
 1244|      0|  case CURLOPT_FTP_ALTERNATIVE_TO_USER:
 1245|      0|    result = Curl_setstropt(&data->set.str[STRING_FTP_ALTERNATIVE_TO_USER],
 1246|      0|                            va_arg(param, char *));
 1247|      0|    break;
 1248|       |
 1249|      0|  case CURLOPT_FTPSSLAUTH:
 1250|       |    /*
 1251|       |     * Set a specific auth for FTP-SSL transfers.
 1252|       |     */
 1253|      0|    arg = va_arg(param, long);
 1254|      0|    if((arg < CURLFTPAUTH_DEFAULT) || (arg >= CURLFTPAUTH_LAST))
 1255|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1256|      0|    data->set.ftpsslauth = (curl_ftpauth)arg;
 1257|      0|    break;
 1258|      0|  case CURLOPT_KRBLEVEL:
 1259|       |    /*
 1260|       |     * A string that defines the kerberos security level.
 1261|       |     */
 1262|      0|    result = Curl_setstropt(&data->set.str[STRING_KRB_LEVEL],
 1263|      0|                            va_arg(param, char *));
 1264|      0|    data->set.krb = (data->set.str[STRING_KRB_LEVEL]) ? TRUE : FALSE;
 1265|      0|    break;
 1266|      0|#endif
 1267|      0|  case CURLOPT_FTP_CREATE_MISSING_DIRS:
 1268|       |    /*
 1269|       |     * An FTP/SFTP option that modifies an upload to create missing
 1270|       |     * directories on the server.
 1271|       |     */
 1272|      0|    arg = va_arg(param, long);
 1273|       |    /* reserve other values for future use */
 1274|      0|    if((arg < CURLFTP_CREATE_DIR_NONE) ||
 1275|      0|       (arg > CURLFTP_CREATE_DIR_RETRY))
 1276|      0|      result = CURLE_BAD_FUNCTION_ARGUMENT;
 1277|      0|    else
 1278|      0|      data->set.ftp_create_missing_dirs = (int)arg;
 1279|      0|    break;
 1280|    462|  case CURLOPT_READDATA:
 1281|       |    /*
 1282|       |     * FILE pointer to read the file to be uploaded from. Or possibly
 1283|       |     * used as argument to the read callback.
 1284|       |     */
 1285|    462|    data->set.in_set = va_arg(param, void *);
 1286|    462|    break;
 1287|      0|  case CURLOPT_INFILESIZE:
 1288|       |    /*
 1289|       |     * If known, this should inform curl about the file size of the
 1290|       |     * to-be-uploaded file.
 1291|       |     */
 1292|      0|    arg = va_arg(param, long);
 1293|      0|    if(arg < -1)
 1294|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1295|      0|    data->set.filesize = arg;
 1296|      0|    break;
 1297|      6|  case CURLOPT_INFILESIZE_LARGE:
 1298|       |    /*
 1299|       |     * If known, this should inform curl about the file size of the
 1300|       |     * to-be-uploaded file.
 1301|       |     */
 1302|      6|    bigsize = va_arg(param, curl_off_t);
 1303|      6|    if(bigsize < -1)
 1304|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1305|      6|    data->set.filesize = bigsize;
 1306|      6|    break;
 1307|      0|  case CURLOPT_LOW_SPEED_LIMIT:
 1308|       |    /*
 1309|       |     * The low speed limit that if transfers are below this for
 1310|       |     * CURLOPT_LOW_SPEED_TIME, the transfer is aborted.
 1311|       |     */
 1312|      0|    arg = va_arg(param, long);
 1313|      0|    if(arg < 0)
 1314|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1315|      0|    data->set.low_speed_limit = arg;
 1316|      0|    break;
 1317|      0|  case CURLOPT_MAX_SEND_SPEED_LARGE:
 1318|       |    /*
 1319|       |     * When transfer uploads are faster then CURLOPT_MAX_SEND_SPEED_LARGE
 1320|       |     * bytes per second the transfer is throttled..
 1321|       |     */
 1322|      0|    bigsize = va_arg(param, curl_off_t);
 1323|      0|    if(bigsize < 0)
 1324|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1325|      0|    data->set.max_send_speed = bigsize;
 1326|      0|    break;
 1327|      0|  case CURLOPT_MAX_RECV_SPEED_LARGE:
 1328|       |    /*
 1329|       |     * When receiving data faster than CURLOPT_MAX_RECV_SPEED_LARGE bytes per
 1330|       |     * second the transfer is throttled..
 1331|       |     */
 1332|      0|    bigsize = va_arg(param, curl_off_t);
 1333|      0|    if(bigsize < 0)
 1334|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1335|      0|    data->set.max_recv_speed = bigsize;
 1336|      0|    break;
 1337|      0|  case CURLOPT_LOW_SPEED_TIME:
 1338|       |    /*
 1339|       |     * The low speed time that if transfers are below the set
 1340|       |     * CURLOPT_LOW_SPEED_LIMIT during this time, the transfer is aborted.
 1341|       |     */
 1342|      0|    arg = va_arg(param, long);
 1343|      0|    if(arg < 0)
 1344|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1345|      0|    data->set.low_speed_time = arg;
 1346|      0|    break;
 1347|      0|  case CURLOPT_CURLU:
 1348|       |    /*
 1349|       |     * pass CURLU to set URL
 1350|       |     */
 1351|      0|    data->set.uh = va_arg(param, CURLU *);
 1352|      0|    break;
 1353|    260|  case CURLOPT_URL:
 1354|       |    /*
 1355|       |     * The URL to fetch.
 1356|       |     */
 1357|    260|    if(data->state.url_alloc) {
 1358|       |      /* the already set URL is allocated, free it first! */
 1359|      0|      Curl_safefree(data->state.url);
 1360|      0|      data->state.url_alloc = FALSE;
 1361|      0|    }
 1362|    260|    result = Curl_setstropt(&data->set.str[STRING_SET_URL],
 1363|    260|                            va_arg(param, char *));
 1364|    260|    data->state.url = data->set.str[STRING_SET_URL];
 1365|    260|    break;
 1366|      0|  case CURLOPT_PORT:
 1367|       |    /*
 1368|       |     * The port number to use when getting the URL
 1369|       |     */
 1370|      0|    arg = va_arg(param, long);
 1371|      0|    if((arg < 0) || (arg > 65535))
 1372|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1373|      0|    data->set.use_port = arg;
 1374|      0|    break;
 1375|      0|  case CURLOPT_TIMEOUT:
 1376|       |    /*
 1377|       |     * The maximum time you allow curl to use for a single transfer
 1378|       |     * operation.
 1379|       |     */
 1380|      0|    arg = va_arg(param, long);
 1381|      0|    if((arg >= 0) && (arg <= (INT_MAX/1000)))
 1382|      0|      data->set.timeout = arg * 1000;
 1383|      0|    else
 1384|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1385|      0|    break;
 1386|       |
 1387|    462|  case CURLOPT_TIMEOUT_MS:
 1388|    462|    arg = va_arg(param, long);
 1389|    462|    if(arg < 0)
 1390|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1391|    462|    data->set.timeout = arg;
 1392|    462|    break;
 1393|       |
 1394|      0|  case CURLOPT_CONNECTTIMEOUT:
 1395|       |    /*
 1396|       |     * The maximum time you allow curl to use to connect.
 1397|       |     */
 1398|      0|    arg = va_arg(param, long);
 1399|      0|    if((arg >= 0) && (arg <= (INT_MAX/1000)))
 1400|      0|      data->set.connecttimeout = arg * 1000;
 1401|      0|    else
 1402|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1403|      0|    break;
 1404|       |
 1405|      0|  case CURLOPT_CONNECTTIMEOUT_MS:
 1406|      0|    arg = va_arg(param, long);
 1407|      0|    if(arg < 0)
 1408|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1409|      0|    data->set.connecttimeout = arg;
 1410|      0|    break;
 1411|       |
 1412|      0|  case CURLOPT_ACCEPTTIMEOUT_MS:
 1413|       |    /*
 1414|       |     * The maximum time you allow curl to wait for server connect
 1415|       |     */
 1416|      0|    arg = va_arg(param, long);
 1417|      0|    if(arg < 0)
 1418|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1419|      0|    data->set.accepttimeout = arg;
 1420|      0|    break;
 1421|       |
 1422|      0|  case CURLOPT_USERPWD:
 1423|       |    /*
 1424|       |     * user:password to use in the operation
 1425|       |     */
 1426|      0|    result = setstropt_userpwd(va_arg(param, char *),
 1427|      0|                               &data->set.str[STRING_USERNAME],
 1428|      0|                               &data->set.str[STRING_PASSWORD]);
 1429|      0|    break;
 1430|       |
 1431|      3|  case CURLOPT_USERNAME:
 1432|       |    /*
 1433|       |     * authentication user name to use in the operation
 1434|       |     */
 1435|      3|    result = Curl_setstropt(&data->set.str[STRING_USERNAME],
 1436|      3|                            va_arg(param, char *));
 1437|      3|    break;
 1438|      5|  case CURLOPT_PASSWORD:
 1439|       |    /*
 1440|       |     * authentication password to use in the operation
 1441|       |     */
 1442|      5|    result = Curl_setstropt(&data->set.str[STRING_PASSWORD],
 1443|      5|                            va_arg(param, char *));
 1444|      5|    break;
 1445|       |
 1446|      0|  case CURLOPT_LOGIN_OPTIONS:
 1447|       |    /*
 1448|       |     * authentication options to use in the operation
 1449|       |     */
 1450|      0|    result = Curl_setstropt(&data->set.str[STRING_OPTIONS],
 1451|      0|                            va_arg(param, char *));
 1452|      0|    break;
 1453|       |
 1454|      0|  case CURLOPT_XOAUTH2_BEARER:
 1455|       |    /*
 1456|       |     * OAuth 2.0 bearer token to use in the operation
 1457|       |     */
 1458|      0|    result = Curl_setstropt(&data->set.str[STRING_BEARER],
 1459|      0|                            va_arg(param, char *));
 1460|      0|    break;
 1461|       |
 1462|      0|  case CURLOPT_POSTQUOTE:
 1463|       |    /*
 1464|       |     * List of RAW FTP commands to use after a transfer
 1465|       |     */
 1466|      0|    data->set.postquote = va_arg(param, struct curl_slist *);
 1467|      0|    break;
 1468|      0|  case CURLOPT_PREQUOTE:
 1469|       |    /*
 1470|       |     * List of RAW FTP commands to use prior to RETR (Wesley Laxton)
 1471|       |     */
 1472|      0|    data->set.prequote = va_arg(param, struct curl_slist *);
 1473|      0|    break;
 1474|      0|  case CURLOPT_QUOTE:
 1475|       |    /*
 1476|       |     * List of RAW FTP commands to use before a transfer
 1477|       |     */
 1478|      0|    data->set.quote = va_arg(param, struct curl_slist *);
 1479|      0|    break;
 1480|      0|  case CURLOPT_RESOLVE:
 1481|       |    /*
 1482|       |     * List of HOST:PORT:[addresses] strings to populate the DNS cache with
 1483|       |     * Entries added this way will remain in the cache until explicitly
 1484|       |     * removed or the handle is cleaned up.
 1485|       |     *
 1486|       |     * Prefix the HOST with plus sign (+) to have the entry expire just like
 1487|       |     * automatically added entries.
 1488|       |     *
 1489|       |     * Prefix the HOST with dash (-) to _remove_ the entry from the cache.
 1490|       |     *
 1491|       |     * This API can remove any entry from the DNS cache, but only entries
 1492|       |     * that aren't actually in use right now will be pruned immediately.
 1493|       |     */
 1494|      0|    data->set.resolve = va_arg(param, struct curl_slist *);
 1495|      0|    data->state.resolve = data->set.resolve;
 1496|      0|    break;
 1497|      0|  case CURLOPT_PROGRESSFUNCTION:
 1498|       |    /*
 1499|       |     * Progress callback function
 1500|       |     */
 1501|      0|    data->set.fprogress = va_arg(param, curl_progress_callback);
 1502|      0|    if(data->set.fprogress)
 1503|      0|      data->progress.callback = TRUE; /* no longer internal */
 1504|      0|    else
 1505|      0|      data->progress.callback = FALSE; /* NULL enforces internal */
 1506|      0|    break;
 1507|       |
 1508|      0|  case CURLOPT_XFERINFOFUNCTION:
 1509|       |    /*
 1510|       |     * Transfer info callback function
 1511|       |     */
 1512|      0|    data->set.fxferinfo = va_arg(param, curl_xferinfo_callback);
 1513|      0|    if(data->set.fxferinfo)
 1514|      0|      data->progress.callback = TRUE; /* no longer internal */
 1515|      0|    else
 1516|      0|      data->progress.callback = FALSE; /* NULL enforces internal */
 1517|       |
 1518|      0|    break;
 1519|       |
 1520|      0|  case CURLOPT_PROGRESSDATA:
 1521|       |    /*
 1522|       |     * Custom client data to pass to the progress callback
 1523|       |     */
 1524|      0|    data->set.progress_client = va_arg(param, void *);
 1525|      0|    break;
 1526|       |
 1527|      0|#ifndef CURL_DISABLE_PROXY
 1528|      0|  case CURLOPT_PROXYUSERPWD:
 1529|       |    /*
 1530|       |     * user:password needed to use the proxy
 1531|       |     */
 1532|      0|    result = setstropt_userpwd(va_arg(param, char *),
 1533|      0|                               &data->set.str[STRING_PROXYUSERNAME],
 1534|      0|                               &data->set.str[STRING_PROXYPASSWORD]);
 1535|      0|    break;
 1536|      0|  case CURLOPT_PROXYUSERNAME:
 1537|       |    /*
 1538|       |     * authentication user name to use in the operation
 1539|       |     */
 1540|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXYUSERNAME],
 1541|      0|                            va_arg(param, char *));
 1542|      0|    break;
 1543|      0|  case CURLOPT_PROXYPASSWORD:
 1544|       |    /*
 1545|       |     * authentication password to use in the operation
 1546|       |     */
 1547|      0|    result = Curl_setstropt(&data->set.str[STRING_PROXYPASSWORD],
 1548|      0|                            va_arg(param, char *));
 1549|      0|    break;
 1550|      0|  case CURLOPT_NOPROXY:
 1551|       |    /*
 1552|       |     * proxy exception list
 1553|       |     */
 1554|      0|    result = Curl_setstropt(&data->set.str[STRING_NOPROXY],
 1555|      0|                            va_arg(param, char *));
 1556|      0|    break;
 1557|      0|#endif
 1558|       |
 1559|      2|  case CURLOPT_RANGE:
 1560|       |    /*
 1561|       |     * What range of the file you want to transfer
 1562|       |     */
 1563|      2|    result = Curl_setstropt(&data->set.str[STRING_SET_RANGE],
 1564|      2|                            va_arg(param, char *));
 1565|      2|    break;
 1566|      0|  case CURLOPT_RESUME_FROM:
 1567|       |    /*
 1568|       |     * Resume transfer at the given file position
 1569|       |     */
 1570|      0|    arg = va_arg(param, long);
 1571|      0|    if(arg < -1)
 1572|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1573|      0|    data->set.set_resume_from = arg;
 1574|      0|    break;
 1575|      0|  case CURLOPT_RESUME_FROM_LARGE:
 1576|       |    /*
 1577|       |     * Resume transfer at the given file position
 1578|       |     */
 1579|      0|    bigsize = va_arg(param, curl_off_t);
 1580|      0|    if(bigsize < -1)
 1581|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1582|      0|    data->set.set_resume_from = bigsize;
 1583|      0|    break;
 1584|      0|  case CURLOPT_DEBUGFUNCTION:
 1585|       |    /*
 1586|       |     * stderr write callback.
 1587|       |     */
 1588|      0|    data->set.fdebug = va_arg(param, curl_debug_callback);
 1589|       |    /*
 1590|       |     * if the callback provided is NULL, it'll use the default callback
 1591|       |     */
 1592|      0|    break;
 1593|      0|  case CURLOPT_DEBUGDATA:
 1594|       |    /*
 1595|       |     * Set to a void * that should receive all error writes. This
 1596|       |     * defaults to CURLOPT_STDERR for normal operations.
 1597|       |     */
 1598|      0|    data->set.debugdata = va_arg(param, void *);
 1599|      0|    break;
 1600|      0|  case CURLOPT_STDERR:
 1601|       |    /*
 1602|       |     * Set to a FILE * that should receive all error writes. This
 1603|       |     * defaults to stderr for normal operations.
 1604|       |     */
 1605|      0|    data->set.err = va_arg(param, FILE *);
 1606|      0|    if(!data->set.err)
 1607|      0|      data->set.err = stderr;
 1608|      0|    break;
 1609|      0|  case CURLOPT_HEADERFUNCTION:
 1610|       |    /*
 1611|       |     * Set header write callback
 1612|       |     */
 1613|      0|    data->set.fwrite_header = va_arg(param, curl_write_callback);
 1614|      0|    break;
 1615|    462|  case CURLOPT_WRITEFUNCTION:
 1616|       |    /*
 1617|       |     * Set data write callback
 1618|       |     */
 1619|    462|    data->set.fwrite_func = va_arg(param, curl_write_callback);
 1620|    462|    if(!data->set.fwrite_func) {
 1621|      0|      data->set.is_fwrite_set = 0;
 1622|       |      /* When set to NULL, reset to our internal default function */
 1623|      0|      data->set.fwrite_func = (curl_write_callback)fwrite;
 1624|      0|    }
 1625|    462|    else
 1626|    462|      data->set.is_fwrite_set = 1;
 1627|    462|    break;
 1628|    462|  case CURLOPT_READFUNCTION:
 1629|       |    /*
 1630|       |     * Read data callback
 1631|       |     */
 1632|    462|    data->set.fread_func_set = va_arg(param, curl_read_callback);
 1633|    462|    if(!data->set.fread_func_set) {
 1634|      0|      data->set.is_fread_set = 0;
 1635|       |      /* When set to NULL, reset to our internal default function */
 1636|      0|      data->set.fread_func_set = (curl_read_callback)fread;
 1637|      0|    }
 1638|    462|    else
 1639|    462|      data->set.is_fread_set = 1;
 1640|    462|    break;
 1641|      0|  case CURLOPT_SEEKFUNCTION:
 1642|       |    /*
 1643|       |     * Seek callback. Might be NULL.
 1644|       |     */
 1645|      0|    data->set.seek_func = va_arg(param, curl_seek_callback);
 1646|      0|    break;
 1647|      0|  case CURLOPT_SEEKDATA:
 1648|       |    /*
 1649|       |     * Seek control callback. Might be NULL.
 1650|       |     */
 1651|      0|    data->set.seek_client = va_arg(param, void *);
 1652|      0|    break;
 1653|      0|  case CURLOPT_CONV_FROM_NETWORK_FUNCTION:
 1654|       |    /*
 1655|       |     * "Convert from network encoding" callback
 1656|       |     */
 1657|      0|    data->set.convfromnetwork = va_arg(param, curl_conv_callback);
 1658|      0|    break;
 1659|      0|  case CURLOPT_CONV_TO_NETWORK_FUNCTION:
 1660|       |    /*
 1661|       |     * "Convert to network encoding" callback
 1662|       |     */
 1663|      0|    data->set.convtonetwork = va_arg(param, curl_conv_callback);
 1664|      0|    break;
 1665|      0|  case CURLOPT_CONV_FROM_UTF8_FUNCTION:
 1666|       |    /*
 1667|       |     * "Convert from UTF-8 encoding" callback
 1668|       |     */
 1669|      0|    data->set.convfromutf8 = va_arg(param, curl_conv_callback);
 1670|      0|    break;
 1671|      0|  case CURLOPT_IOCTLFUNCTION:
 1672|       |    /*
 1673|       |     * I/O control callback. Might be NULL.
 1674|       |     */
 1675|      0|    data->set.ioctl_func = va_arg(param, curl_ioctl_callback);
 1676|      0|    break;
 1677|      0|  case CURLOPT_IOCTLDATA:
 1678|       |    /*
 1679|       |     * I/O control data pointer. Might be NULL.
 1680|       |     */
 1681|      0|    data->set.ioctl_client = va_arg(param, void *);
 1682|      0|    break;
 1683|      0|  case CURLOPT_SSLCERT:
 1684|       |    /*
 1685|       |     * String that holds file name of the SSL certificate to use
 1686|       |     */
 1687|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT],
 1688|      0|                            va_arg(param, char *));
 1689|      0|    break;
 1690|      0|  case CURLOPT_SSLCERT_BLOB:
 1691|       |    /*
 1692|       |     * Blob that holds file content of the SSL certificate to use
 1693|       |     */
 1694|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_CERT],
 1695|      0|                             va_arg(param, struct curl_blob *));
 1696|      0|    break;
 1697|      0|#ifndef CURL_DISABLE_PROXY
 1698|      0|  case CURLOPT_PROXY_SSLCERT:
 1699|       |    /*
 1700|       |     * String that holds file name of the SSL certificate to use for proxy
 1701|       |     */
 1702|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT_PROXY],
 1703|      0|                            va_arg(param, char *));
 1704|      0|    break;
 1705|      0|  case CURLOPT_PROXY_SSLCERT_BLOB:
 1706|       |    /*
 1707|       |     * Blob that holds file content of the SSL certificate to use for proxy
 1708|       |     */
 1709|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_CERT_PROXY],
 1710|      0|                             va_arg(param, struct curl_blob *));
 1711|      0|    break;
 1712|      0|#endif
 1713|      0|  case CURLOPT_SSLCERTTYPE:
 1714|       |    /*
 1715|       |     * String that holds file type of the SSL certificate to use
 1716|       |     */
 1717|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT_TYPE],
 1718|      0|                            va_arg(param, char *));
 1719|      0|    break;
 1720|      0|#ifndef CURL_DISABLE_PROXY
 1721|      0|  case CURLOPT_PROXY_SSLCERTTYPE:
 1722|       |    /*
 1723|       |     * String that holds file type of the SSL certificate to use for proxy
 1724|       |     */
 1725|      0|    result = Curl_setstropt(&data->set.str[STRING_CERT_TYPE_PROXY],
 1726|      0|                            va_arg(param, char *));
 1727|      0|    break;
 1728|      0|#endif
 1729|      0|  case CURLOPT_SSLKEY:
 1730|       |    /*
 1731|       |     * String that holds file name of the SSL key to use
 1732|       |     */
 1733|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY],
 1734|      0|                            va_arg(param, char *));
 1735|      0|    break;
 1736|      0|  case CURLOPT_SSLKEY_BLOB:
 1737|       |    /*
 1738|       |     * Blob that holds file content of the SSL key to use
 1739|       |     */
 1740|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_KEY],
 1741|      0|                             va_arg(param, struct curl_blob *));
 1742|      0|    break;
 1743|      0|#ifndef CURL_DISABLE_PROXY
 1744|      0|  case CURLOPT_PROXY_SSLKEY:
 1745|       |    /*
 1746|       |     * String that holds file name of the SSL key to use for proxy
 1747|       |     */
 1748|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_PROXY],
 1749|      0|                            va_arg(param, char *));
 1750|      0|    break;
 1751|      0|  case CURLOPT_PROXY_SSLKEY_BLOB:
 1752|       |    /*
 1753|       |     * Blob that holds file content of the SSL key to use for proxy
 1754|       |     */
 1755|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_KEY_PROXY],
 1756|      0|                             va_arg(param, struct curl_blob *));
 1757|      0|    break;
 1758|      0|#endif
 1759|      0|  case CURLOPT_SSLKEYTYPE:
 1760|       |    /*
 1761|       |     * String that holds file type of the SSL key to use
 1762|       |     */
 1763|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_TYPE],
 1764|      0|                            va_arg(param, char *));
 1765|      0|    break;
 1766|      0|#ifndef CURL_DISABLE_PROXY
 1767|      0|  case CURLOPT_PROXY_SSLKEYTYPE:
 1768|       |    /*
 1769|       |     * String that holds file type of the SSL key to use for proxy
 1770|       |     */
 1771|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_TYPE_PROXY],
 1772|      0|                            va_arg(param, char *));
 1773|      0|    break;
 1774|      0|#endif
 1775|      0|  case CURLOPT_KEYPASSWD:
 1776|       |    /*
 1777|       |     * String that holds the SSL or SSH private key password.
 1778|       |     */
 1779|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_PASSWD],
 1780|      0|                            va_arg(param, char *));
 1781|      0|    break;
 1782|      0|#ifndef CURL_DISABLE_PROXY
 1783|      0|  case CURLOPT_PROXY_KEYPASSWD:
 1784|       |    /*
 1785|       |     * String that holds the SSL private key password for proxy.
 1786|       |     */
 1787|      0|    result = Curl_setstropt(&data->set.str[STRING_KEY_PASSWD_PROXY],
 1788|      0|                            va_arg(param, char *));
 1789|      0|    break;
 1790|      0|#endif
 1791|      0|  case CURLOPT_SSLENGINE:
 1792|       |    /*
 1793|       |     * String that holds the SSL crypto engine.
 1794|       |     */
 1795|      0|    argptr = va_arg(param, char *);
 1796|      0|    if(argptr && argptr[0]) {
 1797|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_ENGINE], argptr);
 1798|      0|      if(!result) {
 1799|      0|        result = Curl_ssl_set_engine(data, argptr);
 1800|      0|      }
 1801|      0|    }
 1802|      0|    break;
 1803|       |
 1804|      0|  case CURLOPT_SSLENGINE_DEFAULT:
 1805|       |    /*
 1806|       |     * flag to set engine as default.
 1807|       |     */
 1808|      0|    Curl_setstropt(&data->set.str[STRING_SSL_ENGINE], NULL);
 1809|      0|    result = Curl_ssl_set_engine_default(data);
 1810|      0|    break;
 1811|      0|  case CURLOPT_CRLF:
 1812|       |    /*
 1813|       |     * Kludgy option to enable CRLF conversions. Subject for removal.
 1814|       |     */
 1815|      0|    data->set.crlf = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1816|      0|    break;
 1817|      0|#ifndef CURL_DISABLE_PROXY
 1818|      0|  case CURLOPT_HAPROXYPROTOCOL:
 1819|       |    /*
 1820|       |     * Set to send the HAProxy Proxy Protocol header
 1821|       |     */
 1822|      0|    data->set.haproxyprotocol = (0 != va_arg(param, long)) ? TRUE : FALSE;
 1823|      0|    break;
 1824|      0|#endif
 1825|      0|  case CURLOPT_INTERFACE:
 1826|       |    /*
 1827|       |     * Set what interface or address/hostname to bind the socket to when
 1828|       |     * performing an operation and thus what from-IP your connection will use.
 1829|       |     */
 1830|      0|    result = Curl_setstropt(&data->set.str[STRING_DEVICE],
 1831|      0|                            va_arg(param, char *));
 1832|      0|    break;
 1833|      0|  case CURLOPT_LOCALPORT:
 1834|       |    /*
 1835|       |     * Set what local port to bind the socket to when performing an operation.
 1836|       |     */
 1837|      0|    arg = va_arg(param, long);
 1838|      0|    if((arg < 0) || (arg > 65535))
 1839|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1840|      0|    data->set.localport = curlx_sltous(arg);
 1841|      0|    break;
 1842|      0|  case CURLOPT_LOCALPORTRANGE:
 1843|       |    /*
 1844|       |     * Set number of local ports to try, starting with CURLOPT_LOCALPORT.
 1845|       |     */
 1846|      0|    arg = va_arg(param, long);
 1847|      0|    if((arg < 0) || (arg > 65535))
 1848|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1849|      0|    data->set.localportrange = curlx_sltosi(arg);
 1850|      0|    break;
 1851|      0|  case CURLOPT_GSSAPI_DELEGATION:
 1852|       |    /*
 1853|       |     * GSS-API credential delegation bitmask
 1854|       |     */
 1855|      0|    arg = va_arg(param, long);
 1856|      0|    if(arg < CURLGSSAPI_DELEGATION_NONE)
 1857|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 1858|      0|    data->set.gssapi_delegation = arg;
 1859|      0|    break;
 1860|      0|  case CURLOPT_SSL_VERIFYPEER:
 1861|       |    /*
 1862|       |     * Enable peer SSL verifying.
 1863|       |     */
 1864|      0|    data->set.ssl.primary.verifypeer = (0 != va_arg(param, long)) ?
 1865|      0|      TRUE : FALSE;
 1866|       |
 1867|       |    /* Update the current connection ssl_config. */
 1868|      0|    if(data->conn) {
 1869|      0|      data->conn->ssl_config.verifypeer =
 1870|      0|        data->set.ssl.primary.verifypeer;
 1871|      0|    }
 1872|      0|    break;
 1873|      0|  case CURLOPT_DOH_SSL_VERIFYPEER:
 1874|       |    /*
 1875|       |     * Enable peer SSL verifying for DoH.
 1876|       |     */
 1877|      0|    data->set.doh_verifypeer = (0 != va_arg(param, long)) ?
 1878|      0|      TRUE : FALSE;
 1879|      0|    break;
 1880|      0|#ifndef CURL_DISABLE_PROXY
 1881|      0|  case CURLOPT_PROXY_SSL_VERIFYPEER:
 1882|       |    /*
 1883|       |     * Enable peer SSL verifying for proxy.
 1884|       |     */
 1885|      0|    data->set.proxy_ssl.primary.verifypeer =
 1886|      0|      (0 != va_arg(param, long))?TRUE:FALSE;
 1887|       |
 1888|       |    /* Update the current connection proxy_ssl_config. */
 1889|      0|    if(data->conn) {
 1890|      0|      data->conn->proxy_ssl_config.verifypeer =
 1891|      0|        data->set.proxy_ssl.primary.verifypeer;
 1892|      0|    }
 1893|      0|    break;
 1894|      0|#endif
 1895|      0|  case CURLOPT_SSL_VERIFYHOST:
 1896|       |    /*
 1897|       |     * Enable verification of the host name in the peer certificate
 1898|       |     */
 1899|      0|    arg = va_arg(param, long);
 1900|       |
 1901|       |    /* Obviously people are not reading documentation and too many thought
 1902|       |       this argument took a boolean when it wasn't and misused it.
 1903|       |       Treat 1 and 2 the same */
 1904|      0|    data->set.ssl.primary.verifyhost = (bool)((arg & 3) ? TRUE : FALSE);
 1905|       |
 1906|       |    /* Update the current connection ssl_config. */
 1907|      0|    if(data->conn) {
 1908|      0|      data->conn->ssl_config.verifyhost =
 1909|      0|        data->set.ssl.primary.verifyhost;
 1910|      0|    }
 1911|      0|    break;
 1912|      0|  case CURLOPT_DOH_SSL_VERIFYHOST:
 1913|       |    /*
 1914|       |     * Enable verification of the host name in the peer certificate for DoH
 1915|       |     */
 1916|      0|    arg = va_arg(param, long);
 1917|       |
 1918|       |    /* Treat both 1 and 2 as TRUE */
 1919|      0|    data->set.doh_verifyhost = (bool)((arg & 3) ? TRUE : FALSE);
 1920|      0|    break;
 1921|      0|#ifndef CURL_DISABLE_PROXY
 1922|      0|  case CURLOPT_PROXY_SSL_VERIFYHOST:
 1923|       |    /*
 1924|       |     * Enable verification of the host name in the peer certificate for proxy
 1925|       |     */
 1926|      0|    arg = va_arg(param, long);
 1927|       |
 1928|       |    /* Treat both 1 and 2 as TRUE */
 1929|      0|    data->set.proxy_ssl.primary.verifyhost = (bool)((arg & 3)?TRUE:FALSE);
 1930|       |
 1931|       |    /* Update the current connection proxy_ssl_config. */
 1932|      0|    if(data->conn) {
 1933|      0|      data->conn->proxy_ssl_config.verifyhost =
 1934|      0|        data->set.proxy_ssl.primary.verifyhost;
 1935|      0|    }
 1936|      0|    break;
 1937|      0|#endif
 1938|      0|  case CURLOPT_SSL_VERIFYSTATUS:
 1939|       |    /*
 1940|       |     * Enable certificate status verifying.
 1941|       |     */
 1942|      0|    if(!Curl_ssl_cert_status_request()) {
 1943|      0|      result = CURLE_NOT_BUILT_IN;
 1944|      0|      break;
 1945|      0|    }
 1946|       |
 1947|      0|    data->set.ssl.primary.verifystatus = (0 != va_arg(param, long)) ?
 1948|      0|      TRUE : FALSE;
 1949|       |
 1950|       |    /* Update the current connection ssl_config. */
 1951|      0|    if(data->conn) {
 1952|      0|      data->conn->ssl_config.verifystatus =
 1953|      0|        data->set.ssl.primary.verifystatus;
 1954|      0|    }
 1955|      0|    break;
 1956|      0|  case CURLOPT_DOH_SSL_VERIFYSTATUS:
 1957|       |    /*
 1958|       |     * Enable certificate status verifying for DoH.
 1959|       |     */
 1960|      0|    if(!Curl_ssl_cert_status_request()) {
 1961|      0|      result = CURLE_NOT_BUILT_IN;
 1962|      0|      break;
 1963|      0|    }
 1964|       |
 1965|      0|    data->set.doh_verifystatus = (0 != va_arg(param, long)) ?
 1966|      0|      TRUE : FALSE;
 1967|      0|    break;
 1968|      0|  case CURLOPT_SSL_CTX_FUNCTION:
 1969|       |    /*
 1970|       |     * Set a SSL_CTX callback
 1971|       |     */
 1972|      0|#ifdef USE_SSL
 1973|      0|    if(Curl_ssl->supports & SSLSUPP_SSL_CTX)
 1974|      0|      data->set.ssl.fsslctx = va_arg(param, curl_ssl_ctx_callback);
 1975|      0|    else
 1976|      0|#endif
 1977|      0|      result = CURLE_NOT_BUILT_IN;
 1978|      0|    break;
 1979|      0|  case CURLOPT_SSL_CTX_DATA:
 1980|       |    /*
 1981|       |     * Set a SSL_CTX callback parameter pointer
 1982|       |     */
 1983|      0|#ifdef USE_SSL
 1984|      0|    if(Curl_ssl->supports & SSLSUPP_SSL_CTX)
 1985|      0|      data->set.ssl.fsslctxp = va_arg(param, void *);
 1986|      0|    else
 1987|      0|#endif
 1988|      0|      result = CURLE_NOT_BUILT_IN;
 1989|      0|    break;
 1990|      0|  case CURLOPT_SSL_FALSESTART:
 1991|       |    /*
 1992|       |     * Enable TLS false start.
 1993|       |     */
 1994|      0|    if(!Curl_ssl_false_start()) {
 1995|      0|      result = CURLE_NOT_BUILT_IN;
 1996|      0|      break;
 1997|      0|    }
 1998|       |
 1999|      0|    data->set.ssl.falsestart = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2000|      0|    break;
 2001|      0|  case CURLOPT_CERTINFO:
 2002|      0|#ifdef USE_SSL
 2003|      0|    if(Curl_ssl->supports & SSLSUPP_CERTINFO)
 2004|      0|      data->set.ssl.certinfo = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2005|      0|    else
 2006|      0|#endif
 2007|      0|      result = CURLE_NOT_BUILT_IN;
 2008|      0|        break;
 2009|      0|  case CURLOPT_PINNEDPUBLICKEY:
 2010|       |    /*
 2011|       |     * Set pinned public key for SSL connection.
 2012|       |     * Specify file name of the public key in DER format.
 2013|       |     */
 2014|      0|#ifdef USE_SSL
 2015|      0|    if(Curl_ssl->supports & SSLSUPP_PINNEDPUBKEY)
 2016|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_PINNEDPUBLICKEY],
 2017|      0|                              va_arg(param, char *));
 2018|      0|    else
 2019|      0|#endif
 2020|      0|      result = CURLE_NOT_BUILT_IN;
 2021|      0|    break;
 2022|      0|#ifndef CURL_DISABLE_PROXY
 2023|      0|  case CURLOPT_PROXY_PINNEDPUBLICKEY:
 2024|       |    /*
 2025|       |     * Set pinned public key for SSL connection.
 2026|       |     * Specify file name of the public key in DER format.
 2027|       |     */
 2028|      0|#ifdef USE_SSL
 2029|      0|    if(Curl_ssl->supports & SSLSUPP_PINNEDPUBKEY)
 2030|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY],
 2031|      0|                              va_arg(param, char *));
 2032|      0|    else
 2033|      0|#endif
 2034|      0|      result = CURLE_NOT_BUILT_IN;
 2035|      0|    break;
 2036|      0|#endif
 2037|      0|  case CURLOPT_CAINFO:
 2038|       |    /*
 2039|       |     * Set CA info for SSL connection. Specify file name of the CA certificate
 2040|       |     */
 2041|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE],
 2042|      0|                            va_arg(param, char *));
 2043|      0|    break;
 2044|      0|  case CURLOPT_CAINFO_BLOB:
 2045|       |    /*
 2046|       |     * Blob that holds CA info for SSL connection.
 2047|       |     * Specify entire PEM of the CA certificate
 2048|       |     */
 2049|      0|#ifdef USE_SSL
 2050|      0|    if(Curl_ssl->supports & SSLSUPP_CAINFO_BLOB)
 2051|      0|      result = Curl_setblobopt(&data->set.blobs[BLOB_CAINFO],
 2052|      0|                               va_arg(param, struct curl_blob *));
 2053|      0|    else
 2054|      0|#endif
 2055|      0|      return CURLE_NOT_BUILT_IN;
 2056|       |
 2057|      0|    break;
 2058|      0|#ifndef CURL_DISABLE_PROXY
 2059|      0|  case CURLOPT_PROXY_CAINFO:
 2060|       |    /*
 2061|       |     * Set CA info SSL connection for proxy. Specify file name of the
 2062|       |     * CA certificate
 2063|       |     */
 2064|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE_PROXY],
 2065|      0|                            va_arg(param, char *));
 2066|      0|    break;
 2067|      0|  case CURLOPT_PROXY_CAINFO_BLOB:
 2068|       |    /*
 2069|       |     * Blob that holds CA info for SSL connection proxy.
 2070|       |     * Specify entire PEM of the CA certificate
 2071|       |     */
 2072|      0|#ifdef USE_SSL
 2073|      0|    if(Curl_ssl->supports & SSLSUPP_CAINFO_BLOB)
 2074|      0|      result = Curl_setblobopt(&data->set.blobs[BLOB_CAINFO_PROXY],
 2075|      0|                               va_arg(param, struct curl_blob *));
 2076|      0|    else
 2077|      0|#endif
 2078|      0|      return CURLE_NOT_BUILT_IN;
 2079|      0|    break;
 2080|      0|#endif
 2081|      0|  case CURLOPT_CAPATH:
 2082|       |    /*
 2083|       |     * Set CA path info for SSL connection. Specify directory name of the CA
 2084|       |     * certificates which have been prepared using openssl c_rehash utility.
 2085|       |     */
 2086|      0|#ifdef USE_SSL
 2087|      0|    if(Curl_ssl->supports & SSLSUPP_CA_PATH)
 2088|       |      /* This does not work on windows. */
 2089|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CAPATH],
 2090|      0|                              va_arg(param, char *));
 2091|      0|    else
 2092|      0|#endif
 2093|      0|      result = CURLE_NOT_BUILT_IN;
 2094|      0|    break;
 2095|      0|#ifndef CURL_DISABLE_PROXY
 2096|      0|  case CURLOPT_PROXY_CAPATH:
 2097|       |    /*
 2098|       |     * Set CA path info for SSL connection proxy. Specify directory name of the
 2099|       |     * CA certificates which have been prepared using openssl c_rehash utility.
 2100|       |     */
 2101|      0|#ifdef USE_SSL
 2102|      0|    if(Curl_ssl->supports & SSLSUPP_CA_PATH)
 2103|       |      /* This does not work on windows. */
 2104|      0|      result = Curl_setstropt(&data->set.str[STRING_SSL_CAPATH_PROXY],
 2105|      0|                              va_arg(param, char *));
 2106|      0|    else
 2107|      0|#endif
 2108|      0|      result = CURLE_NOT_BUILT_IN;
 2109|      0|    break;
 2110|      0|#endif
 2111|      0|  case CURLOPT_CRLFILE:
 2112|       |    /*
 2113|       |     * Set CRL file info for SSL connection. Specify file name of the CRL
 2114|       |     * to check certificates revocation
 2115|       |     */
 2116|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CRLFILE],
 2117|      0|                            va_arg(param, char *));
 2118|      0|    break;
 2119|      0|#ifndef CURL_DISABLE_PROXY
 2120|      0|  case CURLOPT_PROXY_CRLFILE:
 2121|       |    /*
 2122|       |     * Set CRL file info for SSL connection for proxy. Specify file name of the
 2123|       |     * CRL to check certificates revocation
 2124|       |     */
 2125|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_CRLFILE_PROXY],
 2126|      0|                            va_arg(param, char *));
 2127|      0|    break;
 2128|      0|#endif
 2129|      0|  case CURLOPT_ISSUERCERT:
 2130|       |    /*
 2131|       |     * Set Issuer certificate file
 2132|       |     * to check certificates issuer
 2133|       |     */
 2134|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_ISSUERCERT],
 2135|      0|                            va_arg(param, char *));
 2136|      0|    break;
 2137|      0|  case CURLOPT_ISSUERCERT_BLOB:
 2138|       |    /*
 2139|       |     * Blob that holds Issuer certificate to check certificates issuer
 2140|       |     */
 2141|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_SSL_ISSUERCERT],
 2142|      0|                             va_arg(param, struct curl_blob *));
 2143|      0|    break;
 2144|      0|#ifndef CURL_DISABLE_PROXY
 2145|      0|  case CURLOPT_PROXY_ISSUERCERT:
 2146|       |    /*
 2147|       |     * Set Issuer certificate file
 2148|       |     * to check certificates issuer
 2149|       |     */
 2150|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_ISSUERCERT_PROXY],
 2151|      0|                            va_arg(param, char *));
 2152|      0|    break;
 2153|      0|  case CURLOPT_PROXY_ISSUERCERT_BLOB:
 2154|       |    /*
 2155|       |     * Blob that holds Issuer certificate to check certificates issuer
 2156|       |     */
 2157|      0|    result = Curl_setblobopt(&data->set.blobs[BLOB_SSL_ISSUERCERT_PROXY],
 2158|      0|                             va_arg(param, struct curl_blob *));
 2159|      0|    break;
 2160|      0|#endif
 2161|      0|#ifndef CURL_DISABLE_TELNET
 2162|      0|  case CURLOPT_TELNETOPTIONS:
 2163|       |    /*
 2164|       |     * Set a linked list of telnet options
 2165|       |     */
 2166|      0|    data->set.telnet_options = va_arg(param, struct curl_slist *);
 2167|      0|    break;
 2168|      0|#endif
 2169|      0|  case CURLOPT_BUFFERSIZE:
 2170|       |    /*
 2171|       |     * The application kindly asks for a differently sized receive buffer.
 2172|       |     * If it seems reasonable, we'll use it.
 2173|       |     */
 2174|      0|    if(data->state.buffer)
 2175|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2176|       |
 2177|      0|    arg = va_arg(param, long);
 2178|       |
 2179|      0|    if(arg > READBUFFER_MAX)
 2180|      0|      arg = READBUFFER_MAX;
 2181|      0|    else if(arg < 1)
 2182|      0|      arg = READBUFFER_SIZE;
 2183|      0|    else if(arg < READBUFFER_MIN)
 2184|      0|      arg = READBUFFER_MIN;
 2185|       |
 2186|      0|    data->set.buffer_size = arg;
 2187|      0|    break;
 2188|       |
 2189|      0|  case CURLOPT_UPLOAD_BUFFERSIZE:
 2190|       |    /*
 2191|       |     * The application kindly asks for a differently sized upload buffer.
 2192|       |     * Cap it to sensible.
 2193|       |     */
 2194|      0|    arg = va_arg(param, long);
 2195|       |
 2196|      0|    if(arg > UPLOADBUFFER_MAX)
 2197|      0|      arg = UPLOADBUFFER_MAX;
 2198|      0|    else if(arg < UPLOADBUFFER_MIN)
 2199|      0|      arg = UPLOADBUFFER_MIN;
 2200|       |
 2201|      0|    data->set.upload_buffer_size = (unsigned int)arg;
 2202|      0|    Curl_safefree(data->state.ulbuf); /* force a realloc next opportunity */
 2203|      0|    break;
 2204|       |
 2205|      0|  case CURLOPT_NOSIGNAL:
 2206|       |    /*
 2207|       |     * The application asks not to set any signal() or alarm() handlers,
 2208|       |     * even when using a timeout.
 2209|       |     */
 2210|      0|    data->set.no_signal = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2211|      0|    break;
 2212|       |
 2213|      0|  case CURLOPT_SHARE:
 2214|      0|  {
 2215|      0|    struct Curl_share *set;
 2216|      0|    set = va_arg(param, struct Curl_share *);
 2217|       |
 2218|       |    /* disconnect from old share, if any */
 2219|      0|    if(data->share) {
 2220|      0|      Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
 2221|       |
 2222|      0|      if(data->dns.hostcachetype == HCACHE_SHARED) {
 2223|      0|        data->dns.hostcache = NULL;
 2224|      0|        data->dns.hostcachetype = HCACHE_NONE;
 2225|      0|      }
 2226|       |
 2227|      0|#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
 2228|      0|      if(data->share->cookies == data->cookies)
 2229|      0|        data->cookies = NULL;
 2230|      0|#endif
 2231|       |
 2232|      0|      if(data->share->sslsession == data->state.session)
 2233|      0|        data->state.session = NULL;
 2234|       |
 2235|       |#ifdef USE_LIBPSL
 2236|       |      if(data->psl == &data->share->psl)
 2237|       |        data->psl = data->multi? &data->multi->psl: NULL;
 2238|       |#endif
 2239|       |
 2240|      0|      data->share->dirty--;
 2241|       |
 2242|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
 2243|      0|      data->share = NULL;
 2244|      0|    }
 2245|       |
 2246|      0|    if(GOOD_SHARE_HANDLE(set))
 2247|       |      /* use new share if it set */
 2248|      0|      data->share = set;
 2249|      0|    if(data->share) {
 2250|       |
 2251|      0|      Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
 2252|       |
 2253|      0|      data->share->dirty++;
 2254|       |
 2255|      0|      if(data->share->specifier & (1<< CURL_LOCK_DATA_DNS)) {
 2256|       |        /* use shared host cache */
 2257|      0|        data->dns.hostcache = &data->share->hostcache;
 2258|      0|        data->dns.hostcachetype = HCACHE_SHARED;
 2259|      0|      }
 2260|      0|#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
 2261|      0|      if(data->share->cookies) {
 2262|       |        /* use shared cookie list, first free own one if any */
 2263|      0|        Curl_cookie_cleanup(data->cookies);
 2264|       |        /* enable cookies since we now use a share that uses cookies! */
 2265|      0|        data->cookies = data->share->cookies;
 2266|      0|      }
 2267|      0|#endif   /* CURL_DISABLE_HTTP */
 2268|      0|      if(data->share->sslsession) {
 2269|      0|        data->set.general_ssl.max_ssl_sessions = data->share->max_ssl_sessions;
 2270|      0|        data->state.session = data->share->sslsession;
 2271|      0|      }
 2272|       |#ifdef USE_LIBPSL
 2273|       |      if(data->share->specifier & (1 << CURL_LOCK_DATA_PSL))
 2274|       |        data->psl = &data->share->psl;
 2275|       |#endif
 2276|       |
 2277|      0|      Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
 2278|      0|    }
 2279|       |    /* check for host cache not needed,
 2280|       |     * it will be done by curl_easy_perform */
 2281|      0|  }
 2282|      0|  break;
 2283|       |
 2284|      0|  case CURLOPT_PRIVATE:
 2285|       |    /*
 2286|       |     * Set private data pointer.
 2287|       |     */
 2288|      0|    data->set.private_data = va_arg(param, void *);
 2289|      0|    break;
 2290|       |
 2291|      0|  case CURLOPT_MAXFILESIZE:
 2292|       |    /*
 2293|       |     * Set the maximum size of a file to download.
 2294|       |     */
 2295|      0|    arg = va_arg(param, long);
 2296|      0|    if(arg < 0)
 2297|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2298|      0|    data->set.max_filesize = arg;
 2299|      0|    break;
 2300|       |
 2301|      0|#ifdef USE_SSL
 2302|      0|  case CURLOPT_USE_SSL:
 2303|       |    /*
 2304|       |     * Make transfers attempt to use SSL/TLS.
 2305|       |     */
 2306|      0|    arg = va_arg(param, long);
 2307|      0|    if((arg < CURLUSESSL_NONE) || (arg >= CURLUSESSL_LAST))
 2308|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2309|      0|    data->set.use_ssl = (curl_usessl)arg;
 2310|      0|    break;
 2311|       |
 2312|      0|  case CURLOPT_SSL_OPTIONS:
 2313|      0|    arg = va_arg(param, long);
 2314|      0|    data->set.ssl.enable_beast = !!(arg & CURLSSLOPT_ALLOW_BEAST);
 2315|      0|    data->set.ssl.no_revoke = !!(arg & CURLSSLOPT_NO_REVOKE);
 2316|      0|    data->set.ssl.no_partialchain = !!(arg & CURLSSLOPT_NO_PARTIALCHAIN);
 2317|      0|    data->set.ssl.revoke_best_effort = !!(arg & CURLSSLOPT_REVOKE_BEST_EFFORT);
 2318|      0|    data->set.ssl.native_ca_store = !!(arg & CURLSSLOPT_NATIVE_CA);
 2319|      0|    data->set.ssl.auto_client_cert = !!(arg & CURLSSLOPT_AUTO_CLIENT_CERT);
 2320|       |    /* If a setting is added here it should also be added in dohprobe()
 2321|       |       which sets its own CURLOPT_SSL_OPTIONS based on these settings. */
 2322|      0|    break;
 2323|       |
 2324|      0|#ifndef CURL_DISABLE_PROXY
 2325|      0|  case CURLOPT_PROXY_SSL_OPTIONS:
 2326|      0|    arg = va_arg(param, long);
 2327|      0|    data->set.proxy_ssl.enable_beast = !!(arg & CURLSSLOPT_ALLOW_BEAST);
 2328|      0|    data->set.proxy_ssl.no_revoke = !!(arg & CURLSSLOPT_NO_REVOKE);
 2329|      0|    data->set.proxy_ssl.no_partialchain = !!(arg & CURLSSLOPT_NO_PARTIALCHAIN);
 2330|      0|    data->set.proxy_ssl.revoke_best_effort =
 2331|      0|      !!(arg & CURLSSLOPT_REVOKE_BEST_EFFORT);
 2332|      0|    data->set.proxy_ssl.native_ca_store = !!(arg & CURLSSLOPT_NATIVE_CA);
 2333|      0|    data->set.proxy_ssl.auto_client_cert =
 2334|      0|      !!(arg & CURLSSLOPT_AUTO_CLIENT_CERT);
 2335|      0|    break;
 2336|      0|#endif
 2337|       |
 2338|      0|  case CURLOPT_SSL_EC_CURVES:
 2339|       |    /*
 2340|       |     * Set accepted curves in SSL connection setup.
 2341|       |     * Specify colon-delimited list of curve algorithm names.
 2342|       |     */
 2343|      0|    result = Curl_setstropt(&data->set.str[STRING_SSL_EC_CURVES],
 2344|      0|                            va_arg(param, char *));
 2345|      0|    break;
 2346|      0|#endif
 2347|      0|  case CURLOPT_IPRESOLVE:
 2348|      0|    arg = va_arg(param, long);
 2349|      0|    if((arg < CURL_IPRESOLVE_WHATEVER) || (arg > CURL_IPRESOLVE_V6))
 2350|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2351|      0|    data->set.ipver = (unsigned char) arg;
 2352|      0|    break;
 2353|       |
 2354|      0|  case CURLOPT_MAXFILESIZE_LARGE:
 2355|       |    /*
 2356|       |     * Set the maximum size of a file to download.
 2357|       |     */
 2358|      0|    bigsize = va_arg(param, curl_off_t);
 2359|      0|    if(bigsize < 0)
 2360|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2361|      0|    data->set.max_filesize = bigsize;
 2362|      0|    break;
 2363|       |
 2364|      0|  case CURLOPT_TCP_NODELAY:
 2365|       |    /*
 2366|       |     * Enable or disable TCP_NODELAY, which will disable/enable the Nagle
 2367|       |     * algorithm
 2368|       |     */
 2369|      0|    data->set.tcp_nodelay = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2370|      0|    break;
 2371|       |
 2372|      0|  case CURLOPT_IGNORE_CONTENT_LENGTH:
 2373|      0|    data->set.ignorecl = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2374|      0|    break;
 2375|       |
 2376|      0|  case CURLOPT_CONNECT_ONLY:
 2377|       |    /*
 2378|       |     * No data transfer, set up connection and let application use the socket
 2379|       |     */
 2380|      0|    data->set.connect_only = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2381|      0|    break;
 2382|       |
 2383|    462|  case CURLOPT_SOCKOPTFUNCTION:
 2384|       |    /*
 2385|       |     * socket callback function: called after socket() but before connect()
 2386|       |     */
 2387|    462|    data->set.fsockopt = va_arg(param, curl_sockopt_callback);
 2388|    462|    break;
 2389|       |
 2390|      0|  case CURLOPT_SOCKOPTDATA:
 2391|       |    /*
 2392|       |     * socket callback data pointer. Might be NULL.
 2393|       |     */
 2394|      0|    data->set.sockopt_client = va_arg(param, void *);
 2395|      0|    break;
 2396|       |
 2397|    462|  case CURLOPT_OPENSOCKETFUNCTION:
 2398|       |    /*
 2399|       |     * open/create socket callback function: called instead of socket(),
 2400|       |     * before connect()
 2401|       |     */
 2402|    462|    data->set.fopensocket = va_arg(param, curl_opensocket_callback);
 2403|    462|    break;
 2404|       |
 2405|    462|  case CURLOPT_OPENSOCKETDATA:
 2406|       |    /*
 2407|       |     * socket callback data pointer. Might be NULL.
 2408|       |     */
 2409|    462|    data->set.opensocket_client = va_arg(param, void *);
 2410|    462|    break;
 2411|       |
 2412|      0|  case CURLOPT_CLOSESOCKETFUNCTION:
 2413|       |    /*
 2414|       |     * close socket callback function: called instead of close()
 2415|       |     * when shutting down a connection
 2416|       |     */
 2417|      0|    data->set.fclosesocket = va_arg(param, curl_closesocket_callback);
 2418|      0|    break;
 2419|       |
 2420|      0|  case CURLOPT_RESOLVER_START_FUNCTION:
 2421|       |    /*
 2422|       |     * resolver start callback function: called before a new resolver request
 2423|       |     * is started
 2424|       |     */
 2425|      0|    data->set.resolver_start = va_arg(param, curl_resolver_start_callback);
 2426|      0|    break;
 2427|       |
 2428|      0|  case CURLOPT_RESOLVER_START_DATA:
 2429|       |    /*
 2430|       |     * resolver start callback data pointer. Might be NULL.
 2431|       |     */
 2432|      0|    data->set.resolver_start_client = va_arg(param, void *);
 2433|      0|    break;
 2434|       |
 2435|      0|  case CURLOPT_CLOSESOCKETDATA:
 2436|       |    /*
 2437|       |     * socket callback data pointer. Might be NULL.
 2438|       |     */
 2439|      0|    data->set.closesocket_client = va_arg(param, void *);
 2440|      0|    break;
 2441|       |
 2442|      0|  case CURLOPT_SSL_SESSIONID_CACHE:
 2443|      0|    data->set.ssl.primary.sessionid = (0 != va_arg(param, long)) ?
 2444|      0|      TRUE : FALSE;
 2445|      0|#ifndef CURL_DISABLE_PROXY
 2446|      0|    data->set.proxy_ssl.primary.sessionid = data->set.ssl.primary.sessionid;
 2447|      0|#endif
 2448|      0|    break;
 2449|       |
 2450|       |#ifdef USE_SSH
 2451|       |    /* we only include SSH options if explicitly built to support SSH */
 2452|       |  case CURLOPT_SSH_AUTH_TYPES:
 2453|       |    data->set.ssh_auth_types = va_arg(param, long);
 2454|       |    break;
 2455|       |
 2456|       |  case CURLOPT_SSH_PUBLIC_KEYFILE:
 2457|       |    /*
 2458|       |     * Use this file instead of the $HOME/.ssh/id_dsa.pub file
 2459|       |     */
 2460|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_PUBLIC_KEY],
 2461|       |                            va_arg(param, char *));
 2462|       |    break;
 2463|       |
 2464|       |  case CURLOPT_SSH_PRIVATE_KEYFILE:
 2465|       |    /*
 2466|       |     * Use this file instead of the $HOME/.ssh/id_dsa file
 2467|       |     */
 2468|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_PRIVATE_KEY],
 2469|       |                            va_arg(param, char *));
 2470|       |    break;
 2471|       |  case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
 2472|       |    /*
 2473|       |     * Option to allow for the MD5 of the host public key to be checked
 2474|       |     * for validation purposes.
 2475|       |     */
 2476|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5],
 2477|       |                            va_arg(param, char *));
 2478|       |    break;
 2479|       |
 2480|       |  case CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256:
 2481|       |    /*
 2482|       |     * Option to allow for the SHA256 of the host public key to be checked
 2483|       |     * for validation purposes.
 2484|       |     */
 2485|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_HOST_PUBLIC_KEY_SHA256],
 2486|       |                            va_arg(param, char *));
 2487|       |    break;
 2488|       |
 2489|       |  case CURLOPT_SSH_KNOWNHOSTS:
 2490|       |    /*
 2491|       |     * Store the file name to read known hosts from.
 2492|       |     */
 2493|       |    result = Curl_setstropt(&data->set.str[STRING_SSH_KNOWNHOSTS],
 2494|       |                            va_arg(param, char *));
 2495|       |    break;
 2496|       |
 2497|       |  case CURLOPT_SSH_KEYFUNCTION:
 2498|       |    /* setting to NULL is fine since the ssh.c functions themselves will
 2499|       |       then revert to use the internal default */
 2500|       |    data->set.ssh_keyfunc = va_arg(param, curl_sshkeycallback);
 2501|       |    break;
 2502|       |
 2503|       |  case CURLOPT_SSH_KEYDATA:
 2504|       |    /*
 2505|       |     * Custom client data to pass to the SSH keyfunc callback
 2506|       |     */
 2507|       |    data->set.ssh_keyfunc_userp = va_arg(param, void *);
 2508|       |    break;
 2509|       |
 2510|       |  case CURLOPT_SSH_COMPRESSION:
 2511|       |    data->set.ssh_compression = (0 != va_arg(param, long))?TRUE:FALSE;
 2512|       |    break;
 2513|       |#endif /* USE_SSH */
 2514|       |
 2515|      0|  case CURLOPT_HTTP_TRANSFER_DECODING:
 2516|       |    /*
 2517|       |     * disable libcurl transfer encoding is used
 2518|       |     */
 2519|      0|#ifndef USE_HYPER
 2520|      0|    data->set.http_te_skip = (0 == va_arg(param, long)) ? TRUE : FALSE;
 2521|      0|    break;
 2522|       |#else
 2523|       |    return CURLE_NOT_BUILT_IN; /* hyper doesn't support */
 2524|       |#endif
 2525|       |
 2526|      0|  case CURLOPT_HTTP_CONTENT_DECODING:
 2527|       |    /*
 2528|       |     * raw data passed to the application when content encoding is used
 2529|       |     */
 2530|      0|    data->set.http_ce_skip = (0 == va_arg(param, long)) ? TRUE : FALSE;
 2531|      0|    break;
 2532|       |
 2533|      0|#if !defined(CURL_DISABLE_FTP) || defined(USE_SSH)
 2534|      0|  case CURLOPT_NEW_FILE_PERMS:
 2535|       |    /*
 2536|       |     * Uses these permissions instead of 0644
 2537|       |     */
 2538|      0|    arg = va_arg(param, long);
 2539|      0|    if((arg < 0) || (arg > 0777))
 2540|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2541|      0|    data->set.new_file_perms = arg;
 2542|      0|    break;
 2543|       |
 2544|      0|  case CURLOPT_NEW_DIRECTORY_PERMS:
 2545|       |    /*
 2546|       |     * Uses these permissions instead of 0755
 2547|       |     */
 2548|      0|    arg = va_arg(param, long);
 2549|      0|    if((arg < 0) || (arg > 0777))
 2550|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2551|      0|    data->set.new_directory_perms = arg;
 2552|      0|    break;
 2553|      0|#endif
 2554|       |
 2555|      0|  case CURLOPT_ADDRESS_SCOPE:
 2556|       |    /*
 2557|       |     * Use this scope id when using IPv6
 2558|       |     * We always get longs when passed plain numericals so we should check
 2559|       |     * that the value fits into an unsigned 32 bit integer.
 2560|       |     */
 2561|      0|    uarg = va_arg(param, unsigned long);
 2562|      0|#if SIZEOF_LONG > 4
 2563|      0|    if(uarg > UINT_MAX)
 2564|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2565|      0|#endif
 2566|      0|    data->set.scope_id = (unsigned int)uarg;
 2567|      0|    break;
 2568|       |
 2569|    462|  case CURLOPT_PROTOCOLS:
 2570|       |    /* set the bitmask for the protocols that are allowed to be used for the
 2571|       |       transfer, which thus helps the app which takes URLs from users or other
 2572|       |       external inputs and want to restrict what protocol(s) to deal
 2573|       |       with. Defaults to CURLPROTO_ALL. */
 2574|    462|    data->set.allowed_protocols = va_arg(param, long);
 2575|    462|    break;
 2576|       |
 2577|      0|  case CURLOPT_REDIR_PROTOCOLS:
 2578|       |    /* set the bitmask for the protocols that libcurl is allowed to follow to,
 2579|       |       as a subset of the CURLOPT_PROTOCOLS ones. That means the protocol needs
 2580|       |       to be set in both bitmasks to be allowed to get redirected to. */
 2581|      0|    data->set.redir_protocols = va_arg(param, long);
 2582|      0|    break;
 2583|       |
 2584|      0|  case CURLOPT_DEFAULT_PROTOCOL:
 2585|       |    /* Set the protocol to use when the URL doesn't include any protocol */
 2586|      0|    result = Curl_setstropt(&data->set.str[STRING_DEFAULT_PROTOCOL],
 2587|      0|                            va_arg(param, char *));
 2588|      0|    break;
 2589|      0|#ifndef CURL_DISABLE_SMTP
 2590|      9|  case CURLOPT_MAIL_FROM:
 2591|       |    /* Set the SMTP mail originator */
 2592|      9|    result = Curl_setstropt(&data->set.str[STRING_MAIL_FROM],
 2593|      9|                            va_arg(param, char *));
 2594|      9|    break;
 2595|       |
 2596|      2|  case CURLOPT_MAIL_AUTH:
 2597|       |    /* Set the SMTP auth originator */
 2598|      2|    result = Curl_setstropt(&data->set.str[STRING_MAIL_AUTH],
 2599|      2|                            va_arg(param, char *));
 2600|      2|    break;
 2601|       |
 2602|     27|  case CURLOPT_MAIL_RCPT:
 2603|       |    /* Set the list of mail recipients */
 2604|     27|    data->set.mail_rcpt = va_arg(param, struct curl_slist *);
 2605|     27|    break;
 2606|      0|  case CURLOPT_MAIL_RCPT_ALLLOWFAILS:
 2607|       |    /* allow RCPT TO command to fail for some recipients */
 2608|      0|    data->set.mail_rcpt_allowfails = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2609|      0|    break;
 2610|      0|#endif
 2611|       |
 2612|      0|  case CURLOPT_SASL_AUTHZID:
 2613|       |    /* Authorisation identity (identity to act as) */
 2614|      0|    result = Curl_setstropt(&data->set.str[STRING_SASL_AUTHZID],
 2615|      0|                            va_arg(param, char *));
 2616|      0|    break;
 2617|       |
 2618|      0|  case CURLOPT_SASL_IR:
 2619|       |    /* Enable/disable SASL initial response */
 2620|      0|    data->set.sasl_ir = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2621|      0|    break;
 2622|      0|#ifndef CURL_DISABLE_RTSP
 2623|      3|  case CURLOPT_RTSP_REQUEST:
 2624|      3|  {
 2625|       |    /*
 2626|       |     * Set the RTSP request method (OPTIONS, SETUP, PLAY, etc...)
 2627|       |     * Would this be better if the RTSPREQ_* were just moved into here?
 2628|       |     */
 2629|      3|    long in_rtspreq = va_arg(param, long);
 2630|      3|    Curl_RtspReq rtspreq = RTSPREQ_NONE;
 2631|      3|    switch(in_rtspreq) {
 2632|      0|    case CURL_RTSPREQ_OPTIONS:
 2633|      0|      rtspreq = RTSPREQ_OPTIONS;
 2634|      0|      break;
 2635|       |
 2636|      0|    case CURL_RTSPREQ_DESCRIBE:
 2637|      0|      rtspreq = RTSPREQ_DESCRIBE;
 2638|      0|      break;
 2639|       |
 2640|      0|    case CURL_RTSPREQ_ANNOUNCE:
 2641|      0|      rtspreq = RTSPREQ_ANNOUNCE;
 2642|      0|      break;
 2643|       |
 2644|      1|    case CURL_RTSPREQ_SETUP:
 2645|      1|      rtspreq = RTSPREQ_SETUP;
 2646|      1|      break;
 2647|       |
 2648|      0|    case CURL_RTSPREQ_PLAY:
 2649|      0|      rtspreq = RTSPREQ_PLAY;
 2650|      0|      break;
 2651|       |
 2652|      0|    case CURL_RTSPREQ_PAUSE:
 2653|      0|      rtspreq = RTSPREQ_PAUSE;
 2654|      0|      break;
 2655|       |
 2656|      0|    case CURL_RTSPREQ_TEARDOWN:
 2657|      0|      rtspreq = RTSPREQ_TEARDOWN;
 2658|      0|      break;
 2659|       |
 2660|      0|    case CURL_RTSPREQ_GET_PARAMETER:
 2661|      0|      rtspreq = RTSPREQ_GET_PARAMETER;
 2662|      0|      break;
 2663|       |
 2664|      0|    case CURL_RTSPREQ_SET_PARAMETER:
 2665|      0|      rtspreq = RTSPREQ_SET_PARAMETER;
 2666|      0|      break;
 2667|       |
 2668|      0|    case CURL_RTSPREQ_RECORD:
 2669|      0|      rtspreq = RTSPREQ_RECORD;
 2670|      0|      break;
 2671|       |
 2672|      0|    case CURL_RTSPREQ_RECEIVE:
 2673|      0|      rtspreq = RTSPREQ_RECEIVE;
 2674|      0|      break;
 2675|      2|    default:
 2676|      2|      rtspreq = RTSPREQ_NONE;
 2677|      3|    }
 2678|       |
 2679|      3|    data->set.rtspreq = rtspreq;
 2680|      3|    break;
 2681|      3|  }
 2682|       |
 2683|       |
 2684|      2|  case CURLOPT_RTSP_SESSION_ID:
 2685|       |    /*
 2686|       |     * Set the RTSP Session ID manually. Useful if the application is
 2687|       |     * resuming a previously established RTSP session
 2688|       |     */
 2689|      2|    result = Curl_setstropt(&data->set.str[STRING_RTSP_SESSION_ID],
 2690|      2|                            va_arg(param, char *));
 2691|      2|    break;
 2692|       |
 2693|      4|  case CURLOPT_RTSP_STREAM_URI:
 2694|       |    /*
 2695|       |     * Set the Stream URI for the RTSP request. Unless the request is
 2696|       |     * for generic server options, the application will need to set this.
 2697|       |     */
 2698|      4|    result = Curl_setstropt(&data->set.str[STRING_RTSP_STREAM_URI],
 2699|      4|                            va_arg(param, char *));
 2700|      4|    break;
 2701|       |
 2702|      2|  case CURLOPT_RTSP_TRANSPORT:
 2703|       |    /*
 2704|       |     * The content of the Transport: header for the RTSP request
 2705|       |     */
 2706|      2|    result = Curl_setstropt(&data->set.str[STRING_RTSP_TRANSPORT],
 2707|      2|                            va_arg(param, char *));
 2708|      2|    break;
 2709|       |
 2710|      2|  case CURLOPT_RTSP_CLIENT_CSEQ:
 2711|       |    /*
 2712|       |     * Set the CSEQ number to issue for the next RTSP request. Useful if the
 2713|       |     * application is resuming a previously broken connection. The CSEQ
 2714|       |     * will increment from this new number henceforth.
 2715|       |     */
 2716|      2|    data->state.rtsp_next_client_CSeq = va_arg(param, long);
 2717|      2|    break;
 2718|       |
 2719|      0|  case CURLOPT_RTSP_SERVER_CSEQ:
 2720|       |    /* Same as the above, but for server-initiated requests */
 2721|      0|    data->state.rtsp_next_server_CSeq = va_arg(param, long);
 2722|      0|    break;
 2723|       |
 2724|      0|  case CURLOPT_INTERLEAVEDATA:
 2725|      0|    data->set.rtp_out = va_arg(param, void *);
 2726|      0|    break;
 2727|      0|  case CURLOPT_INTERLEAVEFUNCTION:
 2728|       |    /* Set the user defined RTP write function */
 2729|      0|    data->set.fwrite_rtp = va_arg(param, curl_write_callback);
 2730|      0|    break;
 2731|      0|#endif
 2732|      0|#ifndef CURL_DISABLE_FTP
 2733|      3|  case CURLOPT_WILDCARDMATCH:
 2734|      3|    data->set.wildcard_enabled = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2735|      3|    break;
 2736|      0|  case CURLOPT_CHUNK_BGN_FUNCTION:
 2737|      0|    data->set.chunk_bgn = va_arg(param, curl_chunk_bgn_callback);
 2738|      0|    break;
 2739|      0|  case CURLOPT_CHUNK_END_FUNCTION:
 2740|      0|    data->set.chunk_end = va_arg(param, curl_chunk_end_callback);
 2741|      0|    break;
 2742|      0|  case CURLOPT_FNMATCH_FUNCTION:
 2743|      0|    data->set.fnmatch = va_arg(param, curl_fnmatch_callback);
 2744|      0|    break;
 2745|      0|  case CURLOPT_CHUNK_DATA:
 2746|      0|    data->wildcard.customptr = va_arg(param, void *);
 2747|      0|    break;
 2748|      0|  case CURLOPT_FNMATCH_DATA:
 2749|      0|    data->set.fnmatch_data = va_arg(param, void *);
 2750|      0|    break;
 2751|      0|#endif
 2752|      0|#ifdef USE_TLS_SRP
 2753|      0|  case CURLOPT_TLSAUTH_USERNAME:
 2754|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_USERNAME],
 2755|      0|                            va_arg(param, char *));
 2756|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME] && !data->set.ssl.authtype)
 2757|      0|      data->set.ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2758|      0|    break;
 2759|      0|  case CURLOPT_PROXY_TLSAUTH_USERNAME:
 2760|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_USERNAME_PROXY],
 2761|      0|                            va_arg(param, char *));
 2762|      0|#ifndef CURL_DISABLE_PROXY
 2763|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME_PROXY] &&
 2764|      0|       !data->set.proxy_ssl.authtype)
 2765|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2766|      0|#endif
 2767|      0|    break;
 2768|      0|  case CURLOPT_TLSAUTH_PASSWORD:
 2769|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_PASSWORD],
 2770|      0|                            va_arg(param, char *));
 2771|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME] && !data->set.ssl.authtype)
 2772|      0|      data->set.ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2773|      0|    break;
 2774|      0|  case CURLOPT_PROXY_TLSAUTH_PASSWORD:
 2775|      0|    result = Curl_setstropt(&data->set.str[STRING_TLSAUTH_PASSWORD_PROXY],
 2776|      0|                            va_arg(param, char *));
 2777|      0|#ifndef CURL_DISABLE_PROXY
 2778|      0|    if(data->set.str[STRING_TLSAUTH_USERNAME_PROXY] &&
 2779|      0|       !data->set.proxy_ssl.authtype)
 2780|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_SRP; /* default to SRP */
 2781|      0|#endif
 2782|      0|    break;
 2783|      0|  case CURLOPT_TLSAUTH_TYPE:
 2784|      0|    argptr = va_arg(param, char *);
 2785|      0|    if(!argptr ||
 2786|      0|       strncasecompare(argptr, "SRP", strlen("SRP")))
 2787|      0|      data->set.ssl.authtype = CURL_TLSAUTH_SRP;
 2788|      0|    else
 2789|      0|      data->set.ssl.authtype = CURL_TLSAUTH_NONE;
 2790|      0|    break;
 2791|      0|#ifndef CURL_DISABLE_PROXY
 2792|      0|  case CURLOPT_PROXY_TLSAUTH_TYPE:
 2793|      0|    argptr = va_arg(param, char *);
 2794|      0|    if(!argptr ||
 2795|      0|       strncasecompare(argptr, "SRP", strlen("SRP")))
 2796|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_SRP;
 2797|      0|    else
 2798|      0|      data->set.proxy_ssl.authtype = CURL_TLSAUTH_NONE;
 2799|      0|    break;
 2800|      0|#endif
 2801|      0|#endif
 2802|       |#ifdef USE_ARES
 2803|       |  case CURLOPT_DNS_SERVERS:
 2804|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_SERVERS],
 2805|       |                            va_arg(param, char *));
 2806|       |    if(result)
 2807|       |      return result;
 2808|       |    result = Curl_set_dns_servers(data, data->set.str[STRING_DNS_SERVERS]);
 2809|       |    break;
 2810|       |  case CURLOPT_DNS_INTERFACE:
 2811|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_INTERFACE],
 2812|       |                            va_arg(param, char *));
 2813|       |    if(result)
 2814|       |      return result;
 2815|       |    result = Curl_set_dns_interface(data, data->set.str[STRING_DNS_INTERFACE]);
 2816|       |    break;
 2817|       |  case CURLOPT_DNS_LOCAL_IP4:
 2818|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_LOCAL_IP4],
 2819|       |                            va_arg(param, char *));
 2820|       |    if(result)
 2821|       |      return result;
 2822|       |    result = Curl_set_dns_local_ip4(data, data->set.str[STRING_DNS_LOCAL_IP4]);
 2823|       |    break;
 2824|       |  case CURLOPT_DNS_LOCAL_IP6:
 2825|       |    result = Curl_setstropt(&data->set.str[STRING_DNS_LOCAL_IP6],
 2826|       |                            va_arg(param, char *));
 2827|       |    if(result)
 2828|       |      return result;
 2829|       |    result = Curl_set_dns_local_ip6(data, data->set.str[STRING_DNS_LOCAL_IP6]);
 2830|       |    break;
 2831|       |#endif
 2832|      0|  case CURLOPT_TCP_KEEPALIVE:
 2833|      0|    data->set.tcp_keepalive = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2834|      0|    break;
 2835|      0|  case CURLOPT_TCP_KEEPIDLE:
 2836|      0|    arg = va_arg(param, long);
 2837|      0|    if(arg < 0)
 2838|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2839|      0|    data->set.tcp_keepidle = arg;
 2840|      0|    break;
 2841|      0|  case CURLOPT_TCP_KEEPINTVL:
 2842|      0|    arg = va_arg(param, long);
 2843|      0|    if(arg < 0)
 2844|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2845|      0|    data->set.tcp_keepintvl = arg;
 2846|      0|    break;
 2847|      0|  case CURLOPT_TCP_FASTOPEN:
 2848|      0|#if defined(CONNECT_DATA_IDEMPOTENT) || defined(MSG_FASTOPEN) || \
 2849|      0|   defined(TCP_FASTOPEN_CONNECT)
 2850|      0|    data->set.tcp_fastopen = (0 != va_arg(param, long))?TRUE:FALSE;
 2851|       |#else
 2852|       |    result = CURLE_NOT_BUILT_IN;
 2853|       |#endif
 2854|      0|    break;
 2855|      0|  case CURLOPT_SSL_ENABLE_NPN:
 2856|      0|    data->set.ssl_enable_npn = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2857|      0|    break;
 2858|      0|  case CURLOPT_SSL_ENABLE_ALPN:
 2859|      0|    data->set.ssl_enable_alpn = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2860|      0|    break;
 2861|      0|#ifdef USE_UNIX_SOCKETS
 2862|      0|  case CURLOPT_UNIX_SOCKET_PATH:
 2863|      0|    data->set.abstract_unix_socket = FALSE;
 2864|      0|    result = Curl_setstropt(&data->set.str[STRING_UNIX_SOCKET_PATH],
 2865|      0|                            va_arg(param, char *));
 2866|      0|    break;
 2867|      0|  case CURLOPT_ABSTRACT_UNIX_SOCKET:
 2868|      0|    data->set.abstract_unix_socket = TRUE;
 2869|      0|    result = Curl_setstropt(&data->set.str[STRING_UNIX_SOCKET_PATH],
 2870|      0|                            va_arg(param, char *));
 2871|      0|    break;
 2872|      0|#endif
 2873|       |
 2874|      0|  case CURLOPT_PATH_AS_IS:
 2875|      0|    data->set.path_as_is = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2876|      0|    break;
 2877|      0|  case CURLOPT_PIPEWAIT:
 2878|      0|    data->set.pipewait = (0 != va_arg(param, long)) ? TRUE : FALSE;
 2879|      0|    break;
 2880|      0|  case CURLOPT_STREAM_WEIGHT:
 2881|       |#ifndef USE_NGHTTP2
 2882|       |    return CURLE_NOT_BUILT_IN;
 2883|       |#else
 2884|      0|    arg = va_arg(param, long);
 2885|      0|    if((arg >= 1) && (arg <= 256))
 2886|      0|      data->set.stream_weight = (int)arg;
 2887|      0|    break;
 2888|      0|#endif
 2889|      0|  case CURLOPT_STREAM_DEPENDS:
 2890|      0|  case CURLOPT_STREAM_DEPENDS_E:
 2891|      0|  {
 2892|       |#ifndef USE_NGHTTP2
 2893|       |    return CURLE_NOT_BUILT_IN;
 2894|       |#else
 2895|      0|    struct Curl_easy *dep = va_arg(param, struct Curl_easy *);
 2896|      0|    if(!dep || GOOD_EASY_HANDLE(dep)) {
 2897|      0|      if(data->set.stream_depends_on) {
 2898|      0|        Curl_http2_remove_child(data->set.stream_depends_on, data);
 2899|      0|      }
 2900|      0|      Curl_http2_add_child(dep, data, (option == CURLOPT_STREAM_DEPENDS_E));
 2901|      0|    }
 2902|      0|    break;
 2903|      0|#endif
 2904|      0|  }
 2905|    462|  case CURLOPT_CONNECT_TO:
 2906|    462|    data->set.connect_to = va_arg(param, struct curl_slist *);
 2907|    462|    break;
 2908|      0|  case CURLOPT_SUPPRESS_CONNECT_HEADERS:
 2909|      0|    data->set.suppress_connect_headers = (0 != va_arg(param, long))?TRUE:FALSE;
 2910|      0|    break;
 2911|      0|  case CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS:
 2912|      0|    arg = va_arg(param, long);
 2913|      0|    if(arg < 0)
 2914|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2915|      0|    data->set.happy_eyeballs_timeout = arg;
 2916|      0|    break;
 2917|      0|#ifndef CURL_DISABLE_SHUFFLE_DNS
 2918|      0|  case CURLOPT_DNS_SHUFFLE_ADDRESSES:
 2919|      0|    data->set.dns_shuffle_addresses = (0 != va_arg(param, long)) ? TRUE:FALSE;
 2920|      0|    break;
 2921|      0|#endif
 2922|      0|  case CURLOPT_DISALLOW_USERNAME_IN_URL:
 2923|      0|    data->set.disallow_username_in_url =
 2924|      0|      (0 != va_arg(param, long)) ? TRUE : FALSE;
 2925|      0|    break;
 2926|      0|#ifndef CURL_DISABLE_DOH
 2927|      2|  case CURLOPT_DOH_URL:
 2928|      2|    result = Curl_setstropt(&data->set.str[STRING_DOH],
 2929|      2|                            va_arg(param, char *));
 2930|      2|    data->set.doh = data->set.str[STRING_DOH]?TRUE:FALSE;
 2931|      2|    break;
 2932|      0|#endif
 2933|      0|  case CURLOPT_UPKEEP_INTERVAL_MS:
 2934|      0|    arg = va_arg(param, long);
 2935|      0|    if(arg < 0)
 2936|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2937|      0|    data->set.upkeep_interval_ms = arg;
 2938|      0|    break;
 2939|      0|  case CURLOPT_MAXAGE_CONN:
 2940|      0|    arg = va_arg(param, long);
 2941|      0|    if(arg < 0)
 2942|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2943|      0|    data->set.maxage_conn = arg;
 2944|      0|    break;
 2945|      0|  case CURLOPT_MAXLIFETIME_CONN:
 2946|      0|    arg = va_arg(param, long);
 2947|      0|    if(arg < 0)
 2948|      0|      return CURLE_BAD_FUNCTION_ARGUMENT;
 2949|      0|    data->set.maxlifetime_conn = arg;
 2950|      0|    break;
 2951|      0|  case CURLOPT_TRAILERFUNCTION:
 2952|      0|#ifndef CURL_DISABLE_HTTP
 2953|      0|    data->set.trailer_callback = va_arg(param, curl_trailer_callback);
 2954|      0|#endif
 2955|      0|    break;
 2956|      0|  case CURLOPT_TRAILERDATA:
 2957|      0|#ifndef CURL_DISABLE_HTTP
 2958|      0|    data->set.trailer_data = va_arg(param, void *);
 2959|      0|#endif
 2960|      0|    break;
 2961|      0|#ifndef CURL_DISABLE_HSTS
 2962|      0|  case CURLOPT_HSTSREADFUNCTION:
 2963|      0|    data->set.hsts_read = va_arg(param, curl_hstsread_callback);
 2964|      0|    break;
 2965|      0|  case CURLOPT_HSTSREADDATA:
 2966|      0|    data->set.hsts_read_userp = va_arg(param, void *);
 2967|      0|    break;
 2968|      0|  case CURLOPT_HSTSWRITEFUNCTION:
 2969|      0|    data->set.hsts_write = va_arg(param, curl_hstswrite_callback);
 2970|      0|    break;
 2971|      0|  case CURLOPT_HSTSWRITEDATA:
 2972|      0|    data->set.hsts_write_userp = va_arg(param, void *);
 2973|      0|    break;
 2974|      0|  case CURLOPT_HSTS:
 2975|      0|    if(!data->hsts) {
 2976|      0|      data->hsts = Curl_hsts_init();
 2977|      0|      if(!data->hsts)
 2978|      0|        return CURLE_OUT_OF_MEMORY;
 2979|      0|    }
 2980|      0|    argptr = va_arg(param, char *);
 2981|      0|    result = Curl_setstropt(&data->set.str[STRING_HSTS], argptr);
 2982|      0|    if(result)
 2983|      0|      return result;
 2984|      0|    if(argptr)
 2985|      0|      (void)Curl_hsts_loadfile(data, data->hsts, argptr);
 2986|      0|    break;
 2987|      0|  case CURLOPT_HSTS_CTRL:
 2988|      0|    arg = va_arg(param, long);
 2989|      0|    if(arg & CURLHSTS_ENABLE) {
 2990|      0|      if(!data->hsts) {
 2991|      0|        data->hsts = Curl_hsts_init();
 2992|      0|        if(!data->hsts)
 2993|      0|          return CURLE_OUT_OF_MEMORY;
 2994|      0|      }
 2995|      0|    }
 2996|      0|    else
 2997|      0|      Curl_hsts_cleanup(&data->hsts);
 2998|      0|    break;
 2999|      0|#endif
 3000|      0|#ifndef CURL_DISABLE_ALTSVC
 3001|      0|  case CURLOPT_ALTSVC:
 3002|      0|    if(!data->asi) {
 3003|      0|      data->asi = Curl_altsvc_init();
 3004|      0|      if(!data->asi)
 3005|      0|        return CURLE_OUT_OF_MEMORY;
 3006|      0|    }
 3007|      0|    argptr = va_arg(param, char *);
 3008|      0|    result = Curl_setstropt(&data->set.str[STRING_ALTSVC], argptr);
 3009|      0|    if(result)
 3010|      0|      return result;
 3011|      0|    if(argptr)
 3012|      0|      (void)Curl_altsvc_load(data->asi, argptr);
 3013|      0|    break;
 3014|      0|  case CURLOPT_ALTSVC_CTRL:
 3015|      0|    if(!data->asi) {
 3016|      0|      data->asi = Curl_altsvc_init();
 3017|      0|      if(!data->asi)
 3018|      0|        return CURLE_OUT_OF_MEMORY;
 3019|      0|    }
 3020|      0|    arg = va_arg(param, long);
 3021|      0|    result = Curl_altsvc_ctrl(data->asi, arg);
 3022|      0|    if(result)
 3023|      0|      return result;
 3024|      0|    break;
 3025|      0|#endif
 3026|      0|  case CURLOPT_PREREQFUNCTION:
 3027|      0|    data->set.fprereq = va_arg(param, curl_prereq_callback);
 3028|      0|    break;
 3029|      0|  case CURLOPT_PREREQDATA:
 3030|      0|    data->set.prereq_userp = va_arg(param, void *);
 3031|      0|    break;
 3032|      0|  default:
 3033|       |    /* unknown tag and its companion, just ignore: */
 3034|      0|    result = CURLE_UNKNOWN_OPTION;
 3035|      0|    break;
 3036|  6.00k|  }
 3037|       |
 3038|  6.00k|  return result;
 3039|  6.00k|}
curl_easy_setopt:
 3051|  6.00k|{
 3052|  6.00k|  va_list arg;
 3053|  6.00k|  CURLcode result;
 3054|       |
 3055|  6.00k|  if(!data)
 3056|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 3057|       |
 3058|  6.00k|  va_start(arg, tag);
 3059|       |
 3060|  6.00k|  result = Curl_vsetopt(data, tag, arg);
 3061|       |
 3062|  6.00k|  va_end(arg);
 3063|  6.00k|  return result;
 3064|  6.00k|}

Curl_share_lock:
  235|  1.05k|{
  236|  1.05k|  struct Curl_share *share = data->share;
  237|       |
  238|  1.05k|  if(!share)
  239|  1.05k|    return CURLSHE_INVALID;
  240|       |
  241|      0|  if(share->specifier & (1<<type)) {
  242|      0|    if(share->lockfunc) /* only call this if set! */
  243|      0|      share->lockfunc(data, type, accesstype, share->clientdata);
  244|      0|  }
  245|       |  /* else if we don't share this, pretend successful lock */
  246|       |
  247|      0|  return CURLSHE_OK;
  248|  1.05k|}
Curl_share_unlock:
  252|  1.05k|{
  253|  1.05k|  struct Curl_share *share = data->share;
  254|       |
  255|  1.05k|  if(!share)
  256|  1.05k|    return CURLSHE_INVALID;
  257|       |
  258|      0|  if(share->specifier & (1<<type)) {
  259|      0|    if(share->unlockfunc) /* only call this if set! */
  260|      0|      share->unlockfunc (data, type, share->clientdata);
  261|      0|  }
  262|       |
  263|      0|  return CURLSHE_OK;
  264|  1.05k|}

Curl_slist_append_nodup:
   60|  2.01k|{
   61|  2.01k|  struct curl_slist     *last;
   62|  2.01k|  struct curl_slist     *new_item;
   63|       |
   64|  2.01k|  DEBUGASSERT(data);
   65|       |
   66|  2.01k|  new_item = malloc(sizeof(struct curl_slist));
   67|  2.01k|  if(!new_item)
   68|      0|    return NULL;
   69|       |
   70|  2.01k|  new_item->next = NULL;
   71|  2.01k|  new_item->data = data;
   72|       |
   73|       |  /* if this is the first item, then new_item *is* the list */
   74|  2.01k|  if(!list)
   75|    524|    return new_item;
   76|       |
   77|  1.49k|  last = slist_get_last(list);
   78|  1.49k|  last->next = new_item;
   79|  1.49k|  return list;
   80|  2.01k|}
curl_slist_append:
   91|  2.01k|{
   92|  2.01k|  char *dupdata = strdup(data);
   93|       |
   94|  2.01k|  if(!dupdata)
   95|      0|    return NULL;
   96|       |
   97|  2.01k|  list = Curl_slist_append_nodup(list, dupdata);
   98|  2.01k|  if(!list)
   99|      0|    free(dupdata);
  100|       |
  101|  2.01k|  return list;
  102|  2.01k|}
curl_slist_free_all:
  130|  4.94k|{
  131|  4.94k|  struct curl_slist     *next;
  132|  4.94k|  struct curl_slist     *item;
  133|       |
  134|  4.94k|  if(!list)
  135|  4.42k|    return;
  136|       |
  137|    524|  item = list;
  138|  2.01k|  do {
  139|  2.01k|    next = item->next;
  140|  2.01k|    Curl_safefree(item->data);
  141|  2.01k|    free(item);
  142|  2.01k|    item = next;
  143|  2.01k|  } while(next);
  144|    524|}
slist.c:slist_get_last:
   35|  1.49k|{
   36|  1.49k|  struct curl_slist     *item;
   37|       |
   38|       |  /* if caller passed us a NULL, return now */
   39|  1.49k|  if(!list)
   40|      0|    return NULL;
   41|       |
   42|       |  /* loop through to find the last item */
   43|  1.49k|  item = list;
   44|  77.9k|  while(item->next) {
   45|  76.4k|    item = item->next;
   46|  76.4k|  }
   47|  1.49k|  return item;
   48|  1.49k|}

Curl_splay:
   42|    462|{
   43|    462|  struct Curl_tree N, *l, *r, *y;
   44|       |
   45|    462|  if(!t)
   46|      0|    return t;
   47|    462|  N.smaller = N.larger = NULL;
   48|    462|  l = r = &N;
   49|       |
   50|    462|  for(;;) {
   51|    462|    long comp = compare(i, t->key);
   52|    462|    if(comp < 0) {
   53|      0|      if(!t->smaller)
   54|      0|        break;
   55|      0|      if(compare(i, t->smaller->key) < 0) {
   56|      0|        y = t->smaller;                           /* rotate smaller */
   57|      0|        t->smaller = y->larger;
   58|      0|        y->larger = t;
   59|      0|        t = y;
   60|      0|        if(!t->smaller)
   61|      0|          break;
   62|      0|      }
   63|      0|      r->smaller = t;                               /* link smaller */
   64|      0|      r = t;
   65|      0|      t = t->smaller;
   66|      0|    }
   67|    462|    else if(comp > 0) {
   68|      0|      if(!t->larger)
   69|      0|        break;
   70|      0|      if(compare(i, t->larger->key) > 0) {
   71|      0|        y = t->larger;                          /* rotate larger */
   72|      0|        t->larger = y->smaller;
   73|      0|        y->smaller = t;
   74|      0|        t = y;
   75|      0|        if(!t->larger)
   76|      0|          break;
   77|      0|      }
   78|      0|      l->larger = t;                              /* link larger */
   79|      0|      l = t;
   80|      0|      t = t->larger;
   81|      0|    }
   82|    462|    else
   83|    462|      break;
   84|    462|  }
   85|       |
   86|    462|  l->larger = t->smaller;                                /* assemble */
   87|    462|  r->smaller = t->larger;
   88|    462|  t->smaller = N.larger;
   89|    462|  t->larger = N.smaller;
   90|       |
   91|    462|  return t;
   92|    462|}
Curl_splayinsert:
  102|    462|{
  103|    462|  static const struct curltime KEY_NOTUSED = {
  104|    462|    (time_t)-1, (unsigned int)-1
  105|    462|  }; /* will *NEVER* appear */
  106|       |
  107|    462|  if(!node)
  108|      0|    return t;
  109|       |
  110|    462|  if(t != NULL) {
  111|      0|    t = Curl_splay(i, t);
  112|      0|    if(compare(i, t->key) == 0) {
  113|       |      /* There already exists a node in the tree with the very same key. Build
  114|       |         a doubly-linked circular list of nodes. We add the new 'node' struct
  115|       |         to the end of this list. */
  116|       |
  117|      0|      node->key = KEY_NOTUSED; /* we set the key in the sub node to NOTUSED
  118|       |                                  to quickly identify this node as a subnode */
  119|      0|      node->samen = t;
  120|      0|      node->samep = t->samep;
  121|      0|      t->samep->samen = node;
  122|      0|      t->samep = node;
  123|       |
  124|      0|      return t; /* the root node always stays the same */
  125|      0|    }
  126|      0|  }
  127|       |
  128|    462|  if(!t) {
  129|    462|    node->smaller = node->larger = NULL;
  130|    462|  }
  131|      0|  else if(compare(i, t->key) < 0) {
  132|      0|    node->smaller = t->smaller;
  133|      0|    node->larger = t;
  134|      0|    t->smaller = NULL;
  135|       |
  136|      0|  }
  137|      0|  else {
  138|      0|    node->larger = t->larger;
  139|      0|    node->smaller = t;
  140|      0|    t->larger = NULL;
  141|      0|  }
  142|    462|  node->key = i;
  143|       |
  144|       |  /* no identical nodes (yet), we are the only one in the list of nodes */
  145|    462|  node->samen = node;
  146|    462|  node->samep = node;
  147|    462|  return node;
  148|    462|}
Curl_splaygetbest:
  156|    462|{
  157|    462|  static const struct curltime tv_zero = {0, 0};
  158|    462|  struct Curl_tree *x;
  159|       |
  160|    462|  if(!t) {
  161|    462|    *removed = NULL; /* none removed since there was no root */
  162|    462|    return NULL;
  163|    462|  }
  164|       |
  165|       |  /* find smallest */
  166|      0|  t = Curl_splay(tv_zero, t);
  167|      0|  if(compare(i, t->key) < 0) {
  168|       |    /* even the smallest is too big */
  169|      0|    *removed = NULL;
  170|      0|    return t;
  171|      0|  }
  172|       |
  173|       |  /* FIRST! Check if there is a list with identical keys */
  174|      0|  x = t->samen;
  175|      0|  if(x != t) {
  176|       |    /* there is, pick one from the list */
  177|       |
  178|       |    /* 'x' is the new root node */
  179|       |
  180|      0|    x->key = t->key;
  181|      0|    x->larger = t->larger;
  182|      0|    x->smaller = t->smaller;
  183|      0|    x->samep = t->samep;
  184|      0|    t->samep->samen = x;
  185|       |
  186|      0|    *removed = t;
  187|      0|    return x; /* new root */
  188|      0|  }
  189|       |
  190|       |  /* we splayed the tree to the smallest element, there is no smaller */
  191|      0|  x = t->larger;
  192|      0|  *removed = t;
  193|       |
  194|      0|  return x;
  195|      0|}
Curl_splayremove:
  212|    462|{
  213|    462|  static const struct curltime KEY_NOTUSED = {
  214|    462|    (time_t)-1, (unsigned int)-1
  215|    462|  }; /* will *NEVER* appear */
  216|    462|  struct Curl_tree *x;
  217|       |
  218|    462|  if(!t || !removenode)
  219|      0|    return 1;
  220|       |
  221|    462|  if(compare(KEY_NOTUSED, removenode->key) == 0) {
  222|       |    /* Key set to NOTUSED means it is a subnode within a 'same' linked list
  223|       |       and thus we can unlink it easily. */
  224|      0|    if(removenode->samen == removenode)
  225|       |      /* A non-subnode should never be set to KEY_NOTUSED */
  226|      0|      return 3;
  227|       |
  228|      0|    removenode->samep->samen = removenode->samen;
  229|      0|    removenode->samen->samep = removenode->samep;
  230|       |
  231|       |    /* Ensures that double-remove gets caught. */
  232|      0|    removenode->samen = removenode;
  233|       |
  234|      0|    *newroot = t; /* return the same root */
  235|      0|    return 0;
  236|      0|  }
  237|       |
  238|    462|  t = Curl_splay(removenode->key, t);
  239|       |
  240|       |  /* First make sure that we got the same root node as the one we want
  241|       |     to remove, as otherwise we might be trying to remove a node that
  242|       |     isn't actually in the tree.
  243|       |
  244|       |     We cannot just compare the keys here as a double remove in quick
  245|       |     succession of a node with key != KEY_NOTUSED && same != NULL
  246|       |     could return the same key but a different node. */
  247|    462|  if(t != removenode)
  248|      0|    return 2;
  249|       |
  250|       |  /* Check if there is a list with identical sizes, as then we're trying to
  251|       |     remove the root node of a list of nodes with identical keys. */
  252|    462|  x = t->samen;
  253|    462|  if(x != t) {
  254|       |    /* 'x' is the new root node, we just make it use the root node's
  255|       |       smaller/larger links */
  256|       |
  257|      0|    x->key = t->key;
  258|      0|    x->larger = t->larger;
  259|      0|    x->smaller = t->smaller;
  260|      0|    x->samep = t->samep;
  261|      0|    t->samep->samen = x;
  262|      0|  }
  263|    462|  else {
  264|       |    /* Remove the root node */
  265|    462|    if(!t->smaller)
  266|    462|      x = t->larger;
  267|      0|    else {
  268|      0|      x = Curl_splay(removenode->key, t->smaller);
  269|      0|      x->larger = t->larger;
  270|      0|    }
  271|    462|  }
  272|       |
  273|    462|  *newroot = x; /* store new root pointer */
  274|       |
  275|    462|  return 0;
  276|    462|}

Curl_raw_toupper:
   34|  16.2k|{
   35|  16.2k|#if !defined(CURL_DOES_CONVERSIONS)
   36|  16.2k|  if(in >= 'a' && in <= 'z')
   37|  7.85k|    return (char)('A' + in - 'a');
   38|       |#else
   39|       |  switch(in) {
   40|       |  case 'a':
   41|       |    return 'A';
   42|       |  case 'b':
   43|       |    return 'B';
   44|       |  case 'c':
   45|       |    return 'C';
   46|       |  case 'd':
   47|       |    return 'D';
   48|       |  case 'e':
   49|       |    return 'E';
   50|       |  case 'f':
   51|       |    return 'F';
   52|       |  case 'g':
   53|       |    return 'G';
   54|       |  case 'h':
   55|       |    return 'H';
   56|       |  case 'i':
   57|       |    return 'I';
   58|       |  case 'j':
   59|       |    return 'J';
   60|       |  case 'k':
   61|       |    return 'K';
   62|       |  case 'l':
   63|       |    return 'L';
   64|       |  case 'm':
   65|       |    return 'M';
   66|       |  case 'n':
   67|       |    return 'N';
   68|       |  case 'o':
   69|       |    return 'O';
   70|       |  case 'p':
   71|       |    return 'P';
   72|       |  case 'q':
   73|       |    return 'Q';
   74|       |  case 'r':
   75|       |    return 'R';
   76|       |  case 's':
   77|       |    return 'S';
   78|       |  case 't':
   79|       |    return 'T';
   80|       |  case 'u':
   81|       |    return 'U';
   82|       |  case 'v':
   83|       |    return 'V';
   84|       |  case 'w':
   85|       |    return 'W';
   86|       |  case 'x':
   87|       |    return 'X';
   88|       |  case 'y':
   89|       |    return 'Y';
   90|       |  case 'z':
   91|       |    return 'Z';
   92|       |  }
   93|       |#endif
   94|       |
   95|  8.38k|  return in;
   96|  16.2k|}
Curl_strcasecompare:
  181|  2.28k|{
  182|  4.95k|  while(*first && *second) {
  183|  4.00k|    if(Curl_raw_toupper(*first) != Curl_raw_toupper(*second))
  184|       |      /* get out of the loop as soon as they don't match */
  185|  1.34k|      break;
  186|  2.66k|    first++;
  187|  2.66k|    second++;
  188|  2.66k|  }
  189|       |  /* we do the comparison here (possibly again), just to make sure that if the
  190|       |     loop above is skipped because one of the strings reached zero, we must not
  191|       |     return this as a successful match */
  192|  2.28k|  return (Curl_raw_toupper(*first) == Curl_raw_toupper(*second));
  193|  2.28k|}
Curl_strncasecompare:
  209|    891|{
  210|    948|  while(*first && *second && max) {
  211|    935|    if(Curl_raw_toupper(*first) != Curl_raw_toupper(*second)) {
  212|    878|      break;
  213|    878|    }
  214|     57|    max--;
  215|     57|    first++;
  216|     57|    second++;
  217|     57|  }
  218|    891|  if(0 == max)
  219|      1|    return 1; /* they are equal this far */
  220|       |
  221|    890|  return Curl_raw_toupper(*first) == Curl_raw_toupper(*second);
  222|    891|}
curl_strnequal:
  261|    891|{
  262|    891|  return Curl_strncasecompare(first, second, max);
  263|    891|}

curl_url_strerror:
  458|     85|{
  459|     85|#ifndef CURL_DISABLE_VERBOSE_STRINGS
  460|     85|  switch(error) {
  461|      0|  case CURLUE_OK:
  462|      0|    return "No error";
  463|       |
  464|      0|  case CURLUE_BAD_HANDLE:
  465|      0|    return "An invalid CURLU pointer was passed as argument";
  466|       |
  467|      0|  case CURLUE_BAD_PARTPOINTER:
  468|      0|    return "An invalid 'part' argument was passed as argument";
  469|       |
  470|     71|  case CURLUE_MALFORMED_INPUT:
  471|     71|    return "A malformed input was passed to a URL API function";
  472|       |
  473|      9|  case CURLUE_BAD_PORT_NUMBER:
  474|      9|    return "The port number was not a decimal number between 0 and 65535";
  475|       |
  476|      0|  case CURLUE_UNSUPPORTED_SCHEME:
  477|      0|    return "This libcurl build doesn't support the given URL scheme";
  478|       |
  479|      0|  case CURLUE_URLDECODE:
  480|      0|    return "URL decode error, most likely because of rubbish in the input";
  481|       |
  482|      0|  case CURLUE_OUT_OF_MEMORY:
  483|      0|    return "A memory function failed";
  484|       |
  485|      0|  case CURLUE_USER_NOT_ALLOWED:
  486|      0|    return "Credentials was passed in the URL when prohibited";
  487|       |
  488|      0|  case CURLUE_UNKNOWN_PART:
  489|      0|    return "An unknown part ID was passed to a URL API function";
  490|       |
  491|      0|  case CURLUE_NO_SCHEME:
  492|      0|    return "There is no scheme part in the URL";
  493|       |
  494|      0|  case CURLUE_NO_USER:
  495|      0|    return "There is no user part in the URL";
  496|       |
  497|      0|  case CURLUE_NO_PASSWORD:
  498|      0|    return "There is no password part in the URL";
  499|       |
  500|      0|  case CURLUE_NO_OPTIONS:
  501|      0|    return "There is no options part in the URL";
  502|       |
  503|      5|  case CURLUE_NO_HOST:
  504|      5|    return "There is no host part in the URL";
  505|       |
  506|      0|  case CURLUE_NO_PORT:
  507|      0|    return "There is no port part in the URL";
  508|       |
  509|      0|  case CURLUE_NO_QUERY:
  510|      0|    return "There is no query part in the URL";
  511|       |
  512|      0|  case CURLUE_NO_FRAGMENT:
  513|      0|    return "There is no fragment part in the URL";
  514|       |
  515|      0|  case CURLUE_LAST:
  516|      0|    break;
  517|     85|  }
  518|       |
  519|      0|  return "CURLUcode unknown";
  520|       |#else
  521|       |  if(error == CURLUE_OK)
  522|       |    return "No error";
  523|       |  else
  524|       |    return "Error";
  525|       |#endif
  526|     85|}

Curl_now:
   62|  2.69k|{
   63|       |  /*
   64|       |  ** clock_gettime() is granted to be increased monotonically when the
   65|       |  ** monotonic clock is queried. Time starting point is unspecified, it
   66|       |  ** could be the system start-up time, the Epoch, or something else,
   67|       |  ** in any case the time starting point does not change once that the
   68|       |  ** system has started up.
   69|       |  */
   70|  2.69k|#ifdef HAVE_GETTIMEOFDAY
   71|  2.69k|  struct timeval now;
   72|  2.69k|#endif
   73|  2.69k|  struct curltime cnow;
   74|  2.69k|  struct timespec tsnow;
   75|       |
   76|       |  /*
   77|       |  ** clock_gettime() may be defined by Apple's SDK as weak symbol thus
   78|       |  ** code compiles but fails during run-time if clock_gettime() is
   79|       |  ** called on unsupported OS version.
   80|       |  */
   81|       |#if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) && \
   82|       |        (HAVE_BUILTIN_AVAILABLE == 1)
   83|       |  bool have_clock_gettime = FALSE;
   84|       |  if(__builtin_available(macOS 10.12, iOS 10, tvOS 10, watchOS 3, *))
   85|       |    have_clock_gettime = TRUE;
   86|       |#endif
   87|       |
   88|  2.69k|  if(
   89|       |#if defined(__APPLE__) && defined(HAVE_BUILTIN_AVAILABLE) && \
   90|       |        (HAVE_BUILTIN_AVAILABLE == 1)
   91|       |    have_clock_gettime &&
   92|       |#endif
   93|  2.69k|    (0 == clock_gettime(CLOCK_MONOTONIC, &tsnow))) {
   94|  2.69k|    cnow.tv_sec = tsnow.tv_sec;
   95|  2.69k|    cnow.tv_usec = (unsigned int)(tsnow.tv_nsec / 1000);
   96|  2.69k|  }
   97|       |  /*
   98|       |  ** Even when the configure process has truly detected monotonic clock
   99|       |  ** availability, it might happen that it is not actually available at
  100|       |  ** run-time. When this occurs simply fallback to other time source.
  101|       |  */
  102|      0|#ifdef HAVE_GETTIMEOFDAY
  103|      0|  else {
  104|      0|    (void)gettimeofday(&now, NULL);
  105|      0|    cnow.tv_sec = now.tv_sec;
  106|      0|    cnow.tv_usec = (unsigned int)now.tv_usec;
  107|      0|  }
  108|       |#else
  109|       |  else {
  110|       |    cnow.tv_sec = time(NULL);
  111|       |    cnow.tv_usec = 0;
  112|       |  }
  113|       |#endif
  114|  2.69k|  return cnow;
  115|  2.69k|}
Curl_timediff:
  187|    506|{
  188|    506|  timediff_t diff = (timediff_t)newer.tv_sec-older.tv_sec;
  189|    506|  if(diff >= (TIMEDIFF_T_MAX/1000))
  190|      0|    return TIMEDIFF_T_MAX;
  191|    506|  else if(diff <= (TIMEDIFF_T_MIN/1000))
  192|      0|    return TIMEDIFF_T_MIN;
  193|    506|  return diff * 1000 + (newer.tv_usec-older.tv_usec)/1000;
  194|    506|}

Curl_init_CONNECT:
 1391|    253|{
 1392|    253|  data->state.fread_func = data->set.fread_func_set;
 1393|    253|  data->state.in = data->set.in_set;
 1394|    253|}
Curl_pretransfer:
 1402|    462|{
 1403|    462|  CURLcode result;
 1404|       |
 1405|    462|  if(!data->state.url && !data->set.uh) {
 1406|       |    /* we can't do anything without URL */
 1407|    209|    failf(data, "No URL set!");
 1408|    209|    return CURLE_URL_MALFORMAT;
 1409|    209|  }
 1410|       |
 1411|       |  /* since the URL may have been redirected in a previous use of this handle */
 1412|    253|  if(data->state.url_alloc) {
 1413|       |    /* the already set URL is allocated, free it first! */
 1414|      0|    Curl_safefree(data->state.url);
 1415|      0|    data->state.url_alloc = FALSE;
 1416|      0|  }
 1417|       |
 1418|    253|  if(!data->state.url && data->set.uh) {
 1419|      0|    CURLUcode uc;
 1420|      0|    free(data->set.str[STRING_SET_URL]);
 1421|      0|    uc = curl_url_get(data->set.uh,
 1422|      0|                      CURLUPART_URL, &data->set.str[STRING_SET_URL], 0);
 1423|      0|    if(uc) {
 1424|      0|      failf(data, "No URL set!");
 1425|      0|      return CURLE_URL_MALFORMAT;
 1426|      0|    }
 1427|      0|  }
 1428|       |
 1429|    253|  data->state.prefer_ascii = data->set.prefer_ascii;
 1430|    253|  data->state.list_only = data->set.list_only;
 1431|    253|  data->state.httpreq = data->set.method;
 1432|    253|  data->state.url = data->set.str[STRING_SET_URL];
 1433|       |
 1434|       |  /* Init the SSL session ID cache here. We do it here since we want to do it
 1435|       |     after the *_setopt() calls (that could specify the size of the cache) but
 1436|       |     before any transfer takes place. */
 1437|    253|  result = Curl_ssl_initsessions(data, data->set.general_ssl.max_ssl_sessions);
 1438|    253|  if(result)
 1439|      0|    return result;
 1440|       |
 1441|    253|  data->state.wildcardmatch = data->set.wildcard_enabled;
 1442|    253|  data->state.followlocation = 0; /* reset the location-follow counter */
 1443|    253|  data->state.this_is_a_follow = FALSE; /* reset this */
 1444|    253|  data->state.errorbuf = FALSE; /* no error has occurred */
 1445|    253|  data->state.httpwant = data->set.httpwant;
 1446|    253|  data->state.httpversion = 0;
 1447|    253|  data->state.authproblem = FALSE;
 1448|    253|  data->state.authhost.want = data->set.httpauth;
 1449|    253|  data->state.authproxy.want = data->set.proxyauth;
 1450|    253|  Curl_safefree(data->info.wouldredirect);
 1451|       |
 1452|    253|  if(data->state.httpreq == HTTPREQ_PUT)
 1453|      1|    data->state.infilesize = data->set.filesize;
 1454|    252|  else if((data->state.httpreq != HTTPREQ_GET) &&
 1455|    252|          (data->state.httpreq != HTTPREQ_HEAD)) {
 1456|      9|    data->state.infilesize = data->set.postfieldsize;
 1457|      9|    if(data->set.postfields && (data->state.infilesize == -1))
 1458|      1|      data->state.infilesize = (curl_off_t)strlen(data->set.postfields);
 1459|      9|  }
 1460|    243|  else
 1461|    243|    data->state.infilesize = 0;
 1462|       |
 1463|       |  /* If there is a list of cookie files to read, do it now! */
 1464|    253|  if(data->state.cookielist)
 1465|      0|    Curl_cookie_loadfiles(data);
 1466|       |
 1467|       |  /* If there is a list of host pairs to deal with */
 1468|    253|  if(data->state.resolve)
 1469|      0|    result = Curl_loadhostpairs(data);
 1470|       |
 1471|    253|  if(!result) {
 1472|       |    /* Allow data->set.use_port to set which port to use. This needs to be
 1473|       |     * disabled for example when we follow Location: headers to URLs using
 1474|       |     * different ports! */
 1475|    253|    data->state.allow_port = TRUE;
 1476|       |
 1477|       |#if defined(HAVE_SIGNAL) && defined(SIGPIPE) && !defined(HAVE_MSG_NOSIGNAL)
 1478|       |    /*************************************************************
 1479|       |     * Tell signal handler to ignore SIGPIPE
 1480|       |     *************************************************************/
 1481|       |    if(!data->set.no_signal)
 1482|       |      data->state.prev_signal = signal(SIGPIPE, SIG_IGN);
 1483|       |#endif
 1484|       |
 1485|    253|    Curl_initinfo(data); /* reset session-specific information "variables" */
 1486|    253|    Curl_pgrsResetTransferSizes(data);
 1487|    253|    Curl_pgrsStartNow(data);
 1488|       |
 1489|       |    /* In case the handle is re-used and an authentication method was picked
 1490|       |       in the session we need to make sure we only use the one(s) we now
 1491|       |       consider to be fine */
 1492|    253|    data->state.authhost.picked &= data->state.authhost.want;
 1493|    253|    data->state.authproxy.picked &= data->state.authproxy.want;
 1494|       |
 1495|    253|#ifndef CURL_DISABLE_FTP
 1496|    253|    if(data->state.wildcardmatch) {
 1497|      1|      struct WildcardData *wc = &data->wildcard;
 1498|      1|      if(wc->state < CURLWC_INIT) {
 1499|      1|        result = Curl_wildcard_init(wc); /* init wildcard structures */
 1500|      1|        if(result)
 1501|      0|          return CURLE_OUT_OF_MEMORY;
 1502|      1|      }
 1503|      1|    }
 1504|    253|#endif
 1505|    253|    Curl_http2_init_state(&data->state);
 1506|    253|    result = Curl_hsts_loadcb(data, data->hsts);
 1507|    253|  }
 1508|       |
 1509|       |  /*
 1510|       |   * Set user-agent. Used for HTTP, but since we can attempt to tunnel
 1511|       |   * basically anything through a http proxy we can't limit this based on
 1512|       |   * protocol.
 1513|       |   */
 1514|    253|  if(data->set.str[STRING_USERAGENT]) {
 1515|      0|    Curl_safefree(data->state.aptr.uagent);
 1516|      0|    data->state.aptr.uagent =
 1517|      0|      aprintf("User-Agent: %s\r\n", data->set.str[STRING_USERAGENT]);
 1518|      0|    if(!data->state.aptr.uagent)
 1519|      0|      return CURLE_OUT_OF_MEMORY;
 1520|      0|  }
 1521|       |
 1522|    253|  if(!result)
 1523|    253|    result = Curl_setstropt(&data->state.aptr.user,
 1524|    253|                            data->set.str[STRING_USERNAME]);
 1525|    253|  if(!result)
 1526|    253|    result = Curl_setstropt(&data->state.aptr.passwd,
 1527|    253|                            data->set.str[STRING_PASSWORD]);
 1528|    253|  if(!result)
 1529|    253|    result = Curl_setstropt(&data->state.aptr.proxyuser,
 1530|    253|                            data->set.str[STRING_PROXYUSERNAME]);
 1531|    253|  if(!result)
 1532|    253|    result = Curl_setstropt(&data->state.aptr.proxypasswd,
 1533|    253|                            data->set.str[STRING_PROXYPASSWORD]);
 1534|       |
 1535|    253|  data->req.headerbytecount = 0;
 1536|    253|  return result;
 1537|    253|}
Curl_posttransfer:
 1543|    253|{
 1544|       |#if defined(HAVE_SIGNAL) && defined(SIGPIPE) && !defined(HAVE_MSG_NOSIGNAL)
 1545|       |  /* restore the signal handler for SIGPIPE before we get back */
 1546|       |  if(!data->set.no_signal)
 1547|       |    signal(SIGPIPE, data->state.prev_signal);
 1548|       |#else
 1549|    253|  (void)data; /* unused parameter */
 1550|    253|#endif
 1551|       |
 1552|    253|  return CURLE_OK;
 1553|    253|}

Curl_freeset:
  310|  1.05k|{
  311|       |  /* Free all dynamic strings stored in the data->set substructure. */
  312|  1.05k|  enum dupstring i;
  313|  1.05k|  enum dupblob j;
  314|       |
  315|  86.8k|  for(i = (enum dupstring)0; i < STRING_LAST; i++) {
  316|  85.7k|    Curl_safefree(data->set.str[i]);
  317|  85.7k|  }
  318|       |
  319|  9.53k|  for(j = (enum dupblob)0; j < BLOB_LAST; j++) {
  320|  8.47k|    Curl_safefree(data->set.blobs[j]);
  321|  8.47k|  }
  322|       |
  323|  1.05k|  if(data->state.referer_alloc) {
  324|      0|    Curl_safefree(data->state.referer);
  325|      0|    data->state.referer_alloc = FALSE;
  326|      0|  }
  327|  1.05k|  data->state.referer = NULL;
  328|  1.05k|  if(data->state.url_alloc) {
  329|    168|    Curl_safefree(data->state.url);
  330|    168|    data->state.url_alloc = FALSE;
  331|    168|  }
  332|  1.05k|  data->state.url = NULL;
  333|       |
  334|  1.05k|  Curl_mime_cleanpart(&data->set.mimepost);
  335|  1.05k|}
Curl_close:
  363|  1.05k|{
  364|  1.05k|  struct Curl_multi *m;
  365|  1.05k|  struct Curl_easy *data;
  366|       |
  367|  1.05k|  if(!datap || !*datap)
  368|      0|    return CURLE_OK;
  369|       |
  370|  1.05k|  data = *datap;
  371|  1.05k|  *datap = NULL;
  372|       |
  373|  1.05k|  Curl_expire_clear(data); /* shut off timers */
  374|       |
  375|       |  /* Detach connection if any is left. This should not be normal, but can be
  376|       |     the case for example with CONNECT_ONLY + recv/send (test 556) */
  377|  1.05k|  Curl_detach_connnection(data);
  378|  1.05k|  m = data->multi;
  379|  1.05k|  if(m)
  380|       |    /* This handle is still part of a multi handle, take care of this first
  381|       |       and detach this handle from there. */
  382|      0|    curl_multi_remove_handle(data->multi, data);
  383|       |
  384|  1.05k|  if(data->multi_easy) {
  385|       |    /* when curl_easy_perform() is used, it creates its own multi handle to
  386|       |       use and this is the one */
  387|      0|    curl_multi_cleanup(data->multi_easy);
  388|      0|    data->multi_easy = NULL;
  389|      0|  }
  390|       |
  391|       |  /* Destroy the timeout list that is held in the easy handle. It is
  392|       |     /normally/ done by curl_multi_remove_handle() but this is "just in
  393|       |     case" */
  394|  1.05k|  Curl_llist_destroy(&data->state.timeoutlist, NULL);
  395|       |
  396|  1.05k|  data->magic = 0; /* force a clear AFTER the possibly enforced removal from
  397|       |                      the multi handle, since that function uses the magic
  398|       |                      field! */
  399|       |
  400|  1.05k|  if(data->state.rangestringalloc)
  401|      0|    free(data->state.range);
  402|       |
  403|       |  /* freed here just in case DONE wasn't called */
  404|  1.05k|  Curl_free_request_state(data);
  405|       |
  406|       |  /* Close down all open SSL info and sessions */
  407|  1.05k|  Curl_ssl_close_all(data);
  408|  1.05k|  Curl_safefree(data->state.first_host);
  409|  1.05k|  Curl_safefree(data->state.scratch);
  410|  1.05k|  Curl_ssl_free_certinfo(data);
  411|       |
  412|       |  /* Cleanup possible redirect junk */
  413|  1.05k|  free(data->req.newurl);
  414|  1.05k|  data->req.newurl = NULL;
  415|       |
  416|  1.05k|  if(data->state.referer_alloc) {
  417|      0|    Curl_safefree(data->state.referer);
  418|      0|    data->state.referer_alloc = FALSE;
  419|      0|  }
  420|  1.05k|  data->state.referer = NULL;
  421|       |
  422|  1.05k|  up_free(data);
  423|  1.05k|  Curl_safefree(data->state.buffer);
  424|  1.05k|  Curl_dyn_free(&data->state.headerb);
  425|  1.05k|  Curl_safefree(data->state.ulbuf);
  426|  1.05k|  Curl_flush_cookies(data, TRUE);
  427|  1.05k|  Curl_altsvc_save(data, data->asi, data->set.str[STRING_ALTSVC]);
  428|  1.05k|  Curl_altsvc_cleanup(&data->asi);
  429|  1.05k|  Curl_hsts_save(data, data->hsts, data->set.str[STRING_HSTS]);
  430|  1.05k|  Curl_hsts_cleanup(&data->hsts);
  431|  1.05k|#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_CRYPTO_AUTH)
  432|  1.05k|  Curl_http_auth_cleanup_digest(data);
  433|  1.05k|#endif
  434|  1.05k|  Curl_safefree(data->info.contenttype);
  435|  1.05k|  Curl_safefree(data->info.wouldredirect);
  436|       |
  437|       |  /* this destroys the channel and we cannot use it anymore after this */
  438|  1.05k|  Curl_resolver_cleanup(data->state.async.resolver);
  439|       |
  440|  1.05k|  Curl_http2_cleanup_dependencies(data);
  441|  1.05k|  Curl_convert_close(data);
  442|       |
  443|       |  /* No longer a dirty share, if it exists */
  444|  1.05k|  if(data->share) {
  445|      0|    Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
  446|      0|    data->share->dirty--;
  447|      0|    Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
  448|      0|  }
  449|       |
  450|  1.05k|  Curl_safefree(data->state.aptr.proxyuserpwd);
  451|  1.05k|  Curl_safefree(data->state.aptr.uagent);
  452|  1.05k|  Curl_safefree(data->state.aptr.userpwd);
  453|  1.05k|  Curl_safefree(data->state.aptr.accept_encoding);
  454|  1.05k|  Curl_safefree(data->state.aptr.te);
  455|  1.05k|  Curl_safefree(data->state.aptr.rangeline);
  456|  1.05k|  Curl_safefree(data->state.aptr.ref);
  457|  1.05k|  Curl_safefree(data->state.aptr.host);
  458|  1.05k|  Curl_safefree(data->state.aptr.cookiehost);
  459|  1.05k|  Curl_safefree(data->state.aptr.rtsp_transport);
  460|  1.05k|  Curl_safefree(data->state.aptr.user);
  461|  1.05k|  Curl_safefree(data->state.aptr.passwd);
  462|  1.05k|  Curl_safefree(data->state.aptr.proxyuser);
  463|  1.05k|  Curl_safefree(data->state.aptr.proxypasswd);
  464|       |
  465|  1.05k|#ifndef CURL_DISABLE_DOH
  466|  1.05k|  if(data->req.doh) {
  467|      0|    Curl_dyn_free(&data->req.doh->probe[0].serverdoh);
  468|      0|    Curl_dyn_free(&data->req.doh->probe[1].serverdoh);
  469|      0|    curl_slist_free_all(data->req.doh->headers);
  470|      0|    Curl_safefree(data->req.doh);
  471|      0|  }
  472|  1.05k|#endif
  473|       |
  474|       |  /* destruct wildcard structures if it is needed */
  475|  1.05k|  Curl_wildcard_dtor(&data->wildcard);
  476|  1.05k|  Curl_freeset(data);
  477|  1.05k|  free(data);
  478|  1.05k|  return CURLE_OK;
  479|  1.05k|}
Curl_init_userdefined:
  486|  1.05k|{
  487|  1.05k|  struct UserDefined *set = &data->set;
  488|  1.05k|  CURLcode result = CURLE_OK;
  489|       |
  490|  1.05k|  set->out = stdout; /* default output to stdout */
  491|  1.05k|  set->in_set = stdin;  /* default input from stdin */
  492|  1.05k|  set->err  = stderr;  /* default stderr to stderr */
  493|       |
  494|       |  /* use fwrite as default function to store output */
  495|  1.05k|  set->fwrite_func = (curl_write_callback)fwrite;
  496|       |
  497|       |  /* use fread as default function to read input */
  498|  1.05k|  set->fread_func_set = (curl_read_callback)fread;
  499|  1.05k|  set->is_fread_set = 0;
  500|  1.05k|  set->is_fwrite_set = 0;
  501|       |
  502|  1.05k|  set->seek_func = ZERO_NULL;
  503|  1.05k|  set->seek_client = ZERO_NULL;
  504|       |
  505|       |  /* conversion callbacks for non-ASCII hosts */
  506|  1.05k|  set->convfromnetwork = ZERO_NULL;
  507|  1.05k|  set->convtonetwork   = ZERO_NULL;
  508|  1.05k|  set->convfromutf8    = ZERO_NULL;
  509|       |
  510|  1.05k|  set->filesize = -1;        /* we don't know the size */
  511|  1.05k|  set->postfieldsize = -1;   /* unknown size */
  512|  1.05k|  set->maxredirs = -1;       /* allow any amount by default */
  513|       |
  514|  1.05k|  set->method = HTTPREQ_GET; /* Default HTTP request */
  515|  1.05k|  set->rtspreq = RTSPREQ_OPTIONS; /* Default RTSP request */
  516|  1.05k|#ifndef CURL_DISABLE_FTP
  517|  1.05k|  set->ftp_use_epsv = TRUE;   /* FTP defaults to EPSV operations */
  518|  1.05k|  set->ftp_use_eprt = TRUE;   /* FTP defaults to EPRT operations */
  519|  1.05k|  set->ftp_use_pret = FALSE;  /* mainly useful for drftpd servers */
  520|  1.05k|  set->ftp_filemethod = FTPFILE_MULTICWD;
  521|  1.05k|  set->ftp_skip_ip = TRUE;    /* skip PASV IP by default */
  522|  1.05k|#endif
  523|  1.05k|  set->dns_cache_timeout = 60; /* Timeout every 60 seconds by default */
  524|       |
  525|       |  /* Set the default size of the SSL session ID cache */
  526|  1.05k|  set->general_ssl.max_ssl_sessions = 5;
  527|       |
  528|  1.05k|  set->proxyport = 0;
  529|  1.05k|  set->proxytype = CURLPROXY_HTTP; /* defaults to HTTP proxy */
  530|  1.05k|  set->httpauth = CURLAUTH_BASIC;  /* defaults to basic */
  531|  1.05k|  set->proxyauth = CURLAUTH_BASIC; /* defaults to basic */
  532|       |
  533|       |  /* SOCKS5 proxy auth defaults to username/password + GSS-API */
  534|  1.05k|  set->socks5auth = CURLAUTH_BASIC | CURLAUTH_GSSAPI;
  535|       |
  536|       |  /* make libcurl quiet by default: */
  537|  1.05k|  set->hide_progress = TRUE;  /* CURLOPT_NOPROGRESS changes these */
  538|       |
  539|  1.05k|  Curl_mime_initpart(&set->mimepost, data);
  540|       |
  541|       |  /*
  542|       |   * libcurl 7.10 introduced SSL verification *by default*! This needs to be
  543|       |   * switched off unless wanted.
  544|       |   */
  545|  1.05k|  set->doh_verifyhost = TRUE;
  546|  1.05k|  set->doh_verifypeer = TRUE;
  547|  1.05k|  set->ssl.primary.verifypeer = TRUE;
  548|  1.05k|  set->ssl.primary.verifyhost = TRUE;
  549|  1.05k|#ifdef USE_TLS_SRP
  550|  1.05k|  set->ssl.authtype = CURL_TLSAUTH_NONE;
  551|  1.05k|#endif
  552|  1.05k|  set->ssh_auth_types = CURLSSH_AUTH_DEFAULT; /* defaults to any auth
  553|       |                                                      type */
  554|  1.05k|  set->ssl.primary.sessionid = TRUE; /* session ID caching enabled by
  555|       |                                        default */
  556|  1.05k|#ifndef CURL_DISABLE_PROXY
  557|  1.05k|  set->proxy_ssl = set->ssl;
  558|  1.05k|#endif
  559|       |
  560|  1.05k|  set->new_file_perms = 0644;    /* Default permissions */
  561|  1.05k|  set->new_directory_perms = 0755; /* Default permissions */
  562|       |
  563|       |  /* for the *protocols fields we don't use the CURLPROTO_ALL convenience
  564|       |     define since we internally only use the lower 16 bits for the passed
  565|       |     in bitmask to not conflict with the private bits */
  566|  1.05k|  set->allowed_protocols = CURLPROTO_ALL;
  567|  1.05k|  set->redir_protocols = CURLPROTO_HTTP | CURLPROTO_HTTPS | CURLPROTO_FTP |
  568|  1.05k|                         CURLPROTO_FTPS;
  569|       |
  570|       |#if defined(HAVE_GSSAPI) || defined(USE_WINDOWS_SSPI)
  571|       |  /*
  572|       |   * disallow unprotected protection negotiation NEC reference implementation
  573|       |   * seem not to follow rfc1961 section 4.3/4.4
  574|       |   */
  575|       |  set->socks5_gssapi_nec = FALSE;
  576|       |#endif
  577|       |
  578|       |  /* Set the default CA cert bundle/path detected/specified at build time.
  579|       |   *
  580|       |   * If Schannel is the selected SSL backend then these locations are
  581|       |   * ignored. We allow setting CA location for schannel only when explicitly
  582|       |   * specified by the user via CURLOPT_CAINFO / --cacert.
  583|       |   */
  584|  1.05k|  if(Curl_ssl_backend() != CURLSSLBACKEND_SCHANNEL) {
  585|  1.05k|#if defined(CURL_CA_BUNDLE)
  586|  1.05k|    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE], CURL_CA_BUNDLE);
  587|  1.05k|    if(result)
  588|      0|      return result;
  589|       |
  590|  1.05k|    result = Curl_setstropt(&set->str[STRING_SSL_CAFILE_PROXY],
  591|  1.05k|                            CURL_CA_BUNDLE);
  592|  1.05k|    if(result)
  593|      0|      return result;
  594|  1.05k|#endif
  595|       |#if defined(CURL_CA_PATH)
  596|       |    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH], CURL_CA_PATH);
  597|       |    if(result)
  598|       |      return result;
  599|       |
  600|       |    result = Curl_setstropt(&set->str[STRING_SSL_CAPATH_PROXY], CURL_CA_PATH);
  601|       |    if(result)
  602|       |      return result;
  603|       |#endif
  604|  1.05k|  }
  605|       |
  606|  1.05k|  set->wildcard_enabled = FALSE;
  607|  1.05k|  set->chunk_bgn      = ZERO_NULL;
  608|  1.05k|  set->chunk_end      = ZERO_NULL;
  609|  1.05k|  set->tcp_keepalive = FALSE;
  610|  1.05k|  set->tcp_keepintvl = 60;
  611|  1.05k|  set->tcp_keepidle = 60;
  612|  1.05k|  set->tcp_fastopen = FALSE;
  613|  1.05k|  set->tcp_nodelay = TRUE;
  614|  1.05k|  set->ssl_enable_npn = TRUE;
  615|  1.05k|  set->ssl_enable_alpn = TRUE;
  616|  1.05k|  set->expect_100_timeout = 1000L; /* Wait for a second by default. */
  617|  1.05k|  set->sep_headers = TRUE; /* separated header lists by default */
  618|  1.05k|  set->buffer_size = READBUFFER_SIZE;
  619|  1.05k|  set->upload_buffer_size = UPLOADBUFFER_DEFAULT;
  620|  1.05k|  set->happy_eyeballs_timeout = CURL_HET_DEFAULT;
  621|  1.05k|  set->fnmatch = ZERO_NULL;
  622|  1.05k|  set->upkeep_interval_ms = CURL_UPKEEP_INTERVAL_DEFAULT;
  623|  1.05k|  set->maxconnects = DEFAULT_CONNCACHE_SIZE; /* for easy handles */
  624|  1.05k|  set->maxage_conn = 118;
  625|  1.05k|  set->maxlifetime_conn = 0;
  626|  1.05k|  set->http09_allowed = FALSE;
  627|  1.05k|  set->httpwant =
  628|  1.05k|#ifdef USE_NGHTTP2
  629|  1.05k|    CURL_HTTP_VERSION_2TLS
  630|       |#else
  631|       |    CURL_HTTP_VERSION_1_1
  632|       |#endif
  633|  1.05k|    ;
  634|  1.05k|  Curl_http2_init_userset(set);
  635|  1.05k|  return result;
  636|  1.05k|}
Curl_open:
  647|  1.05k|{
  648|  1.05k|  CURLcode result;
  649|  1.05k|  struct Curl_easy *data;
  650|       |
  651|       |  /* Very simple start-up: alloc the struct, init it with zeroes and return */
  652|  1.05k|  data = calloc(1, sizeof(struct Curl_easy));
  653|  1.05k|  if(!data) {
  654|       |    /* this is a very serious error */
  655|      0|    DEBUGF(fprintf(stderr, "Error: calloc of Curl_easy failed\n"));
  656|      0|    return CURLE_OUT_OF_MEMORY;
  657|      0|  }
  658|       |
  659|  1.05k|  data->magic = CURLEASY_MAGIC_NUMBER;
  660|       |
  661|  1.05k|  result = Curl_resolver_init(data, &data->state.async.resolver);
  662|  1.05k|  if(result) {
  663|      0|    DEBUGF(fprintf(stderr, "Error: resolver_init failed\n"));
  664|      0|    free(data);
  665|      0|    return result;
  666|      0|  }
  667|       |
  668|  1.05k|  result = Curl_init_userdefined(data);
  669|  1.05k|  if(!result) {
  670|  1.05k|    Curl_dyn_init(&data->state.headerb, CURL_MAX_HTTP_HEADER);
  671|  1.05k|    Curl_convert_init(data);
  672|  1.05k|    Curl_initinfo(data);
  673|       |
  674|       |    /* most recent connection is not yet defined */
  675|  1.05k|    data->state.lastconnect_id = -1;
  676|       |
  677|  1.05k|    data->progress.flags |= PGRS_HIDE;
  678|  1.05k|    data->state.current_speed = -1; /* init to negative == impossible */
  679|  1.05k|  }
  680|       |
  681|  1.05k|  if(result) {
  682|      0|    Curl_resolver_cleanup(data->state.async.resolver);
  683|      0|    Curl_dyn_free(&data->state.headerb);
  684|      0|    Curl_freeset(data);
  685|      0|    free(data);
  686|      0|    data = NULL;
  687|      0|  }
  688|  1.05k|  else
  689|  1.05k|    *curl = data;
  690|       |
  691|  1.05k|  return result;
  692|  1.05k|}
Curl_disconnect:
  826|    253|{
  827|       |  /* there must be a connection to close */
  828|    253|  DEBUGASSERT(conn);
  829|       |
  830|       |  /* it must be removed from the connection cache */
  831|    253|  DEBUGASSERT(!conn->bundle);
  832|       |
  833|       |  /* there must be an associated transfer */
  834|    253|  DEBUGASSERT(data);
  835|       |
  836|       |  /* the transfer must be detached from the connection */
  837|    253|  DEBUGASSERT(!data->conn);
  838|       |
  839|       |  /*
  840|       |   * If this connection isn't marked to force-close, leave it open if there
  841|       |   * are other users of it
  842|       |   */
  843|    253|  if(CONN_INUSE(conn) && !dead_connection) {
  844|      0|    DEBUGF(infof(data, "Curl_disconnect when inuse: %zu", CONN_INUSE(conn)));
  845|      0|    return CURLE_OK;
  846|      0|  }
  847|       |
  848|    253|  if(conn->dns_entry != NULL) {
  849|      0|    Curl_resolv_unlock(data, conn->dns_entry);
  850|      0|    conn->dns_entry = NULL;
  851|      0|  }
  852|       |
  853|       |  /* Cleanup NTLM connection-related data */
  854|    253|  Curl_http_auth_cleanup_ntlm(conn);
  855|       |
  856|       |  /* Cleanup NEGOTIATE connection-related data */
  857|    253|  Curl_http_auth_cleanup_negotiate(conn);
  858|       |
  859|    253|  if(conn->bits.connect_only)
  860|       |    /* treat the connection as dead in CONNECT_ONLY situations */
  861|      0|    dead_connection = TRUE;
  862|       |
  863|       |  /* temporarily attach the connection to this transfer handle for the
  864|       |     disconnect and shutdown */
  865|    253|  Curl_attach_connnection(data, conn);
  866|       |
  867|    253|  if(conn->handler->disconnect)
  868|       |    /* This is set if protocol-specific cleanups should be made */
  869|      0|    conn->handler->disconnect(data, conn, dead_connection);
  870|       |
  871|    253|  conn_shutdown(data, conn);
  872|       |
  873|       |  /* detach it again */
  874|    253|  Curl_detach_connnection(data);
  875|       |
  876|    253|  conn_free(conn);
  877|    253|  return CURLE_OK;
  878|    253|}
Curl_free_idnconverted_hostname:
 1654|  1.01k|{
 1655|       |#if defined(USE_LIBIDN2)
 1656|       |  if(host->encalloc) {
 1657|       |    idn2_free(host->encalloc); /* must be freed with idn2_free() since this was
 1658|       |                                 allocated by libidn */
 1659|       |    host->encalloc = NULL;
 1660|       |  }
 1661|       |#elif defined(USE_WIN32_IDN)
 1662|       |  free(host->encalloc); /* must be freed with free() since this was
 1663|       |                           allocated by curl_win32_idn_to_ascii */
 1664|       |  host->encalloc = NULL;
 1665|       |#else
 1666|  1.01k|  (void)host;
 1667|  1.01k|#endif
 1668|  1.01k|}
Curl_builtin_scheme:
 1816|    364|{
 1817|    364|  const struct Curl_handler * const *pp;
 1818|    364|  const struct Curl_handler *p;
 1819|       |  /* Scan protocol handler table and match against 'scheme'. The handler may
 1820|       |     be changed later when the protocol specific setup function is called. */
 1821|  2.09k|  for(pp = protocols; (p = *pp) != NULL; pp++)
 1822|  2.02k|    if(strcasecompare(p->scheme, scheme))
 1823|       |      /* Protocol found in table. Check if allowed */
 1824|    293|      return p;
 1825|     71|  return NULL; /* not found */
 1826|    364|}
Curl_uc_to_curlcode:
 1864|     85|{
 1865|     85|  switch(uc) {
 1866|     85|  default:
 1867|     85|    return CURLE_URL_MALFORMAT;
 1868|      0|  case CURLUE_UNSUPPORTED_SCHEME:
 1869|      0|    return CURLE_UNSUPPORTED_PROTOCOL;
 1870|      0|  case CURLUE_OUT_OF_MEMORY:
 1871|      0|    return CURLE_OUT_OF_MEMORY;
 1872|      0|  case CURLUE_USER_NOT_ALLOWED:
 1873|      0|    return CURLE_LOGIN_DENIED;
 1874|     85|  }
 1875|     85|}
Curl_free_request_state:
 2204|  1.31k|{
 2205|  1.31k|  Curl_safefree(data->req.p.http);
 2206|  1.31k|  Curl_safefree(data->req.newurl);
 2207|       |
 2208|  1.31k|#ifndef CURL_DISABLE_DOH
 2209|  1.31k|  if(data->req.doh) {
 2210|      0|    Curl_close(&data->req.doh->probe[0].easy);
 2211|      0|    Curl_close(&data->req.doh->probe[1].easy);
 2212|      0|  }
 2213|  1.31k|#endif
 2214|  1.31k|}
Curl_parse_login_details:
 2777|     11|{
 2778|     11|  CURLcode result = CURLE_OK;
 2779|     11|  char *ubuf = NULL;
 2780|     11|  char *pbuf = NULL;
 2781|     11|  char *obuf = NULL;
 2782|     11|  const char *psep = NULL;
 2783|     11|  const char *osep = NULL;
 2784|     11|  size_t ulen;
 2785|     11|  size_t plen;
 2786|     11|  size_t olen;
 2787|       |
 2788|       |  /* the input length check is because this is called directly from setopt
 2789|       |     and isn't going through the regular string length check */
 2790|     11|  size_t llen = strlen(login);
 2791|     11|  if(llen > CURL_MAX_INPUT_LENGTH)
 2792|      0|    return CURLE_BAD_FUNCTION_ARGUMENT;
 2793|       |
 2794|       |  /* Attempt to find the password separator */
 2795|     11|  if(passwdp) {
 2796|     11|    psep = strchr(login, ':');
 2797|       |
 2798|       |    /* Within the constraint of the login string */
 2799|     11|    if(psep >= login + len)
 2800|      1|      psep = NULL;
 2801|     11|  }
 2802|       |
 2803|       |  /* Attempt to find the options separator */
 2804|     11|  if(optionsp) {
 2805|      0|    osep = strchr(login, ';');
 2806|       |
 2807|       |    /* Within the constraint of the login string */
 2808|      0|    if(osep >= login + len)
 2809|      0|      osep = NULL;
 2810|      0|  }
 2811|       |
 2812|       |  /* Calculate the portion lengths */
 2813|     11|  ulen = (psep ?
 2814|      1|          (size_t)(osep && psep > osep ? osep - login : psep - login) :
 2815|     11|          (osep ? (size_t)(osep - login) : len));
 2816|     11|  plen = (psep ?
 2817|      1|          (osep && osep > psep ? (size_t)(osep - psep) :
 2818|     10|                                 (size_t)(login + len - psep)) - 1 : 0);
 2819|     11|  olen = (osep ?
 2820|      0|          (psep && psep > osep ? (size_t)(psep - osep) :
 2821|     11|                                 (size_t)(login + len - osep)) - 1 : 0);
 2822|       |
 2823|       |  /* Allocate the user portion buffer */
 2824|     11|  if(userp && ulen) {
 2825|      5|    ubuf = malloc(ulen + 1);
 2826|      5|    if(!ubuf)
 2827|      0|      result = CURLE_OUT_OF_MEMORY;
 2828|      5|  }
 2829|       |
 2830|       |  /* Allocate the password portion buffer */
 2831|     11|  if(!result && passwdp && plen) {
 2832|      1|    pbuf = malloc(plen + 1);
 2833|      1|    if(!pbuf) {
 2834|      0|      free(ubuf);
 2835|      0|      result = CURLE_OUT_OF_MEMORY;
 2836|      0|    }
 2837|      1|  }
 2838|       |
 2839|       |  /* Allocate the options portion buffer */
 2840|     11|  if(!result && optionsp && olen) {
 2841|      0|    obuf = malloc(olen + 1);
 2842|      0|    if(!obuf) {
 2843|      0|      free(pbuf);
 2844|      0|      free(ubuf);
 2845|      0|      result = CURLE_OUT_OF_MEMORY;
 2846|      0|    }
 2847|      0|  }
 2848|       |
 2849|     11|  if(!result) {
 2850|       |    /* Store the user portion if necessary */
 2851|     11|    if(ubuf) {
 2852|      5|      memcpy(ubuf, login, ulen);
 2853|      5|      ubuf[ulen] = '\0';
 2854|      5|      Curl_safefree(*userp);
 2855|      5|      *userp = ubuf;
 2856|      5|    }
 2857|       |
 2858|       |    /* Store the password portion if necessary */
 2859|     11|    if(pbuf) {
 2860|      1|      memcpy(pbuf, psep + 1, plen);
 2861|      1|      pbuf[plen] = '\0';
 2862|      1|      Curl_safefree(*passwdp);
 2863|      1|      *passwdp = pbuf;
 2864|      1|    }
 2865|       |
 2866|       |    /* Store the options portion if necessary */
 2867|     11|    if(obuf) {
 2868|      0|      memcpy(obuf, osep + 1, olen);
 2869|      0|      obuf[olen] = '\0';
 2870|      0|      Curl_safefree(*optionsp);
 2871|      0|      *optionsp = obuf;
 2872|      0|    }
 2873|     11|  }
 2874|       |
 2875|     11|  return result;
 2876|     11|}
Curl_connect:
 4109|    253|{
 4110|    253|  CURLcode result;
 4111|    253|  struct connectdata *conn;
 4112|       |
 4113|    253|  *asyncp = FALSE; /* assume synchronous resolves by default */
 4114|       |
 4115|       |  /* init the single-transfer specific data */
 4116|    253|  Curl_free_request_state(data);
 4117|    253|  memset(&data->req, 0, sizeof(struct SingleRequest));
 4118|    253|  data->req.size = data->req.maxdownload = -1;
 4119|       |
 4120|       |  /* call the stuff that needs to be called */
 4121|    253|  result = create_conn(data, &conn, asyncp);
 4122|       |
 4123|    253|  if(!result) {
 4124|      0|    if(CONN_INUSE(conn) > 1)
 4125|       |      /* multiplexed */
 4126|      0|      *protocol_done = TRUE;
 4127|      0|    else if(!*asyncp) {
 4128|       |      /* DNS resolution is done: that's either because this is a reused
 4129|       |         connection, in which case DNS was unnecessary, or because DNS
 4130|       |         really did finish already (synch resolver/fast async resolve) */
 4131|      0|      result = Curl_setup_conn(data, protocol_done);
 4132|      0|    }
 4133|      0|  }
 4134|       |
 4135|    253|  if(result == CURLE_NO_CONNECTION_AVAILABLE) {
 4136|      0|    return result;
 4137|      0|  }
 4138|    253|  else if(result && conn) {
 4139|       |    /* We're not allowed to return failure with memory left allocated in the
 4140|       |       connectdata struct, free those here */
 4141|    253|    Curl_detach_connnection(data);
 4142|    253|    Curl_conncache_remove_conn(data, conn, TRUE);
 4143|    253|    Curl_disconnect(data, conn, TRUE);
 4144|    253|  }
 4145|       |
 4146|    253|  return result;
 4147|    253|}
url.c:up_free:
  339|  1.31k|{
  340|  1.31k|  struct urlpieces *up = &data->state.up;
  341|  1.31k|  Curl_safefree(up->scheme);
  342|  1.31k|  Curl_safefree(up->hostname);
  343|  1.31k|  Curl_safefree(up->port);
  344|  1.31k|  Curl_safefree(up->user);
  345|  1.31k|  Curl_safefree(up->password);
  346|  1.31k|  Curl_safefree(up->options);
  347|  1.31k|  Curl_safefree(up->path);
  348|  1.31k|  Curl_safefree(up->query);
  349|  1.31k|  curl_url_cleanup(data->state.uh);
  350|  1.31k|  data->state.uh = NULL;
  351|  1.31k|}
url.c:conn_shutdown:
  734|    253|{
  735|    253|  DEBUGASSERT(conn);
  736|    253|  DEBUGASSERT(data);
  737|    253|  infof(data, "Closing connection %ld", conn->connection_id);
  738|       |
  739|    253|#ifndef USE_HYPER
  740|    253|  if(conn->connect_state && conn->connect_state->prot_save) {
  741|       |    /* If this was closed with a CONNECT in progress, cleanup this temporary
  742|       |       struct arrangement */
  743|      0|    data->req.p.http = NULL;
  744|      0|    Curl_safefree(conn->connect_state->prot_save);
  745|      0|  }
  746|    253|#endif
  747|       |
  748|       |  /* possible left-overs from the async name resolvers */
  749|    253|  Curl_resolver_cancel(data);
  750|       |
  751|       |  /* close the SSL stuff before we close any sockets since they will/may
  752|       |     write to the sockets */
  753|    253|  Curl_ssl_close(data, conn, FIRSTSOCKET);
  754|    253|  Curl_ssl_close(data, conn, SECONDARYSOCKET);
  755|       |
  756|       |  /* close possibly still open sockets */
  757|    253|  if(CURL_SOCKET_BAD != conn->sock[SECONDARYSOCKET])
  758|      0|    Curl_closesocket(data, conn, conn->sock[SECONDARYSOCKET]);
  759|    253|  if(CURL_SOCKET_BAD != conn->sock[FIRSTSOCKET])
  760|      0|    Curl_closesocket(data, conn, conn->sock[FIRSTSOCKET]);
  761|    253|  if(CURL_SOCKET_BAD != conn->tempsock[0])
  762|      0|    Curl_closesocket(data, conn, conn->tempsock[0]);
  763|    253|  if(CURL_SOCKET_BAD != conn->tempsock[1])
  764|      0|    Curl_closesocket(data, conn, conn->tempsock[1]);
  765|    253|}
url.c:conn_free:
  768|    253|{
  769|    253|  DEBUGASSERT(conn);
  770|       |
  771|    253|  Curl_free_idnconverted_hostname(&conn->host);
  772|    253|  Curl_free_idnconverted_hostname(&conn->conn_to_host);
  773|    253|#ifndef CURL_DISABLE_PROXY
  774|    253|  Curl_free_idnconverted_hostname(&conn->http_proxy.host);
  775|    253|  Curl_free_idnconverted_hostname(&conn->socks_proxy.host);
  776|    253|  Curl_safefree(conn->http_proxy.user);
  777|    253|  Curl_safefree(conn->socks_proxy.user);
  778|    253|  Curl_safefree(conn->http_proxy.passwd);
  779|    253|  Curl_safefree(conn->socks_proxy.passwd);
  780|    253|  Curl_safefree(conn->http_proxy.host.rawalloc); /* http proxy name buffer */
  781|    253|  Curl_safefree(conn->socks_proxy.host.rawalloc); /* socks proxy name buffer */
  782|    253|  Curl_free_primary_ssl_config(&conn->proxy_ssl_config);
  783|    253|#endif
  784|    253|  Curl_safefree(conn->user);
  785|    253|  Curl_safefree(conn->passwd);
  786|    253|  Curl_safefree(conn->sasl_authzid);
  787|    253|  Curl_safefree(conn->options);
  788|    253|  Curl_dyn_free(&conn->trailer);
  789|    253|  Curl_safefree(conn->host.rawalloc); /* host name buffer */
  790|    253|  Curl_safefree(conn->conn_to_host.rawalloc); /* host name buffer */
  791|    253|  Curl_safefree(conn->hostname_resolve);
  792|    253|  Curl_safefree(conn->secondaryhostname);
  793|    253|  Curl_safefree(conn->connect_state);
  794|       |
  795|    253|  conn_reset_all_postponed_data(conn);
  796|    253|  Curl_llist_destroy(&conn->easyq, NULL);
  797|    253|  Curl_safefree(conn->localdev);
  798|    253|  Curl_free_primary_ssl_config(&conn->ssl_config);
  799|       |
  800|    253|#ifdef USE_UNIX_SOCKETS
  801|    253|  Curl_safefree(conn->unix_domain_socket);
  802|    253|#endif
  803|       |
  804|    253|#ifdef USE_SSL
  805|    253|  Curl_safefree(conn->ssl_extra);
  806|    253|#endif
  807|    253|  free(conn); /* free all the connection oriented data */
  808|    253|}
url.c:create_conn:
 3571|    253|{
 3572|    253|  CURLcode result = CURLE_OK;
 3573|    253|  struct connectdata *conn;
 3574|    253|  struct connectdata *conn_temp = NULL;
 3575|    253|  bool reuse;
 3576|    253|  bool connections_available = TRUE;
 3577|    253|  bool force_reuse = FALSE;
 3578|    253|  bool waitpipe = FALSE;
 3579|    253|  size_t max_host_connections = Curl_multi_max_host_connections(data->multi);
 3580|    253|  size_t max_total_connections = Curl_multi_max_total_connections(data->multi);
 3581|       |
 3582|    253|  *async = FALSE;
 3583|    253|  *in_connect = NULL;
 3584|       |
 3585|       |  /*************************************************************
 3586|       |   * Check input data
 3587|       |   *************************************************************/
 3588|    253|  if(!data->state.url) {
 3589|      0|    result = CURLE_URL_MALFORMAT;
 3590|      0|    goto out;
 3591|      0|  }
 3592|       |
 3593|       |  /* First, split up the current URL in parts so that we can use the
 3594|       |     parts for checking against the already present connections. In order
 3595|       |     to not have to modify everything at once, we allocate a temporary
 3596|       |     connection data struct and fill in for comparison purposes. */
 3597|    253|  conn = allocate_conn(data);
 3598|       |
 3599|    253|  if(!conn) {
 3600|      0|    result = CURLE_OUT_OF_MEMORY;
 3601|      0|    goto out;
 3602|      0|  }
 3603|       |
 3604|       |  /* We must set the return variable as soon as possible, so that our
 3605|       |     parent can cleanup any possible allocs we may have done before
 3606|       |     any failure */
 3607|    253|  *in_connect = conn;
 3608|       |
 3609|    253|  result = parseurlandfillconn(data, conn);
 3610|    253|  if(result)
 3611|    253|    goto out;
 3612|       |
 3613|      0|  if(data->set.str[STRING_SASL_AUTHZID]) {
 3614|      0|    conn->sasl_authzid = strdup(data->set.str[STRING_SASL_AUTHZID]);
 3615|      0|    if(!conn->sasl_authzid) {
 3616|      0|      result = CURLE_OUT_OF_MEMORY;
 3617|      0|      goto out;
 3618|      0|    }
 3619|      0|  }
 3620|       |
 3621|      0|#ifdef USE_UNIX_SOCKETS
 3622|      0|  if(data->set.str[STRING_UNIX_SOCKET_PATH]) {
 3623|      0|    conn->unix_domain_socket = strdup(data->set.str[STRING_UNIX_SOCKET_PATH]);
 3624|      0|    if(!conn->unix_domain_socket) {
 3625|      0|      result = CURLE_OUT_OF_MEMORY;
 3626|      0|      goto out;
 3627|      0|    }
 3628|      0|    conn->bits.abstract_unix_socket = data->set.abstract_unix_socket;
 3629|      0|  }
 3630|      0|#endif
 3631|       |
 3632|       |  /* After the unix socket init but before the proxy vars are used, parse and
 3633|       |     initialize the proxy vars */
 3634|      0|#ifndef CURL_DISABLE_PROXY
 3635|      0|  result = create_conn_helper_init_proxy(data, conn);
 3636|      0|  if(result)
 3637|      0|    goto out;
 3638|       |
 3639|       |  /*************************************************************
 3640|       |   * If the protocol is using SSL and HTTP proxy is used, we set
 3641|       |   * the tunnel_proxy bit.
 3642|       |   *************************************************************/
 3643|      0|  if((conn->given->flags&PROTOPT_SSL) && conn->bits.httpproxy)
 3644|      0|    conn->bits.tunnel_proxy = TRUE;
 3645|      0|#endif
 3646|       |
 3647|       |  /*************************************************************
 3648|       |   * Figure out the remote port number and fix it in the URL
 3649|       |   *************************************************************/
 3650|      0|  result = parse_remote_port(data, conn);
 3651|      0|  if(result)
 3652|      0|    goto out;
 3653|       |
 3654|       |  /* Check for overridden login details and set them accordingly so that
 3655|       |     they are known when protocol->setup_connection is called! */
 3656|      0|  result = override_login(data, conn);
 3657|      0|  if(result)
 3658|      0|    goto out;
 3659|       |
 3660|      0|  result = set_login(conn); /* default credentials */
 3661|      0|  if(result)
 3662|      0|    goto out;
 3663|       |
 3664|       |  /*************************************************************
 3665|       |   * Process the "connect to" linked list of hostname/port mappings.
 3666|       |   * Do this after the remote port number has been fixed in the URL.
 3667|       |   *************************************************************/
 3668|      0|  result = parse_connect_to_slist(data, conn, data->set.connect_to);
 3669|      0|  if(result)
 3670|      0|    goto out;
 3671|       |
 3672|       |  /*************************************************************
 3673|       |   * IDN-convert the hostnames
 3674|       |   *************************************************************/
 3675|      0|  result = Curl_idnconvert_hostname(data, &conn->host);
 3676|      0|  if(result)
 3677|      0|    goto out;
 3678|      0|  if(conn->bits.conn_to_host) {
 3679|      0|    result = Curl_idnconvert_hostname(data, &conn->conn_to_host);
 3680|      0|    if(result)
 3681|      0|      goto out;
 3682|      0|  }
 3683|      0|#ifndef CURL_DISABLE_PROXY
 3684|      0|  if(conn->bits.httpproxy) {
 3685|      0|    result = Curl_idnconvert_hostname(data, &conn->http_proxy.host);
 3686|      0|    if(result)
 3687|      0|      goto out;
 3688|      0|  }
 3689|      0|  if(conn->bits.socksproxy) {
 3690|      0|    result = Curl_idnconvert_hostname(data, &conn->socks_proxy.host);
 3691|      0|    if(result)
 3692|      0|      goto out;
 3693|      0|  }
 3694|      0|#endif
 3695|       |
 3696|       |  /*************************************************************
 3697|       |   * Check whether the host and the "connect to host" are equal.
 3698|       |   * Do this after the hostnames have been IDN-converted.
 3699|       |   *************************************************************/
 3700|      0|  if(conn->bits.conn_to_host &&
 3701|      0|     strcasecompare(conn->conn_to_host.name, conn->host.name)) {
 3702|      0|    conn->bits.conn_to_host = FALSE;
 3703|      0|  }
 3704|       |
 3705|       |  /*************************************************************
 3706|       |   * Check whether the port and the "connect to port" are equal.
 3707|       |   * Do this after the remote port number has been fixed in the URL.
 3708|       |   *************************************************************/
 3709|      0|  if(conn->bits.conn_to_port && conn->conn_to_port == conn->remote_port) {
 3710|      0|    conn->bits.conn_to_port = FALSE;
 3711|      0|  }
 3712|       |
 3713|      0|#ifndef CURL_DISABLE_PROXY
 3714|       |  /*************************************************************
 3715|       |   * If the "connect to" feature is used with an HTTP proxy,
 3716|       |   * we set the tunnel_proxy bit.
 3717|       |   *************************************************************/
 3718|      0|  if((conn->bits.conn_to_host || conn->bits.conn_to_port) &&
 3719|      0|      conn->bits.httpproxy)
 3720|      0|    conn->bits.tunnel_proxy = TRUE;
 3721|      0|#endif
 3722|       |
 3723|       |  /*************************************************************
 3724|       |   * Setup internals depending on protocol. Needs to be done after
 3725|       |   * we figured out what/if proxy to use.
 3726|       |   *************************************************************/
 3727|      0|  result = setup_connection_internals(data, conn);
 3728|      0|  if(result)
 3729|      0|    goto out;
 3730|       |
 3731|      0|  conn->recv[FIRSTSOCKET] = Curl_recv_plain;
 3732|      0|  conn->send[FIRSTSOCKET] = Curl_send_plain;
 3733|      0|  conn->recv[SECONDARYSOCKET] = Curl_recv_plain;
 3734|      0|  conn->send[SECONDARYSOCKET] = Curl_send_plain;
 3735|       |
 3736|      0|  conn->bits.tcp_fastopen = data->set.tcp_fastopen;
 3737|       |
 3738|       |  /***********************************************************************
 3739|       |   * file: is a special case in that it doesn't need a network connection
 3740|       |   ***********************************************************************/
 3741|      0|#ifndef CURL_DISABLE_FILE
 3742|      0|  if(conn->handler->flags & PROTOPT_NONETWORK) {
 3743|      0|    bool done;
 3744|       |    /* this is supposed to be the connect function so we better at least check
 3745|       |       that the file is present here! */
 3746|      0|    DEBUGASSERT(conn->handler->connect_it);
 3747|      0|    Curl_persistconninfo(data, conn, NULL, -1);
 3748|      0|    result = conn->handler->connect_it(data, &done);
 3749|       |
 3750|       |    /* Setup a "faked" transfer that'll do nothing */
 3751|      0|    if(!result) {
 3752|      0|      conn->bits.tcpconnect[FIRSTSOCKET] = TRUE; /* we are "connected */
 3753|       |
 3754|      0|      Curl_attach_connnection(data, conn);
 3755|      0|      result = Curl_conncache_add_conn(data);
 3756|      0|      if(result)
 3757|      0|        goto out;
 3758|       |
 3759|       |      /*
 3760|       |       * Setup whatever necessary for a resumed transfer
 3761|       |       */
 3762|      0|      result = setup_range(data);
 3763|      0|      if(result) {
 3764|      0|        DEBUGASSERT(conn->handler->done);
 3765|       |        /* we ignore the return code for the protocol-specific DONE */
 3766|      0|        (void)conn->handler->done(data, result, FALSE);
 3767|      0|        goto out;
 3768|      0|      }
 3769|      0|      Curl_setup_transfer(data, -1, -1, FALSE, -1);
 3770|      0|    }
 3771|       |
 3772|       |    /* since we skip do_init() */
 3773|      0|    Curl_init_do(data, conn);
 3774|       |
 3775|      0|    goto out;
 3776|      0|  }
 3777|      0|#endif
 3778|       |
 3779|       |  /* Get a cloned copy of the SSL config situation stored in the
 3780|       |     connection struct. But to get this going nicely, we must first make
 3781|       |     sure that the strings in the master copy are pointing to the correct
 3782|       |     strings in the session handle strings array!
 3783|       |
 3784|       |     Keep in mind that the pointers in the master copy are pointing to strings
 3785|       |     that will be freed as part of the Curl_easy struct, but all cloned
 3786|       |     copies will be separately allocated.
 3787|       |  */
 3788|      0|  data->set.ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH];
 3789|      0|  data->set.ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE];
 3790|      0|  data->set.ssl.primary.issuercert = data->set.str[STRING_SSL_ISSUERCERT];
 3791|      0|  data->set.ssl.primary.issuercert_blob = data->set.blobs[BLOB_SSL_ISSUERCERT];
 3792|      0|  data->set.ssl.primary.random_file = data->set.str[STRING_SSL_RANDOM_FILE];
 3793|      0|  data->set.ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];
 3794|      0|  data->set.ssl.primary.cipher_list =
 3795|      0|    data->set.str[STRING_SSL_CIPHER_LIST];
 3796|      0|  data->set.ssl.primary.cipher_list13 =
 3797|      0|    data->set.str[STRING_SSL_CIPHER13_LIST];
 3798|      0|  data->set.ssl.primary.pinned_key =
 3799|      0|    data->set.str[STRING_SSL_PINNEDPUBLICKEY];
 3800|      0|  data->set.ssl.primary.cert_blob = data->set.blobs[BLOB_CERT];
 3801|      0|  data->set.ssl.primary.ca_info_blob = data->set.blobs[BLOB_CAINFO];
 3802|      0|  data->set.ssl.primary.curves = data->set.str[STRING_SSL_EC_CURVES];
 3803|       |
 3804|      0|#ifndef CURL_DISABLE_PROXY
 3805|      0|  data->set.proxy_ssl.primary.CApath = data->set.str[STRING_SSL_CAPATH_PROXY];
 3806|      0|  data->set.proxy_ssl.primary.CAfile = data->set.str[STRING_SSL_CAFILE_PROXY];
 3807|      0|  data->set.proxy_ssl.primary.random_file =
 3808|      0|    data->set.str[STRING_SSL_RANDOM_FILE];
 3809|      0|  data->set.proxy_ssl.primary.egdsocket = data->set.str[STRING_SSL_EGDSOCKET];
 3810|      0|  data->set.proxy_ssl.primary.cipher_list =
 3811|      0|    data->set.str[STRING_SSL_CIPHER_LIST_PROXY];
 3812|      0|  data->set.proxy_ssl.primary.cipher_list13 =
 3813|      0|    data->set.str[STRING_SSL_CIPHER13_LIST_PROXY];
 3814|      0|  data->set.proxy_ssl.primary.pinned_key =
 3815|      0|    data->set.str[STRING_SSL_PINNEDPUBLICKEY_PROXY];
 3816|      0|  data->set.proxy_ssl.primary.cert_blob = data->set.blobs[BLOB_CERT_PROXY];
 3817|      0|  data->set.proxy_ssl.primary.ca_info_blob =
 3818|      0|    data->set.blobs[BLOB_CAINFO_PROXY];
 3819|      0|  data->set.proxy_ssl.primary.issuercert =
 3820|      0|    data->set.str[STRING_SSL_ISSUERCERT_PROXY];
 3821|      0|  data->set.proxy_ssl.primary.issuercert_blob =
 3822|      0|    data->set.blobs[BLOB_SSL_ISSUERCERT_PROXY];
 3823|      0|  data->set.proxy_ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE_PROXY];
 3824|      0|  data->set.proxy_ssl.cert_type = data->set.str[STRING_CERT_TYPE_PROXY];
 3825|      0|  data->set.proxy_ssl.key = data->set.str[STRING_KEY_PROXY];
 3826|      0|  data->set.proxy_ssl.key_type = data->set.str[STRING_KEY_TYPE_PROXY];
 3827|      0|  data->set.proxy_ssl.key_passwd = data->set.str[STRING_KEY_PASSWD_PROXY];
 3828|      0|  data->set.proxy_ssl.primary.clientcert = data->set.str[STRING_CERT_PROXY];
 3829|      0|  data->set.proxy_ssl.key_blob = data->set.blobs[BLOB_KEY_PROXY];
 3830|      0|#endif
 3831|      0|  data->set.ssl.CRLfile = data->set.str[STRING_SSL_CRLFILE];
 3832|      0|  data->set.ssl.cert_type = data->set.str[STRING_CERT_TYPE];
 3833|      0|  data->set.ssl.key = data->set.str[STRING_KEY];
 3834|      0|  data->set.ssl.key_type = data->set.str[STRING_KEY_TYPE];
 3835|      0|  data->set.ssl.key_passwd = data->set.str[STRING_KEY_PASSWD];
 3836|      0|  data->set.ssl.primary.clientcert = data->set.str[STRING_CERT];
 3837|      0|#ifdef USE_TLS_SRP
 3838|      0|  data->set.ssl.username = data->set.str[STRING_TLSAUTH_USERNAME];
 3839|      0|  data->set.ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD];
 3840|      0|#ifndef CURL_DISABLE_PROXY
 3841|      0|  data->set.proxy_ssl.username = data->set.str[STRING_TLSAUTH_USERNAME_PROXY];
 3842|      0|  data->set.proxy_ssl.password = data->set.str[STRING_TLSAUTH_PASSWORD_PROXY];
 3843|      0|#endif
 3844|      0|#endif
 3845|      0|  data->set.ssl.key_blob = data->set.blobs[BLOB_KEY];
 3846|       |
 3847|      0|  if(!Curl_clone_primary_ssl_config(&data->set.ssl.primary,
 3848|      0|                                    &conn->ssl_config)) {
 3849|      0|    result = CURLE_OUT_OF_MEMORY;
 3850|      0|    goto out;
 3851|      0|  }
 3852|       |
 3853|      0|#ifndef CURL_DISABLE_PROXY
 3854|      0|  if(!Curl_clone_primary_ssl_config(&data->set.proxy_ssl.primary,
 3855|      0|                                    &conn->proxy_ssl_config)) {
 3856|      0|    result = CURLE_OUT_OF_MEMORY;
 3857|      0|    goto out;
 3858|      0|  }
 3859|      0|#endif
 3860|       |
 3861|      0|  prune_dead_connections(data);
 3862|       |
 3863|       |  /*************************************************************
 3864|       |   * Check the current list of connections to see if we can
 3865|       |   * re-use an already existing one or if we have to create a
 3866|       |   * new one.
 3867|       |   *************************************************************/
 3868|       |
 3869|      0|  DEBUGASSERT(conn->user);
 3870|      0|  DEBUGASSERT(conn->passwd);
 3871|       |
 3872|       |  /* reuse_fresh is TRUE if we are told to use a new connection by force, but
 3873|       |     we only acknowledge this option if this is not a re-used connection
 3874|       |     already (which happens due to follow-location or during a HTTP
 3875|       |     authentication phase). CONNECT_ONLY transfers also refuse reuse. */
 3876|      0|  if((data->set.reuse_fresh && !data->state.this_is_a_follow) ||
 3877|      0|     data->set.connect_only)
 3878|      0|    reuse = FALSE;
 3879|      0|  else
 3880|      0|    reuse = ConnectionExists(data, conn, &conn_temp, &force_reuse, &waitpipe);
 3881|       |
 3882|      0|  if(reuse) {
 3883|       |    /*
 3884|       |     * We already have a connection for this, we got the former connection in
 3885|       |     * the conn_temp variable and thus we need to cleanup the one we just
 3886|       |     * allocated before we can move along and use the previously existing one.
 3887|       |     */
 3888|      0|    reuse_conn(data, conn, conn_temp);
 3889|      0|#ifdef USE_SSL
 3890|      0|    free(conn->ssl_extra);
 3891|      0|#endif
 3892|      0|    free(conn);          /* we don't need this anymore */
 3893|      0|    conn = conn_temp;
 3894|      0|    *in_connect = conn;
 3895|       |
 3896|      0|#ifndef CURL_DISABLE_PROXY
 3897|      0|    infof(data, "Re-using existing connection! (#%ld) with %s %s",
 3898|      0|          conn->connection_id,
 3899|      0|          conn->bits.proxy?"proxy":"host",
 3900|      0|          conn->socks_proxy.host.name ? conn->socks_proxy.host.dispname :
 3901|      0|          conn->http_proxy.host.name ? conn->http_proxy.host.dispname :
 3902|      0|          conn->host.dispname);
 3903|       |#else
 3904|       |    infof(data, "Re-using existing connection! (#%ld) with host %s",
 3905|       |          conn->connection_id, conn->host.dispname);
 3906|       |#endif
 3907|      0|  }
 3908|      0|  else {
 3909|       |    /* We have decided that we want a new connection. However, we may not
 3910|       |       be able to do that if we have reached the limit of how many
 3911|       |       connections we are allowed to open. */
 3912|       |
 3913|      0|    if(conn->handler->flags & PROTOPT_ALPN_NPN) {
 3914|       |      /* The protocol wants it, so set the bits if enabled in the easy handle
 3915|       |         (default) */
 3916|      0|      if(data->set.ssl_enable_alpn)
 3917|      0|        conn->bits.tls_enable_alpn = TRUE;
 3918|      0|      if(data->set.ssl_enable_npn)
 3919|      0|        conn->bits.tls_enable_npn = TRUE;
 3920|      0|    }
 3921|       |
 3922|      0|    if(waitpipe)
 3923|       |      /* There is a connection that *might* become usable for multiplexing
 3924|       |         "soon", and we wait for that */
 3925|      0|      connections_available = FALSE;
 3926|      0|    else {
 3927|       |      /* this gets a lock on the conncache */
 3928|      0|      const char *bundlehost;
 3929|      0|      struct connectbundle *bundle =
 3930|      0|        Curl_conncache_find_bundle(data, conn, data->state.conn_cache,
 3931|      0|                                   &bundlehost);
 3932|       |
 3933|      0|      if(max_host_connections > 0 && bundle &&
 3934|      0|         (bundle->num_connections >= max_host_connections)) {
 3935|      0|        struct connectdata *conn_candidate;
 3936|       |
 3937|       |        /* The bundle is full. Extract the oldest connection. */
 3938|      0|        conn_candidate = Curl_conncache_extract_bundle(data, bundle);
 3939|      0|        CONNCACHE_UNLOCK(data);
 3940|       |
 3941|      0|        if(conn_candidate)
 3942|      0|          (void)Curl_disconnect(data, conn_candidate, FALSE);
 3943|      0|        else {
 3944|      0|          infof(data, "No more connections allowed to host %s: %zu",
 3945|      0|                bundlehost, max_host_connections);
 3946|      0|          connections_available = FALSE;
 3947|      0|        }
 3948|      0|      }
 3949|      0|      else
 3950|      0|        CONNCACHE_UNLOCK(data);
 3951|       |
 3952|      0|    }
 3953|       |
 3954|      0|    if(connections_available &&
 3955|      0|       (max_total_connections > 0) &&
 3956|      0|       (Curl_conncache_size(data) >= max_total_connections)) {
 3957|      0|      struct connectdata *conn_candidate;
 3958|       |
 3959|       |      /* The cache is full. Let's see if we can kill a connection. */
 3960|      0|      conn_candidate = Curl_conncache_extract_oldest(data);
 3961|      0|      if(conn_candidate)
 3962|      0|        (void)Curl_disconnect(data, conn_candidate, FALSE);
 3963|      0|      else {
 3964|      0|        infof(data, "No connections available in cache");
 3965|      0|        connections_available = FALSE;
 3966|      0|      }
 3967|      0|    }
 3968|       |
 3969|      0|    if(!connections_available) {
 3970|      0|      infof(data, "No connections available.");
 3971|       |
 3972|      0|      conn_free(conn);
 3973|      0|      *in_connect = NULL;
 3974|       |
 3975|      0|      result = CURLE_NO_CONNECTION_AVAILABLE;
 3976|      0|      goto out;
 3977|      0|    }
 3978|      0|    else {
 3979|       |      /*
 3980|       |       * This is a brand new connection, so let's store it in the connection
 3981|       |       * cache of ours!
 3982|       |       */
 3983|      0|      Curl_attach_connnection(data, conn);
 3984|      0|      result = Curl_conncache_add_conn(data);
 3985|      0|      if(result)
 3986|      0|        goto out;
 3987|      0|    }
 3988|       |
 3989|      0|#if defined(USE_NTLM)
 3990|       |    /* If NTLM is requested in a part of this connection, make sure we don't
 3991|       |       assume the state is fine as this is a fresh connection and NTLM is
 3992|       |       connection based. */
 3993|      0|    if((data->state.authhost.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
 3994|      0|       data->state.authhost.done) {
 3995|      0|      infof(data, "NTLM picked AND auth done set, clear picked!");
 3996|      0|      data->state.authhost.picked = CURLAUTH_NONE;
 3997|      0|      data->state.authhost.done = FALSE;
 3998|      0|    }
 3999|       |
 4000|      0|    if((data->state.authproxy.picked & (CURLAUTH_NTLM | CURLAUTH_NTLM_WB)) &&
 4001|      0|       data->state.authproxy.done) {
 4002|      0|      infof(data, "NTLM-proxy picked AND auth done set, clear picked!");
 4003|      0|      data->state.authproxy.picked = CURLAUTH_NONE;
 4004|      0|      data->state.authproxy.done = FALSE;
 4005|      0|    }
 4006|      0|#endif
 4007|      0|  }
 4008|       |
 4009|       |  /* Setup and init stuff before DO starts, in preparing for the transfer. */
 4010|      0|  Curl_init_do(data, conn);
 4011|       |
 4012|       |  /*
 4013|       |   * Setup whatever necessary for a resumed transfer
 4014|       |   */
 4015|      0|  result = setup_range(data);
 4016|      0|  if(result)
 4017|      0|    goto out;
 4018|       |
 4019|       |  /* Continue connectdata initialization here. */
 4020|       |
 4021|       |  /*
 4022|       |   * Inherit the proper values from the urldata struct AFTER we have arranged
 4023|       |   * the persistent connection stuff
 4024|       |   */
 4025|      0|  conn->seek_func = data->set.seek_func;
 4026|      0|  conn->seek_client = data->set.seek_client;
 4027|       |
 4028|       |  /*************************************************************
 4029|       |   * Resolve the address of the server or proxy
 4030|       |   *************************************************************/
 4031|      0|  result = resolve_server(data, conn, async);
 4032|       |
 4033|       |  /* Strip trailing dots. resolve_server copied the name. */
 4034|      0|  strip_trailing_dot(&conn->host);
 4035|      0|#ifndef CURL_DISABLE_PROXY
 4036|      0|  if(conn->bits.httpproxy)
 4037|      0|    strip_trailing_dot(&conn->http_proxy.host);
 4038|      0|  if(conn->bits.socksproxy)
 4039|      0|    strip_trailing_dot(&conn->socks_proxy.host);
 4040|      0|#endif
 4041|      0|  if(conn->bits.conn_to_host)
 4042|      0|    strip_trailing_dot(&conn->conn_to_host);
 4043|       |
 4044|    253|out:
 4045|    253|  return result;
 4046|      0|}
url.c:allocate_conn:
 1674|    253|{
 1675|    253|  struct connectdata *conn = calloc(1, sizeof(struct connectdata));
 1676|    253|  if(!conn)
 1677|      0|    return NULL;
 1678|       |
 1679|    253|#ifdef USE_SSL
 1680|       |  /* The SSL backend-specific data (ssl_backend_data) objects are allocated as
 1681|       |     a separate array to ensure suitable alignment.
 1682|       |     Note that these backend pointers can be swapped by vtls (eg ssl backend
 1683|       |     data becomes proxy backend data). */
 1684|    253|  {
 1685|    253|    size_t sslsize = Curl_ssl->sizeof_ssl_backend_data;
 1686|    253|    char *ssl = calloc(4, sslsize);
 1687|    253|    if(!ssl) {
 1688|      0|      free(conn);
 1689|      0|      return NULL;
 1690|      0|    }
 1691|    253|    conn->ssl_extra = ssl;
 1692|    253|    conn->ssl[0].backend = (void *)ssl;
 1693|    253|    conn->ssl[1].backend = (void *)(ssl + sslsize);
 1694|    253|#ifndef CURL_DISABLE_PROXY
 1695|    253|    conn->proxy_ssl[0].backend = (void *)(ssl + 2 * sslsize);
 1696|    253|    conn->proxy_ssl[1].backend = (void *)(ssl + 3 * sslsize);
 1697|    253|#endif
 1698|    253|  }
 1699|      0|#endif
 1700|       |
 1701|      0|  conn->handler = &Curl_handler_dummy;  /* Be sure we have a handler defined
 1702|       |                                           already from start to avoid NULL
 1703|       |                                           situations and checks */
 1704|       |
 1705|       |  /* and we setup a few fields in case we end up actually using this struct */
 1706|       |
 1707|    253|  conn->sock[FIRSTSOCKET] = CURL_SOCKET_BAD;     /* no file descriptor */
 1708|    253|  conn->sock[SECONDARYSOCKET] = CURL_SOCKET_BAD; /* no file descriptor */
 1709|    253|  conn->tempsock[0] = CURL_SOCKET_BAD; /* no file descriptor */
 1710|    253|  conn->tempsock[1] = CURL_SOCKET_BAD; /* no file descriptor */
 1711|    253|  conn->connection_id = -1;    /* no ID */
 1712|    253|  conn->port = -1; /* unknown at this point */
 1713|    253|  conn->remote_port = -1; /* unknown at this point */
 1714|       |#if defined(USE_RECV_BEFORE_SEND_WORKAROUND) && defined(DEBUGBUILD)
 1715|       |  conn->postponed[0].bindsock = CURL_SOCKET_BAD; /* no file descriptor */
 1716|       |  conn->postponed[1].bindsock = CURL_SOCKET_BAD; /* no file descriptor */
 1717|       |#endif /* USE_RECV_BEFORE_SEND_WORKAROUND && DEBUGBUILD */
 1718|       |
 1719|       |  /* Default protocol-independent behavior doesn't support persistent
 1720|       |     connections, so we set this to force-close. Protocols that support
 1721|       |     this need to set this to FALSE in their "curl_do" functions. */
 1722|    253|  connclose(conn, "Default to force-close");
 1723|       |
 1724|       |  /* Store creation time to help future close decision making */
 1725|    253|  conn->created = Curl_now();
 1726|       |
 1727|       |  /* Store current time to give a baseline to keepalive connection times. */
 1728|    253|  conn->keepalive = Curl_now();
 1729|       |
 1730|    253|#ifndef CURL_DISABLE_PROXY
 1731|    253|  conn->http_proxy.proxytype = data->set.proxytype;
 1732|    253|  conn->socks_proxy.proxytype = CURLPROXY_SOCKS4;
 1733|       |
 1734|       |  /* note that these two proxy bits are now just on what looks to be
 1735|       |     requested, they may be altered down the road */
 1736|    253|  conn->bits.proxy = (data->set.str[STRING_PROXY] &&
 1737|    253|                      *data->set.str[STRING_PROXY]) ? TRUE : FALSE;
 1738|    253|  conn->bits.httpproxy = (conn->bits.proxy &&
 1739|    253|                          (conn->http_proxy.proxytype == CURLPROXY_HTTP ||
 1740|      0|                           conn->http_proxy.proxytype == CURLPROXY_HTTP_1_0 ||
 1741|      0|                           conn->http_proxy.proxytype == CURLPROXY_HTTPS)) ?
 1742|    253|                           TRUE : FALSE;
 1743|    253|  conn->bits.socksproxy = (conn->bits.proxy &&
 1744|    253|                           !conn->bits.httpproxy) ? TRUE : FALSE;
 1745|       |
 1746|    253|  if(data->set.str[STRING_PRE_PROXY] && *data->set.str[STRING_PRE_PROXY]) {
 1747|      0|    conn->bits.proxy = TRUE;
 1748|      0|    conn->bits.socksproxy = TRUE;
 1749|      0|  }
 1750|       |
 1751|    253|  conn->bits.proxy_user_passwd =
 1752|    253|    (data->state.aptr.proxyuser) ? TRUE : FALSE;
 1753|    253|  conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;
 1754|    253|#endif /* CURL_DISABLE_PROXY */
 1755|       |
 1756|    253|  conn->bits.user_passwd = (data->state.aptr.user) ? TRUE : FALSE;
 1757|    253|#ifndef CURL_DISABLE_FTP
 1758|    253|  conn->bits.ftp_use_epsv = data->set.ftp_use_epsv;
 1759|    253|  conn->bits.ftp_use_eprt = data->set.ftp_use_eprt;
 1760|    253|#endif
 1761|    253|  conn->ssl_config.verifystatus = data->set.ssl.primary.verifystatus;
 1762|    253|  conn->ssl_config.verifypeer = data->set.ssl.primary.verifypeer;
 1763|    253|  conn->ssl_config.verifyhost = data->set.ssl.primary.verifyhost;
 1764|    253|#ifndef CURL_DISABLE_PROXY
 1765|    253|  conn->proxy_ssl_config.verifystatus =
 1766|    253|    data->set.proxy_ssl.primary.verifystatus;
 1767|    253|  conn->proxy_ssl_config.verifypeer = data->set.proxy_ssl.primary.verifypeer;
 1768|    253|  conn->proxy_ssl_config.verifyhost = data->set.proxy_ssl.primary.verifyhost;
 1769|    253|#endif
 1770|    253|  conn->ip_version = data->set.ipver;
 1771|    253|  conn->bits.connect_only = data->set.connect_only;
 1772|    253|  conn->transport = TRNSPRT_TCP; /* most of them are TCP streams */
 1773|       |
 1774|    253|#if !defined(CURL_DISABLE_HTTP) && defined(USE_NTLM) && \
 1775|    253|    defined(NTLM_WB_ENABLED)
 1776|    253|  conn->ntlm.ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;
 1777|    253|  conn->proxyntlm.ntlm_auth_hlpr_socket = CURL_SOCKET_BAD;
 1778|    253|#endif
 1779|       |
 1780|       |  /* Initialize the easy handle list */
 1781|    253|  Curl_llist_init(&conn->easyq, NULL);
 1782|       |
 1783|       |#ifdef HAVE_GSSAPI
 1784|       |  conn->data_prot = PROT_CLEAR;
 1785|       |#endif
 1786|       |
 1787|       |  /* Store the local bind parameters that will be used for this connection */
 1788|    253|  if(data->set.str[STRING_DEVICE]) {
 1789|      0|    conn->localdev = strdup(data->set.str[STRING_DEVICE]);
 1790|      0|    if(!conn->localdev)
 1791|      0|      goto error;
 1792|      0|  }
 1793|    253|  conn->localportrange = data->set.localportrange;
 1794|    253|  conn->localport = data->set.localport;
 1795|       |
 1796|       |  /* the close socket stuff needs to be copied to the connection struct as
 1797|       |     it may live on without (this specific) Curl_easy */
 1798|    253|  conn->fclosesocket = data->set.fclosesocket;
 1799|    253|  conn->closesocket_client = data->set.closesocket_client;
 1800|    253|  conn->lastused = Curl_now(); /* used now */
 1801|       |
 1802|    253|  return conn;
 1803|      0|  error:
 1804|       |
 1805|      0|  Curl_llist_destroy(&conn->easyq, NULL);
 1806|      0|  free(conn->localdev);
 1807|      0|#ifdef USE_SSL
 1808|      0|  free(conn->ssl_extra);
 1809|      0|#endif
 1810|      0|  free(conn);
 1811|      0|  return NULL;
 1812|    253|}
url.c:parseurlandfillconn:
 1932|    253|{
 1933|    253|  CURLcode result;
 1934|    253|  CURLU *uh;
 1935|    253|  CURLUcode uc;
 1936|    253|  char *hostname;
 1937|    253|  bool use_set_uh = (data->set.uh && !data->state.this_is_a_follow);
 1938|       |
 1939|    253|  up_free(data); /* cleanup previous leftovers first */
 1940|       |
 1941|       |  /* parse the URL */
 1942|    253|  if(use_set_uh) {
 1943|      0|    uh = data->state.uh = curl_url_dup(data->set.uh);
 1944|      0|  }
 1945|    253|  else {
 1946|    253|    uh = data->state.uh = curl_url();
 1947|    253|  }
 1948|       |
 1949|    253|  if(!uh)
 1950|      0|    return CURLE_OUT_OF_MEMORY;
 1951|       |
 1952|    253|  if(data->set.str[STRING_DEFAULT_PROTOCOL] &&
 1953|    253|     !Curl_is_absolute_url(data->state.url, NULL, MAX_SCHEME_LEN)) {
 1954|      0|    char *url = aprintf("%s://%s", data->set.str[STRING_DEFAULT_PROTOCOL],
 1955|      0|                        data->state.url);
 1956|      0|    if(!url)
 1957|      0|      return CURLE_OUT_OF_MEMORY;
 1958|      0|    if(data->state.url_alloc)
 1959|      0|      free(data->state.url);
 1960|      0|    data->state.url = url;
 1961|      0|    data->state.url_alloc = TRUE;
 1962|      0|  }
 1963|       |
 1964|    253|  if(!use_set_uh) {
 1965|    253|    char *newurl;
 1966|    253|    uc = curl_url_set(uh, CURLUPART_URL, data->state.url,
 1967|    253|                    CURLU_GUESS_SCHEME |
 1968|    253|                    CURLU_NON_SUPPORT_SCHEME |
 1969|    253|                    (data->set.disallow_username_in_url ?
 1970|    253|                     CURLU_DISALLOW_USER : 0) |
 1971|    253|                    (data->set.path_as_is ? CURLU_PATH_AS_IS : 0));
 1972|    253|    if(uc) {
 1973|     85|      DEBUGF(infof(data, "curl_url_set rejected %s: %s", data->state.url,
 1974|     85|                   curl_url_strerror(uc)));
 1975|     85|      return Curl_uc_to_curlcode(uc);
 1976|     85|    }
 1977|       |
 1978|       |    /* after it was parsed, get the generated normalized version */
 1979|    168|    uc = curl_url_get(uh, CURLUPART_URL, &newurl, 0);
 1980|    168|    if(uc)
 1981|      0|      return Curl_uc_to_curlcode(uc);
 1982|    168|    if(data->state.url_alloc)
 1983|      0|      free(data->state.url);
 1984|    168|    data->state.url = newurl;
 1985|    168|    data->state.url_alloc = TRUE;
 1986|    168|  }
 1987|       |
 1988|    168|  uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);
 1989|    168|  if(uc)
 1990|      0|    return Curl_uc_to_curlcode(uc);
 1991|       |
 1992|    168|  uc = curl_url_get(uh, CURLUPART_HOST, &data->state.up.hostname, 0);
 1993|    168|  if(uc) {
 1994|      5|    if(!strcasecompare("file", data->state.up.scheme))
 1995|      0|      return CURLE_OUT_OF_MEMORY;
 1996|      5|  }
 1997|       |
 1998|    168|#ifndef CURL_DISABLE_HSTS
 1999|    168|  if(data->hsts && strcasecompare("http", data->state.up.scheme)) {
 2000|      0|    if(Curl_hsts(data->hsts, data->state.up.hostname, TRUE)) {
 2001|      0|      char *url;
 2002|      0|      Curl_safefree(data->state.up.scheme);
 2003|      0|      uc = curl_url_set(uh, CURLUPART_SCHEME, "https", 0);
 2004|      0|      if(uc)
 2005|      0|        return Curl_uc_to_curlcode(uc);
 2006|      0|      if(data->state.url_alloc)
 2007|      0|        Curl_safefree(data->state.url);
 2008|       |      /* after update, get the updated version */
 2009|      0|      uc = curl_url_get(uh, CURLUPART_URL, &url, 0);
 2010|      0|      if(uc)
 2011|      0|        return Curl_uc_to_curlcode(uc);
 2012|      0|      uc = curl_url_get(uh, CURLUPART_SCHEME, &data->state.up.scheme, 0);
 2013|      0|      if(uc) {
 2014|      0|        free(url);
 2015|      0|        return Curl_uc_to_curlcode(uc);
 2016|      0|      }
 2017|      0|      data->state.url = url;
 2018|      0|      data->state.url_alloc = TRUE;
 2019|      0|      infof(data, "Switched from HTTP to HTTPS due to HSTS => %s",
 2020|      0|            data->state.url);
 2021|      0|    }
 2022|      0|  }
 2023|    168|#endif
 2024|       |
 2025|    168|  result = findprotocol(data, conn, data->state.up.scheme);
 2026|    168|  if(result)
 2027|    168|    return result;
 2028|       |
 2029|       |  /*
 2030|       |   * User name and password set with their own options override the
 2031|       |   * credentials possibly set in the URL.
 2032|       |   */
 2033|      0|  if(!data->state.aptr.user) {
 2034|       |    /* we don't use the URL API's URL decoder option here since it rejects
 2035|       |       control codes and we want to allow them for some schemes in the user
 2036|       |       and password fields */
 2037|      0|    uc = curl_url_get(uh, CURLUPART_USER, &data->state.up.user, 0);
 2038|      0|    if(!uc) {
 2039|      0|      char *decoded;
 2040|      0|      result = Curl_urldecode(NULL, data->state.up.user, 0, &decoded, NULL,
 2041|      0|                              conn->handler->flags&PROTOPT_USERPWDCTRL ?
 2042|      0|                              REJECT_ZERO : REJECT_CTRL);
 2043|      0|      if(result)
 2044|      0|        return result;
 2045|      0|      conn->user = decoded;
 2046|      0|      conn->bits.user_passwd = TRUE;
 2047|      0|      result = Curl_setstropt(&data->state.aptr.user, decoded);
 2048|      0|      if(result)
 2049|      0|        return result;
 2050|      0|    }
 2051|      0|    else if(uc != CURLUE_NO_USER)
 2052|      0|      return Curl_uc_to_curlcode(uc);
 2053|      0|  }
 2054|       |
 2055|      0|  if(!data->state.aptr.passwd) {
 2056|      0|    uc = curl_url_get(uh, CURLUPART_PASSWORD, &data->state.up.password, 0);
 2057|      0|    if(!uc) {
 2058|      0|      char *decoded;
 2059|      0|      result = Curl_urldecode(NULL, data->state.up.password, 0, &decoded, NULL,
 2060|      0|                              conn->handler->flags&PROTOPT_USERPWDCTRL ?
 2061|      0|                              REJECT_ZERO : REJECT_CTRL);
 2062|      0|      if(result)
 2063|      0|        return result;
 2064|      0|      conn->passwd = decoded;
 2065|      0|      conn->bits.user_passwd = TRUE;
 2066|      0|      result = Curl_setstropt(&data->state.aptr.passwd, decoded);
 2067|      0|      if(result)
 2068|      0|        return result;
 2069|      0|    }
 2070|      0|    else if(uc != CURLUE_NO_PASSWORD)
 2071|      0|      return Curl_uc_to_curlcode(uc);
 2072|      0|  }
 2073|       |
 2074|      0|  uc = curl_url_get(uh, CURLUPART_OPTIONS, &data->state.up.options,
 2075|      0|                    CURLU_URLDECODE);
 2076|      0|  if(!uc) {
 2077|      0|    conn->options = strdup(data->state.up.options);
 2078|      0|    if(!conn->options)
 2079|      0|      return CURLE_OUT_OF_MEMORY;
 2080|      0|  }
 2081|      0|  else if(uc != CURLUE_NO_OPTIONS)
 2082|      0|    return Curl_uc_to_curlcode(uc);
 2083|       |
 2084|      0|  uc = curl_url_get(uh, CURLUPART_PATH, &data->state.up.path, 0);
 2085|      0|  if(uc)
 2086|      0|    return Curl_uc_to_curlcode(uc);
 2087|       |
 2088|      0|  uc = curl_url_get(uh, CURLUPART_PORT, &data->state.up.port,
 2089|      0|                    CURLU_DEFAULT_PORT);
 2090|      0|  if(uc) {
 2091|      0|    if(!strcasecompare("file", data->state.up.scheme))
 2092|      0|      return CURLE_OUT_OF_MEMORY;
 2093|      0|  }
 2094|      0|  else {
 2095|      0|    unsigned long port = strtoul(data->state.up.port, NULL, 10);
 2096|      0|    conn->port = conn->remote_port =
 2097|      0|      (data->set.use_port && data->state.allow_port) ?
 2098|      0|      (int)data->set.use_port : curlx_ultous(port);
 2099|      0|  }
 2100|       |
 2101|      0|  (void)curl_url_get(uh, CURLUPART_QUERY, &data->state.up.query, 0);
 2102|       |
 2103|      0|  hostname = data->state.up.hostname;
 2104|      0|  if(hostname && hostname[0] == '[') {
 2105|       |    /* This looks like an IPv6 address literal. See if there is an address
 2106|       |       scope. */
 2107|      0|    size_t hlen;
 2108|      0|    conn->bits.ipv6_ip = TRUE;
 2109|       |    /* cut off the brackets! */
 2110|      0|    hostname++;
 2111|      0|    hlen = strlen(hostname);
 2112|      0|    hostname[hlen - 1] = 0;
 2113|       |
 2114|      0|    zonefrom_url(uh, data, conn);
 2115|      0|  }
 2116|       |
 2117|       |  /* make sure the connect struct gets its own copy of the host name */
 2118|      0|  conn->host.rawalloc = strdup(hostname ? hostname : "");
 2119|      0|  if(!conn->host.rawalloc)
 2120|      0|    return CURLE_OUT_OF_MEMORY;
 2121|      0|  conn->host.name = conn->host.rawalloc;
 2122|       |
 2123|      0|  if(data->set.scope_id)
 2124|       |    /* Override any scope that was set above.  */
 2125|      0|    conn->scope_id = data->set.scope_id;
 2126|       |
 2127|      0|  return CURLE_OK;
 2128|      0|}
url.c:findprotocol:
 1832|    168|{
 1833|    168|  const struct Curl_handler *p = Curl_builtin_scheme(protostr);
 1834|       |
 1835|    168|  if(p && /* Protocol found in table. Check if allowed */
 1836|    168|     (data->set.allowed_protocols & p->protocol)) {
 1837|       |
 1838|       |    /* it is allowed for "normal" request, now do an extra check if this is
 1839|       |       the result of a redirect */
 1840|      0|    if(data->state.this_is_a_follow &&
 1841|      0|       !(data->set.redir_protocols & p->protocol))
 1842|       |      /* nope, get out */
 1843|      0|      ;
 1844|      0|    else {
 1845|       |      /* Perform setup complement if some. */
 1846|      0|      conn->handler = conn->given = p;
 1847|       |
 1848|       |      /* 'port' and 'remote_port' are set in setup_connection_internals() */
 1849|      0|      return CURLE_OK;
 1850|      0|    }
 1851|      0|  }
 1852|       |
 1853|       |  /* The protocol was not found in the table, but we don't have to assign it
 1854|       |     to anything since it is already assigned to a dummy-struct in the
 1855|       |     create_conn() function when the connectdata struct is allocated. */
 1856|    168|  failf(data, "Protocol \"%s\" not supported or disabled in " LIBCURL_NAME,
 1857|    168|        protostr);
 1858|       |
 1859|    168|  return CURLE_UNSUPPORTED_PROTOCOL;
 1860|    168|}

Curl_is_absolute_url:
  236|    506|{
  237|    506|  size_t i;
  238|       |#ifdef WIN32
  239|       |  if(STARTS_WITH_DRIVE_PREFIX(url))
  240|       |    return FALSE;
  241|       |#endif
  242|  2.16k|  for(i = 0; i < buflen && url[i]; ++i) {
  243|  2.07k|    char s = url[i];
  244|  2.07k|    if((s == ':') && (url[i + 1] == '/')) {
  245|    106|      if(buf)
  246|     53|        buf[i] = 0;
  247|    106|      return TRUE;
  248|    106|    }
  249|       |    /* RFC 3986 3.1 explains:
  250|       |      scheme      = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
  251|       |    */
  252|  1.96k|    else if(ISALNUM(s) || (s == '+') || (s == '-') || (s == '.') ) {
  253|  1.65k|      if(buf)
  254|    829|        buf[i] = (char)TOLOWER(s);
  255|  1.65k|    }
  256|    306|    else
  257|    306|      break;
  258|  2.07k|  }
  259|    400|  return FALSE;
  260|    506|}
Curl_parse_port:
  500|    194|{
  501|    194|  char *portptr = NULL;
  502|    194|  char endbracket;
  503|    194|  int len;
  504|       |
  505|       |  /*
  506|       |   * Find the end of an IPv6 address, either on the ']' ending bracket or
  507|       |   * a percent-encoded zone index.
  508|       |   */
  509|    194|  if(1 == sscanf(hostname, "[%*45[0123456789abcdefABCDEF:.]%c%n",
  510|    194|                 &endbracket, &len)) {
  511|      9|    if(']' == endbracket)
  512|      3|      portptr = &hostname[len];
  513|      6|    else if('%' == endbracket) {
  514|      5|      int zonelen = len;
  515|      5|      if(1 == sscanf(hostname + zonelen, "%*[^]]%c%n", &endbracket, &len)) {
  516|      4|        if(']' != endbracket)
  517|      0|          return CURLUE_MALFORMED_INPUT;
  518|      4|        portptr = &hostname[--zonelen + len + 1];
  519|      4|      }
  520|      1|      else
  521|      1|        return CURLUE_MALFORMED_INPUT;
  522|      5|    }
  523|      1|    else
  524|      1|      return CURLUE_MALFORMED_INPUT;
  525|       |
  526|       |    /* this is a RFC2732-style specified IP-address */
  527|      7|    if(portptr && *portptr) {
  528|      2|      if(*portptr != ':')
  529|      1|        return CURLUE_MALFORMED_INPUT;
  530|      2|    }
  531|      5|    else
  532|      5|      portptr = NULL;
  533|      7|  }
  534|    185|  else
  535|    185|    portptr = strchr(hostname, ':');
  536|       |
  537|    191|  if(portptr) {
  538|     19|    char *rest;
  539|     19|    long port;
  540|     19|    char portbuf[7];
  541|       |
  542|       |    /* Browser behavior adaptation. If there's a colon with no digits after,
  543|       |       just cut off the name there which makes us ignore the colon and just
  544|       |       use the default port. Firefox, Chrome and Safari all do that.
  545|       |
  546|       |       Don't do it if the URL has no scheme, to make something that looks like
  547|       |       a scheme not work!
  548|       |    */
  549|     19|    if(!portptr[1]) {
  550|      2|      *portptr = '\0';
  551|      2|      return has_scheme ? CURLUE_OK : CURLUE_BAD_PORT_NUMBER;
  552|      2|    }
  553|       |
  554|     17|    if(!ISDIGIT(portptr[1]))
  555|      2|      return CURLUE_BAD_PORT_NUMBER;
  556|       |
  557|     15|    port = strtol(portptr + 1, &rest, 10);  /* Port number must be decimal */
  558|       |
  559|     15|    if((port <= 0) || (port > 0xffff))
  560|       |      /* Single unix standard says port numbers are 16 bits long, but we don't
  561|       |         treat port zero as OK. */
  562|      3|      return CURLUE_BAD_PORT_NUMBER;
  563|       |
  564|     12|    if(rest[0])
  565|      3|      return CURLUE_BAD_PORT_NUMBER;
  566|       |
  567|      9|    *portptr++ = '\0'; /* cut off the name there */
  568|      9|    *rest = 0;
  569|       |    /* generate a new port number string to get rid of leading zeroes etc */
  570|      9|    msnprintf(portbuf, sizeof(portbuf), "%ld", port);
  571|      9|    u->portnum = port;
  572|      9|    u->port = strdup(portbuf);
  573|      9|    if(!u->port)
  574|      0|      return CURLUE_OUT_OF_MEMORY;
  575|      9|  }
  576|       |
  577|    181|  return CURLUE_OK;
  578|    191|}
curl_url:
 1117|    506|{
 1118|    506|  return calloc(sizeof(struct Curl_URL), 1);
 1119|    506|}
curl_url_cleanup:
 1122|  1.39k|{
 1123|  1.39k|  if(u) {
 1124|    338|    free_urlhandle(u);
 1125|    338|    free(u);
 1126|    338|  }
 1127|  1.39k|}
curl_url_get:
 1161|    704|{
 1162|    704|  char *ptr;
 1163|    704|  CURLUcode ifmissing = CURLUE_UNKNOWN_PART;
 1164|    704|  char portbuf[7];
 1165|    704|  bool urldecode = (flags & CURLU_URLDECODE)?1:0;
 1166|    704|  bool urlencode = (flags & CURLU_URLENCODE)?1:0;
 1167|    704|  bool plusdecode = FALSE;
 1168|    704|  (void)flags;
 1169|    704|  if(!u)
 1170|      0|    return CURLUE_BAD_HANDLE;
 1171|    704|  if(!part)
 1172|      0|    return CURLUE_BAD_PARTPOINTER;
 1173|    704|  *part = NULL;
 1174|       |
 1175|    704|  switch(what) {
 1176|    168|  case CURLUPART_SCHEME:
 1177|    168|    ptr = u->scheme;
 1178|    168|    ifmissing = CURLUE_NO_SCHEME;
 1179|    168|    urldecode = FALSE; /* never for schemes */
 1180|    168|    break;
 1181|      0|  case CURLUPART_USER:
 1182|      0|    ptr = u->user;
 1183|      0|    ifmissing = CURLUE_NO_USER;
 1184|      0|    break;
 1185|      0|  case CURLUPART_PASSWORD:
 1186|      0|    ptr = u->password;
 1187|      0|    ifmissing = CURLUE_NO_PASSWORD;
 1188|      0|    break;
 1189|      0|  case CURLUPART_OPTIONS:
 1190|      0|    ptr = u->options;
 1191|      0|    ifmissing = CURLUE_NO_OPTIONS;
 1192|      0|    break;
 1193|    168|  case CURLUPART_HOST:
 1194|    168|    ptr = u->host;
 1195|    168|    ifmissing = CURLUE_NO_HOST;
 1196|    168|    break;
 1197|      0|  case CURLUPART_ZONEID:
 1198|      0|    ptr = u->zoneid;
 1199|      0|    break;
 1200|      0|  case CURLUPART_PORT:
 1201|      0|    ptr = u->port;
 1202|      0|    ifmissing = CURLUE_NO_PORT;
 1203|      0|    urldecode = FALSE; /* never for port */
 1204|      0|    if(!ptr && (flags & CURLU_DEFAULT_PORT) && u->scheme) {
 1205|       |      /* there's no stored port number, but asked to deliver
 1206|       |         a default one for the scheme */
 1207|      0|      const struct Curl_handler *h =
 1208|      0|        Curl_builtin_scheme(u->scheme);
 1209|      0|      if(h) {
 1210|      0|        msnprintf(portbuf, sizeof(portbuf), "%u", h->defport);
 1211|      0|        ptr = portbuf;
 1212|      0|      }
 1213|      0|    }
 1214|      0|    else if(ptr && u->scheme) {
 1215|       |      /* there is a stored port number, but ask to inhibit if
 1216|       |         it matches the default one for the scheme */
 1217|      0|      const struct Curl_handler *h =
 1218|      0|        Curl_builtin_scheme(u->scheme);
 1219|      0|      if(h && (h->defport == u->portnum) &&
 1220|      0|         (flags & CURLU_NO_DEFAULT_PORT))
 1221|      0|        ptr = NULL;
 1222|      0|    }
 1223|      0|    break;
 1224|      0|  case CURLUPART_PATH:
 1225|      0|    ptr = u->path;
 1226|      0|    if(!ptr) {
 1227|      0|      ptr = u->path = strdup("/");
 1228|      0|      if(!u->path)
 1229|      0|        return CURLUE_OUT_OF_MEMORY;
 1230|      0|    }
 1231|      0|    break;
 1232|      0|  case CURLUPART_QUERY:
 1233|      0|    ptr = u->query;
 1234|      0|    ifmissing = CURLUE_NO_QUERY;
 1235|      0|    plusdecode = urldecode;
 1236|      0|    break;
 1237|      0|  case CURLUPART_FRAGMENT:
 1238|      0|    ptr = u->fragment;
 1239|      0|    ifmissing = CURLUE_NO_FRAGMENT;
 1240|      0|    break;
 1241|    368|  case CURLUPART_URL: {
 1242|    368|    char *url;
 1243|    368|    char *scheme;
 1244|    368|    char *options = u->options;
 1245|    368|    char *port = u->port;
 1246|    368|    char *allochost = NULL;
 1247|    368|    if(u->scheme && strcasecompare("file", u->scheme)) {
 1248|      5|      url = aprintf("file://%s%s%s",
 1249|      5|                    u->path,
 1250|      5|                    u->fragment? "#": "",
 1251|      5|                    u->fragment? u->fragment : "");
 1252|      5|    }
 1253|    363|    else if(!u->host)
 1254|    200|      return CURLUE_NO_HOST;
 1255|    163|    else {
 1256|    163|      const struct Curl_handler *h = NULL;
 1257|    163|      if(u->scheme)
 1258|    163|        scheme = u->scheme;
 1259|      0|      else if(flags & CURLU_DEFAULT_SCHEME)
 1260|      0|        scheme = (char *) DEFAULT_SCHEME;
 1261|      0|      else
 1262|      0|        return CURLUE_NO_SCHEME;
 1263|       |
 1264|    163|      h = Curl_builtin_scheme(scheme);
 1265|    163|      if(!port && (flags & CURLU_DEFAULT_PORT)) {
 1266|       |        /* there's no stored port number, but asked to deliver
 1267|       |           a default one for the scheme */
 1268|      0|        if(h) {
 1269|      0|          msnprintf(portbuf, sizeof(portbuf), "%u", h->defport);
 1270|      0|          port = portbuf;
 1271|      0|        }
 1272|      0|      }
 1273|    163|      else if(port) {
 1274|       |        /* there is a stored port number, but asked to inhibit if it matches
 1275|       |           the default one for the scheme */
 1276|      6|        if(h && (h->defport == u->portnum) &&
 1277|      6|           (flags & CURLU_NO_DEFAULT_PORT))
 1278|      0|          port = NULL;
 1279|      6|      }
 1280|       |
 1281|    163|      if(h && !(h->flags & PROTOPT_URLOPTIONS))
 1282|    144|        options = NULL;
 1283|       |
 1284|    163|      if(u->host[0] == '[') {
 1285|      0|        if(u->zoneid) {
 1286|       |          /* make it '[ host %25 zoneid ]' */
 1287|      0|          size_t hostlen = strlen(u->host);
 1288|      0|          size_t alen = hostlen + 3 + strlen(u->zoneid) + 1;
 1289|      0|          allochost = malloc(alen);
 1290|      0|          if(!allochost)
 1291|      0|            return CURLUE_OUT_OF_MEMORY;
 1292|      0|          memcpy(allochost, u->host, hostlen - 1);
 1293|      0|          msnprintf(&allochost[hostlen - 1], alen - hostlen + 1,
 1294|      0|                    "%%25%s]", u->zoneid);
 1295|      0|        }
 1296|      0|      }
 1297|    163|      else if(urlencode) {
 1298|      0|        allochost = curl_easy_escape(NULL, u->host, 0);
 1299|      0|        if(!allochost)
 1300|      0|          return CURLUE_OUT_OF_MEMORY;
 1301|      0|      }
 1302|    163|      else {
 1303|       |        /* only encode '%' in output host name */
 1304|    163|        char *host = u->host;
 1305|    163|        size_t pcount = 0;
 1306|       |        /* first, count number of percents present in the name */
 1307|  3.58k|        while(*host) {
 1308|  3.42k|          if(*host == '%')
 1309|    190|            pcount++;
 1310|  3.42k|          host++;
 1311|  3.42k|        }
 1312|       |        /* if there were percents, encode the host name */
 1313|    163|        if(pcount) {
 1314|     26|          size_t hostlen = strlen(u->host);
 1315|     26|          size_t alen = hostlen + 2 * pcount + 1;
 1316|     26|          char *o = allochost = malloc(alen);
 1317|     26|          if(!allochost)
 1318|      0|            return CURLUE_OUT_OF_MEMORY;
 1319|       |
 1320|     26|          host = u->host;
 1321|    894|          while(*host) {
 1322|    868|            if(*host == '%') {
 1323|    190|              memcpy(o, "%25", 3);
 1324|    190|              o += 3;
 1325|    190|              host++;
 1326|    190|              continue;
 1327|    190|            }
 1328|    678|            *o++ = *host++;
 1329|    678|          }
 1330|     26|          *o = '\0';
 1331|     26|        }
 1332|    163|      }
 1333|       |
 1334|    163|      url = aprintf("%s://%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
 1335|    163|                    scheme,
 1336|    163|                    u->user ? u->user : "",
 1337|    163|                    u->password ? ":": "",
 1338|    163|                    u->password ? u->password : "",
 1339|    163|                    options ? ";" : "",
 1340|    163|                    options ? options : "",
 1341|    163|                    (u->user || u->password || options) ? "@": "",
 1342|    163|                    allochost ? allochost : u->host,
 1343|    163|                    port ? ":": "",
 1344|    163|                    port ? port : "",
 1345|    163|                    (u->path && (u->path[0] != '/')) ? "/": "",
 1346|    163|                    u->path ? u->path : "/",
 1347|    163|                    (u->query && u->query[0]) ? "?": "",
 1348|    163|                    (u->query && u->query[0]) ? u->query : "",
 1349|    163|                    u->fragment? "#": "",
 1350|    163|                    u->fragment? u->fragment : "");
 1351|    163|      free(allochost);
 1352|    163|    }
 1353|    168|    if(!url)
 1354|      0|      return CURLUE_OUT_OF_MEMORY;
 1355|    168|    *part = url;
 1356|    168|    return CURLUE_OK;
 1357|    168|  }
 1358|      0|  default:
 1359|      0|    ptr = NULL;
 1360|      0|    break;
 1361|    704|  }
 1362|    336|  if(ptr) {
 1363|    331|    *part = strdup(ptr);
 1364|    331|    if(!*part)
 1365|      0|      return CURLUE_OUT_OF_MEMORY;
 1366|    331|    if(plusdecode) {
 1367|       |      /* convert + to space */
 1368|      0|      char *plus;
 1369|      0|      for(plus = *part; *plus; ++plus) {
 1370|      0|        if(*plus == '+')
 1371|      0|          *plus = ' ';
 1372|      0|      }
 1373|      0|    }
 1374|    331|    if(urldecode) {
 1375|      0|      char *decoded;
 1376|      0|      size_t dlen;
 1377|       |      /* this unconditional rejection of control bytes is documented
 1378|       |         API behavior */
 1379|      0|      CURLcode res = Curl_urldecode(NULL, *part, 0, &decoded, &dlen,
 1380|      0|                                    REJECT_CTRL);
 1381|      0|      free(*part);
 1382|      0|      if(res) {
 1383|      0|        *part = NULL;
 1384|      0|        return CURLUE_URLDECODE;
 1385|      0|      }
 1386|      0|      *part = decoded;
 1387|      0|    }
 1388|    331|    return CURLUE_OK;
 1389|    331|  }
 1390|      5|  else
 1391|      5|    return ifmissing;
 1392|    336|}
curl_url_set:
 1396|    253|{
 1397|    253|  char **storep = NULL;
 1398|    253|  long port = 0;
 1399|    253|  bool urlencode = (flags & CURLU_URLENCODE)? 1 : 0;
 1400|    253|  bool plusencode = FALSE;
 1401|    253|  bool urlskipslash = FALSE;
 1402|    253|  bool appendquery = FALSE;
 1403|    253|  bool equalsencode = FALSE;
 1404|       |
 1405|    253|  if(!u)
 1406|      0|    return CURLUE_BAD_HANDLE;
 1407|    253|  if(!part) {
 1408|       |    /* setting a part to NULL clears it */
 1409|      0|    switch(what) {
 1410|      0|    case CURLUPART_URL:
 1411|      0|      break;
 1412|      0|    case CURLUPART_SCHEME:
 1413|      0|      storep = &u->scheme;
 1414|      0|      break;
 1415|      0|    case CURLUPART_USER:
 1416|      0|      storep = &u->user;
 1417|      0|      break;
 1418|      0|    case CURLUPART_PASSWORD:
 1419|      0|      storep = &u->password;
 1420|      0|      break;
 1421|      0|    case CURLUPART_OPTIONS:
 1422|      0|      storep = &u->options;
 1423|      0|      break;
 1424|      0|    case CURLUPART_HOST:
 1425|      0|      storep = &u->host;
 1426|      0|      break;
 1427|      0|    case CURLUPART_ZONEID:
 1428|      0|      storep = &u->zoneid;
 1429|      0|      break;
 1430|      0|    case CURLUPART_PORT:
 1431|      0|      u->portnum = 0;
 1432|      0|      storep = &u->port;
 1433|      0|      break;
 1434|      0|    case CURLUPART_PATH:
 1435|      0|      storep = &u->path;
 1436|      0|      break;
 1437|      0|    case CURLUPART_QUERY:
 1438|      0|      storep = &u->query;
 1439|      0|      break;
 1440|      0|    case CURLUPART_FRAGMENT:
 1441|      0|      storep = &u->fragment;
 1442|      0|      break;
 1443|      0|    default:
 1444|      0|      return CURLUE_UNKNOWN_PART;
 1445|      0|    }
 1446|      0|    if(storep && *storep) {
 1447|      0|      Curl_safefree(*storep);
 1448|      0|    }
 1449|      0|    return CURLUE_OK;
 1450|      0|  }
 1451|       |
 1452|    253|  switch(what) {
 1453|      0|  case CURLUPART_SCHEME:
 1454|      0|    if(strlen(part) > MAX_SCHEME_LEN)
 1455|       |      /* too long */
 1456|      0|      return CURLUE_MALFORMED_INPUT;
 1457|      0|    if(!(flags & CURLU_NON_SUPPORT_SCHEME) &&
 1458|       |       /* verify that it is a fine scheme */
 1459|      0|       !Curl_builtin_scheme(part))
 1460|      0|      return CURLUE_UNSUPPORTED_SCHEME;
 1461|      0|    storep = &u->scheme;
 1462|      0|    urlencode = FALSE; /* never */
 1463|      0|    break;
 1464|      0|  case CURLUPART_USER:
 1465|      0|    storep = &u->user;
 1466|      0|    break;
 1467|      0|  case CURLUPART_PASSWORD:
 1468|      0|    storep = &u->password;
 1469|      0|    break;
 1470|      0|  case CURLUPART_OPTIONS:
 1471|      0|    storep = &u->options;
 1472|      0|    break;
 1473|      0|  case CURLUPART_HOST: {
 1474|      0|    size_t len = strcspn(part, " \r\n");
 1475|      0|    if(strlen(part) != len)
 1476|       |      /* hostname with bad content */
 1477|      0|      return CURLUE_MALFORMED_INPUT;
 1478|      0|    storep = &u->host;
 1479|      0|    Curl_safefree(u->zoneid);
 1480|      0|    break;
 1481|      0|  }
 1482|      0|  case CURLUPART_ZONEID:
 1483|      0|    storep = &u->zoneid;
 1484|      0|    break;
 1485|      0|  case CURLUPART_PORT:
 1486|      0|  {
 1487|      0|    char *endp;
 1488|      0|    urlencode = FALSE; /* never */
 1489|      0|    port = strtol(part, &endp, 10);  /* Port number must be decimal */
 1490|      0|    if((port <= 0) || (port > 0xffff))
 1491|      0|      return CURLUE_BAD_PORT_NUMBER;
 1492|      0|    if(*endp)
 1493|       |      /* weirdly provided number, not good! */
 1494|      0|      return CURLUE_MALFORMED_INPUT;
 1495|      0|    storep = &u->port;
 1496|      0|  }
 1497|      0|  break;
 1498|      0|  case CURLUPART_PATH:
 1499|      0|    urlskipslash = TRUE;
 1500|      0|    storep = &u->path;
 1501|      0|    break;
 1502|      0|  case CURLUPART_QUERY:
 1503|      0|    plusencode = urlencode;
 1504|      0|    appendquery = (flags & CURLU_APPENDQUERY)?1:0;
 1505|      0|    equalsencode = appendquery;
 1506|      0|    storep = &u->query;
 1507|      0|    break;
 1508|      0|  case CURLUPART_FRAGMENT:
 1509|      0|    storep = &u->fragment;
 1510|      0|    break;
 1511|    253|  case CURLUPART_URL: {
 1512|       |    /*
 1513|       |     * Allow a new URL to replace the existing (if any) contents.
 1514|       |     *
 1515|       |     * If the existing contents is enough for a URL, allow a relative URL to
 1516|       |     * replace it.
 1517|       |     */
 1518|    253|    CURLUcode result;
 1519|    253|    char *oldurl;
 1520|    253|    char *redired_url;
 1521|    253|    CURLU *handle2;
 1522|       |
 1523|    253|    if(Curl_is_absolute_url(part, NULL, MAX_SCHEME_LEN + 1)) {
 1524|     53|      handle2 = curl_url();
 1525|     53|      if(!handle2)
 1526|      0|        return CURLUE_OUT_OF_MEMORY;
 1527|     53|      result = parseurl(part, handle2, flags);
 1528|     53|      if(!result)
 1529|     23|        mv_urlhandle(handle2, u);
 1530|     30|      else
 1531|     30|        curl_url_cleanup(handle2);
 1532|     53|      return result;
 1533|     53|    }
 1534|       |    /* extract the full "old" URL to do the redirect on */
 1535|    200|    result = curl_url_get(u, CURLUPART_URL, &oldurl, flags);
 1536|    200|    if(result) {
 1537|       |      /* couldn't get the old URL, just use the new! */
 1538|    200|      handle2 = curl_url();
 1539|    200|      if(!handle2)
 1540|      0|        return CURLUE_OUT_OF_MEMORY;
 1541|    200|      result = parseurl(part, handle2, flags);
 1542|    200|      if(!result)
 1543|    145|        mv_urlhandle(handle2, u);
 1544|     55|      else
 1545|     55|        curl_url_cleanup(handle2);
 1546|    200|      return result;
 1547|    200|    }
 1548|       |
 1549|       |    /* apply the relative part to create a new URL */
 1550|      0|    redired_url = concat_url(oldurl, part);
 1551|      0|    free(oldurl);
 1552|      0|    if(!redired_url)
 1553|      0|      return CURLUE_OUT_OF_MEMORY;
 1554|       |
 1555|       |    /* now parse the new URL */
 1556|      0|    handle2 = curl_url();
 1557|      0|    if(!handle2) {
 1558|      0|      free(redired_url);
 1559|      0|      return CURLUE_OUT_OF_MEMORY;
 1560|      0|    }
 1561|      0|    result = parseurl(redired_url, handle2, flags);
 1562|      0|    free(redired_url);
 1563|      0|    if(!result)
 1564|      0|      mv_urlhandle(handle2, u);
 1565|      0|    else
 1566|      0|      curl_url_cleanup(handle2);
 1567|      0|    return result;
 1568|      0|  }
 1569|      0|  default:
 1570|      0|    return CURLUE_UNKNOWN_PART;
 1571|    253|  }
 1572|      0|  DEBUGASSERT(storep);
 1573|      0|  {
 1574|      0|    const char *newp = part;
 1575|      0|    size_t nalloc = strlen(part);
 1576|       |
 1577|      0|    if(nalloc > CURL_MAX_INPUT_LENGTH)
 1578|       |      /* excessive input length */
 1579|      0|      return CURLUE_MALFORMED_INPUT;
 1580|       |
 1581|      0|    if(urlencode) {
 1582|      0|      const unsigned char *i;
 1583|      0|      char *o;
 1584|      0|      char *enc = malloc(nalloc * 3 + 1); /* for worst case! */
 1585|      0|      if(!enc)
 1586|      0|        return CURLUE_OUT_OF_MEMORY;
 1587|      0|      for(i = (const unsigned char *)part, o = enc; *i; i++) {
 1588|      0|        if((*i == ' ') && plusencode) {
 1589|      0|          *o = '+';
 1590|      0|          o++;
 1591|      0|        }
 1592|      0|        else if(Curl_isunreserved(*i) ||
 1593|      0|                ((*i == '/') && urlskipslash) ||
 1594|      0|                ((*i == '=') && equalsencode)) {
 1595|      0|          if((*i == '=') && equalsencode)
 1596|       |            /* only skip the first equals sign */
 1597|      0|            equalsencode = FALSE;
 1598|      0|          *o = *i;
 1599|      0|          o++;
 1600|      0|        }
 1601|      0|        else {
 1602|      0|          msnprintf(o, 4, "%%%02x", *i);
 1603|      0|          o += 3;
 1604|      0|        }
 1605|      0|      }
 1606|      0|      *o = 0; /* null-terminate */
 1607|      0|      newp = enc;
 1608|      0|    }
 1609|      0|    else {
 1610|      0|      char *p;
 1611|      0|      newp = strdup(part);
 1612|      0|      if(!newp)
 1613|      0|        return CURLUE_OUT_OF_MEMORY;
 1614|      0|      p = (char *)newp;
 1615|      0|      while(*p) {
 1616|       |        /* make sure percent encoded are lower case */
 1617|      0|        if((*p == '%') && ISXDIGIT(p[1]) && ISXDIGIT(p[2]) &&
 1618|      0|           (ISUPPER(p[1]) || ISUPPER(p[2]))) {
 1619|      0|          p[1] = (char)TOLOWER(p[1]);
 1620|      0|          p[2] = (char)TOLOWER(p[2]);
 1621|      0|          p += 3;
 1622|      0|        }
 1623|      0|        else
 1624|      0|          p++;
 1625|      0|      }
 1626|      0|    }
 1627|       |
 1628|      0|    if(appendquery) {
 1629|       |      /* Append the string onto the old query. Add a '&' separator if none is
 1630|       |         present at the end of the exsting query already */
 1631|      0|      size_t querylen = u->query ? strlen(u->query) : 0;
 1632|      0|      bool addamperand = querylen && (u->query[querylen -1] != '&');
 1633|      0|      if(querylen) {
 1634|      0|        size_t newplen = strlen(newp);
 1635|      0|        char *p = malloc(querylen + addamperand + newplen + 1);
 1636|      0|        if(!p) {
 1637|      0|          free((char *)newp);
 1638|      0|          return CURLUE_OUT_OF_MEMORY;
 1639|      0|        }
 1640|      0|        strcpy(p, u->query); /* original query */
 1641|      0|        if(addamperand)
 1642|      0|          p[querylen] = '&'; /* ampersand */
 1643|      0|        strcpy(&p[querylen + addamperand], newp); /* new suffix */
 1644|      0|        free((char *)newp);
 1645|      0|        free(*storep);
 1646|      0|        *storep = p;
 1647|      0|        return CURLUE_OK;
 1648|      0|      }
 1649|      0|    }
 1650|       |
 1651|      0|    if(what == CURLUPART_HOST) {
 1652|      0|      if(0 == strlen(newp) && (flags & CURLU_NO_AUTHORITY)) {
 1653|       |        /* Skip hostname check, it's allowed to be empty. */
 1654|      0|      }
 1655|      0|      else {
 1656|      0|        if(hostname_check(u, (char *)newp)) {
 1657|      0|          free((char *)newp);
 1658|      0|          return CURLUE_MALFORMED_INPUT;
 1659|      0|        }
 1660|      0|      }
 1661|      0|    }
 1662|       |
 1663|      0|    free(*storep);
 1664|      0|    *storep = (char *)newp;
 1665|      0|  }
 1666|       |  /* set after the string, to make it not assigned if the allocation above
 1667|       |     fails */
 1668|      0|  if(port)
 1669|      0|    u->portnum = port;
 1670|      0|  return CURLUE_OK;
 1671|      0|}
urlapi.c:free_urlhandle:
   74|    591|{
   75|    591|  free(u->scheme);
   76|    591|  free(u->user);
   77|    591|  free(u->password);
   78|    591|  free(u->options);
   79|    591|  free(u->host);
   80|    591|  free(u->zoneid);
   81|    591|  free(u->port);
   82|    591|  free(u->path);
   83|    591|  free(u->query);
   84|    591|  free(u->fragment);
   85|    591|  free(u->scratch);
   86|    591|  free(u->temppath);
   87|    591|}
urlapi.c:parseurl:
 1105|    253|{
 1106|    253|  CURLUcode result = seturl(url, u, flags);
 1107|    253|  if(result) {
 1108|     85|    free_urlhandle(u);
 1109|     85|    memset(u, 0, sizeof(struct Curl_URL));
 1110|     85|  }
 1111|    253|  return result;
 1112|    253|}
urlapi.c:seturl:
  782|    253|{
  783|    253|  char *path;
  784|    253|  bool path_alloced = FALSE;
  785|    253|  bool uncpath = FALSE;
  786|    253|  char *hostname;
  787|    253|  char *query = NULL;
  788|    253|  char *fragment = NULL;
  789|    253|  CURLUcode result;
  790|    253|  bool url_has_scheme = FALSE;
  791|    253|  char schemebuf[MAX_SCHEME_LEN + 1];
  792|    253|  const char *schemep = NULL;
  793|    253|  size_t schemelen = 0;
  794|    253|  size_t urllen;
  795|       |
  796|    253|  DEBUGASSERT(url);
  797|       |
  798|       |  /*************************************************************
  799|       |   * Parse the URL.
  800|       |   ************************************************************/
  801|       |  /* allocate scratch area */
  802|    253|  urllen = strlen(url);
  803|    253|  if(urllen > CURL_MAX_INPUT_LENGTH)
  804|       |    /* excessive input length */
  805|      0|    return CURLUE_MALFORMED_INPUT;
  806|       |
  807|    253|  path = u->scratch = malloc(urllen * 2 + 2);
  808|    253|  if(!path)
  809|      0|    return CURLUE_OUT_OF_MEMORY;
  810|       |
  811|    253|  hostname = &path[urllen + 1];
  812|    253|  hostname[0] = 0;
  813|       |
  814|    253|  if(Curl_is_absolute_url(url, schemebuf, sizeof(schemebuf))) {
  815|     53|    url_has_scheme = TRUE;
  816|     53|    schemelen = strlen(schemebuf);
  817|     53|  }
  818|       |
  819|       |  /* handle the file: scheme */
  820|    253|  if(url_has_scheme && strcasecompare(schemebuf, "file")) {
  821|       |    /* path has been allocated large enough to hold this */
  822|     23|    strcpy(path, &url[5]);
  823|       |
  824|     23|    u->scheme = strdup("file");
  825|     23|    if(!u->scheme)
  826|      0|      return CURLUE_OUT_OF_MEMORY;
  827|       |
  828|       |    /* Extra handling URLs with an authority component (i.e. that start with
  829|       |     * "file://")
  830|       |     *
  831|       |     * We allow omitted hostname (e.g. file:/<path>) -- valid according to
  832|       |     * RFC 8089, but not the (current) WHAT-WG URL spec.
  833|       |     */
  834|     23|    if(path[0] == '/' && path[1] == '/') {
  835|       |      /* swallow the two slashes */
  836|     16|      char *ptr = &path[2];
  837|       |
  838|       |      /*
  839|       |       * According to RFC 8089, a file: URL can be reliably dereferenced if:
  840|       |       *
  841|       |       *  o it has no/blank hostname, or
  842|       |       *
  843|       |       *  o the hostname matches "localhost" (case-insensitively), or
  844|       |       *
  845|       |       *  o the hostname is a FQDN that resolves to this machine, or
  846|       |       *
  847|       |       *  o it is an UNC String transformed to an URI (Windows only, RFC 8089
  848|       |       *    Appendix E.3).
  849|       |       *
  850|       |       * For brevity, we only consider URLs with empty, "localhost", or
  851|       |       * "127.0.0.1" hostnames as local, otherwise as an UNC String.
  852|       |       *
  853|       |       * Additionally, there is an exception for URLs with a Windows drive
  854|       |       * letter in the authority (which was accidentally omitted from RFC 8089
  855|       |       * Appendix E, but believe me, it was meant to be there. --MK)
  856|       |       */
  857|     16|      if(ptr[0] != '/' && !STARTS_WITH_URL_DRIVE_PREFIX(ptr)) {
  858|       |        /* the URL includes a host name, it must match "localhost" or
  859|       |           "127.0.0.1" to be valid */
  860|     12|        if(checkprefix("localhost/", ptr) ||
  861|     12|           checkprefix("127.0.0.1/", ptr)) {
  862|      0|          ptr += 9; /* now points to the slash after the host */
  863|      0|        }
  864|     12|        else {
  865|       |#if defined(WIN32)
  866|       |          size_t len;
  867|       |
  868|       |          /* the host name, NetBIOS computer name, can not contain disallowed
  869|       |             chars, and the delimiting slash character must be appended to the
  870|       |             host name */
  871|       |          path = strpbrk(ptr, "/\\:*?\"<>|");
  872|       |          if(!path || *path != '/')
  873|       |            return CURLUE_MALFORMED_INPUT;
  874|       |
  875|       |          len = path - ptr;
  876|       |          if(len) {
  877|       |            memcpy(hostname, ptr, len);
  878|       |            hostname[len] = 0;
  879|       |            uncpath = TRUE;
  880|       |          }
  881|       |
  882|       |          ptr -= 2; /* now points to the // before the host in UNC */
  883|       |#else
  884|       |          /* Invalid file://hostname/, expected localhost or 127.0.0.1 or
  885|       |             none */
  886|     12|          return CURLUE_MALFORMED_INPUT;
  887|     12|#endif
  888|     12|        }
  889|     12|      }
  890|       |
  891|      4|      path = ptr;
  892|      4|    }
  893|       |
  894|     11|    if(!uncpath)
  895|     11|        hostname = NULL; /* no host for file: URLs by default */
  896|       |
  897|     11|#if !defined(MSDOS) && !defined(WIN32) && !defined(__CYGWIN__)
  898|       |    /* Don't allow Windows drive letters when not in Windows.
  899|       |     * This catches both "file:/c:" and "file:c:" */
  900|     11|    if(('/' == path[0] && STARTS_WITH_URL_DRIVE_PREFIX(&path[1])) ||
  901|     11|       STARTS_WITH_URL_DRIVE_PREFIX(path)) {
  902|       |      /* File drive letters are only accepted in MSDOS/Windows */
  903|      6|      return CURLUE_MALFORMED_INPUT;
  904|      6|    }
  905|       |#else
  906|       |    /* If the path starts with a slash and a drive letter, ditch the slash */
  907|       |    if('/' == path[0] && STARTS_WITH_URL_DRIVE_PREFIX(&path[1])) {
  908|       |      /* This cannot be done with strcpy, as the memory chunks overlap! */
  909|       |      memmove(path, &path[1], strlen(&path[1]) + 1);
  910|       |    }
  911|       |#endif
  912|       |
  913|     11|  }
  914|    230|  else {
  915|       |    /* clear path */
  916|    230|    const char *p;
  917|    230|    const char *hostp;
  918|    230|    size_t len;
  919|    230|    path[0] = 0;
  920|       |
  921|    230|    if(url_has_scheme) {
  922|     30|      int i = 0;
  923|     30|      p = &url[schemelen + 1];
  924|     82|      while(p && (*p == '/') && (i < 4)) {
  925|     52|        p++;
  926|     52|        i++;
  927|     52|      }
  928|     30|      if((i < 1) || (i>3))
  929|       |        /* less than one or more than three slashes */
  930|      3|        return CURLUE_MALFORMED_INPUT;
  931|       |
  932|     27|      schemep = schemebuf;
  933|     27|      if(!Curl_builtin_scheme(schemep) &&
  934|     27|         !(flags & CURLU_NON_SUPPORT_SCHEME))
  935|      0|        return CURLUE_UNSUPPORTED_SCHEME;
  936|       |
  937|     27|      if(junkscan(schemep, flags))
  938|      0|        return CURLUE_MALFORMED_INPUT;
  939|     27|    }
  940|    200|    else {
  941|       |      /* no scheme! */
  942|       |
  943|    200|      if(!(flags & (CURLU_DEFAULT_SCHEME|CURLU_GUESS_SCHEME)))
  944|      0|        return CURLUE_MALFORMED_INPUT;
  945|    200|      if(flags & CURLU_DEFAULT_SCHEME)
  946|      0|        schemep = DEFAULT_SCHEME;
  947|       |
  948|       |      /*
  949|       |       * The URL was badly formatted, let's try without scheme specified.
  950|       |       */
  951|    200|      p = url;
  952|    200|    }
  953|    227|    hostp = p; /* host name starts here */
  954|       |
  955|  4.77k|    while(*p && !HOSTNAME_END(*p)) /* find end of host name */
  956|  4.55k|      p++;
  957|       |
  958|    227|    len = p - hostp;
  959|    227|    if(len) {
  960|    209|      memcpy(hostname, hostp, len);
  961|    209|      hostname[len] = 0;
  962|    209|    }
  963|     18|    else {
  964|     18|      if(!(flags & CURLU_NO_AUTHORITY))
  965|     18|        return CURLUE_MALFORMED_INPUT;
  966|     18|    }
  967|       |
  968|    209|    len = strlen(p);
  969|    209|    memcpy(path, p, len);
  970|    209|    path[len] = 0;
  971|       |
  972|    209|    if(schemep) {
  973|     23|      u->scheme = strdup(schemep);
  974|     23|      if(!u->scheme)
  975|      0|        return CURLUE_OUT_OF_MEMORY;
  976|     23|    }
  977|    209|  }
  978|       |
  979|    214|  if(junkscan(path, flags))
  980|      3|    return CURLUE_MALFORMED_INPUT;
  981|       |
  982|    211|  if((flags & CURLU_URLENCODE) && path[0]) {
  983|       |    /* worst case output length is 3x the original! */
  984|      0|    char *newp = malloc(strlen(path) * 3);
  985|      0|    if(!newp)
  986|      0|      return CURLUE_OUT_OF_MEMORY;
  987|      0|    path_alloced = TRUE;
  988|      0|    strcpy_url(newp, path, TRUE); /* consider it relative */
  989|      0|    u->temppath = path = newp;
  990|      0|  }
  991|       |
  992|    211|  fragment = strchr(path, '#');
  993|    211|  if(fragment) {
  994|      4|    *fragment++ = 0;
  995|      4|    if(fragment[0]) {
  996|      3|      u->fragment = strdup(fragment);
  997|      3|      if(!u->fragment)
  998|      0|        return CURLUE_OUT_OF_MEMORY;
  999|      3|    }
 1000|      4|  }
 1001|       |
 1002|    211|  query = strchr(path, '?');
 1003|    211|  if(query) {
 1004|      4|    *query++ = 0;
 1005|       |    /* done even if the query part is a blank string */
 1006|      4|    u->query = strdup(query);
 1007|      4|    if(!u->query)
 1008|      0|      return CURLUE_OUT_OF_MEMORY;
 1009|      4|  }
 1010|       |
 1011|    211|  if(!path[0])
 1012|       |    /* if there's no path left set, unset */
 1013|    127|    path = NULL;
 1014|     84|  else {
 1015|     84|    if(!(flags & CURLU_PATH_AS_IS)) {
 1016|       |      /* remove ../ and ./ sequences according to RFC3986 */
 1017|     84|      char *newp = Curl_dedotdotify(path);
 1018|     84|      if(!newp)
 1019|      0|        return CURLUE_OUT_OF_MEMORY;
 1020|       |
 1021|     84|      if(strcmp(newp, path)) {
 1022|       |        /* if we got a new version */
 1023|     45|        if(path_alloced)
 1024|      0|          Curl_safefree(u->temppath);
 1025|     45|        u->temppath = path = newp;
 1026|     45|        path_alloced = TRUE;
 1027|     45|      }
 1028|     39|      else
 1029|     39|        free(newp);
 1030|     84|    }
 1031|       |
 1032|     84|    u->path = path_alloced?path:strdup(path);
 1033|     84|    if(!u->path)
 1034|      0|      return CURLUE_OUT_OF_MEMORY;
 1035|     84|    u->temppath = NULL; /* used now */
 1036|     84|  }
 1037|       |
 1038|    211|  if(hostname) {
 1039|    206|    char normalized_ipv4[sizeof("255.255.255.255") + 1];
 1040|       |    /*
 1041|       |     * Parse the login details and strip them out of the host name.
 1042|       |     */
 1043|    206|    if(junkscan(hostname, flags))
 1044|     12|      return CURLUE_MALFORMED_INPUT;
 1045|       |
 1046|    194|    result = parse_hostname_login(u, &hostname, flags);
 1047|    194|    if(result)
 1048|      0|      return result;
 1049|       |
 1050|    194|    result = Curl_parse_port(u, hostname, url_has_scheme);
 1051|    194|    if(result)
 1052|     12|      return result;
 1053|       |
 1054|    182|    if(0 == strlen(hostname) && (flags & CURLU_NO_AUTHORITY)) {
 1055|       |      /* Skip hostname check, it's allowed to be empty. */
 1056|      0|      u->host = strdup("");
 1057|      0|    }
 1058|    182|    else {
 1059|    182|      if(ipv4_normalize(hostname, normalized_ipv4, sizeof(normalized_ipv4)))
 1060|     12|        u->host = strdup(normalized_ipv4);
 1061|    170|      else {
 1062|    170|        result = decode_host(hostname, &u->host);
 1063|    170|        if(result)
 1064|      2|          return result;
 1065|    168|        result = hostname_check(u, u->host);
 1066|    168|        if(result)
 1067|     17|          return result;
 1068|    168|      }
 1069|    182|    }
 1070|    163|    if(!u->host)
 1071|      0|      return CURLUE_OUT_OF_MEMORY;
 1072|    163|    if((flags & CURLU_GUESS_SCHEME) && !schemep) {
 1073|       |      /* legacy curl-style guess based on host name */
 1074|    145|      if(checkprefix("ftp.", hostname))
 1075|      0|        schemep = "ftp";
 1076|    145|      else if(checkprefix("dict.", hostname))
 1077|      0|        schemep = "dict";
 1078|    145|      else if(checkprefix("ldap.", hostname))
 1079|      1|        schemep = "ldap";
 1080|    144|      else if(checkprefix("imap.", hostname))
 1081|      0|        schemep = "imap";
 1082|    144|      else if(checkprefix("smtp.", hostname))
 1083|      0|        schemep = "smtp";
 1084|    144|      else if(checkprefix("pop3.", hostname))
 1085|      0|        schemep = "pop3";
 1086|    144|      else
 1087|    144|        schemep = "http";
 1088|       |
 1089|    145|      u->scheme = strdup(schemep);
 1090|    145|      if(!u->scheme)
 1091|      0|        return CURLUE_OUT_OF_MEMORY;
 1092|    145|    }
 1093|    163|  }
 1094|       |
 1095|    168|  Curl_safefree(u->scratch);
 1096|    168|  Curl_safefree(u->temppath);
 1097|       |
 1098|    168|  return CURLUE_OK;
 1099|    211|}
urlapi.c:junkscan:
  582|    447|{
  583|    447|  if(part) {
  584|    447|    static const char badbytes[]={
  585|    447|      /* */ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  586|    447|      0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  587|    447|      0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  588|    447|      0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  589|    447|      0x7f, 0x00 /* null-terminate */
  590|    447|    };
  591|    447|    size_t n = strlen(part);
  592|    447|    size_t nfine = strcspn(part, badbytes);
  593|    447|    if(nfine != n)
  594|       |      /* since we don't know which part is scanned, return a generic error
  595|       |         code */
  596|     13|      return TRUE;
  597|    434|    if(!(flags & CURLU_ALLOW_SPACE) && strchr(part, ' '))
  598|      2|      return TRUE;
  599|    434|  }
  600|    432|  return FALSE;
  601|    447|}
urlapi.c:parse_hostname_login:
  431|    194|{
  432|    194|  CURLUcode result = CURLUE_OK;
  433|    194|  CURLcode ccode;
  434|    194|  char *userp = NULL;
  435|    194|  char *passwdp = NULL;
  436|    194|  char *optionsp = NULL;
  437|    194|  const struct Curl_handler *h = NULL;
  438|       |
  439|       |  /* At this point, we're hoping all the other special cases have
  440|       |   * been taken care of, so conn->host.name is at most
  441|       |   *    [user[:password][;options]]@]hostname
  442|       |   *
  443|       |   * We need somewhere to put the embedded details, so do that first.
  444|       |   */
  445|       |
  446|    194|  char *ptr = strchr(*hostname, '@');
  447|    194|  char *login = *hostname;
  448|       |
  449|    194|  if(!ptr)
  450|    183|    goto out;
  451|       |
  452|       |  /* We will now try to extract the
  453|       |   * possible login information in a string like:
  454|       |   * ftp://user:password@ftp.my.site:8021/README */
  455|     11|  *hostname = ++ptr;
  456|       |
  457|       |  /* if this is a known scheme, get some details */
  458|     11|  if(u->scheme)
  459|      6|    h = Curl_builtin_scheme(u->scheme);
  460|       |
  461|       |  /* We could use the login information in the URL so extract it. Only parse
  462|       |     options if the handler says we should. Note that 'h' might be NULL! */
  463|     11|  ccode = Curl_parse_login_details(login, ptr - login - 1,
  464|     11|                                   &userp, &passwdp,
  465|     11|                                   (h && (h->flags & PROTOPT_URLOPTIONS)) ?
  466|      0|                                   &optionsp:NULL);
  467|     11|  if(ccode) {
  468|      0|    result = CURLUE_MALFORMED_INPUT;
  469|      0|    goto out;
  470|      0|  }
  471|       |
  472|     11|  if(userp) {
  473|      5|    if(flags & CURLU_DISALLOW_USER) {
  474|       |      /* Option DISALLOW_USER is set and url contains username. */
  475|      0|      result = CURLUE_USER_NOT_ALLOWED;
  476|      0|      goto out;
  477|      0|    }
  478|       |
  479|      5|    u->user = userp;
  480|      5|  }
  481|       |
  482|     11|  if(passwdp)
  483|      1|    u->password = passwdp;
  484|       |
  485|     11|  if(optionsp)
  486|      0|    u->options = optionsp;
  487|       |
  488|     11|  return CURLUE_OK;
  489|    183|  out:
  490|       |
  491|    183|  free(userp);
  492|    183|  free(passwdp);
  493|    183|  free(optionsp);
  494|       |
  495|    183|  return result;
  496|     11|}
urlapi.c:ipv4_normalize:
  680|    182|{
  681|    182|  bool done = FALSE;
  682|    182|  int n = 0;
  683|    182|  const char *c = hostname;
  684|    182|  unsigned long parts[4] = {0, 0, 0, 0};
  685|       |
  686|    241|  while(!done) {
  687|    219|    char *endp;
  688|    219|    unsigned long l;
  689|    219|    if((*c < '0') || (*c > '9'))
  690|       |      /* most importantly this doesn't allow a leading plus or minus */
  691|    154|      return FALSE;
  692|     65|    l = strtoul(c, &endp, 0);
  693|       |
  694|       |    /* overflow or nothing parsed at all */
  695|     65|    if(((l == ULONG_MAX) && (errno == ERANGE)) ||  (endp == c))
  696|      1|      return FALSE;
  697|       |
  698|     64|#if SIZEOF_LONG > 4
  699|       |    /* a value larger than 32 bits */
  700|     64|    if(l > UINT_MAX)
  701|      1|      return FALSE;
  702|     63|#endif
  703|       |
  704|     63|    parts[n] = l;
  705|     63|    c = endp;
  706|       |
  707|     63|    switch (*c) {
  708|     38|    case '.' :
  709|     38|      if(n == 3)
  710|      1|        return FALSE;
  711|     37|      n++;
  712|     37|      c++;
  713|     37|      break;
  714|       |
  715|     22|    case '\0':
  716|     22|      done = TRUE;
  717|     22|      break;
  718|       |
  719|      3|    default:
  720|      3|      return FALSE;
  721|     63|    }
  722|     63|  }
  723|       |
  724|       |  /* this is deemed a valid IPv4 numerical address */
  725|       |
  726|     22|  switch(n) {
  727|      8|  case 0: /* a -- 32 bits */
  728|      8|    msnprintf(outp, olen, "%u.%u.%u.%u",
  729|      8|              parts[0] >> 24, (parts[0] >> 16) & 0xff,
  730|      8|              (parts[0] >> 8) & 0xff, parts[0] & 0xff);
  731|      8|    break;
  732|      3|  case 1: /* a.b -- 8.24 bits */
  733|      3|    if((parts[0] > 0xff) || (parts[1] > 0xffffff))
  734|      2|      return FALSE;
  735|      1|    msnprintf(outp, olen, "%u.%u.%u.%u",
  736|      1|              parts[0], (parts[1] >> 16) & 0xff,
  737|      1|              (parts[1] >> 8) & 0xff, parts[1] & 0xff);
  738|      1|    break;
  739|      5|  case 2: /* a.b.c -- 8.8.16 bits */
  740|      5|    if((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xffff))
  741|      3|      return FALSE;
  742|      2|    msnprintf(outp, olen, "%u.%u.%u.%u",
  743|      2|              parts[0], parts[1], (parts[2] >> 8) & 0xff,
  744|      2|              parts[2] & 0xff);
  745|      2|    break;
  746|      6|  case 3: /* a.b.c.d -- 8.8.8.8 bits */
  747|      6|    if((parts[0] > 0xff) || (parts[1] > 0xff) || (parts[2] > 0xff) ||
  748|      6|       (parts[3] > 0xff))
  749|      5|      return FALSE;
  750|      1|    msnprintf(outp, olen, "%u.%u.%u.%u",
  751|      1|              parts[0], parts[1], parts[2], parts[3]);
  752|      1|    break;
  753|     22|  }
  754|     12|  return TRUE;
  755|     22|}
urlapi.c:decode_host:
  759|    170|{
  760|    170|  char *per = NULL;
  761|    170|  if(hostname[0] != '[')
  762|       |    /* only decode if not an ipv6 numerical */
  763|    159|    per = strchr(hostname, '%');
  764|    170|  if(!per) {
  765|    134|    *outp = strdup(hostname);
  766|    134|    if(!*outp)
  767|      0|      return CURLUE_OUT_OF_MEMORY;
  768|    134|  }
  769|     36|  else {
  770|       |    /* might be encoded */
  771|     36|    size_t dlen;
  772|     36|    CURLcode result = Curl_urldecode(NULL, hostname, 0,
  773|     36|                                     outp, &dlen, REJECT_CTRL);
  774|     36|    if(result)
  775|      2|      return CURLUE_MALFORMED_INPUT;
  776|     36|  }
  777|       |
  778|    168|  return CURLUE_OK;
  779|    170|}
urlapi.c:mv_urlhandle:
   93|    168|{
   94|    168|  free_urlhandle(to);
   95|    168|  *to = *from;
   96|    168|  free(from);
   97|    168|}
urlapi.c:hostname_check:
  604|    168|{
  605|    168|  size_t len;
  606|    168|  size_t hlen = strlen(hostname);
  607|       |
  608|    168|  if(hostname[0] == '[') {
  609|     11|#ifdef ENABLE_IPV6
  610|     11|    char dest[16]; /* fits a binary IPv6 address */
  611|     11|#endif
  612|     11|    const char *l = "0123456789abcdefABCDEF:.";
  613|     11|    if(hlen < 4) /* '[::]' is the shortest possible valid string */
  614|      1|      return CURLUE_MALFORMED_INPUT;
  615|     10|    hostname++;
  616|     10|    hlen -= 2;
  617|       |
  618|     10|    if(hostname[hlen] != ']')
  619|      1|      return CURLUE_MALFORMED_INPUT;
  620|       |
  621|       |    /* only valid letters are ok */
  622|      9|    len = strspn(hostname, l);
  623|      9|    if(hlen != len) {
  624|      8|      hlen = len;
  625|      8|      if(hostname[len] == '%') {
  626|       |        /* this could now be '%[zone id]' */
  627|      7|        char zoneid[16];
  628|      7|        int i = 0;
  629|      7|        char *h = &hostname[len + 1];
  630|       |        /* pass '25' if present and is a url encoded percent sign */
  631|      7|        if(!strncmp(h, "25", 2) && h[2] && (h[2] != ']'))
  632|      1|          h += 2;
  633|     40|        while(*h && (*h != ']') && (i < 15))
  634|     33|          zoneid[i++] = *h++;
  635|      7|        if(!i || (']' != *h))
  636|      2|          return CURLUE_MALFORMED_INPUT;
  637|      5|        zoneid[i] = 0;
  638|      5|        u->zoneid = strdup(zoneid);
  639|      5|        if(!u->zoneid)
  640|      0|          return CURLUE_OUT_OF_MEMORY;
  641|      5|        hostname[len] = ']'; /* insert end bracket */
  642|      5|        hostname[len + 1] = 0; /* terminate the hostname */
  643|      5|      }
  644|      1|      else
  645|      1|        return CURLUE_MALFORMED_INPUT;
  646|       |      /* hostname is fine */
  647|      8|    }
  648|      6|#ifdef ENABLE_IPV6
  649|      6|    hostname[hlen] = 0; /* end the address there */
  650|      6|    if(1 != Curl_inet_pton(AF_INET6, hostname, dest))
  651|      6|      return CURLUE_MALFORMED_INPUT;
  652|      0|    hostname[hlen] = ']'; /* restore ending bracket */
  653|      0|#endif
  654|      0|  }
  655|    157|  else {
  656|       |    /* letters from the second string is not ok */
  657|    157|    len = strcspn(hostname, " \r\n");
  658|    157|    if(hlen != len)
  659|       |      /* hostname with bad content */
  660|      1|      return CURLUE_MALFORMED_INPUT;
  661|    157|  }
  662|    156|  if(!hostname[0])
  663|      5|    return CURLUE_NO_HOST;
  664|    151|  return CURLUE_OK;
  665|    156|}

Curl_auth_digest_cleanup:
  960|  2.11k|{
  961|  2.11k|  Curl_safefree(digest->nonce);
  962|  2.11k|  Curl_safefree(digest->cnonce);
  963|  2.11k|  Curl_safefree(digest->realm);
  964|  2.11k|  Curl_safefree(digest->opaque);
  965|  2.11k|  Curl_safefree(digest->qop);
  966|  2.11k|  Curl_safefree(digest->algorithm);
  967|       |
  968|  2.11k|  digest->nc = 0;
  969|  2.11k|  digest->algo = CURLDIGESTALGO_MD5; /* default algorithm */
  970|  2.11k|  digest->stale = FALSE; /* default means normal, not stale */
  971|  2.11k|  digest->userhash = FALSE;
  972|  2.11k|}

Curl_auth_cleanup_ntlm:
  849|    506|{
  850|       |  /* Free the target info */
  851|    506|  Curl_safefree(ntlm->target_info);
  852|       |
  853|       |  /* Reset any variables */
  854|    506|  ntlm->target_info_len = 0;
  855|    506|}

Curl_tls_keylog_open:
   47|      1|{
   48|      1|  char *keylog_file_name;
   49|       |
   50|      1|  if(!keylog_file_fp) {
   51|      1|    keylog_file_name = curl_getenv("SSLKEYLOGFILE");
   52|      1|    if(keylog_file_name) {
   53|      0|      keylog_file_fp = fopen(keylog_file_name, FOPEN_APPENDTEXT);
   54|      0|      if(keylog_file_fp) {
   55|       |#ifdef WIN32
   56|       |        if(setvbuf(keylog_file_fp, NULL, _IONBF, 0))
   57|       |#else
   58|      0|        if(setvbuf(keylog_file_fp, NULL, _IOLBF, 4096))
   59|      0|#endif
   60|      0|        {
   61|      0|          fclose(keylog_file_fp);
   62|      0|          keylog_file_fp = NULL;
   63|      0|        }
   64|      0|      }
   65|      0|      Curl_safefree(keylog_file_name);
   66|      0|    }
   67|      1|  }
   68|      1|}

openssl.c:ossl_init:
 1172|      1|{
 1173|       |#if (OPENSSL_VERSION_NUMBER >= 0x10100000L) &&  \
 1174|       |  !defined(LIBRESSL_VERSION_NUMBER)
 1175|       |  const uint64_t flags =
 1176|       |#ifdef OPENSSL_INIT_ENGINE_ALL_BUILTIN
 1177|       |    /* not present in BoringSSL */
 1178|       |    OPENSSL_INIT_ENGINE_ALL_BUILTIN |
 1179|       |#endif
 1180|       |#ifdef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG
 1181|       |    OPENSSL_INIT_NO_LOAD_CONFIG |
 1182|       |#else
 1183|       |    OPENSSL_INIT_LOAD_CONFIG |
 1184|       |#endif
 1185|       |    0;
 1186|       |  OPENSSL_init_ssl(flags, NULL);
 1187|       |#else
 1188|      1|  OPENSSL_load_builtin_modules();
 1189|       |
 1190|      1|#ifdef USE_OPENSSL_ENGINE
 1191|      1|  ENGINE_load_builtin_engines();
 1192|      1|#endif
 1193|       |
 1194|       |/* CONF_MFLAGS_DEFAULT_SECTION was introduced some time between 0.9.8b and
 1195|       |   0.9.8e */
 1196|       |#ifndef CONF_MFLAGS_DEFAULT_SECTION
 1197|       |#define CONF_MFLAGS_DEFAULT_SECTION 0x0
 1198|       |#endif
 1199|       |
 1200|      1|#ifndef CURL_DISABLE_OPENSSL_AUTO_LOAD_CONFIG
 1201|      1|  CONF_modules_load_file(NULL, NULL,
 1202|      1|                         CONF_MFLAGS_DEFAULT_SECTION|
 1203|      1|                         CONF_MFLAGS_IGNORE_MISSING_FILE);
 1204|      1|#endif
 1205|       |
 1206|       |  /* Let's get nice error messages */
 1207|      1|  SSL_load_error_strings();
 1208|       |
 1209|       |  /* Init the global ciphers and digests */
 1210|      1|  if(!SSLeay_add_ssl_algorithms())
 1211|      0|    return 0;
 1212|       |
 1213|      1|  OpenSSL_add_all_algorithms();
 1214|      1|#endif
 1215|       |
 1216|      1|  Curl_tls_keylog_open();
 1217|       |
 1218|       |  /* Initialize the extra data indexes */
 1219|      1|  if(ossl_get_ssl_data_index() < 0 || ossl_get_ssl_conn_index() < 0 ||
 1220|      1|     ossl_get_ssl_sockindex_index() < 0 || ossl_get_proxy_index() < 0)
 1221|      0|    return 0;
 1222|       |
 1223|      1|  return 1;
 1224|      1|}
openssl.c:ossl_get_ssl_data_index:
  373|      1|{
  374|      1|  static int ssl_ex_data_data_index = -1;
  375|      1|  if(ssl_ex_data_data_index < 0) {
  376|      1|    ssl_ex_data_data_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  377|      1|  }
  378|      1|  return ssl_ex_data_data_index;
  379|      1|}
openssl.c:ossl_get_ssl_conn_index:
  385|      1|{
  386|      1|  static int ssl_ex_data_conn_index = -1;
  387|      1|  if(ssl_ex_data_conn_index < 0) {
  388|      1|    ssl_ex_data_conn_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  389|      1|  }
  390|      1|  return ssl_ex_data_conn_index;
  391|      1|}
openssl.c:ossl_get_ssl_sockindex_index:
  397|      1|{
  398|      1|  static int sockindex_index = -1;
  399|      1|  if(sockindex_index < 0) {
  400|      1|    sockindex_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  401|      1|  }
  402|      1|  return sockindex_index;
  403|      1|}
openssl.c:ossl_get_proxy_index:
  409|      1|{
  410|      1|  static int proxy_index = -1;
  411|      1|  if(proxy_index < 0) {
  412|      1|    proxy_index = SSL_get_ex_new_index(0, NULL, NULL, NULL, NULL);
  413|      1|  }
  414|      1|  return proxy_index;
  415|      1|}
openssl.c:ossl_random:
 4427|    778|{
 4428|    778|  int rc;
 4429|    778|  if(data) {
 4430|    778|    if(ossl_seed(data)) /* Initiate the seed if not already done */
 4431|      0|      return CURLE_FAILED_INIT; /* couldn't seed for some reason */
 4432|    778|  }
 4433|      0|  else {
 4434|      0|    if(!rand_enough())
 4435|      0|      return CURLE_FAILED_INIT;
 4436|      0|  }
 4437|       |  /* RAND_bytes() returns 1 on success, 0 otherwise.  */
 4438|    778|  rc = RAND_bytes(entropy, curlx_uztosi(length));
 4439|    778|  return (rc == 1 ? CURLE_OK : CURLE_FAILED_INIT);
 4440|    778|}
openssl.c:ossl_seed:
  441|    778|{
  442|       |  /* This might get called before it has been added to a multi handle */
  443|    778|  if(data->multi && data->multi->ssl_seeded)
  444|      0|    return CURLE_OK;
  445|       |
  446|    778|  if(rand_enough()) {
  447|       |    /* OpenSSL 1.1.0+ should return here */
  448|    778|    if(data->multi)
  449|      0|      data->multi->ssl_seeded = TRUE;
  450|    778|    return CURLE_OK;
  451|    778|  }
  452|       |#ifdef HAVE_RANDOM_INIT_BY_DEFAULT
  453|       |  /* with OpenSSL 1.1.0+, a failed RAND_status is a showstopper */
  454|       |  failf(data, "Insufficient randomness");
  455|       |  return CURLE_SSL_CONNECT_ERROR;
  456|       |#else
  457|       |
  458|       |#ifndef RANDOM_FILE
  459|       |  /* if RANDOM_FILE isn't defined, we only perform this if an option tells
  460|       |     us to! */
  461|       |  if(data->set.str[STRING_SSL_RANDOM_FILE])
  462|       |#define RANDOM_FILE "" /* doesn't matter won't be used */
  463|       |#endif
  464|      0|  {
  465|       |    /* let the option override the define */
  466|      0|    RAND_load_file((data->set.str[STRING_SSL_RANDOM_FILE]?
  467|      0|                    data->set.str[STRING_SSL_RANDOM_FILE]:
  468|      0|                    RANDOM_FILE),
  469|      0|                   RAND_LOAD_LENGTH);
  470|      0|    if(rand_enough())
  471|      0|      return CURLE_OK;
  472|      0|  }
  473|       |
  474|      0|#if defined(HAVE_RAND_EGD)
  475|       |  /* only available in OpenSSL 0.9.5 and later */
  476|       |  /* EGD_SOCKET is set at configure time or not at all */
  477|      0|#ifndef EGD_SOCKET
  478|       |  /* If we don't have the define set, we only do this if the egd-option
  479|       |     is set */
  480|      0|  if(data->set.str[STRING_SSL_EGDSOCKET])
  481|      0|#define EGD_SOCKET "" /* doesn't matter won't be used */
  482|      0|#endif
  483|      0|  {
  484|       |    /* If there's an option and a define, the option overrides the
  485|       |       define */
  486|      0|    int ret = RAND_egd(data->set.str[STRING_SSL_EGDSOCKET]?
  487|      0|                       data->set.str[STRING_SSL_EGDSOCKET]:EGD_SOCKET);
  488|      0|    if(-1 != ret) {
  489|      0|      if(rand_enough())
  490|      0|        return CURLE_OK;
  491|      0|    }
  492|      0|  }
  493|      0|#endif
  494|       |
  495|       |  /* fallback to a custom seeding of the PRNG using a hash based on a current
  496|       |     time */
  497|      0|  do {
  498|      0|    unsigned char randb[64];
  499|      0|    size_t len = sizeof(randb);
  500|      0|    size_t i, i_max;
  501|      0|    for(i = 0, i_max = len / sizeof(struct curltime); i < i_max; ++i) {
  502|      0|      struct curltime tv = Curl_now();
  503|      0|      Curl_wait_ms(1);
  504|      0|      tv.tv_sec *= i + 1;
  505|      0|      tv.tv_usec *= (unsigned int)i + 2;
  506|      0|      tv.tv_sec ^= ((Curl_now().tv_sec + Curl_now().tv_usec) *
  507|      0|                    (i + 3)) << 8;
  508|      0|      tv.tv_usec ^= (unsigned int) ((Curl_now().tv_sec +
  509|      0|                                     Curl_now().tv_usec) *
  510|      0|                                    (i + 4)) << 16;
  511|      0|      memcpy(&randb[i * sizeof(struct curltime)], &tv,
  512|      0|             sizeof(struct curltime));
  513|      0|    }
  514|      0|    RAND_add(randb, (int)len, (double)len/2);
  515|      0|  } while(!rand_enough());
  516|       |
  517|      0|  {
  518|       |    /* generates a default path for the random seed file */
  519|      0|    char fname[256];
  520|      0|    fname[0] = 0; /* blank it first */
  521|      0|    RAND_file_name(fname, sizeof(fname));
  522|      0|    if(fname[0]) {
  523|       |      /* we got a file name to try */
  524|      0|      RAND_load_file(fname, RAND_LOAD_LENGTH);
  525|      0|      if(rand_enough())
  526|      0|        return CURLE_OK;
  527|      0|    }
  528|      0|  }
  529|       |
  530|      0|  infof(data, "libcurl is now using a weak random seed!");
  531|      0|  return (rand_enough() ? CURLE_OK :
  532|      0|          CURLE_SSL_CONNECT_ERROR /* confusing error code */);
  533|      0|#endif
  534|      0|}
openssl.c:rand_enough:
  436|    778|{
  437|    778|  return (0 != RAND_status()) ? TRUE : FALSE;
  438|    778|}
openssl.c:ossl_close:
 1437|    506|{
 1438|    506|  ossl_closeone(data, conn, &conn->ssl[sockindex]);
 1439|    506|#ifndef CURL_DISABLE_PROXY
 1440|    506|  ossl_closeone(data, conn, &conn->proxy_ssl[sockindex]);
 1441|    506|#endif
 1442|    506|}
openssl.c:ossl_closeone:
 1410|  1.01k|{
 1411|  1.01k|  struct ssl_backend_data *backend = connssl->backend;
 1412|  1.01k|  if(backend->handle) {
 1413|      0|    char buf[32];
 1414|      0|    set_logger(conn, data);
 1415|       |
 1416|       |    /* Maybe the server has already sent a close notify alert.
 1417|       |       Read it to avoid an RST on the TCP connection. */
 1418|      0|    (void)SSL_read(backend->handle, buf, (int)sizeof(buf));
 1419|       |
 1420|      0|    (void)SSL_shutdown(backend->handle);
 1421|      0|    SSL_set_connect_state(backend->handle);
 1422|       |
 1423|      0|    SSL_free(backend->handle);
 1424|      0|    backend->handle = NULL;
 1425|      0|  }
 1426|  1.01k|  if(backend->ctx) {
 1427|      0|    SSL_CTX_free(backend->ctx);
 1428|      0|    backend->ctx = NULL;
 1429|      0|  }
 1430|  1.01k|}
openssl.c:ossl_close_all:
 1561|  1.05k|{
 1562|  1.05k|#ifdef USE_OPENSSL_ENGINE
 1563|  1.05k|  if(data->state.engine) {
 1564|      0|    ENGINE_finish(data->state.engine);
 1565|      0|    ENGINE_free(data->state.engine);
 1566|      0|    data->state.engine = NULL;
 1567|      0|  }
 1568|       |#else
 1569|       |  (void)data;
 1570|       |#endif
 1571|  1.05k|#if !defined(HAVE_ERR_REMOVE_THREAD_STATE_DEPRECATED) && \
 1572|  1.05k|  defined(HAVE_ERR_REMOVE_THREAD_STATE)
 1573|       |  /* OpenSSL 1.0.1 and 1.0.2 build an error queue that is stored per-thread
 1574|       |     so we need to clean it here in case the thread will be killed. All OpenSSL
 1575|       |     code should extract the error in association with the error so clearing
 1576|       |     this queue here should be harmless at worst. */
 1577|  1.05k|  ERR_remove_thread_state(NULL);
 1578|  1.05k|#endif
 1579|  1.05k|}
openssl.c:ossl_associate_connection:
 4485|    253|{
 4486|    253|  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 4487|    253|  struct ssl_backend_data *backend = connssl->backend;
 4488|       |
 4489|       |  /* If we don't have SSL context, do nothing. */
 4490|    253|  if(!backend->handle)
 4491|    253|    return;
 4492|       |
 4493|      0|  if(SSL_SET_OPTION(primary.sessionid)) {
 4494|      0|    int data_idx = ossl_get_ssl_data_index();
 4495|      0|    int connectdata_idx = ossl_get_ssl_conn_index();
 4496|      0|    int sockindex_idx = ossl_get_ssl_sockindex_index();
 4497|      0|    int proxy_idx = ossl_get_proxy_index();
 4498|       |
 4499|      0|    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&
 4500|      0|       proxy_idx >= 0) {
 4501|       |      /* Store the data needed for the "new session" callback.
 4502|       |       * The sockindex is stored as a pointer to an array element. */
 4503|      0|      SSL_set_ex_data(backend->handle, data_idx, data);
 4504|      0|      SSL_set_ex_data(backend->handle, connectdata_idx, conn);
 4505|      0|      SSL_set_ex_data(backend->handle, sockindex_idx, conn->sock + sockindex);
 4506|      0|#ifndef CURL_DISABLE_PROXY
 4507|      0|      SSL_set_ex_data(backend->handle, proxy_idx, SSL_IS_PROXY() ? (void *) 1:
 4508|      0|                      NULL);
 4509|       |#else
 4510|       |      SSL_set_ex_data(backend->handle, proxy_idx, NULL);
 4511|       |#endif
 4512|      0|    }
 4513|      0|  }
 4514|      0|}
openssl.c:ossl_disassociate_connection:
 4526|    253|{
 4527|    253|  struct connectdata *conn = data->conn;
 4528|    253|  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 4529|    253|  struct ssl_backend_data *backend = connssl->backend;
 4530|       |
 4531|       |  /* If we don't have SSL context, do nothing. */
 4532|    253|  if(!backend->handle)
 4533|    253|    return;
 4534|       |
 4535|      0|  if(SSL_SET_OPTION(primary.sessionid)) {
 4536|      0|    int data_idx = ossl_get_ssl_data_index();
 4537|      0|    int connectdata_idx = ossl_get_ssl_conn_index();
 4538|      0|    int sockindex_idx = ossl_get_ssl_sockindex_index();
 4539|      0|    int proxy_idx = ossl_get_proxy_index();
 4540|       |
 4541|      0|    if(data_idx >= 0 && connectdata_idx >= 0 && sockindex_idx >= 0 &&
 4542|      0|       proxy_idx >= 0) {
 4543|       |      /* Disable references to data in "new session" callback to avoid
 4544|       |       * accessing a stale pointer. */
 4545|      0|      SSL_set_ex_data(backend->handle, data_idx, NULL);
 4546|      0|      SSL_set_ex_data(backend->handle, connectdata_idx, NULL);
 4547|      0|      SSL_set_ex_data(backend->handle, sockindex_idx, NULL);
 4548|      0|      SSL_set_ex_data(backend->handle, proxy_idx, NULL);
 4549|      0|    }
 4550|      0|  }
 4551|      0|}

Curl_free_primary_ssl_config:
  194|    506|{
  195|    506|  Curl_safefree(sslc->CApath);
  196|    506|  Curl_safefree(sslc->CAfile);
  197|    506|  Curl_safefree(sslc->issuercert);
  198|    506|  Curl_safefree(sslc->clientcert);
  199|    506|  Curl_safefree(sslc->random_file);
  200|    506|  Curl_safefree(sslc->egdsocket);
  201|    506|  Curl_safefree(sslc->cipher_list);
  202|    506|  Curl_safefree(sslc->cipher_list13);
  203|    506|  Curl_safefree(sslc->pinned_key);
  204|    506|  Curl_safefree(sslc->cert_blob);
  205|    506|  Curl_safefree(sslc->ca_info_blob);
  206|    506|  Curl_safefree(sslc->issuercert_blob);
  207|    506|  Curl_safefree(sslc->curves);
  208|    506|}
Curl_ssl_backend:
  215|  1.05k|{
  216|  1.05k|#ifdef USE_SSL
  217|  1.05k|  multissl_setup(NULL);
  218|  1.05k|  return Curl_ssl->info.id;
  219|       |#else
  220|       |  return (int)CURLSSLBACKEND_NONE;
  221|       |#endif
  222|  1.05k|}
Curl_ssl_init:
  236|      1|{
  237|       |  /* make sure this is only done once */
  238|      1|  if(init_ssl)
  239|      0|    return 1;
  240|      1|  init_ssl = TRUE; /* never again */
  241|       |
  242|      1|  return Curl_ssl->init();
  243|      1|}
Curl_ssl_kill_session:
  474|  1.26k|{
  475|  1.26k|  if(session->sessionid) {
  476|       |    /* defensive check */
  477|       |
  478|       |    /* free the ID the SSL-layer specific way */
  479|      0|    Curl_ssl->session_free(session->sessionid);
  480|       |
  481|      0|    session->sessionid = NULL;
  482|      0|    session->age = 0; /* fresh */
  483|       |
  484|      0|    Curl_free_primary_ssl_config(&session->ssl_config);
  485|       |
  486|      0|    Curl_safefree(session->name);
  487|      0|    Curl_safefree(session->conn_to_host);
  488|      0|  }
  489|  1.26k|}
Curl_ssl_associate_conn:
  628|    253|{
  629|    253|  if(Curl_ssl->associate_connection) {
  630|    253|    Curl_ssl->associate_connection(data, conn, FIRSTSOCKET);
  631|    253|    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)
  632|      0|      Curl_ssl->associate_connection(data, conn, SECONDARYSOCKET);
  633|    253|  }
  634|    253|}
Curl_ssl_detach_conn:
  638|    253|{
  639|    253|  if(Curl_ssl->disassociate_connection) {
  640|    253|    Curl_ssl->disassociate_connection(data, FIRSTSOCKET);
  641|    253|    if(conn->sock[SECONDARYSOCKET] && conn->bits.sock_accepted)
  642|      0|      Curl_ssl->disassociate_connection(data, SECONDARYSOCKET);
  643|    253|  }
  644|    253|}
Curl_ssl_close_all:
  647|  1.05k|{
  648|       |  /* kill the session ID cache if not shared */
  649|  1.05k|  if(data->state.session && !SSLSESSION_SHARED(data)) {
  650|    253|    size_t i;
  651|  1.51k|    for(i = 0; i < data->set.general_ssl.max_ssl_sessions; i++)
  652|       |      /* the single-killer function handles empty table slots */
  653|  1.26k|      Curl_ssl_kill_session(&data->state.session[i]);
  654|       |
  655|       |    /* free the cache data */
  656|    253|    Curl_safefree(data->state.session);
  657|    253|  }
  658|       |
  659|  1.05k|  Curl_ssl->close_all(data);
  660|  1.05k|}
Curl_ssl_close:
  682|    506|{
  683|    506|  DEBUGASSERT((sockindex <= 1) && (sockindex >= -1));
  684|    506|  Curl_ssl->close_one(data, conn, sockindex);
  685|    506|  conn->ssl[sockindex].state = ssl_connection_none;
  686|    506|}
Curl_ssl_initsessions:
  728|    253|{
  729|    253|  struct Curl_ssl_session *session;
  730|       |
  731|    253|  if(data->state.session)
  732|       |    /* this is just a precaution to prevent multiple inits */
  733|      0|    return CURLE_OK;
  734|       |
  735|    253|  session = calloc(amount, sizeof(struct Curl_ssl_session));
  736|    253|  if(!session)
  737|      0|    return CURLE_OUT_OF_MEMORY;
  738|       |
  739|       |  /* store the info in the SSL section */
  740|    253|  data->set.general_ssl.max_ssl_sessions = amount;
  741|    253|  data->state.session = session;
  742|    253|  data->state.sessionage = 1; /* this is brand new */
  743|    253|  return CURLE_OK;
  744|    253|}
Curl_ssl_free_certinfo:
  777|  2.37k|{
  778|  2.37k|  struct curl_certinfo *ci = &data->info.certs;
  779|       |
  780|  2.37k|  if(ci->num_of_certs) {
  781|       |    /* free all individual lists used */
  782|      0|    int i;
  783|      0|    for(i = 0; i<ci->num_of_certs; i++) {
  784|      0|      curl_slist_free_all(ci->certinfo[i]);
  785|      0|      ci->certinfo[i] = NULL;
  786|      0|    }
  787|       |
  788|      0|    free(ci->certinfo); /* free the actual array too */
  789|      0|    ci->certinfo = NULL;
  790|      0|    ci->num_of_certs = 0;
  791|      0|  }
  792|  2.37k|}
Curl_ssl_random:
  870|    778|{
  871|    778|  return Curl_ssl->random(data, entropy, length);
  872|    778|}
vtls.c:multissl_setup:
 1389|  1.05k|{
 1390|  1.05k|  const char *env;
 1391|  1.05k|  char *env_tmp;
 1392|       |
 1393|  1.05k|  if(Curl_ssl != &Curl_ssl_multi)
 1394|  1.05k|    return 1;
 1395|       |
 1396|      0|  if(backend) {
 1397|      0|    Curl_ssl = backend;
 1398|      0|    return 0;
 1399|      0|  }
 1400|       |
 1401|      0|  if(!available_backends[0])
 1402|      0|    return 1;
 1403|       |
 1404|      0|  env = env_tmp = curl_getenv("CURL_SSL_BACKEND");
 1405|       |#ifdef CURL_DEFAULT_SSL_BACKEND
 1406|       |  if(!env)
 1407|       |    env = CURL_DEFAULT_SSL_BACKEND;
 1408|       |#endif
 1409|      0|  if(env) {
 1410|      0|    int i;
 1411|      0|    for(i = 0; available_backends[i]; i++) {
 1412|      0|      if(strcasecompare(env, available_backends[i]->info.name)) {
 1413|      0|        Curl_ssl = available_backends[i];
 1414|      0|        free(env_tmp);
 1415|      0|        return 0;
 1416|      0|      }
 1417|      0|    }
 1418|      0|  }
 1419|       |
 1420|       |  /* Fall back to first available backend */
 1421|      0|  Curl_ssl = available_backends[0];
 1422|      0|  free(env_tmp);
 1423|      0|  return 0;
 1424|      0|}

curlx_ultouc:
   82|     54|{
   83|       |#ifdef __INTEL_COMPILER
   84|       |#  pragma warning(push)
   85|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
   86|       |#endif
   87|       |
   88|     54|  DEBUGASSERT(ulnum <= (unsigned long) CURL_MASK_UCHAR);
   89|     54|  return (unsigned char)(ulnum & (unsigned long) CURL_MASK_UCHAR);
   90|       |
   91|       |#ifdef __INTEL_COMPILER
   92|       |#  pragma warning(pop)
   93|       |#endif
   94|     54|}
curlx_uztosi:
  123|    778|{
  124|       |#ifdef __INTEL_COMPILER
  125|       |#  pragma warning(push)
  126|       |#  pragma warning(disable:810) /* conversion may lose significant bits */
  127|       |#endif
  128|       |
  129|    778|  DEBUGASSERT(uznum <= (size_t) CURL_MASK_SINT);
  130|    778|  return (int)(uznum & (size_t) CURL_MASK_SINT);
  131|       |
  132|       |#ifdef __INTEL_COMPILER
  133|       |#  pragma warning(pop)
  134|       |#endif
  135|    778|}

Curl_wildcard_init:
   42|      1|{
   43|      1|  Curl_llist_init(&wc->filelist, fileinfo_dtor);
   44|      1|  wc->state = CURLWC_INIT;
   45|       |
   46|      1|  return CURLE_OK;
   47|      1|}
Curl_wildcard_dtor:
   50|  1.52k|{
   51|  1.52k|  if(!wc)
   52|      0|    return;
   53|       |
   54|  1.52k|  if(wc->dtor) {
   55|      0|    wc->dtor(wc->protdata);
   56|      0|    wc->dtor = ZERO_NULL;
   57|      0|    wc->protdata = NULL;
   58|      0|  }
   59|  1.52k|  DEBUGASSERT(wc->protdata == NULL);
   60|       |
   61|  1.52k|  Curl_llist_destroy(&wc->filelist, NULL);
   62|       |
   63|       |
   64|  1.52k|  free(wc->path);
   65|  1.52k|  wc->path = NULL;
   66|  1.52k|  free(wc->pattern);
   67|  1.52k|  wc->pattern = NULL;
   68|       |
   69|  1.52k|  wc->customptr = NULL;
   70|  1.52k|  wc->state = CURLWC_INIT;
   71|  1.52k|}

LLVMFuzzerTestOneInput:
   35|    598|{
   36|    598|  int rc = 0;
   37|    598|  int tlv_rc;
   38|    598|  FUZZ_DATA fuzz;
   39|    598|  TLV tlv;
   40|       |
   41|       |  /* Ignore SIGPIPE errors. We'll handle the errors ourselves. */
   42|    598|  signal(SIGPIPE, SIG_IGN);
   43|       |
   44|       |  /* Have to set all fields to zero before getting to the terminate function */
   45|    598|  memset(&fuzz, 0, sizeof(FUZZ_DATA));
   46|       |
   47|    598|  if(size < sizeof(TLV_RAW)) {
   48|       |    /* Not enough data for a single TLV - don't continue */
   49|      1|    goto EXIT_LABEL;
   50|      1|  }
   51|       |
   52|       |  /* Try to initialize the fuzz data */
   53|    597|  FTRY(fuzz_initialize_fuzz_data(&fuzz, data, size));
   54|       |
   55|    597|  for(tlv_rc = fuzz_get_first_tlv(&fuzz, &tlv);
   56|  6.80k|      tlv_rc == 0;
   57|  6.26k|      tlv_rc = fuzz_get_next_tlv(&fuzz, &tlv)) {
   58|       |
   59|       |    /* Have the TLV in hand. Parse the TLV. */
   60|  6.26k|    rc = fuzz_parse_tlv(&fuzz, &tlv);
   61|       |
   62|  6.26k|    if(rc != 0) {
   63|       |      /* Failed to parse the TLV. Can't continue. */
   64|     56|      goto EXIT_LABEL;
   65|     56|    }
   66|  6.26k|  }
   67|       |
   68|    541|  if(tlv_rc != TLV_RC_NO_MORE_TLVS) {
   69|       |    /* A TLV call failed. Can't continue. */
   70|     79|    goto EXIT_LABEL;
   71|     79|  }
   72|       |
   73|       |  /* Set up the standard easy options. */
   74|    462|  FTRY(fuzz_set_easy_options(&fuzz));
   75|       |
   76|       |  /**
   77|       |   * Add in more curl options that have been accumulated over possibly
   78|       |   * multiple TLVs.
   79|       |   */
   80|    462|  if(fuzz.header_list != NULL) {
   81|     13|    curl_easy_setopt(fuzz.easy, CURLOPT_HTTPHEADER, fuzz.header_list);
   82|     13|  }
   83|       |
   84|    462|  if(fuzz.mail_recipients_list != NULL) {
   85|     27|    curl_easy_setopt(fuzz.easy, CURLOPT_MAIL_RCPT, fuzz.mail_recipients_list);
   86|     27|  }
   87|       |
   88|    462|  if(fuzz.mime != NULL) {
   89|     68|    curl_easy_setopt(fuzz.easy, CURLOPT_MIMEPOST, fuzz.mime);
   90|     68|  }
   91|       |
   92|       |  /* Run the transfer. */
   93|    462|  fuzz_handle_transfer(&fuzz);
   94|       |
   95|    598|EXIT_LABEL:
   96|       |
   97|    598|  fuzz_terminate_fuzz_data(&fuzz);
   98|       |
   99|       |  /* This function must always return 0. Non-zero codes are reserved. */
  100|    598|  return 0;
  101|    462|}
_Z6to_u32PKh:
  107|  7.25k|{
  108|  7.25k|  uint32_t u;
  109|  7.25k|  u = (b[0] << 24) + (b[1] << 16) + (b[2] << 8) + b[3];
  110|  7.25k|  return u;
  111|  7.25k|}
_Z6to_u16PKh:
  117|  7.22k|{
  118|  7.22k|  uint16_t u;
  119|  7.22k|  u = (b[0] << 8) + b[1];
  120|  7.22k|  return u;
  121|  7.22k|}
_Z25fuzz_initialize_fuzz_dataP9fuzz_dataPKhm:
  129|    597|{
  130|    597|  int rc = 0;
  131|    597|  int ii;
  132|       |
  133|       |  /* Initialize the fuzz data. */
  134|    597|  memset(fuzz, 0, sizeof(FUZZ_DATA));
  135|       |
  136|       |  /* Create an easy handle. This will have all of the settings configured on
  137|       |     it. */
  138|    597|  fuzz->easy = curl_easy_init();
  139|    597|  FCHECK(fuzz->easy != NULL);
  140|       |
  141|       |  /* Set up the state parser */
  142|    597|  fuzz->state.data = data;
  143|    597|  fuzz->state.data_len = data_len;
  144|       |
  145|       |  /* Set up the state of the server sockets. */
  146|  1.79k|  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  147|  1.19k|    fuzz->sockman[ii].index = ii;
  148|  1.19k|    fuzz->sockman[ii].fd_state = FUZZ_SOCK_CLOSED;
  149|  1.19k|  }
  150|       |
  151|       |  /* Check for verbose mode. */
  152|    597|  fuzz->verbose = (getenv("FUZZ_VERBOSE") != NULL);
  153|       |
  154|    597|EXIT_LABEL:
  155|       |
  156|    597|  return rc;
  157|    597|}
_Z21fuzz_set_easy_optionsP9fuzz_data:
  163|    462|{
  164|    462|  int rc = 0;
  165|    462|  unsigned long allowed_protocols;
  166|       |
  167|       |  /* Set some standard options on the CURL easy handle. We need to override the
  168|       |     socket function so that we create our own sockets to present to CURL. */
  169|    462|  FTRY(curl_easy_setopt(fuzz->easy,
  170|    462|                        CURLOPT_OPENSOCKETFUNCTION,
  171|    462|                        fuzz_open_socket));
  172|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_OPENSOCKETDATA, fuzz));
  173|       |
  174|       |  /* In case something tries to set a socket option, intercept this. */
  175|    462|  FTRY(curl_easy_setopt(fuzz->easy,
  176|    462|                        CURLOPT_SOCKOPTFUNCTION,
  177|    462|                        fuzz_sockopt_callback));
  178|       |
  179|       |  /* Set the standard read function callback. */
  180|    462|  FTRY(curl_easy_setopt(fuzz->easy,
  181|    462|                        CURLOPT_READFUNCTION,
  182|    462|                        fuzz_read_callback));
  183|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_READDATA, fuzz));
  184|       |
  185|       |  /* Set the standard write function callback. */
  186|    462|  FTRY(curl_easy_setopt(fuzz->easy,
  187|    462|                        CURLOPT_WRITEFUNCTION,
  188|    462|                        fuzz_write_callback));
  189|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_WRITEDATA, fuzz));
  190|       |
  191|       |  /* Set the cookie jar so cookies are tested. */
  192|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_COOKIEJAR, FUZZ_COOKIE_JAR_PATH));
  193|       |
  194|       |  /* Time out requests quickly. */
  195|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_TIMEOUT_MS, 200L));
  196|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_SERVER_RESPONSE_TIMEOUT, 1L));
  197|       |
  198|       |  /* Can enable verbose mode by having the environment variable FUZZ_VERBOSE. */
  199|    462|  if(fuzz->verbose) {
  200|      0|    FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_VERBOSE, 1L));
  201|      0|  }
  202|       |
  203|       |  /* Force resolution of all addresses to a specific IP address. */
  204|    462|  fuzz->connect_to_list = curl_slist_append(NULL, "::127.0.1.127:");
  205|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_CONNECT_TO, fuzz->connect_to_list));
  206|       |
  207|       |  /* Limit the protocols in use by this fuzzer. */
  208|    462|  FTRY(fuzz_set_allowed_protocols(fuzz));
  209|       |
  210|    462|EXIT_LABEL:
  211|       |
  212|    462|  return rc;
  213|    462|}
_Z24fuzz_terminate_fuzz_dataP9fuzz_data:
  219|    598|{
  220|    598|  int ii;
  221|       |
  222|    598|  fuzz_free((void **)&fuzz->postfields);
  223|       |
  224|  1.79k|  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  225|  1.19k|    if(fuzz->sockman[ii].fd_state != FUZZ_SOCK_CLOSED) {
  226|      0|      close(fuzz->sockman[ii].fd);
  227|      0|      fuzz->sockman[ii].fd_state = FUZZ_SOCK_CLOSED;
  228|      0|    }
  229|  1.19k|  }
  230|       |
  231|    598|  if(fuzz->connect_to_list != NULL) {
  232|    462|    curl_slist_free_all(fuzz->connect_to_list);
  233|    462|    fuzz->connect_to_list = NULL;
  234|    462|  }
  235|       |
  236|    598|  if(fuzz->header_list != NULL) {
  237|     19|    curl_slist_free_all(fuzz->header_list);
  238|     19|    fuzz->header_list = NULL;
  239|     19|  }
  240|       |
  241|    598|  if(fuzz->mail_recipients_list != NULL) {
  242|     43|    curl_slist_free_all(fuzz->mail_recipients_list);
  243|     43|    fuzz->mail_recipients_list = NULL;
  244|     43|  }
  245|       |
  246|    598|  if(fuzz->mime != NULL) {
  247|    158|    curl_mime_free(fuzz->mime);
  248|    158|    fuzz->mime = NULL;
  249|    158|  }
  250|       |
  251|    598|  if(fuzz->easy != NULL) {
  252|    597|    curl_easy_cleanup(fuzz->easy);
  253|    597|    fuzz->easy = NULL;
  254|    597|  }
  255|    598|}
_Z9fuzz_freePPv:
  261|  6.88k|{
  262|  6.88k|  if(*ptr != NULL) {
  263|  1.88k|    free(*ptr);
  264|  1.88k|    *ptr = NULL;
  265|  1.88k|  }
  266|  6.88k|}
_Z20fuzz_handle_transferP9fuzz_data:
  273|    462|{
  274|    462|  int rc = 0;
  275|    462|  CURLM *multi_handle;
  276|    462|  int still_running; /* keep number of running handles */
  277|    462|  CURLMsg *msg; /* for picking up messages with the transfer status */
  278|    462|  int msgs_left; /* how many messages are left */
  279|    462|  int double_timeout = 0;
  280|    462|  fd_set fdread;
  281|    462|  fd_set fdwrite;
  282|    462|  fd_set fdexcep;
  283|    462|  struct timeval timeout;
  284|    462|  int select_rc;
  285|    462|  CURLMcode mc;
  286|    462|  int maxfd = -1;
  287|    462|  long curl_timeo = -1;
  288|    462|  int ii;
  289|    462|  FUZZ_SOCKET_MANAGER *sman[FUZZ_NUM_CONNECTIONS];
  290|       |
  291|  1.38k|  for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  292|    924|    sman[ii] = &fuzz->sockman[ii];
  293|       |
  294|       |    /* Set up the starting index for responses. */
  295|    924|    sman[ii]->response_index = 1;
  296|    924|  }
  297|       |
  298|       |  /* init a multi stack */
  299|    462|  multi_handle = curl_multi_init();
  300|       |
  301|       |  /* add the individual transfers */
  302|    462|  curl_multi_add_handle(multi_handle, fuzz->easy);
  303|       |
  304|       |  /* Do an initial process. This might end the transfer immediately. */
  305|    462|  curl_multi_perform(multi_handle, &still_running);
  306|    462|  FV_PRINTF(fuzz,
  307|    462|            "FUZZ: Initial perform; still running? %d \n",
  308|    462|            still_running);
  309|       |
  310|    462|  while(still_running) {
  311|       |    /* Reset the sets of file descriptors. */
  312|      0|    FD_ZERO(&fdread);
  313|      0|    FD_ZERO(&fdwrite);
  314|      0|    FD_ZERO(&fdexcep);
  315|       |
  316|       |    /* Set a timeout of 10ms. This is lower than recommended by the multi guide
  317|       |       but we're not going to any remote servers, so everything should complete
  318|       |       very quickly. */
  319|      0|    timeout.tv_sec = 0;
  320|      0|    timeout.tv_usec = 10000;
  321|       |
  322|       |    /* get file descriptors from the transfers */
  323|      0|    mc = curl_multi_fdset(multi_handle, &fdread, &fdwrite, &fdexcep, &maxfd);
  324|      0|    if(mc != CURLM_OK) {
  325|      0|      fprintf(stderr, "curl_multi_fdset() failed, code %d.\n", mc);
  326|      0|      rc = -1;
  327|      0|      break;
  328|      0|    }
  329|       |
  330|      0|    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  331|       |      /* Add the socket FD into the readable set if connected. */
  332|      0|      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN) {
  333|      0|        FD_SET(sman[ii]->fd, &fdread);
  334|       |
  335|       |        /* Work out the maximum FD between the cURL file descriptors and the
  336|       |           server FD. */
  337|      0|        maxfd = FUZZ_MAX(sman[ii]->fd, maxfd);
  338|      0|      }
  339|      0|    }
  340|       |
  341|       |    /* Work out what file descriptors need work. */
  342|      0|    rc = fuzz_select(maxfd + 1, &fdread, &fdwrite, &fdexcep, &timeout);
  343|       |
  344|      0|    if(rc == -1) {
  345|       |      /* Had an issue while selecting a file descriptor. Let's just exit. */
  346|      0|      FV_PRINTF(fuzz, "FUZZ: select failed, exiting \n");
  347|      0|      break;
  348|      0|    }
  349|      0|    else if(rc == 0) {
  350|      0|      FV_PRINTF(fuzz,
  351|      0|                "FUZZ: Timed out; double timeout? %d \n",
  352|      0|                double_timeout);
  353|       |
  354|       |      /* Timed out. */
  355|      0|      if(double_timeout == 1) {
  356|       |        /* We don't expect multiple timeouts in a row. If there are double
  357|       |           timeouts then exit. */
  358|      0|        break;
  359|      0|      }
  360|      0|      else {
  361|       |        /* Set the timeout flag for the next time we select(). */
  362|      0|        double_timeout = 1;
  363|      0|      }
  364|      0|    }
  365|      0|    else {
  366|       |      /* There's an active file descriptor. Reset the timeout flag. */
  367|      0|      double_timeout = 0;
  368|      0|    }
  369|       |
  370|       |    /* Check to see if a server file descriptor is readable. If it is,
  371|       |       then send the next response from the fuzzing data. */
  372|      0|    for(ii = 0; ii < FUZZ_NUM_CONNECTIONS; ii++) {
  373|      0|      if(sman[ii]->fd_state == FUZZ_SOCK_OPEN &&
  374|      0|         FD_ISSET(sman[ii]->fd, &fdread)) {
  375|      0|        rc = fuzz_send_next_response(fuzz, sman[ii]);
  376|      0|        if(rc != 0) {
  377|       |          /* Failed to send a response. Break out here. */
  378|      0|          break;
  379|      0|        }
  380|      0|      }
  381|      0|    }
  382|       |
  383|      0|    curl_multi_perform(multi_handle, &still_running);
  384|      0|  }
  385|       |
  386|       |  /* Remove the easy handle from the multi stack. */
  387|    462|  curl_multi_remove_handle(multi_handle, fuzz->easy);
  388|       |
  389|       |  /* Clean up the multi handle - the top level function will handle the easy
  390|       |     handle. */
  391|    462|  curl_multi_cleanup(multi_handle);
  392|       |
  393|    462|  return(rc);
  394|    462|}
_Z26fuzz_set_allowed_protocolsP9fuzz_data:
  468|    462|{
  469|    462|  int rc = 0;
  470|    462|  unsigned long allowed_protocols = 0;
  471|       |
  472|       |#ifdef FUZZ_PROTOCOLS_ALL
  473|       |  /* Do not allow telnet currently as it accepts input from stdin. */
  474|       |  allowed_protocols |= CURLPROTO_ALL & ~CURLPROTO_TELNET;
  475|       |#endif
  476|       |#ifdef FUZZ_PROTOCOLS_DICT
  477|       |  allowed_protocols |= CURLPROTO_DICT;
  478|       |#endif
  479|       |#ifdef FUZZ_PROTOCOLS_FILE
  480|       |  allowed_protocols |= CURLPROTO_FILE;
  481|       |#endif
  482|       |#ifdef FUZZ_PROTOCOLS_FTP
  483|       |  allowed_protocols |= CURLPROTO_FTP;
  484|       |  allowed_protocols |= CURLPROTO_FTPS;
  485|       |#endif
  486|       |#ifdef FUZZ_PROTOCOLS_GOPHER
  487|       |  allowed_protocols |= CURLPROTO_GOPHER;
  488|       |#endif
  489|       |#ifdef FUZZ_PROTOCOLS_HTTP
  490|       |  allowed_protocols |= CURLPROTO_HTTP;
  491|       |#endif
  492|       |#ifdef FUZZ_PROTOCOLS_HTTPS
  493|       |  allowed_protocols |= CURLPROTO_HTTPS;
  494|       |#endif
  495|       |#ifdef FUZZ_PROTOCOLS_IMAP
  496|       |  allowed_protocols |= CURLPROTO_IMAP;
  497|       |  allowed_protocols |= CURLPROTO_IMAPS;
  498|       |#endif
  499|    462|#ifdef FUZZ_PROTOCOLS_LDAP
  500|    462|  allowed_protocols |= CURLPROTO_LDAP;
  501|    462|  allowed_protocols |= CURLPROTO_LDAPS;
  502|    462|#endif
  503|       |#ifdef FUZZ_PROTOCOLS_MQTT
  504|       |  allowed_protocols |= CURLPROTO_MQTT;
  505|       |#endif
  506|       |#ifdef FUZZ_PROTOCOLS_POP3
  507|       |  allowed_protocols |= CURLPROTO_POP3;
  508|       |  allowed_protocols |= CURLPROTO_POP3S;
  509|       |#endif
  510|       |#ifdef FUZZ_PROTOCOLS_RTMP
  511|       |  allowed_protocols |= CURLPROTO_RTMP;
  512|       |  allowed_protocols |= CURLPROTO_RTMPE;
  513|       |  allowed_protocols |= CURLPROTO_RTMPS;
  514|       |  allowed_protocols |= CURLPROTO_RTMPT;
  515|       |  allowed_protocols |= CURLPROTO_RTMPTE;
  516|       |  allowed_protocols |= CURLPROTO_RTMPTS;
  517|       |#endif
  518|       |#ifdef FUZZ_PROTOCOLS_RTSP
  519|       |  allowed_protocols |= CURLPROTO_RTSP;
  520|       |#endif
  521|       |#ifdef FUZZ_PROTOCOLS_SCP
  522|       |  allowed_protocols |= CURLPROTO_SCP;
  523|       |#endif
  524|       |#ifdef FUZZ_PROTOCOLS_SFTP
  525|       |  allowed_protocols |= CURLPROTO_SFTP;
  526|       |#endif
  527|       |#ifdef FUZZ_PROTOCOLS_SMB
  528|       |  allowed_protocols |= CURLPROTO_SMB;
  529|       |  allowed_protocols |= CURLPROTO_SMBS;
  530|       |#endif
  531|       |#ifdef FUZZ_PROTOCOLS_SMTP
  532|       |  allowed_protocols |= CURLPROTO_SMTP;
  533|       |  allowed_protocols |= CURLPROTO_SMTPS;
  534|       |#endif
  535|       |#ifdef FUZZ_PROTOCOLS_TFTP
  536|       |  allowed_protocols |= CURLPROTO_TFTP;
  537|       |#endif
  538|       |
  539|    462|  FTRY(curl_easy_setopt(fuzz->easy, CURLOPT_PROTOCOLS, allowed_protocols));
  540|       |
  541|    462|EXIT_LABEL:
  542|       |
  543|    462|  return rc;
  544|    462|}

_Z18fuzz_get_first_tlvP9fuzz_dataP3tlv:
   32|  1.01k|{
   33|       |  /* Reset the cursor. */
   34|  1.01k|  fuzz->state.data_pos = 0;
   35|  1.01k|  return fuzz_get_tlv_comn(fuzz, tlv);
   36|  1.01k|}
_Z17fuzz_get_next_tlvP9fuzz_dataP3tlv:
   43|  6.83k|{
   44|       |  /* Advance the cursor by the full length of the previous TLV. */
   45|  6.83k|  fuzz->state.data_pos += sizeof(TLV_RAW) + tlv->length;
   46|       |
   47|       |  /* Work out if there's a TLV's worth of data to read */
   48|  6.83k|  if(fuzz->state.data_pos + sizeof(TLV_RAW) > fuzz->state.data_len) {
   49|       |    /* No more TLVs to parse */
   50|    615|    return TLV_RC_NO_MORE_TLVS;
   51|    615|  }
   52|       |
   53|  6.21k|  return fuzz_get_tlv_comn(fuzz, tlv);
   54|  6.83k|}
_Z17fuzz_get_tlv_comnP9fuzz_dataP3tlv:
   61|  7.22k|{
   62|  7.22k|  int rc = 0;
   63|  7.22k|  size_t data_offset;
   64|  7.22k|  TLV_RAW *raw;
   65|       |
   66|       |  /* Start by casting the data stream to a TLV. */
   67|  7.22k|  raw = (TLV_RAW *)&fuzz->state.data[fuzz->state.data_pos];
   68|  7.22k|  data_offset = fuzz->state.data_pos + sizeof(TLV_RAW);
   69|       |
   70|       |  /* Set the TLV values. */
   71|  7.22k|  tlv->type = to_u16(raw->raw_type);
   72|  7.22k|  tlv->length = to_u32(raw->raw_length);
   73|  7.22k|  tlv->value = &fuzz->state.data[data_offset];
   74|       |
   75|  7.22k|  FV_PRINTF(fuzz, "TLV: type %x length %u\n", tlv->type, tlv->length);
   76|       |
   77|       |  /* Use uint64s to verify lengths of TLVs so that overflow problems don't
   78|       |     matter. */
   79|  7.22k|  uint64_t check_length = data_offset;
   80|  7.22k|  check_length += tlv->length;
   81|       |
   82|  7.22k|  uint64_t remaining_len = fuzz->state.data_len;
   83|  7.22k|  FV_PRINTF(fuzz, "Check length of data: %lu \n", check_length);
   84|  7.22k|  FV_PRINTF(fuzz, "Remaining length of data: %lu \n", remaining_len);
   85|       |
   86|       |  /* Sanity check that the TLV length is ok. */
   87|  7.22k|  if(check_length > remaining_len) {
   88|    205|    FV_PRINTF(fuzz, "Returning TLV_RC_SIZE_ERROR\n");
   89|    205|    rc = TLV_RC_SIZE_ERROR;
   90|    205|  }
   91|       |
   92|  7.22k|  return rc;
   93|  7.22k|}
_Z14fuzz_parse_tlvP9fuzz_dataP3tlv:
   99|  6.26k|{
  100|  6.26k|  int rc;
  101|  6.26k|  char *tmp = NULL;
  102|  6.26k|  uint32_t tmp_u32;
  103|       |
  104|  6.26k|  switch(tlv->type) {
  105|       |    /* The pointers in response TLVs will always be valid as long as the fuzz
  106|       |       data is in scope, which is the entirety of this file. */
  107|     66|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE0, 0);
  108|     67|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE1, 1);
  109|     66|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE2, 2);
  110|     66|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE3, 3);
  111|     69|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE4, 4);
  112|     66|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE5, 5);
  113|     66|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE6, 6);
  114|     67|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE7, 7);
  115|     83|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE8, 8);
  116|     66|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE9, 9);
  117|     66|    FRESPONSETLV(&fuzz->sockman[0], TLV_TYPE_RESPONSE10, 10);
  118|       |
  119|    130|    FRESPONSETLV(&fuzz->sockman[1], TLV_TYPE_SECOND_RESPONSE0, 0);
  120|     66|    FRESPONSETLV(&fuzz->sockman[1], TLV_TYPE_SECOND_RESPONSE1, 1);
  121|       |
  122|      7|    case TLV_TYPE_UPLOAD1:
  123|       |      /* The pointers in the TLV will always be valid as long as the fuzz data
  124|       |         is in scope, which is the entirety of this file. */
  125|       |
  126|      7|      FCHECK_OPTION_UNSET(fuzz, CURLOPT_UPLOAD);
  127|       |
  128|      6|      fuzz->upload1_data = tlv->value;
  129|      6|      fuzz->upload1_data_len = tlv->length;
  130|       |
  131|      6|      FSET_OPTION(fuzz, CURLOPT_UPLOAD, 1L);
  132|      6|      FSET_OPTION(fuzz,
  133|      6|                  CURLOPT_INFILESIZE_LARGE,
  134|      6|                  (curl_off_t)fuzz->upload1_data_len);
  135|      6|      break;
  136|       |
  137|     88|    case TLV_TYPE_HEADER:
  138|       |      /* Limit the number of headers that can be added to a message to prevent
  139|       |         timeouts. */
  140|     88|      if(fuzz->header_list_count >= TLV_MAX_NUM_CURLOPT_HEADER) {
  141|      0|        rc = 255;
  142|      0|        goto EXIT_LABEL;
  143|      0|      }
  144|       |
  145|     88|      tmp = fuzz_tlv_to_string(tlv);
  146|     88|      fuzz->header_list = curl_slist_append(fuzz->header_list, tmp);
  147|     88|      fuzz->header_list_count++;
  148|     88|      break;
  149|       |
  150|  1.46k|    case TLV_TYPE_MAIL_RECIPIENT:
  151|  1.46k|      tmp = fuzz_tlv_to_string(tlv);
  152|  1.46k|      fuzz->mail_recipients_list =
  153|  1.46k|                            curl_slist_append(fuzz->mail_recipients_list, tmp);
  154|  1.46k|      break;
  155|       |
  156|  3.36k|    case TLV_TYPE_MIME_PART:
  157|  3.36k|      if(fuzz->mime == NULL) {
  158|    158|        fuzz->mime = curl_mime_init(fuzz->easy);
  159|    158|      }
  160|       |
  161|  3.36k|      fuzz->part = curl_mime_addpart(fuzz->mime);
  162|       |
  163|       |      /* This TLV may have sub TLVs. */
  164|  3.36k|      fuzz_add_mime_part(tlv, fuzz->part);
  165|  3.36k|      break;
  166|       |
  167|      8|    case TLV_TYPE_POSTFIELDS:
  168|      8|      FCHECK_OPTION_UNSET(fuzz, CURLOPT_POSTFIELDS);
  169|      7|      fuzz->postfields = fuzz_tlv_to_string(tlv);
  170|      7|      FSET_OPTION(fuzz, CURLOPT_POSTFIELDS, fuzz->postfields);
  171|      7|      break;
  172|       |
  173|       |    /* Define a set of u32 options. */
  174|     24|    FU32TLV(fuzz, TLV_TYPE_HTTPAUTH, CURLOPT_HTTPAUTH);
  175|      9|    FU32TLV(fuzz, TLV_TYPE_OPTHEADER, CURLOPT_HEADER);
  176|     15|    FU32TLV(fuzz, TLV_TYPE_NOBODY, CURLOPT_NOBODY);
  177|      9|    FU32TLV(fuzz, TLV_TYPE_FOLLOWLOCATION, CURLOPT_FOLLOWLOCATION);
  178|     12|    FU32TLV(fuzz, TLV_TYPE_WILDCARDMATCH, CURLOPT_WILDCARDMATCH);
  179|     12|    FU32TLV(fuzz, TLV_TYPE_RTSP_REQUEST, CURLOPT_RTSP_REQUEST);
  180|      9|    FU32TLV(fuzz, TLV_TYPE_RTSP_CLIENT_CSEQ, CURLOPT_RTSP_CLIENT_CSEQ);
  181|     15|    FU32TLV(fuzz, TLV_TYPE_HTTP_VERSION, CURLOPT_HTTP_VERSION);
  182|       |
  183|       |    /* Define a set of singleton TLVs - they can only have their value set once
  184|       |       and all follow the same pattern. */
  185|    521|    FSINGLETONTLV(fuzz, TLV_TYPE_URL, CURLOPT_URL);
  186|      5|    FSINGLETONTLV(fuzz, TLV_TYPE_DOH_URL, CURLOPT_DOH_URL);
  187|      7|    FSINGLETONTLV(fuzz, TLV_TYPE_USERNAME, CURLOPT_USERNAME);
  188|     11|    FSINGLETONTLV(fuzz, TLV_TYPE_PASSWORD, CURLOPT_PASSWORD);
  189|      5|    FSINGLETONTLV(fuzz, TLV_TYPE_COOKIE, CURLOPT_COOKIE);
  190|      5|    FSINGLETONTLV(fuzz, TLV_TYPE_RANGE, CURLOPT_RANGE);
  191|     11|    FSINGLETONTLV(fuzz, TLV_TYPE_CUSTOMREQUEST, CURLOPT_CUSTOMREQUEST);
  192|     19|    FSINGLETONTLV(fuzz, TLV_TYPE_MAIL_FROM, CURLOPT_MAIL_FROM);
  193|     17|    FSINGLETONTLV(fuzz, TLV_TYPE_ACCEPTENCODING, CURLOPT_ACCEPT_ENCODING);
  194|      5|    FSINGLETONTLV(fuzz, TLV_TYPE_RTSP_SESSION_ID, CURLOPT_RTSP_SESSION_ID);
  195|      9|    FSINGLETONTLV(fuzz, TLV_TYPE_RTSP_STREAM_URI, CURLOPT_RTSP_STREAM_URI);
  196|      5|    FSINGLETONTLV(fuzz, TLV_TYPE_RTSP_TRANSPORT, CURLOPT_RTSP_TRANSPORT);
  197|      5|    FSINGLETONTLV(fuzz, TLV_TYPE_MAIL_AUTH, CURLOPT_MAIL_AUTH);
  198|       |
  199|     23|    default:
  200|       |      /* The fuzzer generates lots of unknown TLVs - we don't want these in the
  201|       |         corpus so we reject any unknown TLVs. */
  202|     23|      rc = 127;
  203|     23|      goto EXIT_LABEL;
  204|      0|      break;
  205|  6.26k|  }
  206|       |
  207|  6.20k|  rc = 0;
  208|       |
  209|  6.26k|EXIT_LABEL:
  210|       |
  211|  6.26k|  fuzz_free((void **)&tmp);
  212|       |
  213|  6.26k|  return rc;
  214|  6.20k|}
_Z18fuzz_tlv_to_stringP3tlv:
  220|  1.88k|{
  221|  1.88k|  char *tlvstr;
  222|       |
  223|       |  /* Allocate enough space, plus a null terminator */
  224|  1.88k|  tlvstr = (char *)malloc(tlv->length + 1);
  225|       |
  226|  1.88k|  if(tlvstr != NULL) {
  227|  1.88k|    memcpy(tlvstr, tlv->value, tlv->length);
  228|  1.88k|    tlvstr[tlv->length] = 0;
  229|  1.88k|  }
  230|       |
  231|  1.88k|  return tlvstr;
  232|  1.88k|}
_Z18fuzz_add_mime_partP3tlvP13curl_mimepart:
  238|  3.36k|{
  239|  3.36k|  FUZZ_DATA part_fuzz;
  240|  3.36k|  TLV tlv;
  241|  3.36k|  int rc = 0;
  242|  3.36k|  int tlv_rc;
  243|       |
  244|  3.36k|  memset(&part_fuzz, 0, sizeof(FUZZ_DATA));
  245|       |
  246|  3.36k|  if(src_tlv->length < sizeof(TLV_RAW)) {
  247|       |    /* Not enough data for a single TLV - don't continue */
  248|  2.94k|    goto EXIT_LABEL;
  249|  2.94k|  }
  250|       |
  251|       |  /* Set up the state parser */
  252|    417|  part_fuzz.state.data = src_tlv->value;
  253|    417|  part_fuzz.state.data_len = src_tlv->length;
  254|       |
  255|    417|  for(tlv_rc = fuzz_get_first_tlv(&part_fuzz, &tlv);
  256|  1.04k|      tlv_rc == 0;
  257|    763|      tlv_rc = fuzz_get_next_tlv(&part_fuzz, &tlv)) {
  258|       |
  259|       |    /* Have the TLV in hand. Parse the TLV. */
  260|    763|    rc = fuzz_parse_mime_tlv(part, &tlv);
  261|       |
  262|    763|    if(rc != 0) {
  263|       |      /* Failed to parse the TLV. Can't continue. */
  264|    138|      goto EXIT_LABEL;
  265|    138|    }
  266|    763|  }
  267|       |
  268|    279|  if(tlv_rc != TLV_RC_NO_MORE_TLVS) {
  269|       |    /* A TLV call failed. Can't continue. */
  270|    126|    goto EXIT_LABEL;
  271|    126|  }
  272|       |
  273|  3.36k|EXIT_LABEL:
  274|       |
  275|  3.36k|  return(rc);
  276|    279|}
_Z19fuzz_parse_mime_tlvP13curl_mimepartP3tlv:
  282|    763|{
  283|    763|  int rc;
  284|    763|  char *tmp;
  285|       |
  286|    763|  switch(tlv->type) {
  287|     23|    case TLV_TYPE_MIME_PART_NAME:
  288|     23|      tmp = fuzz_tlv_to_string(tlv);
  289|     23|      curl_mime_name(part, tmp);
  290|     23|      fuzz_free((void **)&tmp);
  291|     23|      break;
  292|       |
  293|    602|    case TLV_TYPE_MIME_PART_DATA:
  294|    602|      curl_mime_data(part, (const char *)tlv->value, tlv->length);
  295|    602|      break;
  296|       |
  297|    138|    default:
  298|       |      /* The fuzzer generates lots of unknown TLVs - we don't want these in the
  299|       |         corpus so we reject any unknown TLVs. */
  300|    138|      rc = 255;
  301|    138|      goto EXIT_LABEL;
  302|      0|      break;
  303|    763|  }
  304|       |
  305|    625|  rc = 0;
  306|       |
  307|    763|EXIT_LABEL:
  308|       |
  309|    763|  return rc;
  310|    625|}

ex_data.c:ex_class_item_LHASH_HASH:
  105|     19|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|     19|                const o_type *a = arg; \
  107|     19|                return name##_hash(a); }
ex_data.c:ex_class_item_LHASH_COMP:
  114|     15|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|     15|                const o_type *a = arg1;             \
  116|     15|                const o_type *b = arg2; \
  117|     15|                return name##_cmp(a,b); }

EVP_PKEY_asn1_get_count:
  133|     13|{
  134|     13|    int num = sizeof(standard_methods) / sizeof(EVP_PKEY_ASN1_METHOD *);
  135|     13|    if (app_methods)
  136|      0|        num += sk_EVP_PKEY_ASN1_METHOD_num(app_methods);
  137|     13|    return num;
  138|     13|}
EVP_PKEY_asn1_get0:
  141|     12|{
  142|     12|    int num = sizeof(standard_methods) / sizeof(EVP_PKEY_ASN1_METHOD *);
  143|     12|    if (idx < 0)
  144|      0|        return NULL;
  145|     12|    if (idx < num)
  146|     12|        return standard_methods[idx];
  147|      0|    idx -= num;
  148|      0|    return sk_EVP_PKEY_ASN1_METHOD_value(app_methods, idx);
  149|     12|}
EVP_PKEY_asn1_find_str:
  202|      1|{
  203|      1|    int i;
  204|      1|    const EVP_PKEY_ASN1_METHOD *ameth;
  205|      1|    if (len == -1)
  206|      1|        len = strlen(str);
  207|      1|    if (pe) {
  208|      1|#ifndef OPENSSL_NO_ENGINE
  209|      1|        ENGINE *e;
  210|      1|        ameth = ENGINE_pkey_asn1_find_str(&e, str, len);
  211|      1|        if (ameth) {
  212|       |            /*
  213|       |             * Convert structural into functional reference
  214|       |             */
  215|      0|            if (!ENGINE_init(e))
  216|      0|                ameth = NULL;
  217|      0|            ENGINE_free(e);
  218|      0|            *pe = e;
  219|      0|            return ameth;
  220|      0|        }
  221|      1|#endif
  222|      1|        *pe = NULL;
  223|      1|    }
  224|     13|    for (i = 0; i < EVP_PKEY_asn1_get_count(); i++) {
  225|     12|        ameth = EVP_PKEY_asn1_get0(i);
  226|     12|        if (ameth->pkey_flags & ASN1_PKEY_ALIAS)
  227|      5|            continue;
  228|      7|        if (((int)strlen(ameth->pem_str) == len) &&
  229|      7|            !strncasecmp(ameth->pem_str, str, len))
  230|      0|            return ameth;
  231|      7|    }
  232|      1|    return NULL;
  233|      1|}
EVP_PKEY_asn1_new:
  289|      3|{
  290|      3|    EVP_PKEY_ASN1_METHOD *ameth;
  291|      3|    ameth = OPENSSL_malloc(sizeof(EVP_PKEY_ASN1_METHOD));
  292|      3|    if (!ameth)
  293|      0|        return NULL;
  294|       |
  295|      3|    memset(ameth, 0, sizeof(EVP_PKEY_ASN1_METHOD));
  296|       |
  297|      3|    ameth->pkey_id = id;
  298|      3|    ameth->pkey_base_id = id;
  299|      3|    ameth->pkey_flags = flags | ASN1_PKEY_DYNAMIC;
  300|       |
  301|      3|    if (info) {
  302|      3|        ameth->info = BUF_strdup(info);
  303|      3|        if (!ameth->info)
  304|      0|            goto err;
  305|      3|    } else
  306|      0|        ameth->info = NULL;
  307|       |
  308|      3|    if (pem_str) {
  309|      3|        ameth->pem_str = BUF_strdup(pem_str);
  310|      3|        if (!ameth->pem_str)
  311|      0|            goto err;
  312|      3|    } else
  313|      0|        ameth->pem_str = NULL;
  314|       |
  315|      3|    ameth->pub_decode = 0;
  316|      3|    ameth->pub_encode = 0;
  317|      3|    ameth->pub_cmp = 0;
  318|      3|    ameth->pub_print = 0;
  319|       |
  320|      3|    ameth->priv_decode = 0;
  321|      3|    ameth->priv_encode = 0;
  322|      3|    ameth->priv_print = 0;
  323|       |
  324|      3|    ameth->old_priv_encode = 0;
  325|      3|    ameth->old_priv_decode = 0;
  326|       |
  327|      3|    ameth->item_verify = 0;
  328|      3|    ameth->item_sign = 0;
  329|       |
  330|      3|    ameth->pkey_size = 0;
  331|      3|    ameth->pkey_bits = 0;
  332|       |
  333|      3|    ameth->param_decode = 0;
  334|      3|    ameth->param_encode = 0;
  335|      3|    ameth->param_missing = 0;
  336|      3|    ameth->param_copy = 0;
  337|      3|    ameth->param_cmp = 0;
  338|      3|    ameth->param_print = 0;
  339|       |
  340|      3|    ameth->pkey_free = 0;
  341|      3|    ameth->pkey_ctrl = 0;
  342|       |
  343|      3|    return ameth;
  344|       |
  345|      0| err:
  346|       |
  347|      0|    EVP_PKEY_asn1_free(ameth);
  348|      0|    return NULL;
  349|       |
  350|      3|}
EVP_PKEY_asn1_set_public:
  409|      2|{
  410|      2|    ameth->pub_decode = pub_decode;
  411|      2|    ameth->pub_encode = pub_encode;
  412|      2|    ameth->pub_cmp = pub_cmp;
  413|      2|    ameth->pub_print = pub_print;
  414|      2|    ameth->pkey_size = pkey_size;
  415|      2|    ameth->pkey_bits = pkey_bits;
  416|      2|}
EVP_PKEY_asn1_set_private:
  428|      2|{
  429|      2|    ameth->priv_decode = priv_decode;
  430|      2|    ameth->priv_encode = priv_encode;
  431|      2|    ameth->priv_print = priv_print;
  432|      2|}
EVP_PKEY_asn1_set_param:
  448|      2|{
  449|      2|    ameth->param_decode = param_decode;
  450|      2|    ameth->param_encode = param_encode;
  451|      2|    ameth->param_missing = param_missing;
  452|      2|    ameth->param_copy = param_copy;
  453|      2|    ameth->param_cmp = param_cmp;
  454|      2|    ameth->param_print = param_print;
  455|      2|}
EVP_PKEY_asn1_set_free:
  459|      3|{
  460|      3|    ameth->pkey_free = pkey_free;
  461|      3|}
EVP_PKEY_asn1_set_ctrl:
  466|      3|{
  467|      3|    ameth->pkey_ctrl = pkey_ctrl;
  468|      3|}

ERR_load_ASN1_strings:
  346|      1|{
  347|      1|#ifndef OPENSSL_NO_ERR
  348|       |
  349|      1|    if (ERR_func_error_string(ASN1_str_functs[0].error) == NULL) {
  350|      1|        ERR_load_strings(0, ASN1_str_functs);
  351|      1|        ERR_load_strings(0, ASN1_str_reasons);
  352|      1|    }
  353|      1|#endif
  354|      1|}

ASN1_add_oid_module:
   99|      1|{
  100|      1|    CONF_module_add("oid_section", oid_module_init, oid_module_finish);
  101|      1|}

ERR_load_BIO_strings:
  149|      1|{
  150|      1|#ifndef OPENSSL_NO_ERR
  151|       |
  152|      1|    if (ERR_func_error_string(BIO_str_functs[0].error) == NULL) {
  153|      1|        ERR_load_strings(0, BIO_str_functs);
  154|      1|        ERR_load_strings(0, BIO_str_reasons);
  155|      1|    }
  156|      1|#endif
  157|      1|}

BIO_new_file:
  170|      1|{
  171|      1|    BIO  *ret;
  172|      1|    FILE *file = file_fopen(filename, mode);
  173|       |
  174|      1|    if (file == NULL) {
  175|      1|        SYSerr(SYS_F_FOPEN, get_last_sys_error());
  176|      1|        ERR_add_error_data(5, "fopen('", filename, "','", mode, "')");
  177|      1|        if (errno == ENOENT
  178|      1|# ifdef ENXIO
  179|      1|            || errno == ENXIO
  180|      1|# endif
  181|      1|            )
  182|      1|            BIOerr(BIO_F_BIO_NEW_FILE, BIO_R_NO_SUCH_FILE);
  183|      0|        else
  184|      1|            BIOerr(BIO_F_BIO_NEW_FILE, ERR_R_SYS_LIB);
  185|      1|        return (NULL);
  186|      1|    }
  187|      0|    if ((ret = BIO_new(BIO_s_file())) == NULL) {
  188|      0|        fclose(file);
  189|      0|        return (NULL);
  190|      0|    }
  191|       |
  192|      0|    BIO_clear_flags(ret, BIO_FLAGS_UPLINK); /* we did fopen -> we disengage
  193|       |                                             * UPLINK */
  194|      0|    BIO_set_fp(ret, file, BIO_CLOSE);
  195|      0|    return (ret);
  196|      0|}
bss_file.c:file_fopen:
  119|      1|{
  120|      1|    FILE *file = NULL;
  121|       |
  122|       |#  if defined(_WIN32) && defined(CP_UTF8)
  123|       |    int sz, len_0 = (int)strlen(filename) + 1;
  124|       |    DWORD flags;
  125|       |
  126|       |    /*
  127|       |     * Basically there are three cases to cover: a) filename is
  128|       |     * pure ASCII string; b) actual UTF-8 encoded string and
  129|       |     * c) locale-ized string, i.e. one containing 8-bit
  130|       |     * characters that are meaningful in current system locale.
  131|       |     * If filename is pure ASCII or real UTF-8 encoded string,
  132|       |     * MultiByteToWideChar succeeds and _wfopen works. If
  133|       |     * filename is locale-ized string, chances are that
  134|       |     * MultiByteToWideChar fails reporting
  135|       |     * ERROR_NO_UNICODE_TRANSLATION, in which case we fall
  136|       |     * back to fopen...
  137|       |     */
  138|       |    if ((sz = MultiByteToWideChar(CP_UTF8, (flags = MB_ERR_INVALID_CHARS),
  139|       |                                  filename, len_0, NULL, 0)) > 0 ||
  140|       |        (GetLastError() == ERROR_INVALID_FLAGS &&
  141|       |         (sz = MultiByteToWideChar(CP_UTF8, (flags = 0),
  142|       |                                   filename, len_0, NULL, 0)) > 0)
  143|       |        ) {
  144|       |        WCHAR wmode[8];
  145|       |        WCHAR *wfilename = _alloca(sz * sizeof(WCHAR));
  146|       |
  147|       |        if (MultiByteToWideChar(CP_UTF8, flags,
  148|       |                                filename, len_0, wfilename, sz) &&
  149|       |            MultiByteToWideChar(CP_UTF8, 0, mode, strlen(mode) + 1,
  150|       |                                wmode, sizeof(wmode) / sizeof(wmode[0])) &&
  151|       |            (file = _wfopen(wfilename, wmode)) == NULL &&
  152|       |            (errno == ENOENT || errno == EBADF)
  153|       |            ) {
  154|       |            /*
  155|       |             * UTF-8 decode succeeded, but no file, filename
  156|       |             * could still have been locale-ized...
  157|       |             */
  158|       |            file = fopen(filename, mode);
  159|       |        }
  160|       |    } else if (GetLastError() == ERROR_NO_UNICODE_TRANSLATION) {
  161|       |        file = fopen(filename, mode);
  162|       |    }
  163|       |#  else
  164|      1|    file = fopen(filename, mode);
  165|      1|#  endif
  166|      1|    return (file);
  167|      1|}

ERR_load_BN_strings:
  146|      1|{
  147|      1|#ifndef OPENSSL_NO_ERR
  148|       |
  149|      1|    if (ERR_func_error_string(BN_str_functs[0].error) == NULL) {
  150|      1|        ERR_load_strings(0, BN_str_functs);
  151|      1|        ERR_load_strings(0, BN_str_reasons);
  152|      1|    }
  153|      1|#endif
  154|      1|}

ERR_load_BUF_strings:
   89|      1|{
   90|      1|#ifndef OPENSSL_NO_ERR
   91|       |
   92|      1|    if (ERR_func_error_string(BUF_str_functs[0].error) == NULL) {
   93|      1|        ERR_load_strings(0, BUF_str_functs);
   94|      1|        ERR_load_strings(0, BUF_str_reasons);
   95|      1|    }
   96|      1|#endif
   97|      1|}

BUF_strnlen:
   65|      9|{
   66|      9|    const char *p;
   67|       |
   68|    109|    for (p = str; maxlen-- != 0 && *p != '\0'; ++p) ;
   69|       |
   70|      9|    return p - str;
   71|      9|}
BUF_strdup:
   74|      9|{
   75|      9|    if (str == NULL)
   76|      0|        return NULL;
   77|      9|    return BUF_strndup(str, strlen(str));
   78|      9|}
BUF_strndup:
   81|      9|{
   82|      9|    char *ret;
   83|       |
   84|      9|    if (str == NULL)
   85|      0|        return NULL;
   86|       |
   87|      9|    siz = BUF_strnlen(str, siz);
   88|       |
   89|      9|    if (siz >= INT_MAX)
   90|      0|        return NULL;
   91|       |
   92|      9|    ret = OPENSSL_malloc(siz + 1);
   93|      9|    if (ret == NULL) {
   94|      0|        BUFerr(BUF_F_BUF_STRNDUP, ERR_R_MALLOC_FAILURE);
   95|      0|        return NULL;
   96|      0|    }
   97|       |
   98|      9|    memcpy(ret, str, siz);
   99|      9|    ret[siz] = '\0';
  100|       |
  101|      9|    return (ret);
  102|      9|}
BUF_strlcpy:
  120|     28|{
  121|     28|    size_t l = 0;
  122|    539|    for (; size > 1 && *src; size--) {
  123|    511|        *dst++ = *src++;
  124|    511|        l++;
  125|    511|    }
  126|     28|    if (size)
  127|     28|        *dst = '\0';
  128|     28|    return l + strlen(src);
  129|     28|}
BUF_strlcat:
  132|     23|{
  133|     23|    size_t l = 0;
  134|    435|    for (; size > 0 && *dst; size--, dst++)
  135|    412|        l++;
  136|     23|    return l + BUF_strlcpy(dst, src, size);
  137|     23|}

ERR_load_CMS_strings:
  301|      1|{
  302|      1|#ifndef OPENSSL_NO_ERR
  303|       |
  304|      1|    if (ERR_func_error_string(CMS_str_functs[0].error) == NULL) {
  305|      1|        ERR_load_strings(0, CMS_str_functs);
  306|      1|        ERR_load_strings(0, CMS_str_reasons);
  307|      1|    }
  308|      1|#endif
  309|      1|}

COMP_zlib:
  344|      1|{
  345|      1|    COMP_METHOD *meth = &zlib_method_nozlib;
  346|       |
  347|       |#ifdef ZLIB_SHARED
  348|       |    if (!zlib_loaded) {
  349|       |# if defined(OPENSSL_SYS_WINDOWS) || defined(OPENSSL_SYS_WIN32)
  350|       |        zlib_dso = DSO_load(NULL, "ZLIB1", NULL, 0);
  351|       |# else
  352|       |        zlib_dso = DSO_load(NULL, "z", NULL, 0);
  353|       |# endif
  354|       |        if (zlib_dso != NULL) {
  355|       |            p_compress = (compress_ft) DSO_bind_func(zlib_dso, "compress");
  356|       |            p_inflateEnd
  357|       |                = (inflateEnd_ft) DSO_bind_func(zlib_dso, "inflateEnd");
  358|       |            p_inflate = (inflate_ft) DSO_bind_func(zlib_dso, "inflate");
  359|       |            p_inflateInit_
  360|       |                = (inflateInit__ft) DSO_bind_func(zlib_dso, "inflateInit_");
  361|       |            p_deflateEnd
  362|       |                = (deflateEnd_ft) DSO_bind_func(zlib_dso, "deflateEnd");
  363|       |            p_deflate = (deflate_ft) DSO_bind_func(zlib_dso, "deflate");
  364|       |            p_deflateInit_
  365|       |                = (deflateInit__ft) DSO_bind_func(zlib_dso, "deflateInit_");
  366|       |            p_zError = (zError__ft) DSO_bind_func(zlib_dso, "zError");
  367|       |
  368|       |            if (p_compress && p_inflateEnd && p_inflate
  369|       |                && p_inflateInit_ && p_deflateEnd
  370|       |                && p_deflate && p_deflateInit_ && p_zError)
  371|       |                zlib_loaded++;
  372|       |        }
  373|       |    }
  374|       |#endif
  375|       |#ifdef ZLIB_SHARED
  376|       |    if (zlib_loaded)
  377|       |#endif
  378|       |#if defined(ZLIB) || defined(ZLIB_SHARED)
  379|       |    {
  380|       |        /*
  381|       |         * init zlib_stateful_ex_idx here so that in a multi-process
  382|       |         * application it's enough to intialize openssl before forking (idx
  383|       |         * will be inherited in all the children)
  384|       |         */
  385|       |        if (zlib_stateful_ex_idx == -1) {
  386|       |            CRYPTO_w_lock(CRYPTO_LOCK_COMP);
  387|       |            if (zlib_stateful_ex_idx == -1)
  388|       |                zlib_stateful_ex_idx =
  389|       |                    CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_COMP,
  390|       |                                            0, NULL, NULL, NULL, NULL);
  391|       |            CRYPTO_w_unlock(CRYPTO_LOCK_COMP);
  392|       |            if (zlib_stateful_ex_idx == -1)
  393|       |                goto err;
  394|       |        }
  395|       |
  396|       |        meth = &zlib_stateful_method;
  397|       |    }
  398|       | err:
  399|       |#endif
  400|       |
  401|      1|    return (meth);
  402|      1|}

ERR_load_COMP_strings:
   90|      1|{
   91|      1|#ifndef OPENSSL_NO_ERR
   92|       |
   93|      1|    if (ERR_func_error_string(COMP_str_functs[0].error) == NULL) {
   94|      1|        ERR_load_strings(0, COMP_str_functs);
   95|      1|        ERR_load_strings(0, COMP_str_reasons);
   96|      1|    }
   97|      1|#endif
   98|      1|}

_CONF_free_data:
  223|      1|{
  224|      1|    if (conf == NULL || conf->data == NULL)
  225|      1|        return;
  226|       |
  227|      0|    lh_CONF_VALUE_down_load(conf->data) = 0; /* evil thing to make * sure the
  228|       |                                              * 'OPENSSL_free()' works as *
  229|       |                                              * expected */
  230|      0|    lh_CONF_VALUE_doall_arg(conf->data,
  231|      0|                            LHASH_DOALL_ARG_FN(value_free_hash),
  232|      0|                            LHASH_OF(CONF_VALUE), conf->data);
  233|       |
  234|       |    /*
  235|       |     * We now have only 'section' entries in the hash table. Due to problems
  236|       |     * with
  237|       |     */
  238|       |
  239|      0|    lh_CONF_VALUE_doall(conf->data, LHASH_DOALL_FN(value_free_stack));
  240|      0|    lh_CONF_VALUE_free(conf->data);
  241|      0|}

NCONF_default:
  126|      1|{
  127|      1|    return &default_method;
  128|      1|}
conf_def.c:def_create:
  136|      1|{
  137|      1|    CONF *ret;
  138|       |
  139|      1|    ret = OPENSSL_malloc(sizeof(CONF) + sizeof(unsigned short *));
  140|      1|    if (ret)
  141|      1|        if (meth->init(ret) == 0) {
  142|      0|            OPENSSL_free(ret);
  143|      0|            ret = NULL;
  144|      0|        }
  145|      1|    return ret;
  146|      1|}
conf_def.c:def_init_default:
  149|      1|{
  150|      1|    if (conf == NULL)
  151|      0|        return 0;
  152|       |
  153|      1|    conf->meth = &default_method;
  154|      1|    conf->meth_data = CONF_type_default;
  155|      1|    conf->data = NULL;
  156|       |
  157|      1|    return 1;
  158|      1|}
conf_def.c:def_destroy:
  173|      1|{
  174|      1|    if (def_destroy_data(conf)) {
  175|      1|        OPENSSL_free(conf);
  176|      1|        return 1;
  177|      1|    }
  178|      0|    return 0;
  179|      1|}
conf_def.c:def_destroy_data:
  182|      1|{
  183|      1|    if (conf == NULL)
  184|      0|        return 0;
  185|      1|    _CONF_free_data(conf);
  186|      1|    return 1;
  187|      1|}
conf_def.c:def_load:
  190|      1|{
  191|      1|    int ret;
  192|      1|    BIO *in = NULL;
  193|       |
  194|       |#ifdef OPENSSL_SYS_VMS
  195|       |    in = BIO_new_file(name, "r");
  196|       |#else
  197|      1|    in = BIO_new_file(name, "rb");
  198|      1|#endif
  199|      1|    if (in == NULL) {
  200|      1|        if (ERR_GET_REASON(ERR_peek_last_error()) == BIO_R_NO_SUCH_FILE)
  201|      1|            CONFerr(CONF_F_DEF_LOAD, CONF_R_NO_SUCH_FILE);
  202|      0|        else
  203|      1|            CONFerr(CONF_F_DEF_LOAD, ERR_R_SYS_LIB);
  204|      1|        return 0;
  205|      1|    }
  206|       |
  207|      0|    ret = def_load_bio(conf, in, line);
  208|      0|    BIO_free(in);
  209|       |
  210|      0|    return ret;
  211|      1|}

ERR_load_CONF_strings:
  127|      1|{
  128|      1|#ifndef OPENSSL_NO_ERR
  129|       |
  130|      1|    if (ERR_func_error_string(CONF_str_functs[0].error) == NULL) {
  131|      1|        ERR_load_strings(0, CONF_str_functs);
  132|      1|        ERR_load_strings(0, CONF_str_reasons);
  133|      1|    }
  134|      1|#endif
  135|      1|}

NCONF_new:
  229|      1|{
  230|      1|    CONF *ret;
  231|       |
  232|      1|    if (meth == NULL)
  233|      1|        meth = NCONF_default();
  234|       |
  235|      1|    ret = meth->create(meth);
  236|      1|    if (ret == NULL) {
  237|      0|        CONFerr(CONF_F_NCONF_NEW, ERR_R_MALLOC_FAILURE);
  238|      0|        return (NULL);
  239|      0|    }
  240|       |
  241|      1|    return ret;
  242|      1|}
NCONF_free:
  245|      1|{
  246|      1|    if (conf == NULL)
  247|      0|        return;
  248|      1|    conf->meth->destroy(conf);
  249|      1|}
NCONF_load:
  259|      1|{
  260|      1|    if (conf == NULL) {
  261|      0|        CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF);
  262|      0|        return 0;
  263|      0|    }
  264|       |
  265|      1|    return conf->meth->load(conf, file, eline);
  266|      1|}

OPENSSL_load_builtin_modules:
   74|      1|{
   75|       |    /* Add builtin modules here */
   76|      1|    ASN1_add_oid_module();
   77|      1|#ifndef OPENSSL_NO_ENGINE
   78|      1|    ENGINE_add_conf_module();
   79|      1|#endif
   80|      1|    EVP_add_alg_module();
   81|      1|}

CONF_modules_load_file:
  164|      1|{
  165|      1|    char *file = NULL;
  166|      1|    CONF *conf = NULL;
  167|      1|    int ret = 0;
  168|      1|    conf = NCONF_new(NULL);
  169|      1|    if (!conf)
  170|      0|        goto err;
  171|       |
  172|      1|    if (filename == NULL) {
  173|      1|        file = CONF_get1_default_config_file();
  174|      1|        if (!file)
  175|      0|            goto err;
  176|      1|    } else
  177|      0|        file = (char *)filename;
  178|       |
  179|      1|    if (NCONF_load(conf, file, NULL) <= 0) {
  180|      1|        if ((flags & CONF_MFLAGS_IGNORE_MISSING_FILE) &&
  181|      1|            (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) {
  182|      1|            ERR_clear_error();
  183|      1|            ret = 1;
  184|      1|        }
  185|      1|        goto err;
  186|      1|    }
  187|       |
  188|      0|    ret = CONF_modules_load(conf, appname, flags);
  189|       |
  190|      1| err:
  191|      1|    if (filename == NULL)
  192|      1|        OPENSSL_free(file);
  193|      1|    NCONF_free(conf);
  194|       |
  195|      1|    return ret;
  196|      0|}
CONF_module_add:
  466|      3|{
  467|      3|    if (module_add(NULL, name, ifunc, ffunc))
  468|      3|        return 1;
  469|      0|    else
  470|      0|        return 0;
  471|      3|}
CONF_get1_default_config_file:
  529|      1|{
  530|      1|    char *file;
  531|      1|    int len;
  532|       |
  533|      1|    file = getenv("OPENSSL_CONF");
  534|      1|    if (file)
  535|      0|        return BUF_strdup(file);
  536|       |
  537|      1|    len = strlen(X509_get_default_cert_area());
  538|      1|#ifndef OPENSSL_SYS_VMS
  539|      1|    len++;
  540|      1|#endif
  541|      1|    len += strlen(OPENSSL_CONF);
  542|       |
  543|      1|    file = OPENSSL_malloc(len + 1);
  544|       |
  545|      1|    if (!file)
  546|      0|        return NULL;
  547|      1|    BUF_strlcpy(file, X509_get_default_cert_area(), len + 1);
  548|      1|#ifndef OPENSSL_SYS_VMS
  549|      1|    BUF_strlcat(file, "/", len + 1);
  550|      1|#endif
  551|      1|    BUF_strlcat(file, OPENSSL_CONF, len + 1);
  552|       |
  553|      1|    return file;
  554|      1|}
conf_mod.c:module_add:
  279|      3|{
  280|      3|    CONF_MODULE *tmod = NULL;
  281|      3|    if (supported_modules == NULL)
  282|      1|        supported_modules = sk_CONF_MODULE_new_null();
  283|      3|    if (supported_modules == NULL)
  284|      0|        return NULL;
  285|      3|    tmod = OPENSSL_malloc(sizeof(CONF_MODULE));
  286|      3|    if (tmod == NULL)
  287|      0|        return NULL;
  288|       |
  289|      3|    tmod->dso = dso;
  290|      3|    tmod->name = BUF_strdup(name);
  291|      3|    if (tmod->name == NULL) {
  292|      0|        OPENSSL_free(tmod);
  293|      0|        return NULL;
  294|      0|    }
  295|      3|    tmod->init = ifunc;
  296|      3|    tmod->finish = ffunc;
  297|      3|    tmod->links = 0;
  298|       |
  299|      3|    if (!sk_CONF_MODULE_push(supported_modules, tmod)) {
  300|      0|        OPENSSL_free(tmod);
  301|      0|        return NULL;
  302|      0|    }
  303|       |
  304|      3|    return tmod;
  305|      3|}

ERR_load_CRYPTO_strings:
   96|      1|{
   97|      1|#ifndef OPENSSL_NO_ERR
   98|       |
   99|      1|    if (ERR_func_error_string(CRYPTO_str_functs[0].error) == NULL) {
  100|      1|        ERR_load_strings(0, CRYPTO_str_functs);
  101|      1|        ERR_load_strings(0, CRYPTO_str_reasons);
  102|      1|    }
  103|      1|#endif
  104|      1|}

CRYPTO_THREADID_set_pointer:
  436|  5.93k|{
  437|  5.93k|    unsigned char *dest = (void *)&id->val;
  438|  5.93k|    unsigned int accum = 0;
  439|  5.93k|    unsigned char dnum = sizeof(id->val);
  440|       |
  441|  5.93k|    memset(id, 0, sizeof(*id));
  442|  5.93k|    id->ptr = ptr;
  443|  5.93k|    if (sizeof(id->val) >= sizeof(id->ptr)) {
  444|       |        /*
  445|       |         * 'ptr' can be embedded in 'val' without loss of uniqueness
  446|       |         */
  447|  5.93k|        id->val = (unsigned long)id->ptr;
  448|  5.93k|        return;
  449|  5.93k|    }
  450|       |    /*
  451|       |     * hash ptr ==> val. Each byte of 'val' gets the mod-256 total of a
  452|       |     * linear function over the bytes in 'ptr', the co-efficients of which
  453|       |     * are a sequence of low-primes (hash_coeffs is an 8-element cycle) - the
  454|       |     * starting prime for the sequence varies for each byte of 'val' (unique
  455|       |     * polynomials unless pointers are >64-bit). For added spice, the totals
  456|       |     * accumulate rather than restarting from zero, and the index of the
  457|       |     * 'val' byte is added each time (position dependence). If I was a
  458|       |     * black-belt, I'd scan big-endian pointers in reverse to give low-order
  459|       |     * bits more play, but this isn't crypto and I'd prefer nobody mistake it
  460|       |     * as such. Plus I'm lazy.
  461|       |     */
  462|      0|    while (dnum--) {
  463|      0|        const unsigned char *src = (void *)&id->ptr;
  464|      0|        unsigned char snum = sizeof(id->ptr);
  465|      0|        while (snum--)
  466|      0|            accum += *(src++) * hash_coeffs[(snum + dnum) & 7];
  467|      0|        accum += dnum;
  468|      0|        *(dest++) = accum & 255;
  469|      0|    }
  470|      0|}
CRYPTO_THREADID_current:
  492|  5.93k|{
  493|  5.93k|    if (threadid_callback) {
  494|      0|        threadid_callback(id);
  495|      0|        return;
  496|      0|    }
  497|  5.93k|#ifndef OPENSSL_NO_DEPRECATED
  498|       |    /* If the deprecated callback was set, fall back to that */
  499|  5.93k|    if (id_callback) {
  500|      0|        CRYPTO_THREADID_set_numeric(id, id_callback());
  501|      0|        return;
  502|      0|    }
  503|  5.93k|#endif
  504|       |    /* Else pick a backup */
  505|       |#ifdef OPENSSL_SYS_WIN16
  506|       |    CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentTask());
  507|       |#elif defined(OPENSSL_SYS_WIN32)
  508|       |    CRYPTO_THREADID_set_numeric(id, (unsigned long)GetCurrentThreadId());
  509|       |#elif defined(OPENSSL_SYS_BEOS)
  510|       |    CRYPTO_THREADID_set_numeric(id, (unsigned long)find_thread(NULL));
  511|       |#else
  512|       |    /* For everything else, default to using the address of 'errno' */
  513|  5.93k|    CRYPTO_THREADID_set_pointer(id, (void *)&errno);
  514|  5.93k|#endif
  515|  5.93k|}
CRYPTO_THREADID_cmp:
  518|  3.83k|{
  519|  3.83k|    return memcmp(a, b, sizeof(*a));
  520|  3.83k|}
CRYPTO_THREADID_cpy:
  523|  4.56k|{
  524|  4.56k|    memcpy(dest, src, sizeof(*src));
  525|  4.56k|}
CRYPTO_THREADID_hash:
  528|  4.30k|{
  529|  4.30k|    return id->val;
  530|  4.30k|}
CRYPTO_lock:
  565|   115k|{
  566|       |#ifdef LOCK_DEBUG
  567|       |    {
  568|       |        CRYPTO_THREADID id;
  569|       |        char *rw_text, *operation_text;
  570|       |
  571|       |        if (mode & CRYPTO_LOCK)
  572|       |            operation_text = "lock  ";
  573|       |        else if (mode & CRYPTO_UNLOCK)
  574|       |            operation_text = "unlock";
  575|       |        else
  576|       |            operation_text = "ERROR ";
  577|       |
  578|       |        if (mode & CRYPTO_READ)
  579|       |            rw_text = "r";
  580|       |        else if (mode & CRYPTO_WRITE)
  581|       |            rw_text = "w";
  582|       |        else
  583|       |            rw_text = "ERROR";
  584|       |
  585|       |        CRYPTO_THREADID_current(&id);
  586|       |        fprintf(stderr, "lock:%08lx:(%s)%s %-18s %s:%d\n",
  587|       |                CRYPTO_THREADID_hash(&id), rw_text, operation_text,
  588|       |                CRYPTO_get_lock_name(type), file, line);
  589|       |    }
  590|       |#endif
  591|   115k|    if (type < 0) {
  592|      0|        if (dynlock_lock_callback != NULL) {
  593|      0|            struct CRYPTO_dynlock_value *pointer
  594|      0|                = CRYPTO_get_dynlock_value(type);
  595|       |
  596|      0|            OPENSSL_assert(pointer != NULL);
  597|       |
  598|      0|            dynlock_lock_callback(mode, pointer, file, line);
  599|       |
  600|      0|            CRYPTO_destroy_dynlockid(type);
  601|      0|        }
  602|   115k|    } else if (locking_callback != NULL)
  603|      0|        locking_callback(mode, type, file, line);
  604|   115k|}
CRYPTO_add_lock:
  608|  4.32k|{
  609|  4.32k|    int ret = 0;
  610|       |
  611|  4.32k|    if (add_lock_callback != NULL) {
  612|       |#ifdef LOCK_DEBUG
  613|       |        int before = *pointer;
  614|       |#endif
  615|       |
  616|      0|        ret = add_lock_callback(pointer, amount, type, file, line);
  617|       |#ifdef LOCK_DEBUG
  618|       |        {
  619|       |            CRYPTO_THREADID id;
  620|       |            CRYPTO_THREADID_current(&id);
  621|       |            fprintf(stderr, "ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
  622|       |                    CRYPTO_THREADID_hash(&id), before, amount, ret,
  623|       |                    CRYPTO_get_lock_name(type), file, line);
  624|       |        }
  625|       |#endif
  626|  4.32k|    } else {
  627|  4.32k|        CRYPTO_lock(CRYPTO_LOCK | CRYPTO_WRITE, type, file, line);
  628|       |
  629|  4.32k|        ret = *pointer + amount;
  630|       |#ifdef LOCK_DEBUG
  631|       |        {
  632|       |            CRYPTO_THREADID id;
  633|       |            CRYPTO_THREADID_current(&id);
  634|       |            fprintf(stderr, "ladd:%08lx:%2d+%2d->%2d %-18s %s:%d\n",
  635|       |                    CRYPTO_THREADID_hash(&id),
  636|       |                    *pointer, amount, ret,
  637|       |                    CRYPTO_get_lock_name(type), file, line);
  638|       |        }
  639|       |#endif
  640|  4.32k|        *pointer = ret;
  641|  4.32k|        CRYPTO_lock(CRYPTO_UNLOCK | CRYPTO_WRITE, type, file, line);
  642|  4.32k|    }
  643|  4.32k|    return (ret);
  644|  4.32k|}
OPENSSL_cpuid_setup:
  687|      4|{
  688|      4|    static int trigger = 0;
  689|      4|    IA32CAP OPENSSL_ia32_cpuid(unsigned int *);
  690|      4|    IA32CAP vec;
  691|      4|    char *env;
  692|       |
  693|      4|    if (trigger)
  694|      2|        return;
  695|       |
  696|      2|    trigger = 1;
  697|      2|    if ((env = getenv("OPENSSL_ia32cap"))) {
  698|      0|        int off = (env[0] == '~') ? 1 : 0;
  699|       |#  if defined(_WIN32)
  700|       |        if (!sscanf(env + off, "%I64i", &vec))
  701|       |            vec = strtoul(env + off, NULL, 0);
  702|       |#  else
  703|      0|        if (!sscanf(env + off, "%lli", (long long *)&vec))
  704|      0|            vec = strtoul(env + off, NULL, 0);
  705|      0|#  endif
  706|      0|        if (off)
  707|      0|            vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P) & ~vec;
  708|      0|        else if (env[0] == ':')
  709|      0|            vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);
  710|       |
  711|      0|        OPENSSL_ia32cap_P[2] = 0;
  712|      0|        if ((env = strchr(env, ':'))) {
  713|      0|            unsigned int vecx;
  714|      0|            env++;
  715|      0|            off = (env[0] == '~') ? 1 : 0;
  716|      0|            vecx = strtoul(env + off, NULL, 0);
  717|      0|            if (off)
  718|      0|                OPENSSL_ia32cap_P[2] &= ~vecx;
  719|      0|            else
  720|      0|                OPENSSL_ia32cap_P[2] = vecx;
  721|      0|        }
  722|      0|    } else
  723|      2|        vec = OPENSSL_ia32_cpuid(OPENSSL_ia32cap_P);
  724|       |
  725|       |    /*
  726|       |     * |(1<<10) sets a reserved bit to signal that variable
  727|       |     * was initialized already... This is to avoid interference
  728|       |     * with cpuid snippets in ELF .init segment.
  729|       |     */
  730|      2|    OPENSSL_ia32cap_P[0] = (unsigned int)vec | (1 << 10);
  731|      2|    OPENSSL_ia32cap_P[1] = (unsigned int)(vec >> 32);
  732|      2|}

ERR_load_DH_strings:
  118|      1|{
  119|      1|#ifndef OPENSSL_NO_ERR
  120|       |
  121|      1|    if (ERR_func_error_string(DH_str_functs[0].error) == NULL) {
  122|      1|        ERR_load_strings(0, DH_str_functs);
  123|      1|        ERR_load_strings(0, DH_str_reasons);
  124|      1|    }
  125|      1|#endif
  126|      1|}

DH_OpenSSL:
  124|      7|{
  125|      7|    return &dh_ossl;
  126|      7|}

ERR_load_DSA_strings:
  125|      1|{
  126|      1|#ifndef OPENSSL_NO_ERR
  127|       |
  128|      1|    if (ERR_func_error_string(DSA_str_functs[0].error) == NULL) {
  129|      1|        ERR_load_strings(0, DSA_str_functs);
  130|      1|        ERR_load_strings(0, DSA_str_reasons);
  131|      1|    }
  132|      1|#endif
  133|      1|}

DSA_get_default_method:
   87|      1|{
   88|      1|    if (!default_DSA_method) {
   89|       |#ifdef OPENSSL_FIPS
   90|       |        if (FIPS_mode())
   91|       |            return FIPS_dsa_openssl();
   92|       |        else
   93|       |            return DSA_OpenSSL();
   94|       |#else
   95|      1|        default_DSA_method = DSA_OpenSSL();
   96|      1|#endif
   97|      1|    }
   98|      1|    return default_DSA_method;
   99|      1|}

DSA_OpenSSL:
  129|      5|{
  130|      5|    return &openssl_dsa_meth;
  131|      5|}

DSO_METHOD_dlfcn:
  135|      1|{
  136|      1|    return (&dso_meth_dlfcn);
  137|      1|}
dso_dlfcn.c:dlfcn_load:
  171|      4|{
  172|      4|    void *ptr = NULL;
  173|       |    /* See applicable comments in dso_dl.c */
  174|      4|    char *filename = DSO_convert_filename(dso, NULL);
  175|      4|    int flags = DLOPEN_FLAG;
  176|       |
  177|      4|    if (filename == NULL) {
  178|      0|        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_NO_FILENAME);
  179|      0|        goto err;
  180|      0|    }
  181|      4|# ifdef RTLD_GLOBAL
  182|      4|    if (dso->flags & DSO_FLAG_GLOBAL_SYMBOLS)
  183|      0|        flags |= RTLD_GLOBAL;
  184|      4|# endif
  185|      4|    ptr = dlopen(filename, flags);
  186|      4|    if (ptr == NULL) {
  187|      4|        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_LOAD_FAILED);
  188|      4|        ERR_add_error_data(4, "filename(", filename, "): ", dlerror());
  189|      4|        goto err;
  190|      4|    }
  191|      0|    if (!sk_void_push(dso->meth_data, (char *)ptr)) {
  192|      0|        DSOerr(DSO_F_DLFCN_LOAD, DSO_R_STACK_ERROR);
  193|      0|        goto err;
  194|      0|    }
  195|       |    /* Success */
  196|      0|    dso->loaded_filename = filename;
  197|      0|    return (1);
  198|      4| err:
  199|       |    /* Cleanup! */
  200|      4|    if (filename != NULL)
  201|      4|        OPENSSL_free(filename);
  202|      4|    if (ptr != NULL)
  203|      0|        dlclose(ptr);
  204|      4|    return (0);
  205|      0|}
dso_dlfcn.c:dlfcn_unload:
  208|      4|{
  209|      4|    void *ptr;
  210|      4|    if (dso == NULL) {
  211|      0|        DSOerr(DSO_F_DLFCN_UNLOAD, ERR_R_PASSED_NULL_PARAMETER);
  212|      0|        return (0);
  213|      0|    }
  214|      4|    if (sk_void_num(dso->meth_data) < 1)
  215|      4|        return (1);
  216|      0|    ptr = sk_void_pop(dso->meth_data);
  217|      0|    if (ptr == NULL) {
  218|      0|        DSOerr(DSO_F_DLFCN_UNLOAD, DSO_R_NULL_HANDLE);
  219|       |        /*
  220|       |         * Should push the value back onto the stack in case of a retry.
  221|       |         */
  222|      0|        sk_void_push(dso->meth_data, ptr);
  223|      0|        return (0);
  224|      0|    }
  225|       |    /* For now I'm not aware of any errors associated with dlclose() */
  226|      0|    dlclose(ptr);
  227|      0|    return (1);
  228|      0|}
dso_dlfcn.c:dlfcn_name_converter:
  355|      4|{
  356|      4|    char *translated;
  357|      4|    int len, rsize, transform;
  358|       |
  359|      4|    len = strlen(filename);
  360|      4|    rsize = len + 1;
  361|      4|    transform = (strstr(filename, "/") == NULL);
  362|      4|    if (transform) {
  363|       |        /* We will convert this to "%s.so" or "lib%s.so" etc */
  364|      4|        rsize += DSO_extlen;    /* The length of ".so" */
  365|      4|        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
  366|      4|            rsize += 3;         /* The length of "lib" */
  367|      4|    }
  368|      4|    translated = OPENSSL_malloc(rsize);
  369|      4|    if (translated == NULL) {
  370|      0|        DSOerr(DSO_F_DLFCN_NAME_CONVERTER, DSO_R_NAME_TRANSLATION_FAILED);
  371|      0|        return (NULL);
  372|      0|    }
  373|      4|    if (transform) {
  374|      4|        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
  375|      4|            sprintf(translated, "lib%s" DSO_ext, filename);
  376|      0|        else
  377|      0|            sprintf(translated, "%s" DSO_ext, filename);
  378|      4|    } else
  379|      0|        sprintf(translated, "%s", filename);
  380|      4|    return (translated);
  381|      4|}

ERR_load_DSO_strings:
  150|      1|{
  151|      1|#ifndef OPENSSL_NO_ERR
  152|       |
  153|      1|    if (ERR_func_error_string(DSO_str_functs[0].error) == NULL) {
  154|      1|        ERR_load_strings(0, DSO_str_functs);
  155|      1|        ERR_load_strings(0, DSO_str_reasons);
  156|      1|    }
  157|      1|#endif
  158|      1|}

DSO_new_method:
   96|      4|{
   97|      4|    DSO *ret;
   98|       |
   99|      4|    if (default_DSO_meth == NULL)
  100|       |        /*
  101|       |         * We default to DSO_METH_openssl() which in turn defaults to
  102|       |         * stealing the "best available" method. Will fallback to
  103|       |         * DSO_METH_null() in the worst case.
  104|       |         */
  105|      1|        default_DSO_meth = DSO_METHOD_openssl();
  106|      4|    ret = (DSO *)OPENSSL_malloc(sizeof(DSO));
  107|      4|    if (ret == NULL) {
  108|      0|        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);
  109|      0|        return (NULL);
  110|      0|    }
  111|      4|    memset(ret, 0, sizeof(DSO));
  112|      4|    ret->meth_data = sk_void_new_null();
  113|      4|    if (ret->meth_data == NULL) {
  114|       |        /* sk_new doesn't generate any errors so we do */
  115|      0|        DSOerr(DSO_F_DSO_NEW_METHOD, ERR_R_MALLOC_FAILURE);
  116|      0|        OPENSSL_free(ret);
  117|      0|        return (NULL);
  118|      0|    }
  119|      4|    if (meth == NULL)
  120|      4|        ret->meth = default_DSO_meth;
  121|      0|    else
  122|      0|        ret->meth = meth;
  123|      4|    ret->references = 1;
  124|      4|    if ((ret->meth->init != NULL) && !ret->meth->init(ret)) {
  125|      0|        sk_void_free(ret->meth_data);
  126|      0|        OPENSSL_free(ret);
  127|      0|        ret = NULL;
  128|      0|    }
  129|      4|    return (ret);
  130|      4|}
DSO_free:
  133|      4|{
  134|      4|    int i;
  135|       |
  136|      4|    if (dso == NULL) {
  137|      0|        DSOerr(DSO_F_DSO_FREE, ERR_R_PASSED_NULL_PARAMETER);
  138|      0|        return (0);
  139|      0|    }
  140|       |
  141|      4|    i = CRYPTO_add(&dso->references, -1, CRYPTO_LOCK_DSO);
  142|       |#ifdef REF_PRINT
  143|       |    REF_PRINT("DSO", dso);
  144|       |#endif
  145|      4|    if (i > 0)
  146|      0|        return (1);
  147|       |#ifdef REF_CHECK
  148|       |    if (i < 0) {
  149|       |        fprintf(stderr, "DSO_free, bad reference count\n");
  150|       |        abort();
  151|       |    }
  152|       |#endif
  153|       |
  154|      4|    if ((dso->meth->dso_unload != NULL) && !dso->meth->dso_unload(dso)) {
  155|      0|        DSOerr(DSO_F_DSO_FREE, DSO_R_UNLOAD_FAILED);
  156|      0|        return (0);
  157|      0|    }
  158|       |
  159|      4|    if ((dso->meth->finish != NULL) && !dso->meth->finish(dso)) {
  160|      0|        DSOerr(DSO_F_DSO_FREE, DSO_R_FINISH_FAILED);
  161|      0|        return (0);
  162|      0|    }
  163|       |
  164|      4|    sk_void_free(dso->meth_data);
  165|      4|    if (dso->filename != NULL)
  166|      4|        OPENSSL_free(dso->filename);
  167|      4|    if (dso->loaded_filename != NULL)
  168|      0|        OPENSSL_free(dso->loaded_filename);
  169|       |
  170|      4|    OPENSSL_free(dso);
  171|      4|    return (1);
  172|      4|}
DSO_flags:
  175|      8|{
  176|      8|    return ((dso == NULL) ? 0 : dso->flags);
  177|      8|}
DSO_load:
  191|      4|{
  192|      4|    DSO *ret;
  193|      4|    int allocated = 0;
  194|       |
  195|      4|    if (dso == NULL) {
  196|      4|        ret = DSO_new_method(meth);
  197|      4|        if (ret == NULL) {
  198|      0|            DSOerr(DSO_F_DSO_LOAD, ERR_R_MALLOC_FAILURE);
  199|      0|            goto err;
  200|      0|        }
  201|      4|        allocated = 1;
  202|       |        /* Pass the provided flags to the new DSO object */
  203|      4|        if (DSO_ctrl(ret, DSO_CTRL_SET_FLAGS, flags, NULL) < 0) {
  204|      0|            DSOerr(DSO_F_DSO_LOAD, DSO_R_CTRL_FAILED);
  205|      0|            goto err;
  206|      0|        }
  207|      4|    } else
  208|      0|        ret = dso;
  209|       |    /* Don't load if we're currently already loaded */
  210|      4|    if (ret->filename != NULL) {
  211|      0|        DSOerr(DSO_F_DSO_LOAD, DSO_R_DSO_ALREADY_LOADED);
  212|      0|        goto err;
  213|      0|    }
  214|       |    /*
  215|       |     * filename can only be NULL if we were passed a dso that already has one
  216|       |     * set.
  217|       |     */
  218|      4|    if (filename != NULL)
  219|      4|        if (!DSO_set_filename(ret, filename)) {
  220|      0|            DSOerr(DSO_F_DSO_LOAD, DSO_R_SET_FILENAME_FAILED);
  221|      0|            goto err;
  222|      0|        }
  223|      4|    filename = ret->filename;
  224|      4|    if (filename == NULL) {
  225|      0|        DSOerr(DSO_F_DSO_LOAD, DSO_R_NO_FILENAME);
  226|      0|        goto err;
  227|      0|    }
  228|      4|    if (ret->meth->dso_load == NULL) {
  229|      0|        DSOerr(DSO_F_DSO_LOAD, DSO_R_UNSUPPORTED);
  230|      0|        goto err;
  231|      0|    }
  232|      4|    if (!ret->meth->dso_load(ret)) {
  233|      4|        DSOerr(DSO_F_DSO_LOAD, DSO_R_LOAD_FAILED);
  234|      4|        goto err;
  235|      4|    }
  236|       |    /* Load succeeded */
  237|      0|    return (ret);
  238|      4| err:
  239|      4|    if (allocated)
  240|      4|        DSO_free(ret);
  241|      4|    return (NULL);
  242|      4|}
DSO_ctrl:
  294|      4|{
  295|      4|    if (dso == NULL) {
  296|      0|        DSOerr(DSO_F_DSO_CTRL, ERR_R_PASSED_NULL_PARAMETER);
  297|      0|        return (-1);
  298|      0|    }
  299|       |    /*
  300|       |     * We should intercept certain generic commands and only pass control to
  301|       |     * the method-specific ctrl() function if it's something we don't handle.
  302|       |     */
  303|      4|    switch (cmd) {
  304|      0|    case DSO_CTRL_GET_FLAGS:
  305|      0|        return dso->flags;
  306|      4|    case DSO_CTRL_SET_FLAGS:
  307|      4|        dso->flags = (int)larg;
  308|      4|        return (0);
  309|      0|    case DSO_CTRL_OR_FLAGS:
  310|      0|        dso->flags |= (int)larg;
  311|      0|        return (0);
  312|      0|    default:
  313|      0|        break;
  314|      4|    }
  315|      0|    if ((dso->meth == NULL) || (dso->meth->dso_ctrl == NULL)) {
  316|      0|        DSOerr(DSO_F_DSO_CTRL, DSO_R_UNSUPPORTED);
  317|      0|        return (-1);
  318|      0|    }
  319|      0|    return (dso->meth->dso_ctrl(dso, cmd, larg, parg));
  320|      0|}
DSO_set_filename:
  345|      4|{
  346|      4|    char *copied;
  347|       |
  348|      4|    if ((dso == NULL) || (filename == NULL)) {
  349|      0|        DSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_PASSED_NULL_PARAMETER);
  350|      0|        return (0);
  351|      0|    }
  352|      4|    if (dso->loaded_filename) {
  353|      0|        DSOerr(DSO_F_DSO_SET_FILENAME, DSO_R_DSO_ALREADY_LOADED);
  354|      0|        return (0);
  355|      0|    }
  356|       |    /* We'll duplicate filename */
  357|      4|    copied = OPENSSL_malloc(strlen(filename) + 1);
  358|      4|    if (copied == NULL) {
  359|      0|        DSOerr(DSO_F_DSO_SET_FILENAME, ERR_R_MALLOC_FAILURE);
  360|      0|        return (0);
  361|      0|    }
  362|      4|    BUF_strlcpy(copied, filename, strlen(filename) + 1);
  363|      4|    if (dso->filename)
  364|      0|        OPENSSL_free(dso->filename);
  365|      4|    dso->filename = copied;
  366|      4|    return (1);
  367|      4|}
DSO_convert_filename:
  387|      4|{
  388|      4|    char *result = NULL;
  389|       |
  390|      4|    if (dso == NULL) {
  391|      0|        DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_PASSED_NULL_PARAMETER);
  392|      0|        return (NULL);
  393|      0|    }
  394|      4|    if (filename == NULL)
  395|      4|        filename = dso->filename;
  396|      4|    if (filename == NULL) {
  397|      0|        DSOerr(DSO_F_DSO_CONVERT_FILENAME, DSO_R_NO_FILENAME);
  398|      0|        return (NULL);
  399|      0|    }
  400|      4|    if ((dso->flags & DSO_FLAG_NO_NAME_TRANSLATION) == 0) {
  401|      4|        if (dso->name_converter != NULL)
  402|      0|            result = dso->name_converter(dso, filename);
  403|      4|        else if (dso->meth->dso_name_converter != NULL)
  404|      4|            result = dso->meth->dso_name_converter(dso, filename);
  405|      4|    }
  406|      4|    if (result == NULL) {
  407|      0|        result = OPENSSL_malloc(strlen(filename) + 1);
  408|      0|        if (result == NULL) {
  409|      0|            DSOerr(DSO_F_DSO_CONVERT_FILENAME, ERR_R_MALLOC_FAILURE);
  410|      0|            return (NULL);
  411|      0|        }
  412|      0|        BUF_strlcpy(result, filename, strlen(filename) + 1);
  413|      0|    }
  414|      4|    return (result);
  415|      4|}

DSO_METHOD_openssl:
   67|      1|{
   68|       |#ifdef DEF_DSO_METHOD
   69|       |    return (DEF_DSO_METHOD());
   70|       |#elif defined(DSO_DLFCN)
   71|      1|    return (DSO_METHOD_dlfcn());
   72|       |#elif defined(DSO_DL)
   73|       |    return (DSO_METHOD_dl());
   74|       |#elif defined(DSO_WIN32)
   75|       |    return (DSO_METHOD_win32());
   76|       |#elif defined(DSO_VMS)
   77|       |    return (DSO_METHOD_vms());
   78|       |#elif defined(DSO_BEOS)
   79|       |    return (DSO_METHOD_beos());
   80|       |#else
   81|       |    return (DSO_METHOD_null());
   82|       |#endif
   83|      1|}

ERR_load_EC_strings:
  324|      1|{
  325|      1|#ifndef OPENSSL_NO_ERR
  326|       |
  327|      1|    if (ERR_func_error_string(EC_str_functs[0].error) == NULL) {
  328|      1|        ERR_load_strings(0, EC_str_functs);
  329|      1|        ERR_load_strings(0, EC_str_reasons);
  330|      1|    }
  331|      1|#endif
  332|      1|}

ERR_load_ECDH_strings:
   90|      1|{
   91|      1|#ifndef OPENSSL_NO_ERR
   92|       |
   93|      1|    if (ERR_func_error_string(ECDH_str_functs[0].error) == NULL) {
   94|      1|        ERR_load_strings(0, ECDH_str_functs);
   95|      1|        ERR_load_strings(0, ECDH_str_reasons);
   96|      1|    }
   97|      1|#endif
   98|      1|}

ERR_load_ECDSA_strings:
   99|      1|{
  100|      1|#ifndef OPENSSL_NO_ERR
  101|       |
  102|      1|    if (ERR_func_error_string(ECDSA_str_functs[0].error) == NULL) {
  103|      1|        ERR_load_strings(0, ECDSA_str_functs);
  104|      1|        ERR_load_strings(0, ECDSA_str_reasons);
  105|      1|    }
  106|      1|#endif
  107|      1|}

eng_table.c:engine_pile_LHASH_HASH:
  105|  1.66k|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|  1.66k|                const o_type *a = arg; \
  107|  1.66k|                return name##_hash(a); }
eng_table.c:engine_pile_LHASH_COMP:
  114|     29|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|     29|                const o_type *a = arg1;             \
  116|     29|                const o_type *b = arg2; \
  117|     29|                return name##_cmp(a,b); }

ENGINE_load_builtin_engines:
   64|      1|{
   65|       |    /* Some ENGINEs need this */
   66|      1|    OPENSSL_cpuid_setup();
   67|       |#if 0
   68|       |    /*
   69|       |     * There's no longer any need for an "openssl" ENGINE unless, one day, it
   70|       |     * is the *only* way for standard builtin implementations to be be
   71|       |     * accessed (ie. it would be possible to statically link binaries with
   72|       |     * *no* builtin implementations).
   73|       |     */
   74|       |    ENGINE_load_openssl();
   75|       |#endif
   76|       |#if !defined(OPENSSL_NO_HW) && (defined(__OpenBSD__) || defined(__FreeBSD__) || defined(HAVE_CRYPTODEV))
   77|       |    ENGINE_load_cryptodev();
   78|       |#endif
   79|      1|#ifndef OPENSSL_NO_RDRAND
   80|      1|    ENGINE_load_rdrand();
   81|      1|#endif
   82|      1|    ENGINE_load_dynamic();
   83|      1|#ifndef OPENSSL_NO_STATIC_ENGINE
   84|      1|# ifndef OPENSSL_NO_HW
   85|      1|#  ifndef OPENSSL_NO_HW_4758_CCA
   86|      1|    ENGINE_load_4758cca();
   87|      1|#  endif
   88|      1|#  ifndef OPENSSL_NO_HW_AEP
   89|      1|    ENGINE_load_aep();
   90|      1|#  endif
   91|      1|#  ifndef OPENSSL_NO_HW_ATALLA
   92|      1|    ENGINE_load_atalla();
   93|      1|#  endif
   94|      1|#  ifndef OPENSSL_NO_HW_CSWIFT
   95|      1|    ENGINE_load_cswift();
   96|      1|#  endif
   97|      1|#  ifndef OPENSSL_NO_HW_NCIPHER
   98|      1|    ENGINE_load_chil();
   99|      1|#  endif
  100|      1|#  ifndef OPENSSL_NO_HW_NURON
  101|      1|    ENGINE_load_nuron();
  102|      1|#  endif
  103|      1|#  ifndef OPENSSL_NO_HW_SUREWARE
  104|      1|    ENGINE_load_sureware();
  105|      1|#  endif
  106|      1|#  ifndef OPENSSL_NO_HW_UBSEC
  107|      1|    ENGINE_load_ubsec();
  108|      1|#  endif
  109|      1|#  ifndef OPENSSL_NO_HW_PADLOCK
  110|      1|    ENGINE_load_padlock();
  111|      1|#  endif
  112|      1|# endif
  113|      1|# ifndef OPENSSL_NO_GOST
  114|      1|    ENGINE_load_gost();
  115|      1|# endif
  116|       |# ifndef OPENSSL_NO_GMP
  117|       |    ENGINE_load_gmp();
  118|       |# endif
  119|       |# if defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_NO_CAPIENG)
  120|       |    ENGINE_load_capi();
  121|       |# endif
  122|      1|#endif
  123|      1|    ENGINE_register_all_complete();
  124|      1|}

ENGINE_add_conf_module:
  239|      1|{
  240|      1|    CONF_module_add("engines",
  241|      1|                    int_engine_module_init, int_engine_module_finish);
  242|      1|}

ENGINE_load_dynamic:
  312|      1|{
  313|      1|    ENGINE *toadd = engine_dynamic();
  314|      1|    if (!toadd)
  315|      0|        return;
  316|      1|    ENGINE_add(toadd);
  317|       |    /*
  318|       |     * If the "add" worked, it gets a structural reference. So either way, we
  319|       |     * release our just-created reference.
  320|       |     */
  321|      1|    ENGINE_free(toadd);
  322|       |    /*
  323|       |     * If the "add" didn't work, it was probably a conflict because it was
  324|       |     * already added (eg. someone calling ENGINE_load_blah then calling
  325|       |     * ENGINE_load_builtin_engines() perhaps).
  326|       |     */
  327|      1|    ERR_clear_error();
  328|      1|}
eng_dyn.c:engine_dynamic:
  294|      1|{
  295|      1|    ENGINE *ret = ENGINE_new();
  296|      1|    if (!ret)
  297|      0|        return NULL;
  298|      1|    if (!ENGINE_set_id(ret, engine_dynamic_id) ||
  299|      1|        !ENGINE_set_name(ret, engine_dynamic_name) ||
  300|      1|        !ENGINE_set_init_function(ret, dynamic_init) ||
  301|      1|        !ENGINE_set_finish_function(ret, dynamic_finish) ||
  302|      1|        !ENGINE_set_ctrl_function(ret, dynamic_ctrl) ||
  303|      1|        !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) ||
  304|      1|        !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) {
  305|      0|        ENGINE_free(ret);
  306|      0|        return NULL;
  307|      0|    }
  308|      1|    return ret;
  309|      1|}

ERR_load_ENGINE_strings:
  173|      1|{
  174|      1|#ifndef OPENSSL_NO_ERR
  175|       |
  176|      1|    if (ERR_func_error_string(ENGINE_str_functs[0].error) == NULL) {
  177|      1|        ERR_load_strings(0, ENGINE_str_functs);
  178|      1|        ERR_load_strings(0, ENGINE_str_reasons);
  179|      1|    }
  180|      1|#endif
  181|      1|}

ENGINE_register_complete:
  150|     10|{
  151|     10|    ENGINE_register_ciphers(e);
  152|     10|    ENGINE_register_digests(e);
  153|     10|#ifndef OPENSSL_NO_RSA
  154|     10|    ENGINE_register_RSA(e);
  155|     10|#endif
  156|     10|#ifndef OPENSSL_NO_DSA
  157|     10|    ENGINE_register_DSA(e);
  158|     10|#endif
  159|     10|#ifndef OPENSSL_NO_DH
  160|     10|    ENGINE_register_DH(e);
  161|     10|#endif
  162|     10|#ifndef OPENSSL_NO_ECDH
  163|     10|    ENGINE_register_ECDH(e);
  164|     10|#endif
  165|     10|#ifndef OPENSSL_NO_ECDSA
  166|     10|    ENGINE_register_ECDSA(e);
  167|     10|#endif
  168|     10|    ENGINE_register_RAND(e);
  169|     10|    ENGINE_register_pkey_meths(e);
  170|     10|    return 1;
  171|     10|}
ENGINE_register_all_complete:
  174|      1|{
  175|      1|    ENGINE *e;
  176|       |
  177|     12|    for (e = ENGINE_get_first(); e; e = ENGINE_get_next(e))
  178|     11|        if (!(e->flags & ENGINE_FLAGS_NO_REGISTER_ALL))
  179|     10|            ENGINE_register_complete(e);
  180|      1|    return 1;
  181|      1|}

engine_unlocked_init:
   63|      4|{
   64|      4|    int to_return = 1;
   65|       |
   66|      4|    if ((e->funct_ref == 0) && e->init)
   67|       |        /*
   68|       |         * This is the first functional reference and the engine requires
   69|       |         * initialisation so we do it now.
   70|       |         */
   71|      4|        to_return = e->init(e);
   72|      4|    if (to_return) {
   73|       |        /*
   74|       |         * OK, we return a functional reference which is also a structural
   75|       |         * reference.
   76|       |         */
   77|      0|        e->struct_ref++;
   78|      0|        e->funct_ref++;
   79|      0|        engine_ref_debug(e, 0, 1)
   80|      0|            engine_ref_debug(e, 1, 1)
   81|      0|    }
   82|      4|    return to_return;
   83|      4|}

ENGINE_new:
   66|     11|{
   67|     11|    ENGINE *ret;
   68|       |
   69|     11|    ret = (ENGINE *)OPENSSL_malloc(sizeof(ENGINE));
   70|     11|    if (ret == NULL) {
   71|      0|        ENGINEerr(ENGINE_F_ENGINE_NEW, ERR_R_MALLOC_FAILURE);
   72|      0|        return NULL;
   73|      0|    }
   74|     11|    memset(ret, 0, sizeof(ENGINE));
   75|     11|    ret->struct_ref = 1;
   76|     11|    engine_ref_debug(ret, 0, 1)
   77|     11|        CRYPTO_new_ex_data(CRYPTO_EX_INDEX_ENGINE, ret, &ret->ex_data);
   78|     11|    return ret;
   79|     11|}
engine_free_util:
  108|     22|{
  109|     22|    int i;
  110|       |
  111|     22|    if (e == NULL) {
  112|      0|        ENGINEerr(ENGINE_F_ENGINE_FREE_UTIL, ERR_R_PASSED_NULL_PARAMETER);
  113|      0|        return 0;
  114|      0|    }
  115|     22|    if (locked)
  116|     22|        i = CRYPTO_add(&e->struct_ref, -1, CRYPTO_LOCK_ENGINE);
  117|      0|    else
  118|      0|        i = --e->struct_ref;
  119|     22|    engine_ref_debug(e, 0, -1)
  120|     22|        if (i > 0)
  121|     22|        return 1;
  122|       |#ifdef REF_CHECK
  123|       |    if (i < 0) {
  124|       |        fprintf(stderr, "ENGINE_free, bad structural reference count\n");
  125|       |        abort();
  126|       |    }
  127|       |#endif
  128|       |    /* Free up any dynamically allocated public key methods */
  129|      0|    engine_pkey_meths_free(e);
  130|      0|    engine_pkey_asn1_meths_free(e);
  131|       |    /*
  132|       |     * Give the ENGINE a chance to do any structural cleanup corresponding to
  133|       |     * allocation it did in its constructor (eg. unload error strings)
  134|       |     */
  135|      0|    if (e->destroy)
  136|      0|        e->destroy(e);
  137|      0|    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_ENGINE, e, &e->ex_data);
  138|      0|    OPENSSL_free(e);
  139|      0|    return 1;
  140|     22|}
ENGINE_free:
  143|     22|{
  144|     22|    return engine_free_util(e, 1);
  145|     22|}
engine_cleanup_add_first:
  176|      7|{
  177|      7|    ENGINE_CLEANUP_ITEM *item;
  178|      7|    if (!int_cleanup_check(1))
  179|      0|        return;
  180|      7|    item = int_cleanup_item(cb);
  181|      7|    if (item)
  182|      7|        sk_ENGINE_CLEANUP_ITEM_insert(cleanup_stack, item, 0);
  183|      7|}
engine_cleanup_add_last:
  186|      1|{
  187|      1|    ENGINE_CLEANUP_ITEM *item;
  188|      1|    if (!int_cleanup_check(1))
  189|      0|        return;
  190|      1|    item = int_cleanup_item(cb);
  191|      1|    if (item)
  192|      1|        sk_ENGINE_CLEANUP_ITEM_push(cleanup_stack, item);
  193|      1|}
ENGINE_set_id:
  242|     11|{
  243|     11|    if (id == NULL) {
  244|      0|        ENGINEerr(ENGINE_F_ENGINE_SET_ID, ERR_R_PASSED_NULL_PARAMETER);
  245|      0|        return 0;
  246|      0|    }
  247|     11|    e->id = id;
  248|     11|    return 1;
  249|     11|}
ENGINE_set_name:
  252|     11|{
  253|     11|    if (name == NULL) {
  254|      0|        ENGINEerr(ENGINE_F_ENGINE_SET_NAME, ERR_R_PASSED_NULL_PARAMETER);
  255|      0|        return 0;
  256|      0|    }
  257|     11|    e->name = name;
  258|     11|    return 1;
  259|     11|}
ENGINE_set_destroy_function:
  262|      9|{
  263|      9|    e->destroy = destroy_f;
  264|      9|    return 1;
  265|      9|}
ENGINE_set_init_function:
  268|     11|{
  269|     11|    e->init = init_f;
  270|     11|    return 1;
  271|     11|}
ENGINE_set_finish_function:
  274|     10|{
  275|     10|    e->finish = finish_f;
  276|     10|    return 1;
  277|     10|}
ENGINE_set_ctrl_function:
  280|     10|{
  281|     10|    e->ctrl = ctrl_f;
  282|     10|    return 1;
  283|     10|}
ENGINE_set_flags:
  286|      2|{
  287|      2|    e->flags = flags;
  288|      2|    return 1;
  289|      2|}
ENGINE_set_cmd_defns:
  292|      9|{
  293|      9|    e->cmd_defns = defns;
  294|      9|    return 1;
  295|      9|}
eng_lib.c:int_cleanup_check:
  157|      8|{
  158|      8|    if (cleanup_stack)
  159|      7|        return 1;
  160|      1|    if (!create)
  161|      0|        return 0;
  162|      1|    cleanup_stack = sk_ENGINE_CLEANUP_ITEM_new_null();
  163|      1|    return (cleanup_stack ? 1 : 0);
  164|      1|}
eng_lib.c:int_cleanup_item:
  167|      8|{
  168|      8|    ENGINE_CLEANUP_ITEM *item = OPENSSL_malloc(sizeof(ENGINE_CLEANUP_ITEM));
  169|      8|    if (!item)
  170|      0|        return NULL;
  171|      8|    item->cb = cb;
  172|      8|    return item;
  173|      8|}

ENGINE_get_first:
  185|      1|{
  186|      1|    ENGINE *ret;
  187|       |
  188|      1|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  189|      1|    ret = engine_list_head;
  190|      1|    if (ret) {
  191|      1|        ret->struct_ref++;
  192|      1|        engine_ref_debug(ret, 0, 1)
  193|      1|    }
  194|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  195|      1|    return ret;
  196|      1|}
ENGINE_get_next:
  214|     11|{
  215|     11|    ENGINE *ret = NULL;
  216|     11|    if (e == NULL) {
  217|      0|        ENGINEerr(ENGINE_F_ENGINE_GET_NEXT, ERR_R_PASSED_NULL_PARAMETER);
  218|      0|        return 0;
  219|      0|    }
  220|     11|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  221|     11|    ret = e->next;
  222|     11|    if (ret) {
  223|       |        /* Return a valid structural refernce to the next ENGINE */
  224|     10|        ret->struct_ref++;
  225|     10|        engine_ref_debug(ret, 0, 1)
  226|     10|    }
  227|     11|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  228|       |    /* Release the structural reference to the previous ENGINE */
  229|     11|    ENGINE_free(e);
  230|     11|    return ret;
  231|     11|}
ENGINE_add:
  255|     11|{
  256|     11|    int to_return = 1;
  257|     11|    if (e == NULL) {
  258|      0|        ENGINEerr(ENGINE_F_ENGINE_ADD, ERR_R_PASSED_NULL_PARAMETER);
  259|      0|        return 0;
  260|      0|    }
  261|     11|    if ((e->id == NULL) || (e->name == NULL)) {
  262|      0|        ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_ID_OR_NAME_MISSING);
  263|      0|        return 0;
  264|      0|    }
  265|     11|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  266|     11|    if (!engine_list_add(e)) {
  267|      0|        ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
  268|      0|        to_return = 0;
  269|      0|    }
  270|     11|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  271|     11|    return to_return;
  272|     11|}
eng_list.c:engine_list_add:
  103|     11|{
  104|     11|    int conflict = 0;
  105|     11|    ENGINE *iterator = NULL;
  106|       |
  107|     11|    if (e == NULL) {
  108|      0|        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER);
  109|      0|        return 0;
  110|      0|    }
  111|     11|    iterator = engine_list_head;
  112|     66|    while (iterator && !conflict) {
  113|     55|        conflict = (strcmp(iterator->id, e->id) == 0);
  114|     55|        iterator = iterator->next;
  115|     55|    }
  116|     11|    if (conflict) {
  117|      0|        ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID);
  118|      0|        return 0;
  119|      0|    }
  120|     11|    if (engine_list_head == NULL) {
  121|       |        /* We are adding to an empty list. */
  122|      1|        if (engine_list_tail) {
  123|      0|            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
  124|      0|            return 0;
  125|      0|        }
  126|      1|        engine_list_head = e;
  127|      1|        e->prev = NULL;
  128|       |        /*
  129|       |         * The first time the list allocates, we should register the cleanup.
  130|       |         */
  131|      1|        engine_cleanup_add_last(engine_list_cleanup);
  132|     10|    } else {
  133|       |        /* We are adding to the tail of an existing list. */
  134|     10|        if ((engine_list_tail == NULL) || (engine_list_tail->next != NULL)) {
  135|      0|            ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR);
  136|      0|            return 0;
  137|      0|        }
  138|     10|        engine_list_tail->next = e;
  139|     10|        e->prev = engine_list_tail;
  140|     10|    }
  141|       |    /*
  142|       |     * Having the engine in the list assumes a structural reference.
  143|       |     */
  144|     11|    e->struct_ref++;
  145|     11|    engine_ref_debug(e, 0, 1)
  146|       |        /* However it came to be, e is the last item in the list. */
  147|     11|        engine_list_tail = e;
  148|     11|    e->next = NULL;
  149|     11|    return 1;
  150|     11|}

ENGINE_set_load_privkey_function:
   62|      3|{
   63|      3|    e->load_privkey = loadpriv_f;
   64|      3|    return 1;
   65|      3|}
ENGINE_set_load_pubkey_function:
   68|      3|{
   69|      3|    e->load_pubkey = loadpub_f;
   70|      3|    return 1;
   71|      3|}

ENGINE_load_rdrand:
  133|      1|{
  134|      1|    extern unsigned int OPENSSL_ia32cap_P[];
  135|       |
  136|      1|    if (OPENSSL_ia32cap_P[1] & (1 << (62 - 32))) {
  137|      1|        ENGINE *toadd = ENGINE_rdrand();
  138|      1|        if (!toadd)
  139|      0|            return;
  140|      1|        ENGINE_add(toadd);
  141|      1|        ENGINE_free(toadd);
  142|      1|        ERR_clear_error();
  143|      1|    }
  144|      1|}
eng_rdrand.c:ENGINE_rdrand:
  121|      1|{
  122|      1|    ENGINE *ret = ENGINE_new();
  123|      1|    if (!ret)
  124|      0|        return NULL;
  125|      1|    if (!bind_helper(ret)) {
  126|      0|        ENGINE_free(ret);
  127|      0|        return NULL;
  128|      0|    }
  129|      1|    return ret;
  130|      1|}
eng_rdrand.c:bind_helper:
  109|      1|{
  110|      1|    if (!ENGINE_set_id(e, engine_e_rdrand_id) ||
  111|      1|        !ENGINE_set_name(e, engine_e_rdrand_name) ||
  112|      1|        !ENGINE_set_flags(e, ENGINE_FLAGS_NO_REGISTER_ALL) ||
  113|      1|        !ENGINE_set_init_function(e, rdrand_init) ||
  114|      1|        !ENGINE_set_RAND(e, &rdrand_meth))
  115|      0|        return 0;
  116|       |
  117|      1|    return 1;
  118|      1|}

engine_table_register:
  135|     31|{
  136|     31|    int ret = 0, added = 0;
  137|     31|    ENGINE_PILE tmplate, *fnd;
  138|     31|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  139|     31|    if (!(*table))
  140|      7|        added = 1;
  141|     31|    if (!int_table_check(table, 1))
  142|      0|        goto end;
  143|     31|    if (added)
  144|       |        /* The cleanup callback needs to be added */
  145|      7|        engine_cleanup_add_first(cleanup);
  146|     70|    while (num_nids--) {
  147|     39|        tmplate.nid = *nids;
  148|     39|        fnd = lh_ENGINE_PILE_retrieve(&(*table)->piles, &tmplate);
  149|     39|        if (!fnd) {
  150|     11|            fnd = OPENSSL_malloc(sizeof(ENGINE_PILE));
  151|     11|            if (!fnd)
  152|      0|                goto end;
  153|     11|            fnd->uptodate = 1;
  154|     11|            fnd->nid = *nids;
  155|     11|            fnd->sk = sk_ENGINE_new_null();
  156|     11|            if (!fnd->sk) {
  157|      0|                OPENSSL_free(fnd);
  158|      0|                goto end;
  159|      0|            }
  160|     11|            fnd->funct = NULL;
  161|     11|            (void)lh_ENGINE_PILE_insert(&(*table)->piles, fnd);
  162|     11|        }
  163|       |        /* A registration shouldn't add duplciate entries */
  164|     39|        (void)sk_ENGINE_delete_ptr(fnd->sk, e);
  165|       |        /*
  166|       |         * if 'setdefault', this ENGINE goes to the head of the list
  167|       |         */
  168|     39|        if (!sk_ENGINE_push(fnd->sk, e))
  169|      0|            goto end;
  170|       |        /* "touch" this ENGINE_PILE */
  171|     39|        fnd->uptodate = 0;
  172|     39|        if (setdefault) {
  173|      0|            if (!engine_unlocked_init(e)) {
  174|      0|                ENGINEerr(ENGINE_F_ENGINE_TABLE_REGISTER,
  175|      0|                          ENGINE_R_INIT_FAILED);
  176|      0|                goto end;
  177|      0|            }
  178|      0|            if (fnd->funct)
  179|      0|                engine_unlocked_finish(fnd->funct, 0);
  180|      0|            fnd->funct = e;
  181|      0|            fnd->uptodate = 1;
  182|      0|        }
  183|     39|        nids++;
  184|     39|    }
  185|     31|    ret = 1;
  186|     31| end:
  187|     31|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  188|     31|    return ret;
  189|     31|}
engine_table_select:
  246|  1.61k|{
  247|  1.61k|    ENGINE *ret = NULL;
  248|  1.61k|    ENGINE_PILE tmplate, *fnd = NULL;
  249|  1.61k|    int initres, loop = 0;
  250|       |
  251|  1.61k|    if (!(*table)) {
  252|       |#ifdef ENGINE_TABLE_DEBUG
  253|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, nothing "
  254|       |                "registered!\n", f, l, nid);
  255|       |#endif
  256|      0|        return NULL;
  257|      0|    }
  258|  1.61k|    ERR_set_mark();
  259|  1.61k|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  260|       |    /*
  261|       |     * Check again inside the lock otherwise we could race against cleanup
  262|       |     * operations. But don't worry about a fprintf(stderr).
  263|       |     */
  264|  1.61k|    if (!int_table_check(table, 0))
  265|      0|        goto end;
  266|  1.61k|    tmplate.nid = nid;
  267|  1.61k|    fnd = lh_ENGINE_PILE_retrieve(&(*table)->piles, &tmplate);
  268|  1.61k|    if (!fnd)
  269|  1.61k|        goto end;
  270|      1|    if (fnd->funct && engine_unlocked_init(fnd->funct)) {
  271|       |#ifdef ENGINE_TABLE_DEBUG
  272|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, using "
  273|       |                "ENGINE '%s' cached\n", f, l, nid, fnd->funct->id);
  274|       |#endif
  275|      0|        ret = fnd->funct;
  276|      0|        goto end;
  277|      0|    }
  278|      1|    if (fnd->uptodate) {
  279|      0|        ret = fnd->funct;
  280|      0|        goto end;
  281|      0|    }
  282|      5| trynext:
  283|      5|    ret = sk_ENGINE_value(fnd->sk, loop++);
  284|      5|    if (!ret) {
  285|       |#ifdef ENGINE_TABLE_DEBUG
  286|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, no "
  287|       |                "registered implementations would initialise\n", f, l, nid);
  288|       |#endif
  289|      1|        goto end;
  290|      1|    }
  291|       |    /* Try to initialise the ENGINE? */
  292|      4|    if ((ret->funct_ref > 0) || !(table_flags & ENGINE_TABLE_FLAG_NOINIT))
  293|      4|        initres = engine_unlocked_init(ret);
  294|      0|    else
  295|      0|        initres = 0;
  296|      4|    if (initres) {
  297|       |        /* Update 'funct' */
  298|      0|        if ((fnd->funct != ret) && engine_unlocked_init(ret)) {
  299|       |            /* If there was a previous default we release it. */
  300|      0|            if (fnd->funct)
  301|      0|                engine_unlocked_finish(fnd->funct, 0);
  302|      0|            fnd->funct = ret;
  303|       |#ifdef ENGINE_TABLE_DEBUG
  304|       |            fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, "
  305|       |                    "setting default to '%s'\n", f, l, nid, ret->id);
  306|       |#endif
  307|      0|        }
  308|       |#ifdef ENGINE_TABLE_DEBUG
  309|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, using "
  310|       |                "newly initialised '%s'\n", f, l, nid, ret->id);
  311|       |#endif
  312|      0|        goto end;
  313|      0|    }
  314|      4|    goto trynext;
  315|  1.61k| end:
  316|       |    /*
  317|       |     * If it failed, it is unlikely to succeed again until some future
  318|       |     * registrations have taken place. In all cases, we cache.
  319|       |     */
  320|  1.61k|    if (fnd)
  321|      1|        fnd->uptodate = 1;
  322|       |#ifdef ENGINE_TABLE_DEBUG
  323|       |    if (ret)
  324|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, caching "
  325|       |                "ENGINE '%s'\n", f, l, nid, ret->id);
  326|       |    else
  327|       |        fprintf(stderr, "engine_table_dbg: %s:%d, nid=%d, caching "
  328|       |                "'no matching ENGINE'\n", f, l, nid);
  329|       |#endif
  330|  1.61k|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  331|       |    /*
  332|       |     * Whatever happened, any failed init()s are not failures in this
  333|       |     * context, so clear our error state.
  334|       |     */
  335|  1.61k|    ERR_pop_to_mark();
  336|  1.61k|    return ret;
  337|      4|}
engine_table_doall:
  350|      1|{
  351|      1|    ENGINE_PILE_DOALL dall;
  352|      1|    dall.cb = cb;
  353|      1|    dall.arg = arg;
  354|      1|    if (table)
  355|      1|        lh_ENGINE_PILE_doall_arg(&table->piles,
  356|      1|                                 LHASH_DOALL_ARG_FN(int_cb),
  357|      1|                                 ENGINE_PILE_DOALL, &dall);
  358|      1|}
eng_table.c:int_table_check:
  115|  1.64k|{
  116|  1.64k|    LHASH_OF(ENGINE_PILE) *lh;
  117|       |
  118|  1.64k|    if (*t)
  119|  1.63k|        return 1;
  120|      7|    if (!create)
  121|      0|        return 0;
  122|      7|    if ((lh = lh_ENGINE_PILE_new()) == NULL)
  123|      0|        return 0;
  124|      7|    *t = (ENGINE_TABLE *)lh;
  125|      7|    return 1;
  126|      7|}
eng_table.c:engine_pile_hash:
  102|  1.66k|{
  103|  1.66k|    return c->nid;
  104|  1.66k|}
eng_table.c:engine_pile_cmp:
  107|     29|{
  108|     29|    return a->nid - b->nid;
  109|     29|}

ENGINE_set_pkey_asn1_meths:
  147|      1|{
  148|      1|    e->pkey_asn1_meths = f;
  149|      1|    return 1;
  150|      1|}
ENGINE_pkey_asn1_find_str:
  230|      1|{
  231|      1|    ENGINE_FIND_STR fstr;
  232|      1|    fstr.e = NULL;
  233|      1|    fstr.ameth = NULL;
  234|      1|    fstr.str = str;
  235|      1|    fstr.len = len;
  236|      1|    CRYPTO_w_lock(CRYPTO_LOCK_ENGINE);
  237|      1|    engine_table_doall(pkey_asn1_meth_table, look_str_cb, &fstr);
  238|       |    /* If found obtain a structural reference to engine */
  239|      1|    if (fstr.e) {
  240|      0|        fstr.e->struct_ref++;
  241|      0|        engine_ref_debug(fstr.e, 0, 1)
  242|      0|    }
  243|      1|    *pe = fstr.e;
  244|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_ENGINE);
  245|      1|    return fstr.ameth;
  246|      1|}

ENGINE_register_ciphers:
   77|     11|{
   78|     11|    if (e->ciphers) {
   79|      2|        const int *nids;
   80|      2|        int num_nids = e->ciphers(e, NULL, &nids, 0);
   81|      2|        if (num_nids > 0)
   82|      2|            return engine_table_register(&cipher_table,
   83|      2|                                         engine_unregister_all_ciphers, e,
   84|      2|                                         nids, num_nids, 0);
   85|      2|    }
   86|      9|    return 1;
   87|     11|}
ENGINE_set_ciphers:
  140|      1|{
  141|      1|    e->ciphers = f;
  142|      1|    return 1;
  143|      1|}

ENGINE_register_DH:
   78|     10|{
   79|     10|    if (e->dh_meth)
   80|      7|        return engine_table_register(&dh_table,
   81|      7|                                     engine_unregister_all_DH, e, &dummy_nid,
   82|      7|                                     1, 0);
   83|      3|    return 1;
   84|     10|}
ENGINE_set_DH:
  121|      7|{
  122|      7|    e->dh_meth = dh_meth;
  123|      7|    return 1;
  124|      7|}

ENGINE_register_digests:
   77|     11|{
   78|     11|    if (e->digests) {
   79|      2|        const int *nids;
   80|      2|        int num_nids = e->digests(e, NULL, &nids, 0);
   81|      2|        if (num_nids > 0)
   82|      2|            return engine_table_register(&digest_table,
   83|      2|                                         engine_unregister_all_digests, e,
   84|      2|                                         nids, num_nids, 0);
   85|      2|    }
   86|      9|    return 1;
   87|     11|}
ENGINE_get_digest_engine:
  116|  1.61k|{
  117|  1.61k|    return engine_table_select(&digest_table, nid);
  118|  1.61k|}
ENGINE_set_digests:
  140|      1|{
  141|      1|    e->digests = f;
  142|      1|    return 1;
  143|      1|}

ENGINE_register_DSA:
   78|     10|{
   79|     10|    if (e->dsa_meth)
   80|      6|        return engine_table_register(&dsa_table,
   81|      6|                                     engine_unregister_all_DSA, e, &dummy_nid,
   82|      6|                                     1, 0);
   83|      4|    return 1;
   84|     10|}
ENGINE_set_DSA:
  121|      6|{
  122|      6|    e->dsa_meth = dsa_meth;
  123|      6|    return 1;
  124|      6|}

ENGINE_register_ECDH:
   93|     10|{
   94|     10|    if (e->ecdh_meth)
   95|      0|        return engine_table_register(&ecdh_table,
   96|      0|                                     engine_unregister_all_ECDH, e,
   97|      0|                                     &dummy_nid, 1, 0);
   98|     10|    return 1;
   99|     10|}

ENGINE_register_ECDSA:
   78|     10|{
   79|     10|    if (e->ecdsa_meth)
   80|      0|        return engine_table_register(&ecdsa_table,
   81|      0|                                     engine_unregister_all_ECDSA, e,
   82|      0|                                     &dummy_nid, 1, 0);
   83|     10|    return 1;
   84|     10|}

ENGINE_register_pkey_meths:
   78|     11|{
   79|     11|    if (e->pkey_meths) {
   80|      2|        const int *nids;
   81|      2|        int num_nids = e->pkey_meths(e, NULL, &nids, 0);
   82|      2|        if (num_nids > 0)
   83|      2|            return engine_table_register(&pkey_meth_table,
   84|      2|                                         engine_unregister_all_pkey_meths, e,
   85|      2|                                         nids, num_nids, 0);
   86|      2|    }
   87|      9|    return 1;
   88|     11|}
ENGINE_set_pkey_meths:
  142|      1|{
  143|      1|    e->pkey_meths = f;
  144|      1|    return 1;
  145|      1|}

ENGINE_register_RAND:
   78|     10|{
   79|     10|    if (e->rand_meth)
   80|      4|        return engine_table_register(&rand_table,
   81|      4|                                     engine_unregister_all_RAND, e,
   82|      4|                                     &dummy_nid, 1, 0);
   83|      6|    return 1;
   84|     10|}
ENGINE_get_default_RAND:
  109|      1|{
  110|      1|    return engine_table_select(&rand_table, dummy_nid);
  111|      1|}
ENGINE_set_RAND:
  121|      5|{
  122|      5|    e->rand_meth = rand_meth;
  123|      5|    return 1;
  124|      5|}

ENGINE_register_RSA:
   78|     10|{
   79|     10|    if (e->rsa_meth)
   80|      8|        return engine_table_register(&rsa_table,
   81|      8|                                     engine_unregister_all_RSA, e, &dummy_nid,
   82|      8|                                     1, 0);
   83|      2|    return 1;
   84|     10|}
ENGINE_set_RSA:
  121|      8|{
  122|      8|    e->rsa_meth = rsa_meth;
  123|      8|    return 1;
  124|      8|}

err.c:err_string_data_LHASH_HASH:
  105|  19.0k|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|  19.0k|                const o_type *a = arg; \
  107|  19.0k|                return name##_hash(a); }
err.c:err_string_data_LHASH_COMP:
  114|  17.2k|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|  17.2k|                const o_type *a = arg1;             \
  116|  17.2k|                const o_type *b = arg2; \
  117|  17.2k|                return name##_cmp(a,b); }
err.c:err_state_LHASH_HASH:
  105|  4.30k|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|  4.30k|                const o_type *a = arg; \
  107|  4.30k|                return name##_hash(a); }
err.c:err_state_LHASH_COMP:
  114|  3.78k|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|  3.78k|                const o_type *a = arg1;             \
  116|  3.78k|                const o_type *b = arg2; \
  117|  3.78k|                return name##_cmp(a,b); }

ERR_load_ERR_strings:
  659|     81|{
  660|     81|    err_fns_check();
  661|     81|#ifndef OPENSSL_NO_ERR
  662|     81|    err_load_strings(0, ERR_str_libraries);
  663|     81|    err_load_strings(0, ERR_str_reasons);
  664|     81|    err_load_strings(ERR_LIB_SYS, ERR_str_functs);
  665|     81|    build_SYS_str_reasons();
  666|     81|    err_load_strings(ERR_LIB_SYS, SYS_str_reasons);
  667|     81|#endif
  668|     81|}
ERR_load_strings:
  681|     80|{
  682|     80|    ERR_load_ERR_strings();
  683|     80|    err_load_strings(lib, str);
  684|     80|}
ERR_put_error:
  705|     15|{
  706|     15|    ERR_STATE *es;
  707|       |
  708|       |#ifdef _OSD_POSIX
  709|       |    /*
  710|       |     * In the BS2000-OSD POSIX subsystem, the compiler generates path names
  711|       |     * in the form "*POSIX(/etc/passwd)". This dirty hack strips them to
  712|       |     * something sensible. @@@ We shouldn't modify a const string, though.
  713|       |     */
  714|       |    if (strncmp(file, "*POSIX(", sizeof("*POSIX(") - 1) == 0) {
  715|       |        char *end;
  716|       |
  717|       |        /* Skip the "*POSIX(" prefix */
  718|       |        file += sizeof("*POSIX(") - 1;
  719|       |        end = &file[strlen(file) - 1];
  720|       |        if (*end == ')')
  721|       |            *end = '\0';
  722|       |        /* Optional: use the basename of the path only. */
  723|       |        if ((end = strrchr(file, '/')) != NULL)
  724|       |            file = &end[1];
  725|       |    }
  726|       |#endif
  727|     15|    es = ERR_get_state();
  728|     15|    if (es == NULL)
  729|      0|        return;
  730|       |
  731|     15|    es->top = (es->top + 1) % ERR_NUM_ERRORS;
  732|     15|    if (es->top == es->bottom)
  733|      0|        es->bottom = (es->bottom + 1) % ERR_NUM_ERRORS;
  734|     15|    es->err_flags[es->top] = 0;
  735|     15|    es->err_buffer[es->top] = ERR_PACK(lib, func, reason);
  736|     15|    es->err_file[es->top] = file;
  737|     15|    es->err_line[es->top] = line;
  738|     15|    err_clear_data(es, es->top);
  739|     15|}
ERR_clear_error:
  742|     12|{
  743|     12|    int i;
  744|     12|    ERR_STATE *es;
  745|       |
  746|     12|    es = ERR_get_state();
  747|     12|    if (es == NULL)
  748|      0|        return;
  749|       |
  750|    204|    for (i = 0; i < ERR_NUM_ERRORS; i++) {
  751|    192|        err_clear(es, i);
  752|    192|    }
  753|     12|    es->top = es->bottom = 0;
  754|     12|}
ERR_peek_last_error:
  789|      2|{
  790|      2|    return (get_error_values(0, 1, NULL, NULL, NULL, NULL));
  791|      2|}
ERR_func_error_string:
  971|     28|{
  972|     28|    ERR_STRING_DATA d, *p;
  973|     28|    unsigned long l, f;
  974|       |
  975|     28|    err_fns_check();
  976|     28|    l = ERR_GET_LIB(e);
  977|     28|    f = ERR_GET_FUNC(e);
  978|     28|    d.error = ERR_PACK(l, f, 0);
  979|     28|    p = ERRFN(err_get_item) (&d);
  980|     28|    return ((p == NULL) ? NULL : p->string);
  981|     28|}
ERR_remove_thread_state:
 1001|  1.05k|{
 1002|  1.05k|    ERR_STATE tmp;
 1003|       |
 1004|  1.05k|    if (id)
 1005|      0|        CRYPTO_THREADID_cpy(&tmp.tid, id);
 1006|  1.05k|    else
 1007|  1.05k|        CRYPTO_THREADID_current(&tmp.tid);
 1008|  1.05k|    err_fns_check();
 1009|       |    /*
 1010|       |     * thread_del_item automatically destroys the LHASH if the number of
 1011|       |     * items reaches zero.
 1012|       |     */
 1013|  1.05k|    ERRFN(thread_del_item) (&tmp);
 1014|  1.05k|}
ERR_get_state:
 1024|  3.26k|{
 1025|  3.26k|    ERR_STATE *ret, tmp, *tmpp = NULL;
 1026|  3.26k|    int i;
 1027|  3.26k|    CRYPTO_THREADID tid;
 1028|       |
 1029|  3.26k|    err_fns_check();
 1030|  3.26k|    CRYPTO_THREADID_current(&tid);
 1031|  3.26k|    CRYPTO_THREADID_cpy(&tmp.tid, &tid);
 1032|  3.26k|    ret = ERRFN(thread_get_item) (&tmp);
 1033|       |
 1034|       |    /* ret == the error state, if NULL, make a new one */
 1035|  3.26k|    if (ret == NULL) {
 1036|    520|        ret = (ERR_STATE *)OPENSSL_malloc(sizeof(ERR_STATE));
 1037|    520|        if (ret == NULL)
 1038|      0|            return NULL;
 1039|    520|        CRYPTO_THREADID_cpy(&ret->tid, &tid);
 1040|    520|        ret->top = 0;
 1041|    520|        ret->bottom = 0;
 1042|  8.84k|        for (i = 0; i < ERR_NUM_ERRORS; i++) {
 1043|  8.32k|            ret->err_data[i] = NULL;
 1044|  8.32k|            ret->err_data_flags[i] = 0;
 1045|  8.32k|        }
 1046|    520|        tmpp = ERRFN(thread_set_item) (ret);
 1047|       |        /* To check if insertion failed, do a get. */
 1048|    520|        if (ERRFN(thread_get_item) (ret) != ret) {
 1049|      0|            ERR_STATE_free(ret); /* could not insert it */
 1050|      0|            return NULL;
 1051|      0|        }
 1052|       |        /*
 1053|       |         * If a race occured in this function and we came second, tmpp is the
 1054|       |         * first one that we just replaced.
 1055|       |         */
 1056|    520|        if (tmpp)
 1057|      0|            ERR_STATE_free(tmpp);
 1058|    520|    }
 1059|  3.26k|    return ret;
 1060|  3.26k|}
ERR_get_next_error_library:
 1063|      9|{
 1064|      9|    err_fns_check();
 1065|      9|    return ERRFN(get_next_lib) ();
 1066|      9|}
ERR_set_error_data:
 1069|      5|{
 1070|      5|    ERR_STATE *es;
 1071|      5|    int i;
 1072|       |
 1073|      5|    es = ERR_get_state();
 1074|      5|    if (es == NULL)
 1075|      0|        return;
 1076|       |
 1077|      5|    i = es->top;
 1078|       |
 1079|      5|    err_clear_data(es, i);
 1080|      5|    es->err_data[i] = data;
 1081|      5|    es->err_data_flags[i] = flags;
 1082|      5|}
ERR_add_error_data:
 1085|      5|{
 1086|      5|    va_list args;
 1087|      5|    va_start(args, num);
 1088|      5|    ERR_add_error_vdata(num, args);
 1089|      5|    va_end(args);
 1090|      5|}
ERR_add_error_vdata:
 1093|      5|{
 1094|      5|    int i, n, s;
 1095|      5|    char *str, *p, *a;
 1096|       |
 1097|      5|    s = 80;
 1098|      5|    str = OPENSSL_malloc(s + 1);
 1099|      5|    if (str == NULL)
 1100|      0|        return;
 1101|      5|    str[0] = '\0';
 1102|       |
 1103|      5|    n = 0;
 1104|     26|    for (i = 0; i < num; i++) {
 1105|     21|        a = va_arg(args, char *);
 1106|       |        /* ignore NULLs, thanks to Bob Beck <beck@obtuse.com> */
 1107|     21|        if (a != NULL) {
 1108|     21|            n += strlen(a);
 1109|     21|            if (n > s) {
 1110|      4|                s = n + 20;
 1111|      4|                p = OPENSSL_realloc(str, s + 1);
 1112|      4|                if (p == NULL) {
 1113|      0|                    OPENSSL_free(str);
 1114|      0|                    return;
 1115|      0|                } else
 1116|      4|                    str = p;
 1117|      4|            }
 1118|     21|            BUF_strlcat(str, a, (size_t)s + 1);
 1119|     21|        }
 1120|     21|    }
 1121|      5|    ERR_set_error_data(str, ERR_TXT_MALLOCED | ERR_TXT_STRING);
 1122|      5|}
ERR_set_mark:
 1125|  1.61k|{
 1126|  1.61k|    ERR_STATE *es;
 1127|       |
 1128|  1.61k|    es = ERR_get_state();
 1129|  1.61k|    if (es == NULL)
 1130|      0|        return 0;
 1131|       |
 1132|  1.61k|    if (es->bottom == es->top)
 1133|  1.61k|        return 0;
 1134|      0|    es->err_flags[es->top] |= ERR_FLAG_MARK;
 1135|      0|    return 1;
 1136|  1.61k|}
ERR_pop_to_mark:
 1139|  1.61k|{
 1140|  1.61k|    ERR_STATE *es;
 1141|       |
 1142|  1.61k|    es = ERR_get_state();
 1143|  1.61k|    if (es == NULL)
 1144|      0|        return 0;
 1145|       |
 1146|  1.62k|    while (es->bottom != es->top
 1147|  1.62k|           && (es->err_flags[es->top] & ERR_FLAG_MARK) == 0) {
 1148|     12|        err_clear(es, es->top);
 1149|     12|        es->top -= 1;
 1150|     12|        if (es->top == -1)
 1151|      0|            es->top = ERR_NUM_ERRORS - 1;
 1152|     12|    }
 1153|       |
 1154|  1.61k|    if (es->bottom == es->top)
 1155|  1.61k|        return 0;
 1156|      0|    es->err_flags[es->top] &= ~ERR_FLAG_MARK;
 1157|      0|    return 1;
 1158|  1.61k|}
err.c:err_fns_check:
  292|  28.8k|{
  293|  28.8k|    if (err_fns)
  294|  28.8k|        return;
  295|       |
  296|      1|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  297|      1|    if (!err_fns)
  298|      1|        err_fns = &err_defaults;
  299|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  300|      1|}
err.c:int_err_get:
  358|  19.0k|{
  359|  19.0k|    LHASH_OF(ERR_STRING_DATA) *ret = NULL;
  360|       |
  361|  19.0k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  362|  19.0k|    if (!int_error_hash && create) {
  363|      1|        CRYPTO_push_info("int_err_get (err.c)");
  364|      1|        int_error_hash = lh_ERR_STRING_DATA_new();
  365|      1|        CRYPTO_pop_info();
  366|      1|    }
  367|  19.0k|    if (int_error_hash)
  368|  19.0k|        ret = int_error_hash;
  369|  19.0k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  370|       |
  371|  19.0k|    return ret;
  372|  19.0k|}
err.c:err_string_data_hash:
  339|  19.0k|{
  340|  19.0k|    unsigned long ret, l;
  341|       |
  342|  19.0k|    l = a->error;
  343|  19.0k|    ret = l ^ ERR_GET_LIB(l) ^ ERR_GET_FUNC(l);
  344|  19.0k|    return (ret ^ ret % 19 * 13);
  345|  19.0k|}
err.c:err_string_data_cmp:
  351|  17.2k|{
  352|  17.2k|    return (int)(a->error - b->error);
  353|  17.2k|}
err.c:int_err_get_item:
  385|     28|{
  386|     28|    ERR_STRING_DATA *p;
  387|     28|    LHASH_OF(ERR_STRING_DATA) *hash;
  388|       |
  389|     28|    err_fns_check();
  390|     28|    hash = ERRFN(err_get) (0);
  391|     28|    if (!hash)
  392|      0|        return NULL;
  393|       |
  394|     28|    CRYPTO_r_lock(CRYPTO_LOCK_ERR);
  395|     28|    p = lh_ERR_STRING_DATA_retrieve(hash, d);
  396|     28|    CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  397|       |
  398|     28|    return p;
  399|     28|}
err.c:int_err_set_item:
  402|  19.0k|{
  403|  19.0k|    ERR_STRING_DATA *p;
  404|  19.0k|    LHASH_OF(ERR_STRING_DATA) *hash;
  405|       |
  406|  19.0k|    err_fns_check();
  407|  19.0k|    hash = ERRFN(err_get) (1);
  408|  19.0k|    if (!hash)
  409|      0|        return NULL;
  410|       |
  411|  19.0k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  412|  19.0k|    p = lh_ERR_STRING_DATA_insert(hash, d);
  413|  19.0k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  414|       |
  415|  19.0k|    return p;
  416|  19.0k|}
err.c:int_thread_get:
  450|  5.36k|{
  451|  5.36k|    LHASH_OF(ERR_STATE) *ret = NULL;
  452|       |
  453|  5.36k|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  454|  5.36k|    if (!int_thread_hash && create) {
  455|    520|        CRYPTO_push_info("int_thread_get (err.c)");
  456|    520|        int_thread_hash = lh_ERR_STATE_new();
  457|    520|        CRYPTO_pop_info();
  458|    520|    }
  459|  5.36k|    if (int_thread_hash) {
  460|  4.30k|        int_thread_hash_references++;
  461|  4.30k|        ret = int_thread_hash;
  462|  4.30k|    }
  463|  5.36k|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  464|  5.36k|    return ret;
  465|  5.36k|}
err.c:err_state_hash:
  436|  4.30k|{
  437|  4.30k|    return CRYPTO_THREADID_hash(&a->tid) * 13;
  438|  4.30k|}
err.c:err_state_cmp:
  443|  3.78k|{
  444|  3.78k|    return CRYPTO_THREADID_cmp(&a->tid, &b->tid);
  445|  3.78k|}
err.c:int_thread_release:
  468|  4.30k|{
  469|  4.30k|    int i;
  470|       |
  471|  4.30k|    if (hash == NULL || *hash == NULL)
  472|      0|        return;
  473|       |
  474|  4.30k|    i = CRYPTO_add(&int_thread_hash_references, -1, CRYPTO_LOCK_ERR);
  475|       |
  476|       |#ifdef REF_PRINT
  477|       |    fprintf(stderr, "%4d:%s\n", int_thread_hash_references, "ERR");
  478|       |#endif
  479|  4.30k|    if (i > 0)
  480|      0|        return;
  481|       |#ifdef REF_CHECK
  482|       |    if (i < 0) {
  483|       |        fprintf(stderr, "int_thread_release, bad reference count\n");
  484|       |        abort();                /* ok */
  485|       |    }
  486|       |#endif
  487|  4.30k|    *hash = NULL;
  488|  4.30k|}
err.c:int_thread_get_item:
  491|  3.78k|{
  492|  3.78k|    ERR_STATE *p;
  493|  3.78k|    LHASH_OF(ERR_STATE) *hash;
  494|       |
  495|  3.78k|    err_fns_check();
  496|  3.78k|    hash = ERRFN(thread_get) (0);
  497|  3.78k|    if (!hash)
  498|    520|        return NULL;
  499|       |
  500|  3.26k|    CRYPTO_r_lock(CRYPTO_LOCK_ERR);
  501|  3.26k|    p = lh_ERR_STATE_retrieve(hash, d);
  502|  3.26k|    CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  503|       |
  504|  3.26k|    ERRFN(thread_release) (&hash);
  505|  3.26k|    return p;
  506|  3.78k|}
err.c:int_thread_set_item:
  509|    520|{
  510|    520|    ERR_STATE *p;
  511|    520|    LHASH_OF(ERR_STATE) *hash;
  512|       |
  513|    520|    err_fns_check();
  514|    520|    hash = ERRFN(thread_get) (1);
  515|    520|    if (!hash)
  516|      0|        return NULL;
  517|       |
  518|    520|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  519|    520|    p = lh_ERR_STATE_insert(hash, d);
  520|    520|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  521|       |
  522|    520|    ERRFN(thread_release) (&hash);
  523|    520|    return p;
  524|    520|}
err.c:int_thread_del_item:
  527|  1.05k|{
  528|  1.05k|    ERR_STATE *p;
  529|  1.05k|    LHASH_OF(ERR_STATE) *hash;
  530|       |
  531|  1.05k|    err_fns_check();
  532|  1.05k|    hash = ERRFN(thread_get) (0);
  533|  1.05k|    if (!hash)
  534|    539|        return;
  535|       |
  536|    520|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  537|    520|    p = lh_ERR_STATE_delete(hash, d);
  538|       |    /* make sure we don't leak memory */
  539|    520|    if (int_thread_hash_references == 1
  540|    520|        && int_thread_hash && lh_ERR_STATE_num_items(int_thread_hash) == 0) {
  541|    520|        lh_ERR_STATE_free(int_thread_hash);
  542|    520|        int_thread_hash = NULL;
  543|    520|    }
  544|    520|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  545|       |
  546|    520|    ERRFN(thread_release) (&hash);
  547|    520|    if (p)
  548|    520|        ERR_STATE_free(p);
  549|    520|}
err.c:int_err_get_next_lib:
  552|      9|{
  553|      9|    int ret;
  554|       |
  555|      9|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  556|      9|    ret = int_err_library_number++;
  557|      9|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  558|       |
  559|      9|    return ret;
  560|      9|}
err.c:build_SYS_str_reasons:
  578|     81|{
  579|       |    /* OPENSSL_malloc cannot be used here, use static storage instead */
  580|     81|    static char strerror_tab[NUM_SYS_STR_REASONS][LEN_SYS_STR_REASON];
  581|     81|    int i;
  582|     81|    static int init = 1;
  583|       |
  584|     81|    CRYPTO_r_lock(CRYPTO_LOCK_ERR);
  585|     81|    if (!init) {
  586|     80|        CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  587|     80|        return;
  588|     80|    }
  589|       |
  590|      1|    CRYPTO_r_unlock(CRYPTO_LOCK_ERR);
  591|      1|    CRYPTO_w_lock(CRYPTO_LOCK_ERR);
  592|      1|    if (!init) {
  593|      0|        CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  594|      0|        return;
  595|      0|    }
  596|       |
  597|    128|    for (i = 1; i <= NUM_SYS_STR_REASONS; i++) {
  598|    127|        ERR_STRING_DATA *str = &SYS_str_reasons[i - 1];
  599|       |
  600|    127|        str->error = (unsigned long)i;
  601|    127|        if (str->string == NULL) {
  602|    127|            char (*dest)[LEN_SYS_STR_REASON] = &(strerror_tab[i - 1]);
  603|    127|            char *src = strerror(i);
  604|    127|            if (src != NULL) {
  605|    127|                strncpy(*dest, src, sizeof *dest);
  606|    127|                (*dest)[sizeof *dest - 1] = '\0';
  607|    127|                str->string = *dest;
  608|    127|            }
  609|    127|        }
  610|    127|        if (str->string == NULL)
  611|      0|            str->string = "unknown";
  612|    127|    }
  613|       |
  614|       |    /*
  615|       |     * Now we still have SYS_str_reasons[NUM_SYS_STR_REASONS] = {0, NULL}, as
  616|       |     * required by ERR_load_strings.
  617|       |     */
  618|       |
  619|      1|    init = 0;
  620|       |
  621|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_ERR);
  622|      1|}
err.c:err_load_strings:
  671|    404|{
  672|  19.4k|    while (str->error) {
  673|  19.0k|        if (lib)
  674|  11.4k|            str->error |= ERR_PACK(lib, 0, 0);
  675|  19.0k|        ERRFN(err_set_item) (str);
  676|  19.0k|        str++;
  677|  19.0k|    }
  678|    404|}
err.c:get_error_values:
  807|      2|{
  808|      2|    int i = 0;
  809|      2|    ERR_STATE *es;
  810|      2|    unsigned long ret;
  811|       |
  812|      2|    es = ERR_get_state();
  813|      2|    if (es == NULL)
  814|      0|        return 0;
  815|       |
  816|      2|    if (inc && top) {
  817|      0|        if (file)
  818|      0|            *file = "";
  819|      0|        if (line)
  820|      0|            *line = 0;
  821|      0|        if (data)
  822|      0|            *data = "";
  823|      0|        if (flags)
  824|      0|            *flags = 0;
  825|       |
  826|      0|        return ERR_R_INTERNAL_ERROR;
  827|      0|    }
  828|       |
  829|      2|    if (es->bottom == es->top)
  830|      0|        return 0;
  831|      2|    if (top)
  832|      2|        i = es->top;            /* last error */
  833|      0|    else
  834|      0|        i = (es->bottom + 1) % ERR_NUM_ERRORS; /* first error */
  835|       |
  836|      2|    ret = es->err_buffer[i];
  837|      2|    if (inc) {
  838|      0|        es->bottom = i;
  839|      0|        es->err_buffer[i] = 0;
  840|      0|    }
  841|       |
  842|      2|    if ((file != NULL) && (line != NULL)) {
  843|      0|        if (es->err_file[i] == NULL) {
  844|      0|            *file = "NA";
  845|      0|            if (line != NULL)
  846|      0|                *line = 0;
  847|      0|        } else {
  848|      0|            *file = es->err_file[i];
  849|      0|            if (line != NULL)
  850|      0|                *line = es->err_line[i];
  851|      0|        }
  852|      0|    }
  853|       |
  854|      2|    if (data == NULL) {
  855|      2|        if (inc) {
  856|      0|            err_clear_data(es, i);
  857|      0|        }
  858|      2|    } else {
  859|      0|        if (es->err_data[i] == NULL) {
  860|      0|            *data = "";
  861|      0|            if (flags != NULL)
  862|      0|                *flags = 0;
  863|      0|        } else {
  864|      0|            *data = es->err_data[i];
  865|      0|            if (flags != NULL)
  866|      0|                *flags = es->err_data_flags[i];
  867|      0|        }
  868|      0|    }
  869|      2|    return ret;
  870|      2|}
err.c:ERR_STATE_free:
  646|    520|{
  647|    520|    int i;
  648|       |
  649|    520|    if (s == NULL)
  650|      0|        return;
  651|       |
  652|  8.84k|    for (i = 0; i < ERR_NUM_ERRORS; i++) {
  653|  8.32k|        err_clear_data(s, i);
  654|  8.32k|    }
  655|    520|    OPENSSL_free(s);
  656|    520|}

ERR_load_crypto_strings:
  112|      1|{
  113|      1|#ifndef OPENSSL_NO_ERR
  114|      1|    ERR_load_ERR_strings();     /* include error strings for SYSerr */
  115|      1|    ERR_load_BN_strings();
  116|      1|# ifndef OPENSSL_NO_RSA
  117|      1|    ERR_load_RSA_strings();
  118|      1|# endif
  119|      1|# ifndef OPENSSL_NO_DH
  120|      1|    ERR_load_DH_strings();
  121|      1|# endif
  122|      1|    ERR_load_EVP_strings();
  123|      1|    ERR_load_BUF_strings();
  124|      1|    ERR_load_OBJ_strings();
  125|      1|    ERR_load_PEM_strings();
  126|      1|# ifndef OPENSSL_NO_DSA
  127|      1|    ERR_load_DSA_strings();
  128|      1|# endif
  129|      1|    ERR_load_X509_strings();
  130|      1|    ERR_load_ASN1_strings();
  131|      1|    ERR_load_CONF_strings();
  132|      1|    ERR_load_CRYPTO_strings();
  133|      1|# ifndef OPENSSL_NO_COMP
  134|      1|    ERR_load_COMP_strings();
  135|      1|# endif
  136|      1|# ifndef OPENSSL_NO_EC
  137|      1|    ERR_load_EC_strings();
  138|      1|# endif
  139|      1|# ifndef OPENSSL_NO_ECDSA
  140|      1|    ERR_load_ECDSA_strings();
  141|      1|# endif
  142|      1|# ifndef OPENSSL_NO_ECDH
  143|      1|    ERR_load_ECDH_strings();
  144|      1|# endif
  145|       |    /* skip ERR_load_SSL_strings() because it is not in this library */
  146|      1|    ERR_load_BIO_strings();
  147|      1|    ERR_load_PKCS7_strings();
  148|      1|    ERR_load_X509V3_strings();
  149|      1|    ERR_load_PKCS12_strings();
  150|      1|    ERR_load_RAND_strings();
  151|      1|    ERR_load_DSO_strings();
  152|      1|    ERR_load_TS_strings();
  153|      1|# ifndef OPENSSL_NO_ENGINE
  154|      1|    ERR_load_ENGINE_strings();
  155|      1|# endif
  156|      1|    ERR_load_OCSP_strings();
  157|      1|    ERR_load_UI_strings();
  158|       |# ifdef OPENSSL_FIPS
  159|       |    ERR_load_FIPS_strings();
  160|       |# endif
  161|      1|# ifndef OPENSSL_NO_CMS
  162|      1|    ERR_load_CMS_strings();
  163|      1|# endif
  164|       |# ifndef OPENSSL_NO_JPAKE
  165|       |    ERR_load_JPAKE_strings();
  166|       |# endif
  167|      1|#endif
  168|      1|}

EVP_des_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_cfb1:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_cfb8:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_idea_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cfb1:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_des_ede3_cfb8:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_cfb128:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_seed_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_cbc:
  148|      2|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc2_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_bf_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_cast5_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_cbc:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_cfb64:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_ofb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }
EVP_rc5_32_12_16_ecb:
  148|      1|const EVP_CIPHER *EVP_##cname##_##mode(void) { return &cname##_##mode; }

OPENSSL_add_all_algorithms_noconf:
   76|      1|{
   77|       |    /*
   78|       |     * For the moment OPENSSL_cpuid_setup does something
   79|       |     * only on IA-32, but we reserve the option for all
   80|       |     * platforms...
   81|       |     */
   82|      1|    OPENSSL_cpuid_setup();
   83|      1|    OpenSSL_add_all_ciphers();
   84|      1|    OpenSSL_add_all_digests();
   85|      1|}

OpenSSL_add_all_ciphers:
   66|      1|{
   67|       |
   68|      1|#ifndef OPENSSL_NO_DES
   69|      1|    EVP_add_cipher(EVP_des_cfb());
   70|      1|    EVP_add_cipher(EVP_des_cfb1());
   71|      1|    EVP_add_cipher(EVP_des_cfb8());
   72|      1|    EVP_add_cipher(EVP_des_ede_cfb());
   73|      1|    EVP_add_cipher(EVP_des_ede3_cfb());
   74|      1|    EVP_add_cipher(EVP_des_ede3_cfb1());
   75|      1|    EVP_add_cipher(EVP_des_ede3_cfb8());
   76|       |
   77|      1|    EVP_add_cipher(EVP_des_ofb());
   78|      1|    EVP_add_cipher(EVP_des_ede_ofb());
   79|      1|    EVP_add_cipher(EVP_des_ede3_ofb());
   80|       |
   81|      1|    EVP_add_cipher(EVP_desx_cbc());
   82|      1|    EVP_add_cipher_alias(SN_desx_cbc, "DESX");
   83|      1|    EVP_add_cipher_alias(SN_desx_cbc, "desx");
   84|       |
   85|      1|    EVP_add_cipher(EVP_des_cbc());
   86|      1|    EVP_add_cipher_alias(SN_des_cbc, "DES");
   87|      1|    EVP_add_cipher_alias(SN_des_cbc, "des");
   88|      1|    EVP_add_cipher(EVP_des_ede_cbc());
   89|      1|    EVP_add_cipher(EVP_des_ede3_cbc());
   90|      1|    EVP_add_cipher_alias(SN_des_ede3_cbc, "DES3");
   91|      1|    EVP_add_cipher_alias(SN_des_ede3_cbc, "des3");
   92|       |
   93|      1|    EVP_add_cipher(EVP_des_ecb());
   94|      1|    EVP_add_cipher(EVP_des_ede());
   95|      1|    EVP_add_cipher(EVP_des_ede3());
   96|      1|    EVP_add_cipher(EVP_des_ede3_wrap());
   97|      1|#endif
   98|       |
   99|      1|#ifndef OPENSSL_NO_RC4
  100|      1|    EVP_add_cipher(EVP_rc4());
  101|      1|    EVP_add_cipher(EVP_rc4_40());
  102|      1|# ifndef OPENSSL_NO_MD5
  103|      1|    EVP_add_cipher(EVP_rc4_hmac_md5());
  104|      1|# endif
  105|      1|#endif
  106|       |
  107|      1|#ifndef OPENSSL_NO_IDEA
  108|      1|    EVP_add_cipher(EVP_idea_ecb());
  109|      1|    EVP_add_cipher(EVP_idea_cfb());
  110|      1|    EVP_add_cipher(EVP_idea_ofb());
  111|      1|    EVP_add_cipher(EVP_idea_cbc());
  112|      1|    EVP_add_cipher_alias(SN_idea_cbc, "IDEA");
  113|      1|    EVP_add_cipher_alias(SN_idea_cbc, "idea");
  114|      1|#endif
  115|       |
  116|      1|#ifndef OPENSSL_NO_SEED
  117|      1|    EVP_add_cipher(EVP_seed_ecb());
  118|      1|    EVP_add_cipher(EVP_seed_cfb());
  119|      1|    EVP_add_cipher(EVP_seed_ofb());
  120|      1|    EVP_add_cipher(EVP_seed_cbc());
  121|      1|    EVP_add_cipher_alias(SN_seed_cbc, "SEED");
  122|      1|    EVP_add_cipher_alias(SN_seed_cbc, "seed");
  123|      1|#endif
  124|       |
  125|      1|#ifndef OPENSSL_NO_RC2
  126|      1|    EVP_add_cipher(EVP_rc2_ecb());
  127|      1|    EVP_add_cipher(EVP_rc2_cfb());
  128|      1|    EVP_add_cipher(EVP_rc2_ofb());
  129|      1|    EVP_add_cipher(EVP_rc2_cbc());
  130|      1|    EVP_add_cipher(EVP_rc2_40_cbc());
  131|      1|    EVP_add_cipher(EVP_rc2_64_cbc());
  132|      1|    EVP_add_cipher_alias(SN_rc2_cbc, "RC2");
  133|      1|    EVP_add_cipher_alias(SN_rc2_cbc, "rc2");
  134|      1|#endif
  135|       |
  136|      1|#ifndef OPENSSL_NO_BF
  137|      1|    EVP_add_cipher(EVP_bf_ecb());
  138|      1|    EVP_add_cipher(EVP_bf_cfb());
  139|      1|    EVP_add_cipher(EVP_bf_ofb());
  140|      1|    EVP_add_cipher(EVP_bf_cbc());
  141|      1|    EVP_add_cipher_alias(SN_bf_cbc, "BF");
  142|      1|    EVP_add_cipher_alias(SN_bf_cbc, "bf");
  143|      1|    EVP_add_cipher_alias(SN_bf_cbc, "blowfish");
  144|      1|#endif
  145|       |
  146|      1|#ifndef OPENSSL_NO_CAST
  147|      1|    EVP_add_cipher(EVP_cast5_ecb());
  148|      1|    EVP_add_cipher(EVP_cast5_cfb());
  149|      1|    EVP_add_cipher(EVP_cast5_ofb());
  150|      1|    EVP_add_cipher(EVP_cast5_cbc());
  151|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "CAST");
  152|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "cast");
  153|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "CAST-cbc");
  154|      1|    EVP_add_cipher_alias(SN_cast5_cbc, "cast-cbc");
  155|      1|#endif
  156|       |
  157|      1|#ifndef OPENSSL_NO_RC5
  158|      1|    EVP_add_cipher(EVP_rc5_32_12_16_ecb());
  159|      1|    EVP_add_cipher(EVP_rc5_32_12_16_cfb());
  160|      1|    EVP_add_cipher(EVP_rc5_32_12_16_ofb());
  161|      1|    EVP_add_cipher(EVP_rc5_32_12_16_cbc());
  162|      1|    EVP_add_cipher_alias(SN_rc5_cbc, "rc5");
  163|      1|    EVP_add_cipher_alias(SN_rc5_cbc, "RC5");
  164|      1|#endif
  165|       |
  166|      1|#ifndef OPENSSL_NO_AES
  167|      1|    EVP_add_cipher(EVP_aes_128_ecb());
  168|      1|    EVP_add_cipher(EVP_aes_128_cbc());
  169|      1|    EVP_add_cipher(EVP_aes_128_cfb());
  170|      1|    EVP_add_cipher(EVP_aes_128_cfb1());
  171|      1|    EVP_add_cipher(EVP_aes_128_cfb8());
  172|      1|    EVP_add_cipher(EVP_aes_128_ofb());
  173|      1|    EVP_add_cipher(EVP_aes_128_ctr());
  174|      1|    EVP_add_cipher(EVP_aes_128_gcm());
  175|      1|    EVP_add_cipher(EVP_aes_128_xts());
  176|      1|    EVP_add_cipher(EVP_aes_128_ccm());
  177|      1|    EVP_add_cipher(EVP_aes_128_wrap());
  178|      1|    EVP_add_cipher_alias(SN_aes_128_cbc, "AES128");
  179|      1|    EVP_add_cipher_alias(SN_aes_128_cbc, "aes128");
  180|      1|    EVP_add_cipher(EVP_aes_192_ecb());
  181|      1|    EVP_add_cipher(EVP_aes_192_cbc());
  182|      1|    EVP_add_cipher(EVP_aes_192_cfb());
  183|      1|    EVP_add_cipher(EVP_aes_192_cfb1());
  184|      1|    EVP_add_cipher(EVP_aes_192_cfb8());
  185|      1|    EVP_add_cipher(EVP_aes_192_ofb());
  186|      1|    EVP_add_cipher(EVP_aes_192_ctr());
  187|      1|    EVP_add_cipher(EVP_aes_192_gcm());
  188|      1|    EVP_add_cipher(EVP_aes_192_ccm());
  189|      1|    EVP_add_cipher(EVP_aes_192_wrap());
  190|      1|    EVP_add_cipher_alias(SN_aes_192_cbc, "AES192");
  191|      1|    EVP_add_cipher_alias(SN_aes_192_cbc, "aes192");
  192|      1|    EVP_add_cipher(EVP_aes_256_ecb());
  193|      1|    EVP_add_cipher(EVP_aes_256_cbc());
  194|      1|    EVP_add_cipher(EVP_aes_256_cfb());
  195|      1|    EVP_add_cipher(EVP_aes_256_cfb1());
  196|      1|    EVP_add_cipher(EVP_aes_256_cfb8());
  197|      1|    EVP_add_cipher(EVP_aes_256_ofb());
  198|      1|    EVP_add_cipher(EVP_aes_256_ctr());
  199|      1|    EVP_add_cipher(EVP_aes_256_gcm());
  200|      1|    EVP_add_cipher(EVP_aes_256_xts());
  201|      1|    EVP_add_cipher(EVP_aes_256_ccm());
  202|      1|    EVP_add_cipher(EVP_aes_256_wrap());
  203|      1|    EVP_add_cipher_alias(SN_aes_256_cbc, "AES256");
  204|      1|    EVP_add_cipher_alias(SN_aes_256_cbc, "aes256");
  205|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
  206|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
  207|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
  208|      1|# endif
  209|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA256)
  210|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha256());
  211|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha256());
  212|      1|# endif
  213|      1|#endif
  214|       |
  215|      1|#ifndef OPENSSL_NO_CAMELLIA
  216|      1|    EVP_add_cipher(EVP_camellia_128_ecb());
  217|      1|    EVP_add_cipher(EVP_camellia_128_cbc());
  218|      1|    EVP_add_cipher(EVP_camellia_128_cfb());
  219|      1|    EVP_add_cipher(EVP_camellia_128_cfb1());
  220|      1|    EVP_add_cipher(EVP_camellia_128_cfb8());
  221|      1|    EVP_add_cipher(EVP_camellia_128_ofb());
  222|      1|    EVP_add_cipher_alias(SN_camellia_128_cbc, "CAMELLIA128");
  223|      1|    EVP_add_cipher_alias(SN_camellia_128_cbc, "camellia128");
  224|      1|    EVP_add_cipher(EVP_camellia_192_ecb());
  225|      1|    EVP_add_cipher(EVP_camellia_192_cbc());
  226|      1|    EVP_add_cipher(EVP_camellia_192_cfb());
  227|      1|    EVP_add_cipher(EVP_camellia_192_cfb1());
  228|      1|    EVP_add_cipher(EVP_camellia_192_cfb8());
  229|      1|    EVP_add_cipher(EVP_camellia_192_ofb());
  230|      1|    EVP_add_cipher_alias(SN_camellia_192_cbc, "CAMELLIA192");
  231|      1|    EVP_add_cipher_alias(SN_camellia_192_cbc, "camellia192");
  232|      1|    EVP_add_cipher(EVP_camellia_256_ecb());
  233|      1|    EVP_add_cipher(EVP_camellia_256_cbc());
  234|      1|    EVP_add_cipher(EVP_camellia_256_cfb());
  235|      1|    EVP_add_cipher(EVP_camellia_256_cfb1());
  236|      1|    EVP_add_cipher(EVP_camellia_256_cfb8());
  237|      1|    EVP_add_cipher(EVP_camellia_256_ofb());
  238|      1|    EVP_add_cipher_alias(SN_camellia_256_cbc, "CAMELLIA256");
  239|      1|    EVP_add_cipher_alias(SN_camellia_256_cbc, "camellia256");
  240|      1|#endif
  241|      1|}

OpenSSL_add_all_digests:
   66|      1|{
   67|      1|#ifndef OPENSSL_NO_MD4
   68|      1|    EVP_add_digest(EVP_md4());
   69|      1|#endif
   70|      1|#ifndef OPENSSL_NO_MD5
   71|      1|    EVP_add_digest(EVP_md5());
   72|      1|    EVP_add_digest_alias(SN_md5, "ssl2-md5");
   73|      1|    EVP_add_digest_alias(SN_md5, "ssl3-md5");
   74|      1|#endif
   75|      1|#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA0)
   76|      1|    EVP_add_digest(EVP_sha());
   77|      1|# ifndef OPENSSL_NO_DSA
   78|      1|    EVP_add_digest(EVP_dss());
   79|      1|# endif
   80|      1|#endif
   81|      1|#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
   82|      1|    EVP_add_digest(EVP_sha1());
   83|      1|    EVP_add_digest_alias(SN_sha1, "ssl3-sha1");
   84|      1|    EVP_add_digest_alias(SN_sha1WithRSAEncryption, SN_sha1WithRSA);
   85|      1|# ifndef OPENSSL_NO_DSA
   86|      1|    EVP_add_digest(EVP_dss1());
   87|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, SN_dsaWithSHA1_2);
   88|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "DSS1");
   89|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "dss1");
   90|      1|# endif
   91|      1|# ifndef OPENSSL_NO_ECDSA
   92|      1|    EVP_add_digest(EVP_ecdsa());
   93|      1|# endif
   94|      1|#endif
   95|      1|#if !defined(OPENSSL_NO_MDC2) && !defined(OPENSSL_NO_DES)
   96|      1|    EVP_add_digest(EVP_mdc2());
   97|      1|#endif
   98|      1|#ifndef OPENSSL_NO_RIPEMD
   99|      1|    EVP_add_digest(EVP_ripemd160());
  100|      1|    EVP_add_digest_alias(SN_ripemd160, "ripemd");
  101|      1|    EVP_add_digest_alias(SN_ripemd160, "rmd160");
  102|      1|#endif
  103|      1|#ifndef OPENSSL_NO_SHA256
  104|      1|    EVP_add_digest(EVP_sha224());
  105|      1|    EVP_add_digest(EVP_sha256());
  106|      1|#endif
  107|      1|#ifndef OPENSSL_NO_SHA512
  108|      1|    EVP_add_digest(EVP_sha384());
  109|      1|    EVP_add_digest(EVP_sha512());
  110|      1|#endif
  111|      1|#ifndef OPENSSL_NO_WHIRLPOOL
  112|      1|    EVP_add_digest(EVP_whirlpool());
  113|      1|#endif
  114|      1|}

EVP_MD_CTX_init:
  126|    834|{
  127|    834|    memset(ctx, '\0', sizeof *ctx);
  128|    834|}
EVP_DigestInit_ex:
  147|  1.61k|{
  148|  1.61k|    EVP_MD_CTX_clear_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);
  149|       |#ifdef OPENSSL_FIPS
  150|       |    /* If FIPS mode switch to approved implementation if possible */
  151|       |    if (FIPS_mode()) {
  152|       |        const EVP_MD *fipsmd;
  153|       |        if (type) {
  154|       |            fipsmd = evp_get_fips_md(type);
  155|       |            if (fipsmd)
  156|       |                type = fipsmd;
  157|       |        }
  158|       |    }
  159|       |#endif
  160|  1.61k|#ifndef OPENSSL_NO_ENGINE
  161|       |    /*
  162|       |     * Whether it's nice or not, "Inits" can be used on "Final"'d contexts so
  163|       |     * this context may already have an ENGINE! Try to avoid releasing the
  164|       |     * previous handle, re-querying for an ENGINE, and having a
  165|       |     * reinitialisation, when it may all be unecessary.
  166|       |     */
  167|  1.61k|    if (ctx->engine && ctx->digest && (!type ||
  168|      0|                                       (type
  169|      0|                                        && (type->type ==
  170|      0|                                            ctx->digest->type))))
  171|      0|        goto skip_to_init;
  172|  1.61k|    if (type) {
  173|       |        /*
  174|       |         * Ensure an ENGINE left lying around from last time is cleared (the
  175|       |         * previous check attempted to avoid this if the same ENGINE and
  176|       |         * EVP_MD could be used).
  177|       |         */
  178|  1.61k|        if (ctx->engine)
  179|      0|            ENGINE_finish(ctx->engine);
  180|  1.61k|        if (impl) {
  181|      0|            if (!ENGINE_init(impl)) {
  182|      0|                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
  183|      0|                return 0;
  184|      0|            }
  185|      0|        } else
  186|       |            /* Ask if an ENGINE is reserved for this job */
  187|  1.61k|            impl = ENGINE_get_digest_engine(type->type);
  188|  1.61k|        if (impl) {
  189|       |            /* There's an ENGINE for this job ... (apparently) */
  190|      0|            const EVP_MD *d = ENGINE_get_digest(impl, type->type);
  191|      0|            if (!d) {
  192|       |                /* Same comment from evp_enc.c */
  193|      0|                EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_INITIALIZATION_ERROR);
  194|      0|                ENGINE_finish(impl);
  195|      0|                return 0;
  196|      0|            }
  197|       |            /* We'll use the ENGINE's private digest definition */
  198|      0|            type = d;
  199|       |            /*
  200|       |             * Store the ENGINE functional reference so we know 'type' came
  201|       |             * from an ENGINE and we need to release it when done.
  202|       |             */
  203|      0|            ctx->engine = impl;
  204|      0|        } else
  205|  1.61k|            ctx->engine = NULL;
  206|  1.61k|    } else {
  207|      0|        if (!ctx->digest) {
  208|      0|            EVPerr(EVP_F_EVP_DIGESTINIT_EX, EVP_R_NO_DIGEST_SET);
  209|      0|            return 0;
  210|      0|        }
  211|      0|        type = ctx->digest;
  212|      0|    }
  213|  1.61k|#endif
  214|  1.61k|    if (ctx->digest != type) {
  215|    834|        if (ctx->digest && ctx->digest->ctx_size) {
  216|      0|            OPENSSL_free(ctx->md_data);
  217|      0|            ctx->md_data = NULL;
  218|      0|        }
  219|    834|        ctx->digest = type;
  220|    834|        if (!(ctx->flags & EVP_MD_CTX_FLAG_NO_INIT) && type->ctx_size) {
  221|    834|            ctx->update = type->update;
  222|    834|            ctx->md_data = OPENSSL_malloc(type->ctx_size);
  223|    834|            if (ctx->md_data == NULL) {
  224|      0|                EVPerr(EVP_F_EVP_DIGESTINIT_EX, ERR_R_MALLOC_FAILURE);
  225|      0|                return 0;
  226|      0|            }
  227|    834|        }
  228|    834|    }
  229|  1.61k|#ifndef OPENSSL_NO_ENGINE
  230|  1.61k| skip_to_init:
  231|  1.61k|#endif
  232|  1.61k|    if (ctx->pctx) {
  233|      0|        int r;
  234|      0|        r = EVP_PKEY_CTX_ctrl(ctx->pctx, -1, EVP_PKEY_OP_TYPE_SIG,
  235|      0|                              EVP_PKEY_CTRL_DIGESTINIT, 0, ctx);
  236|      0|        if (r <= 0 && (r != -2))
  237|      0|            return 0;
  238|      0|    }
  239|  1.61k|    if (ctx->flags & EVP_MD_CTX_FLAG_NO_INIT)
  240|      0|        return 1;
  241|       |#ifdef OPENSSL_FIPS
  242|       |    if (FIPS_mode()) {
  243|       |        if (FIPS_digestinit(ctx, type))
  244|       |            return 1;
  245|       |        OPENSSL_free(ctx->md_data);
  246|       |        ctx->md_data = NULL;
  247|       |        return 0;
  248|       |    }
  249|       |#endif
  250|  1.61k|    return ctx->digest->init(ctx);
  251|  1.61k|}
EVP_DigestUpdate:
  254|  6.46k|{
  255|       |#ifdef OPENSSL_FIPS
  256|       |    if (FIPS_mode())
  257|       |        return FIPS_digestupdate(ctx, data, count);
  258|       |#endif
  259|  6.46k|    return ctx->update(ctx, data, count);
  260|  6.46k|}
EVP_DigestFinal_ex:
  273|  1.61k|{
  274|  1.61k|    int ret;
  275|       |#ifdef OPENSSL_FIPS
  276|       |    if (FIPS_mode())
  277|       |        return FIPS_digestfinal(ctx, md, size);
  278|       |#endif
  279|       |
  280|  1.61k|    OPENSSL_assert(ctx->digest->md_size <= EVP_MAX_MD_SIZE);
  281|  1.61k|    ret = ctx->digest->final(ctx, md);
  282|  1.61k|    if (size != NULL)
  283|      0|        *size = ctx->digest->md_size;
  284|  1.61k|    if (ctx->digest->cleanup) {
  285|      0|        ctx->digest->cleanup(ctx);
  286|      0|        EVP_MD_CTX_set_flags(ctx, EVP_MD_CTX_FLAG_CLEANED);
  287|      0|    }
  288|  1.61k|    OPENSSL_cleanse(ctx->md_data, ctx->digest->ctx_size);
  289|  1.61k|    return ret;
  290|  1.61k|}
EVP_MD_CTX_cleanup:
  377|    834|{
  378|    834|#ifndef OPENSSL_FIPS
  379|       |    /*
  380|       |     * Don't assume ctx->md_data was cleaned in EVP_Digest_Final, because
  381|       |     * sometimes only copies of the context are ever finalised.
  382|       |     */
  383|    834|    if (ctx->digest && ctx->digest->cleanup
  384|    834|        && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_CLEANED))
  385|      0|        ctx->digest->cleanup(ctx);
  386|    834|    if (ctx->digest && ctx->digest->ctx_size && ctx->md_data
  387|    834|        && !EVP_MD_CTX_test_flags(ctx, EVP_MD_CTX_FLAG_REUSE)) {
  388|    834|        OPENSSL_cleanse(ctx->md_data, ctx->digest->ctx_size);
  389|    834|        OPENSSL_free(ctx->md_data);
  390|    834|    }
  391|    834|#endif
  392|    834|    if (ctx->pctx)
  393|      0|        EVP_PKEY_CTX_free(ctx->pctx);
  394|    834|#ifndef OPENSSL_NO_ENGINE
  395|    834|    if (ctx->engine)
  396|       |        /*
  397|       |         * The EVP_MD we used belongs to an ENGINE, release the functional
  398|       |         * reference we held for this reason.
  399|       |         */
  400|      0|        ENGINE_finish(ctx->engine);
  401|    834|#endif
  402|       |#ifdef OPENSSL_FIPS
  403|       |    FIPS_md_ctx_cleanup(ctx);
  404|       |#endif
  405|    834|    memset(ctx, '\0', sizeof *ctx);
  406|       |
  407|    834|    return 1;
  408|    834|}

EVP_aes_128_cbc:
  459|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ecb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ofb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_cfb128:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_cfb1:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_cfb8:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ctr:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cbc:
  459|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ecb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ofb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cfb128:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cfb1:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_cfb8:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ctr:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cbc:
  459|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ecb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ofb:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cfb128:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cfb1:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_cfb8:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ctr:
  459|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  460|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_gcm:
  481|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_gcm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_gcm:
  481|      2|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      2|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_xts:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_xts:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_ccm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_192_ccm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_256_ccm:
  481|      1|const EVP_CIPHER *EVP_aes_##keylen##_##mode(void) \
  482|      1|{ return AESNI_CAPABLE?&aesni_##keylen##_##mode:&aes_##keylen##_##mode; }
EVP_aes_128_wrap:
 2001|      1|{
 2002|      1|    return &aes_128_wrap;
 2003|      1|}
EVP_aes_192_wrap:
 2015|      1|{
 2016|      1|    return &aes_192_wrap;
 2017|      1|}
EVP_aes_256_wrap:
 2029|      1|{
 2030|      1|    return &aes_256_wrap;
 2031|      1|}

EVP_aes_128_cbc_hmac_sha1:
  994|      2|{
  995|      2|    return (OPENSSL_ia32cap_P[1] & AESNI_CAPABLE ?
  996|      2|            &aesni_128_cbc_hmac_sha1_cipher : NULL);
  997|      2|}
EVP_aes_256_cbc_hmac_sha1:
 1000|      2|{
 1001|      2|    return (OPENSSL_ia32cap_P[1] & AESNI_CAPABLE ?
 1002|      2|            &aesni_256_cbc_hmac_sha1_cipher : NULL);
 1003|      2|}

EVP_aes_128_cbc_hmac_sha256:
  973|      2|{
  974|      2|    return ((OPENSSL_ia32cap_P[1] & AESNI_CAPABLE) &&
  975|      2|            aesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?
  976|      0|            &aesni_128_cbc_hmac_sha256_cipher : NULL);
  977|      2|}
EVP_aes_256_cbc_hmac_sha256:
  980|      2|{
  981|      2|    return ((OPENSSL_ia32cap_P[1] & AESNI_CAPABLE) &&
  982|      2|            aesni_cbc_sha256_enc(NULL, NULL, 0, NULL, NULL, NULL, NULL) ?
  983|      0|            &aesni_256_cbc_hmac_sha256_cipher : NULL);
  984|      2|}

EVP_camellia_128_cbc:
  240|      2|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      2|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_ecb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_ofb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_cfb128:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_cfb1:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_128_cfb8:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cbc:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_ecb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_ofb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cfb128:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cfb1:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_192_cfb8:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cbc:
  240|      2|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      2|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_ecb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_ofb:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cfb128:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cfb1:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }
EVP_camellia_256_cfb8:
  240|      1|const EVP_CIPHER *EVP_camellia_##keylen##_##mode(void) \
  241|      1|{ return &camellia_##keylen##_##mode; }

EVP_des_ede:
  378|      1|{
  379|      1|    return &des_ede_ecb;
  380|      1|}
EVP_des_ede3:
  383|      1|{
  384|      1|    return &des_ede3_ecb;
  385|      1|}
EVP_des_ede3_wrap:
  492|      1|{
  493|      1|    return &des3_wrap;
  494|      1|}

EVP_rc2_64_cbc:
  123|      1|{
  124|      1|    return (&r2_64_cbc_cipher);
  125|      1|}
EVP_rc2_40_cbc:
  128|      2|{
  129|      2|    return (&r2_40_cbc_cipher);
  130|      2|}

EVP_rc4:
  111|      2|{
  112|      2|    return (&r4_cipher);
  113|      2|}
EVP_rc4_40:
  116|      1|{
  117|      1|    return (&r4_40_cipher);
  118|      1|}

EVP_rc4_hmac_md5:
  309|      2|{
  310|      2|    return (&r4_hmac_md5_cipher);
  311|      2|}

EVP_desx_cbc:
   97|      1|{
   98|      1|    return (&d_xcbc_cipher);
   99|      1|}

EVP_add_alg_module:
  116|      1|{
  117|      1|    CONF_module_add("alg_section", alg_module_init, 0);
  118|      1|}

ERR_load_EVP_strings:
  247|      1|{
  248|      1|#ifndef OPENSSL_NO_ERR
  249|       |
  250|      1|    if (ERR_func_error_string(EVP_str_functs[0].error) == NULL) {
  251|      1|        ERR_load_strings(0, EVP_str_functs);
  252|      1|        ERR_load_strings(0, EVP_str_reasons);
  253|      1|    }
  254|      1|#endif
  255|      1|}

EVP_MD_size:
  311|      5|{
  312|      5|    if (!md) {
  313|      0|        EVPerr(EVP_F_EVP_MD_SIZE, EVP_R_MESSAGE_DIGEST_IS_NULL);
  314|      0|        return -1;
  315|      0|    }
  316|      5|    return md->md_size;
  317|      5|}
EVP_MD_CTX_clear_flags:
  369|  1.61k|{
  370|  1.61k|    ctx->flags &= ~flags;
  371|  1.61k|}
EVP_MD_CTX_test_flags:
  374|    834|{
  375|    834|    return (ctx->flags & flags);
  376|    834|}

EVP_dss:
  101|      1|{
  102|      1|    return (&dsa_md);
  103|      1|}

EVP_dss1:
  102|      2|{
  103|      2|    return (&dss1_md);
  104|      2|}

EVP_ecdsa:
  151|      2|{
  152|      2|    return (&ecdsa_md);
  153|      2|}

EVP_md4:
  105|      1|{
  106|      1|    return (&md4_md);
  107|      1|}

EVP_md5:
  104|      2|{
  105|      2|    return (&md5_md);
  106|      2|}

EVP_mdc2:
  105|      1|{
  106|      1|    return (&mdc2_md);
  107|      1|}

EVP_ripemd160:
  104|      1|{
  105|      1|    return (&ripemd160_md);
  106|      1|}

EVP_sha:
  103|      1|{
  104|      1|    return (&sha_md);
  105|      1|}

EVP_sha1:
  102|  1.61k|{
  103|  1.61k|    return (&sha1_md);
  104|  1.61k|}
EVP_sha224:
  149|      2|{
  150|      2|    return (&sha224_md);
  151|      2|}
EVP_sha256:
  169|      2|{
  170|      2|    return (&sha256_md);
  171|      2|}
EVP_sha384:
  212|      2|{
  213|      2|    return (&sha384_md);
  214|      2|}
EVP_sha512:
  232|      2|{
  233|      2|    return (&sha512_md);
  234|      2|}
m_sha1.c:init:
   72|  1.61k|{
   73|  1.61k|    return SHA1_Init(ctx->md_data);
   74|  1.61k|}
m_sha1.c:update:
   77|  6.46k|{
   78|  6.46k|    return SHA1_Update(ctx->md_data, data, count);
   79|  6.46k|}
m_sha1.c:final:
   82|  1.61k|{
   83|  1.61k|    return SHA1_Final(md, ctx->md_data);
   84|  1.61k|}

EVP_whirlpool:
   45|      1|{
   46|      1|    return (&whirlpool_md);
   47|      1|}

EVP_add_cipher:
   66|    122|{
   67|    122|    int r;
   68|       |
   69|    122|    if (c == NULL)
   70|      4|        return 0;
   71|       |
   72|    118|    OPENSSL_init();
   73|       |
   74|    118|    r = OBJ_NAME_add(OBJ_nid2sn(c->nid), OBJ_NAME_TYPE_CIPHER_METH,
   75|    118|                     (const char *)c);
   76|    118|    if (r == 0)
   77|      0|        return (0);
   78|    118|    check_defer(c->nid);
   79|    118|    r = OBJ_NAME_add(OBJ_nid2ln(c->nid), OBJ_NAME_TYPE_CIPHER_METH,
   80|    118|                     (const char *)c);
   81|    118|    return (r);
   82|    118|}
EVP_add_digest:
   85|     24|{
   86|     24|    int r;
   87|     24|    const char *name;
   88|     24|    OPENSSL_init();
   89|       |
   90|     24|    name = OBJ_nid2sn(md->type);
   91|     24|    r = OBJ_NAME_add(name, OBJ_NAME_TYPE_MD_METH, (const char *)md);
   92|     24|    if (r == 0)
   93|      0|        return (0);
   94|     24|    check_defer(md->type);
   95|     24|    r = OBJ_NAME_add(OBJ_nid2ln(md->type), OBJ_NAME_TYPE_MD_METH,
   96|     24|                     (const char *)md);
   97|     24|    if (r == 0)
   98|      0|        return (0);
   99|       |
  100|     24|    if (md->pkey_type && md->type != md->pkey_type) {
  101|     18|        r = OBJ_NAME_add(OBJ_nid2sn(md->pkey_type),
  102|     18|                         OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);
  103|     18|        if (r == 0)
  104|      0|            return (0);
  105|     18|        check_defer(md->pkey_type);
  106|     18|        r = OBJ_NAME_add(OBJ_nid2ln(md->pkey_type),
  107|     18|                         OBJ_NAME_TYPE_MD_METH | OBJ_NAME_ALIAS, name);
  108|     18|    }
  109|     24|    return (r);
  110|     24|}
EVP_get_cipherbyname:
  113|     13|{
  114|     13|    const EVP_CIPHER *cp;
  115|       |
  116|     13|    cp = (const EVP_CIPHER *)OBJ_NAME_get(name, OBJ_NAME_TYPE_CIPHER_METH);
  117|     13|    return (cp);
  118|     13|}
EVP_get_digestbyname:
  121|      6|{
  122|      6|    const EVP_MD *cp;
  123|       |
  124|      6|    cp = (const EVP_MD *)OBJ_NAME_get(name, OBJ_NAME_TYPE_MD_METH);
  125|      6|    return (cp);
  126|      6|}

EVP_PKEY_meth_new:
  201|      3|{
  202|      3|    EVP_PKEY_METHOD *pmeth;
  203|       |
  204|      3|    pmeth = OPENSSL_malloc(sizeof(EVP_PKEY_METHOD));
  205|      3|    if (!pmeth)
  206|      0|        return NULL;
  207|       |
  208|      3|    memset(pmeth, 0, sizeof(EVP_PKEY_METHOD));
  209|       |
  210|      3|    pmeth->pkey_id = id;
  211|      3|    pmeth->flags = flags | EVP_PKEY_FLAG_DYNAMIC;
  212|      3|    return pmeth;
  213|      3|}
EVP_PKEY_meth_set_init:
  450|      3|{
  451|      3|    pmeth->init = init;
  452|      3|}
EVP_PKEY_meth_set_copy:
  457|      3|{
  458|      3|    pmeth->copy = copy;
  459|      3|}
EVP_PKEY_meth_set_cleanup:
  463|      3|{
  464|      3|    pmeth->cleanup = cleanup;
  465|      3|}
EVP_PKEY_meth_set_paramgen:
  471|      2|{
  472|      2|    pmeth->paramgen_init = paramgen_init;
  473|      2|    pmeth->paramgen = paramgen;
  474|      2|}
EVP_PKEY_meth_set_keygen:
  480|      3|{
  481|      3|    pmeth->keygen_init = keygen_init;
  482|      3|    pmeth->keygen = keygen;
  483|      3|}
EVP_PKEY_meth_set_sign:
  491|      2|{
  492|      2|    pmeth->sign_init = sign_init;
  493|      2|    pmeth->sign = sign;
  494|      2|}
EVP_PKEY_meth_set_verify:
  503|      2|{
  504|      2|    pmeth->verify_init = verify_init;
  505|      2|    pmeth->verify = verify;
  506|      2|}
EVP_PKEY_meth_set_signctx:
  531|      1|{
  532|      1|    pmeth->signctx_init = signctx_init;
  533|      1|    pmeth->signctx = signctx;
  534|      1|}
EVP_PKEY_meth_set_encrypt:
  555|      2|{
  556|      2|    pmeth->encrypt_init = encrypt_init;
  557|      2|    pmeth->encrypt = encryptfn;
  558|      2|}
EVP_PKEY_meth_set_decrypt:
  567|      2|{
  568|      2|    pmeth->decrypt_init = decrypt_init;
  569|      2|    pmeth->decrypt = decrypt;
  570|      2|}
EVP_PKEY_meth_set_derive:
  577|      2|{
  578|      2|    pmeth->derive_init = derive_init;
  579|      2|    pmeth->derive = derive;
  580|      2|}
EVP_PKEY_meth_set_ctrl:
  588|      3|{
  589|      3|    pmeth->ctrl = ctrl;
  590|      3|    pmeth->ctrl_str = ctrl_str;
  591|      3|}

CRYPTO_get_ex_new_index:
  581|      4|{
  582|      4|    int ret = -1;
  583|       |
  584|      4|    IMPL_CHECK
  585|      4|        ret = EX_IMPL(get_new_index) (class_index,
  586|      4|                                      argl, argp, new_func, dup_func,
  587|      4|                                      free_func);
  588|      4|    return ret;
  589|      4|}
CRYPTO_new_ex_data:
  596|     11|{
  597|     11|    IMPL_CHECK return EX_IMPL(new_ex_data) (class_index, obj, ad);
  598|     11|}
ex_data.c:impl_check:
  200|      1|{
  201|      1|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  202|      1|    if (!impl)
  203|      1|        impl = &impl_default;
  204|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  205|      1|}
ex_data.c:ex_data_check:
  276|      1|{
  277|      1|    int toret = 1;
  278|      1|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  279|      1|    if (!ex_data && (ex_data = lh_EX_CLASS_ITEM_new()) == NULL)
  280|      0|        toret = 0;
  281|      1|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  282|      1|    return toret;
  283|      1|}
ex_data.c:ex_class_item_hash:
  258|     19|{
  259|     19|    return a->class_index;
  260|     19|}
ex_data.c:ex_class_item_cmp:
  265|     15|{
  266|     15|    return a->class_index - b->class_index;
  267|     15|}
ex_data.c:int_get_new_index:
  407|      4|{
  408|      4|    EX_CLASS_ITEM *item = def_get_class(class_index);
  409|      4|    if (!item)
  410|      0|        return -1;
  411|      4|    return def_add_index(item, argl, argp, new_func, dup_func, free_func);
  412|      4|}
ex_data.c:def_get_class:
  314|     15|{
  315|     15|    EX_CLASS_ITEM d, *p, *gen;
  316|     15|    EX_DATA_CHECK(return NULL;)
  317|     15|        d.class_index = class_index;
  318|     15|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  319|     15|    p = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);
  320|     15|    if (!p) {
  321|      2|        gen = OPENSSL_malloc(sizeof(EX_CLASS_ITEM));
  322|      2|        if (gen) {
  323|      2|            gen->class_index = class_index;
  324|      2|            gen->meth_num = 0;
  325|      2|            gen->meth = sk_CRYPTO_EX_DATA_FUNCS_new_null();
  326|      2|            if (!gen->meth)
  327|      0|                OPENSSL_free(gen);
  328|      2|            else {
  329|       |                /*
  330|       |                 * Because we're inside the ex_data lock, the return value
  331|       |                 * from the insert will be NULL
  332|       |                 */
  333|      2|                (void)lh_EX_CLASS_ITEM_insert(ex_data, gen);
  334|      2|                p = lh_EX_CLASS_ITEM_retrieve(ex_data, &d);
  335|      2|                if (p != gen) {
  336|      0|                    sk_CRYPTO_EX_DATA_FUNCS_free(gen->meth);
  337|      0|                    OPENSSL_free(gen);
  338|      0|                }
  339|      2|            }
  340|      2|        }
  341|      2|    }
  342|     15|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  343|     15|    if (!p)
  344|     15|        CRYPTOerr(CRYPTO_F_DEF_GET_CLASS, ERR_R_MALLOC_FAILURE);
  345|     15|    return p;
  346|     15|}
ex_data.c:def_add_index:
  355|      4|{
  356|      4|    int toret = -1;
  357|      4|    CRYPTO_EX_DATA_FUNCS *a =
  358|      4|        (CRYPTO_EX_DATA_FUNCS *)OPENSSL_malloc(sizeof(CRYPTO_EX_DATA_FUNCS));
  359|      4|    if (!a) {
  360|      0|        CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);
  361|      0|        return -1;
  362|      0|    }
  363|      4|    a->argl = argl;
  364|      4|    a->argp = argp;
  365|      4|    a->new_func = new_func;
  366|      4|    a->dup_func = dup_func;
  367|      4|    a->free_func = free_func;
  368|      4|    CRYPTO_w_lock(CRYPTO_LOCK_EX_DATA);
  369|      8|    while (sk_CRYPTO_EX_DATA_FUNCS_num(item->meth) <= item->meth_num) {
  370|      4|        if (!sk_CRYPTO_EX_DATA_FUNCS_push(item->meth, NULL)) {
  371|      0|            CRYPTOerr(CRYPTO_F_DEF_ADD_INDEX, ERR_R_MALLOC_FAILURE);
  372|      0|            OPENSSL_free(a);
  373|      0|            goto err;
  374|      0|        }
  375|      4|    }
  376|      4|    toret = item->meth_num++;
  377|      4|    (void)sk_CRYPTO_EX_DATA_FUNCS_set(item->meth, toret, a);
  378|      4| err:
  379|      4|    CRYPTO_w_unlock(CRYPTO_LOCK_EX_DATA);
  380|      4|    return toret;
  381|      4|}
ex_data.c:int_new_ex_data:
  421|     11|{
  422|     11|    int mx, i;
  423|     11|    void *ptr;
  424|     11|    CRYPTO_EX_DATA_FUNCS **storage = NULL;
  425|     11|    EX_CLASS_ITEM *item = def_get_class(class_index);
  426|     11|    if (!item)
  427|       |        /* error is already set */
  428|      0|        return 0;
  429|     11|    ad->sk = NULL;
  430|     11|    CRYPTO_r_lock(CRYPTO_LOCK_EX_DATA);
  431|     11|    mx = sk_CRYPTO_EX_DATA_FUNCS_num(item->meth);
  432|     11|    if (mx > 0) {
  433|      0|        storage = OPENSSL_malloc(mx * sizeof(CRYPTO_EX_DATA_FUNCS *));
  434|      0|        if (!storage)
  435|      0|            goto skip;
  436|      0|        for (i = 0; i < mx; i++)
  437|      0|            storage[i] = sk_CRYPTO_EX_DATA_FUNCS_value(item->meth, i);
  438|      0|    }
  439|     11| skip:
  440|     11|    CRYPTO_r_unlock(CRYPTO_LOCK_EX_DATA);
  441|     11|    if ((mx > 0) && !storage) {
  442|      0|        CRYPTOerr(CRYPTO_F_INT_NEW_EX_DATA, ERR_R_MALLOC_FAILURE);
  443|      0|        return 0;
  444|      0|    }
  445|     11|    for (i = 0; i < mx; i++) {
  446|      0|        if (storage[i] && storage[i]->new_func) {
  447|      0|            ptr = CRYPTO_get_ex_data(ad, i);
  448|      0|            storage[i]->new_func(obj, ptr, ad, i,
  449|      0|                                 storage[i]->argl, storage[i]->argp);
  450|      0|        }
  451|      0|    }
  452|     11|    if (storage)
  453|      0|        OPENSSL_free(storage);
  454|     11|    return 1;
  455|     11|}

lh_new:
  134|    530|{
  135|    530|    _LHASH *ret;
  136|    530|    int i;
  137|       |
  138|    530|    if ((ret = OPENSSL_malloc(sizeof(_LHASH))) == NULL)
  139|      0|        goto err0;
  140|    530|    if ((ret->b = OPENSSL_malloc(sizeof(LHASH_NODE *) * MIN_NODES)) == NULL)
  141|      0|        goto err1;
  142|  9.01k|    for (i = 0; i < MIN_NODES; i++)
  143|  8.48k|        ret->b[i] = NULL;
  144|    530|    ret->comp = ((c == NULL) ? (LHASH_COMP_FN_TYPE)strcmp : c);
  145|    530|    ret->hash = ((h == NULL) ? (LHASH_HASH_FN_TYPE)lh_strhash : h);
  146|    530|    ret->num_nodes = MIN_NODES / 2;
  147|    530|    ret->num_alloc_nodes = MIN_NODES;
  148|    530|    ret->p = 0;
  149|    530|    ret->pmax = MIN_NODES / 2;
  150|    530|    ret->up_load = UP_LOAD;
  151|    530|    ret->down_load = DOWN_LOAD;
  152|    530|    ret->num_items = 0;
  153|       |
  154|    530|    ret->num_expands = 0;
  155|    530|    ret->num_expand_reallocs = 0;
  156|    530|    ret->num_contracts = 0;
  157|    530|    ret->num_contract_reallocs = 0;
  158|    530|    ret->num_hash_calls = 0;
  159|    530|    ret->num_comp_calls = 0;
  160|    530|    ret->num_insert = 0;
  161|    530|    ret->num_replace = 0;
  162|    530|    ret->num_delete = 0;
  163|    530|    ret->num_no_delete = 0;
  164|    530|    ret->num_retrieve = 0;
  165|    530|    ret->num_retrieve_miss = 0;
  166|    530|    ret->num_hash_comps = 0;
  167|       |
  168|    530|    ret->error = 0;
  169|    530|    return (ret);
  170|      0| err1:
  171|      0|    OPENSSL_free(ret);
  172|      0| err0:
  173|      0|    return (NULL);
  174|      0|}
lh_free:
  177|    520|{
  178|    520|    unsigned int i;
  179|    520|    LHASH_NODE *n, *nn;
  180|       |
  181|    520|    if (lh == NULL)
  182|      0|        return;
  183|       |
  184|  4.68k|    for (i = 0; i < lh->num_nodes; i++) {
  185|  4.16k|        n = lh->b[i];
  186|  4.16k|        while (n != NULL) {
  187|      0|            nn = n->next;
  188|      0|            OPENSSL_free(n);
  189|      0|            n = nn;
  190|      0|        }
  191|  4.16k|    }
  192|    520|    OPENSSL_free(lh->b);
  193|    520|    OPENSSL_free(lh);
  194|    520|}
lh_insert:
  197|  19.9k|{
  198|  19.9k|    unsigned long hash;
  199|  19.9k|    LHASH_NODE *nn, **rn;
  200|  19.9k|    void *ret;
  201|       |
  202|  19.9k|    lh->error = 0;
  203|  19.9k|    if (lh->up_load <= (lh->num_items * LH_LOAD_MULT / lh->num_nodes)
  204|  19.9k|            && !expand(lh))
  205|      0|        return NULL;
  206|       |
  207|  19.9k|    rn = getrn(lh, data, &hash);
  208|       |
  209|  19.9k|    if (*rn == NULL) {
  210|  3.73k|        if ((nn = (LHASH_NODE *)OPENSSL_malloc(sizeof(LHASH_NODE))) == NULL) {
  211|      0|            lh->error++;
  212|      0|            return (NULL);
  213|      0|        }
  214|  3.73k|        nn->data = data;
  215|  3.73k|        nn->next = NULL;
  216|  3.73k|#ifndef OPENSSL_NO_HASH_COMP
  217|  3.73k|        nn->hash = hash;
  218|  3.73k|#endif
  219|  3.73k|        *rn = nn;
  220|  3.73k|        ret = NULL;
  221|  3.73k|        lh->num_insert++;
  222|  3.73k|        lh->num_items++;
  223|  16.2k|    } else {                    /* replace same key */
  224|       |
  225|  16.2k|        ret = (*rn)->data;
  226|  16.2k|        (*rn)->data = data;
  227|  16.2k|        lh->num_replace++;
  228|  16.2k|    }
  229|  19.9k|    return (ret);
  230|  19.9k|}
lh_delete:
  233|    520|{
  234|    520|    unsigned long hash;
  235|    520|    LHASH_NODE *nn, **rn;
  236|    520|    void *ret;
  237|       |
  238|    520|    lh->error = 0;
  239|    520|    rn = getrn(lh, data, &hash);
  240|       |
  241|    520|    if (*rn == NULL) {
  242|      0|        lh->num_no_delete++;
  243|      0|        return (NULL);
  244|    520|    } else {
  245|    520|        nn = *rn;
  246|    520|        *rn = nn->next;
  247|    520|        ret = nn->data;
  248|    520|        OPENSSL_free(nn);
  249|    520|        lh->num_delete++;
  250|    520|    }
  251|       |
  252|    520|    lh->num_items--;
  253|    520|    if ((lh->num_nodes > MIN_NODES) &&
  254|    520|        (lh->down_load >= (lh->num_items * LH_LOAD_MULT / lh->num_nodes)))
  255|      0|        contract(lh);
  256|       |
  257|    520|    return (ret);
  258|    520|}
lh_retrieve:
  261|  4.97k|{
  262|  4.97k|    unsigned long hash;
  263|  4.97k|    LHASH_NODE **rn;
  264|  4.97k|    void *ret;
  265|       |
  266|  4.97k|    lh->error = 0;
  267|  4.97k|    rn = getrn(lh, data, &hash);
  268|       |
  269|  4.97k|    if (*rn == NULL) {
  270|  1.65k|        lh->num_retrieve_miss++;
  271|  1.65k|        return (NULL);
  272|  3.32k|    } else {
  273|  3.32k|        ret = (*rn)->data;
  274|  3.32k|        lh->num_retrieve++;
  275|  3.32k|    }
  276|  3.32k|    return (ret);
  277|  4.97k|}
lh_strhash:
  447|    388|{
  448|    388|    unsigned long ret = 0;
  449|    388|    long n;
  450|    388|    unsigned long v;
  451|    388|    int r;
  452|       |
  453|    388|    if ((c == NULL) || (*c == '\0'))
  454|      0|        return (ret);
  455|       |/*-
  456|       |    unsigned char b[16];
  457|       |    MD5(c,strlen(c),b);
  458|       |    return(b[0]|(b[1]<<8)|(b[2]<<16)|(b[3]<<24));
  459|       |*/
  460|       |
  461|    388|    n = 0x100;
  462|  4.39k|    while (*c) {
  463|  4.00k|        v = n | (*c);
  464|  4.00k|        n += 0x100;
  465|  4.00k|        r = (int)((v >> 2) ^ v) & 0x0f;
  466|  4.00k|        ret = (ret << r) | (ret >> (32 - r));
  467|  4.00k|        ret &= 0xFFFFFFFFL;
  468|  4.00k|        ret ^= v * v;
  469|  4.00k|        c++;
  470|  4.00k|    }
  471|    388|    return ((ret >> 16) ^ ret);
  472|    388|}
lh_num_items:
  475|    520|{
  476|    520|    return lh ? lh->num_items : 0;
  477|    520|}
lhash.c:expand:
  323|  1.58k|{
  324|  1.58k|    LHASH_NODE **n, **n1, **n2, *np;
  325|  1.58k|    unsigned int p, pmax, nni, j;
  326|  1.58k|    unsigned long hash;
  327|       |
  328|  1.58k|    nni = lh->num_alloc_nodes;
  329|  1.58k|    p = lh->p;
  330|  1.58k|    pmax = lh->pmax;
  331|  1.58k|    if (p + 1 >= pmax) {
  332|     11|        j = nni * 2;
  333|     11|        n = OPENSSL_realloc(lh->b, (int)(sizeof(LHASH_NODE *) * j));
  334|     11|        if (n == NULL) {
  335|      0|            lh->error++;
  336|      0|            return 0;
  337|      0|        }
  338|     11|        lh->b = n;
  339|     11|        memset(n + nni, 0, sizeof(*n) * (j - nni));
  340|     11|        lh->pmax = nni;
  341|     11|        lh->num_alloc_nodes = j;
  342|     11|        lh->num_expand_reallocs++;
  343|     11|        lh->p = 0;
  344|  1.57k|    } else {
  345|  1.57k|        lh->p++;
  346|  1.57k|    }
  347|       |
  348|  1.58k|    lh->num_nodes++;
  349|  1.58k|    lh->num_expands++;
  350|  1.58k|    n1 = &(lh->b[p]);
  351|  1.58k|    n2 = &(lh->b[p + pmax]);
  352|  1.58k|    *n2 = NULL;
  353|       |
  354|  7.20k|    for (np = *n1; np != NULL;) {
  355|  5.61k|#ifndef OPENSSL_NO_HASH_COMP
  356|  5.61k|        hash = np->hash;
  357|       |#else
  358|       |        hash = lh->hash(np->data);
  359|       |        lh->num_hash_calls++;
  360|       |#endif
  361|  5.61k|        if ((hash % nni) != p) { /* move it */
  362|    558|            *n1 = (*n1)->next;
  363|    558|            np->next = *n2;
  364|    558|            *n2 = np;
  365|    558|        } else
  366|  5.05k|            n1 = &((*n1)->next);
  367|  5.61k|        np = *n1;
  368|  5.61k|    }
  369|       |
  370|  1.58k|    return 1;
  371|  1.58k|}
lhash.c:getrn:
  410|  25.4k|{
  411|  25.4k|    LHASH_NODE **ret, *n1;
  412|  25.4k|    unsigned long hash, nn;
  413|  25.4k|    LHASH_COMP_FN_TYPE cf;
  414|       |
  415|  25.4k|    hash = (*(lh->hash)) (data);
  416|  25.4k|    lh->num_hash_calls++;
  417|  25.4k|    *rhash = hash;
  418|       |
  419|  25.4k|    nn = hash % lh->pmax;
  420|  25.4k|    if (nn < lh->p)
  421|  11.6k|        nn = hash % lh->num_alloc_nodes;
  422|       |
  423|  25.4k|    cf = lh->comp;
  424|  25.4k|    ret = &(lh->b[(int)nn]);
  425|  50.6k|    for (n1 = *ret; n1 != NULL; n1 = n1->next) {
  426|  45.2k|#ifndef OPENSSL_NO_HASH_COMP
  427|  45.2k|        lh->num_hash_comps++;
  428|  45.2k|        if (n1->hash != hash) {
  429|  24.1k|            ret = &(n1->next);
  430|  24.1k|            continue;
  431|  24.1k|        }
  432|  21.1k|#endif
  433|  21.1k|        lh->num_comp_calls++;
  434|  21.1k|        if (cf(n1->data, data) == 0)
  435|  20.0k|            break;
  436|  1.06k|        ret = &(n1->next);
  437|  1.06k|    }
  438|  25.4k|    return (ret);
  439|  25.4k|}

CRYPTO_malloc:
  333|  6.63k|{
  334|  6.63k|    void *ret = NULL;
  335|       |
  336|  6.63k|    if (num <= 0)
  337|      0|        return NULL;
  338|       |
  339|  6.63k|    if (allow_customize)
  340|      1|        allow_customize = 0;
  341|  6.63k|    if (malloc_debug_func != NULL) {
  342|      0|        if (allow_customize_debug)
  343|      0|            allow_customize_debug = 0;
  344|      0|        malloc_debug_func(NULL, num, file, line, 0);
  345|      0|    }
  346|  6.63k|    ret = malloc_ex_func(num, file, line);
  347|       |#ifdef LEVITTE_DEBUG_MEM
  348|       |    fprintf(stderr, "LEVITTE_DEBUG_MEM:         > 0x%p (%d)\n", ret, num);
  349|       |#endif
  350|  6.63k|    if (malloc_debug_func != NULL)
  351|      0|        malloc_debug_func(ret, num, file, line, 1);
  352|       |
  353|  6.63k|    return ret;
  354|  6.63k|}
CRYPTO_realloc:
  368|     23|{
  369|     23|    void *ret = NULL;
  370|       |
  371|     23|    if (str == NULL)
  372|      0|        return CRYPTO_malloc(num, file, line);
  373|       |
  374|     23|    if (num <= 0)
  375|      0|        return NULL;
  376|       |
  377|     23|    if (realloc_debug_func != NULL)
  378|      0|        realloc_debug_func(str, NULL, num, file, line, 0);
  379|     23|    ret = realloc_ex_func(str, num, file, line);
  380|       |#ifdef LEVITTE_DEBUG_MEM
  381|       |    fprintf(stderr, "LEVITTE_DEBUG_MEM:         | 0x%p -> 0x%p (%d)\n", str,
  382|       |            ret, num);
  383|       |#endif
  384|     23|    if (realloc_debug_func != NULL)
  385|      0|        realloc_debug_func(str, ret, num, file, line, 1);
  386|       |
  387|     23|    return ret;
  388|     23|}
CRYPTO_free:
  428|  3.02k|{
  429|  3.02k|    if (free_debug_func != NULL)
  430|      0|        free_debug_func(str, 0);
  431|       |#ifdef LEVITTE_DEBUG_MEM
  432|       |    fprintf(stderr, "LEVITTE_DEBUG_MEM:         < 0x%p\n", str);
  433|       |#endif
  434|  3.02k|    free_func(str);
  435|  3.02k|    if (free_debug_func != NULL)
  436|      0|        free_debug_func(NULL, 1);
  437|  3.02k|}
mem.c:default_malloc_ex:
   78|  6.63k|{
   79|  6.63k|    return malloc_func(num);
   80|  6.63k|}
mem.c:default_realloc_ex:
   96|     23|{
   97|     23|    return realloc_func(str, num);
   98|     23|}

CRYPTO_mem_ctrl:
  209|      4|{
  210|      4|    int ret = mh_mode;
  211|       |
  212|      4|    CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
  213|      4|    switch (mode) {
  214|       |        /*
  215|       |         * for applications (not to be called while multiple threads use the
  216|       |         * library):
  217|       |         */
  218|      0|    case CRYPTO_MEM_CHECK_ON:  /* aka MemCheck_start() */
  219|      0|        mh_mode = CRYPTO_MEM_CHECK_ON | CRYPTO_MEM_CHECK_ENABLE;
  220|      0|        num_disable = 0;
  221|      0|        break;
  222|      0|    case CRYPTO_MEM_CHECK_OFF: /* aka MemCheck_stop() */
  223|      0|        mh_mode = 0;
  224|      0|        num_disable = 0;        /* should be true *before* MemCheck_stop is
  225|       |                                 * used, or there'll be a lot of confusion */
  226|      0|        break;
  227|       |
  228|       |        /* switch off temporarily (for library-internal use): */
  229|      2|    case CRYPTO_MEM_CHECK_DISABLE: /* aka MemCheck_off() */
  230|      2|        if (mh_mode & CRYPTO_MEM_CHECK_ON) {
  231|      0|            CRYPTO_THREADID cur;
  232|      0|            CRYPTO_THREADID_current(&cur);
  233|       |            /* see if we don't have the MALLOC2 lock already */
  234|      0|            if (!num_disable
  235|      0|                || CRYPTO_THREADID_cmp(&disabling_threadid, &cur)) {
  236|       |                /*
  237|       |                 * Long-time lock CRYPTO_LOCK_MALLOC2 must not be claimed
  238|       |                 * while we're holding CRYPTO_LOCK_MALLOC, or we'll deadlock
  239|       |                 * if somebody else holds CRYPTO_LOCK_MALLOC2 (and cannot
  240|       |                 * release it because we block entry to this function). Give
  241|       |                 * them a chance, first, and then claim the locks in
  242|       |                 * appropriate order (long-time lock first).
  243|       |                 */
  244|      0|                CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
  245|       |                /*
  246|       |                 * Note that after we have waited for CRYPTO_LOCK_MALLOC2 and
  247|       |                 * CRYPTO_LOCK_MALLOC, we'll still be in the right "case" and
  248|       |                 * "if" branch because MemCheck_start and MemCheck_stop may
  249|       |                 * never be used while there are multiple OpenSSL threads.
  250|       |                 */
  251|      0|                CRYPTO_w_lock(CRYPTO_LOCK_MALLOC2);
  252|      0|                CRYPTO_w_lock(CRYPTO_LOCK_MALLOC);
  253|      0|                mh_mode &= ~CRYPTO_MEM_CHECK_ENABLE;
  254|      0|                CRYPTO_THREADID_cpy(&disabling_threadid, &cur);
  255|      0|            }
  256|      0|            num_disable++;
  257|      0|        }
  258|      2|        break;
  259|      2|    case CRYPTO_MEM_CHECK_ENABLE: /* aka MemCheck_on() */
  260|      2|        if (mh_mode & CRYPTO_MEM_CHECK_ON) {
  261|      0|            if (num_disable) {  /* always true, or something is going wrong */
  262|      0|                num_disable--;
  263|      0|                if (num_disable == 0) {
  264|      0|                    mh_mode |= CRYPTO_MEM_CHECK_ENABLE;
  265|      0|                    CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC2);
  266|      0|                }
  267|      0|            }
  268|      0|        }
  269|      2|        break;
  270|       |
  271|      0|    default:
  272|      0|        break;
  273|      4|    }
  274|      4|    CRYPTO_w_unlock(CRYPTO_LOCK_MALLOC);
  275|      4|    return (ret);
  276|      4|}
CRYPTO_is_mem_check_on:
  279|  1.04k|{
  280|  1.04k|    int ret = 0;
  281|       |
  282|  1.04k|    if (mh_mode & CRYPTO_MEM_CHECK_ON) {
  283|      0|        CRYPTO_THREADID cur;
  284|      0|        CRYPTO_THREADID_current(&cur);
  285|      0|        CRYPTO_r_lock(CRYPTO_LOCK_MALLOC);
  286|       |
  287|      0|        ret = (mh_mode & CRYPTO_MEM_CHECK_ENABLE)
  288|      0|            || CRYPTO_THREADID_cmp(&disabling_threadid, &cur);
  289|       |
  290|      0|        CRYPTO_r_unlock(CRYPTO_LOCK_MALLOC);
  291|      0|    }
  292|  1.04k|    return (ret);
  293|  1.04k|}
CRYPTO_push_info_:
  390|    521|{
  391|    521|    APP_INFO *ami, *amim;
  392|    521|    int ret = 0;
  393|       |
  394|    521|    if (is_MemCheck_on()) {
  395|      0|        MemCheck_off();         /* obtain MALLOC2 lock */
  396|       |
  397|      0|        if ((ami = (APP_INFO *)OPENSSL_malloc(sizeof(APP_INFO))) == NULL) {
  398|      0|            ret = 0;
  399|      0|            goto err;
  400|      0|        }
  401|      0|        if (amih == NULL) {
  402|      0|            if ((amih = lh_APP_INFO_new()) == NULL) {
  403|      0|                OPENSSL_free(ami);
  404|      0|                ret = 0;
  405|      0|                goto err;
  406|      0|            }
  407|      0|        }
  408|       |
  409|      0|        CRYPTO_THREADID_current(&ami->threadid);
  410|      0|        ami->file = file;
  411|      0|        ami->line = line;
  412|      0|        ami->info = info;
  413|      0|        ami->references = 1;
  414|      0|        ami->next = NULL;
  415|       |
  416|      0|        if ((amim = lh_APP_INFO_insert(amih, ami)) != NULL) {
  417|       |#ifdef LEVITTE_DEBUG_MEM
  418|       |            if (CRYPTO_THREADID_cmp(&ami->threadid, &amim->threadid)) {
  419|       |                fprintf(stderr,
  420|       |                        "CRYPTO_push_info(): previous info has other thread ID (%lu) than the current thread (%lu)!!!!\n",
  421|       |                        CRYPTO_THREADID_hash(&amim->threadid),
  422|       |                        CRYPTO_THREADID_hash(&ami->threadid));
  423|       |                abort();
  424|       |            }
  425|       |#endif
  426|      0|            ami->next = amim;
  427|      0|        }
  428|      0| err:
  429|      0|        MemCheck_on();          /* release MALLOC2 lock */
  430|      0|    }
  431|       |
  432|    521|    return (ret);
  433|    521|}
CRYPTO_pop_info:
  436|    521|{
  437|    521|    int ret = 0;
  438|       |
  439|    521|    if (is_MemCheck_on()) {     /* _must_ be true, or something went severely
  440|       |                                 * wrong */
  441|      0|        MemCheck_off();         /* obtain MALLOC2 lock */
  442|       |
  443|      0|        ret = (pop_info() != NULL);
  444|       |
  445|      0|        MemCheck_on();          /* release MALLOC2 lock */
  446|      0|    }
  447|    521|    return (ret);
  448|    521|}

OPENSSL_init:
   69|    142|{
   70|    142|    static int done = 0;
   71|    142|    if (done)
   72|    141|        return;
   73|      1|    done = 1;
   74|       |#ifdef OPENSSL_FIPS
   75|       |    FIPS_set_locking_callbacks(CRYPTO_lock, CRYPTO_add_lock);
   76|       |# ifndef OPENSSL_NO_DEPRECATED
   77|       |    FIPS_crypto_set_id_callback(CRYPTO_thread_id);
   78|       |# endif
   79|       |    FIPS_set_error_callbacks(ERR_put_error, ERR_add_error_vdata);
   80|       |    FIPS_set_malloc_callbacks(CRYPTO_malloc, CRYPTO_free);
   81|       |    RAND_init_fips();
   82|       |#endif
   83|       |#if 0
   84|       |    fprintf(stderr, "Called OPENSSL_init\n");
   85|       |#endif
   86|      1|}

o_names.c:obj_name_LHASH_HASH:
  105|    388|        unsigned long name##_LHASH_HASH(const void *arg) { \
  106|    388|                const o_type *a = arg; \
  107|    388|                return name##_hash(a); }
o_names.c:obj_name_LHASH_COMP:
  114|     97|        int name##_LHASH_COMP(const void *arg1, const void *arg2) { \
  115|     97|                const o_type *a = arg1;             \
  116|     97|                const o_type *b = arg2; \
  117|     97|                return name##_cmp(a,b); }

OBJ_NAME_init:
   57|      1|{
   58|      1|    if (names_lh != NULL)
   59|      0|        return (1);
   60|      1|    MemCheck_off();
   61|      1|    names_lh = lh_OBJ_NAME_new();
   62|      1|    MemCheck_on();
   63|      1|    return (names_lh != NULL);
   64|      1|}
OBJ_NAME_get:
  151|     19|{
  152|     19|    OBJ_NAME on, *ret;
  153|     19|    int num = 0, alias;
  154|       |
  155|     19|    if (name == NULL)
  156|      0|        return (NULL);
  157|     19|    if ((names_lh == NULL) && !OBJ_NAME_init())
  158|      0|        return (NULL);
  159|       |
  160|     19|    alias = type & OBJ_NAME_ALIAS;
  161|     19|    type &= ~OBJ_NAME_ALIAS;
  162|       |
  163|     19|    on.name = name;
  164|     19|    on.type = type;
  165|       |
  166|     19|    for (;;) {
  167|     19|        ret = lh_OBJ_NAME_retrieve(names_lh, &on);
  168|     19|        if (ret == NULL)
  169|      0|            return (NULL);
  170|     19|        if ((ret->alias) && !alias) {
  171|      0|            if (++num > 10)
  172|      0|                return (NULL);
  173|      0|            on.name = ret->data;
  174|     19|        } else {
  175|     19|            return (ret->data);
  176|     19|        }
  177|     19|    }
  178|     19|}
OBJ_NAME_add:
  181|    369|{
  182|    369|    OBJ_NAME *onp, *ret;
  183|    369|    int alias;
  184|       |
  185|    369|    if ((names_lh == NULL) && !OBJ_NAME_init())
  186|      0|        return (0);
  187|       |
  188|    369|    alias = type & OBJ_NAME_ALIAS;
  189|    369|    type &= ~OBJ_NAME_ALIAS;
  190|       |
  191|    369|    onp = (OBJ_NAME *)OPENSSL_malloc(sizeof(OBJ_NAME));
  192|    369|    if (onp == NULL) {
  193|       |        /* ERROR */
  194|      0|        return 0;
  195|      0|    }
  196|       |
  197|    369|    onp->name = name;
  198|    369|    onp->alias = alias;
  199|    369|    onp->type = type;
  200|    369|    onp->data = data;
  201|       |
  202|    369|    ret = lh_OBJ_NAME_insert(names_lh, onp);
  203|    369|    if (ret != NULL) {
  204|       |        /* free things */
  205|     78|        if ((name_funcs_stack != NULL)
  206|     78|            && (sk_NAME_FUNCS_num(name_funcs_stack) > ret->type)) {
  207|       |            /*
  208|       |             * XXX: I'm not sure I understand why the free function should
  209|       |             * get three arguments... -- Richard Levitte
  210|       |             */
  211|      0|            sk_NAME_FUNCS_value(name_funcs_stack,
  212|      0|                                ret->type)->free_func(ret->name, ret->type,
  213|      0|                                                      ret->data);
  214|      0|        }
  215|     78|        OPENSSL_free(ret);
  216|    291|    } else {
  217|    291|        if (lh_OBJ_NAME_error(names_lh)) {
  218|       |            /* ERROR */
  219|      0|            OPENSSL_free(onp);
  220|      0|            return 0;
  221|      0|        }
  222|    291|    }
  223|    369|    return 1;
  224|    369|}
o_names.c:obj_name_hash:
  134|    388|{
  135|    388|    unsigned long ret;
  136|    388|    const OBJ_NAME *a = (const OBJ_NAME *)a_void;
  137|       |
  138|    388|    if ((name_funcs_stack != NULL)
  139|    388|        && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {
  140|      0|        ret =
  141|      0|            sk_NAME_FUNCS_value(name_funcs_stack,
  142|      0|                                a->type)->hash_func(a->name);
  143|    388|    } else {
  144|    388|        ret = lh_strhash(a->name);
  145|    388|    }
  146|    388|    ret ^= a->type;
  147|    388|    return (ret);
  148|    388|}
o_names.c:obj_name_cmp:
  115|     97|{
  116|     97|    int ret;
  117|     97|    const OBJ_NAME *a = (const OBJ_NAME *)a_void;
  118|     97|    const OBJ_NAME *b = (const OBJ_NAME *)b_void;
  119|       |
  120|     97|    ret = a->type - b->type;
  121|     97|    if (ret == 0) {
  122|     97|        if ((name_funcs_stack != NULL)
  123|     97|            && (sk_NAME_FUNCS_num(name_funcs_stack) > a->type)) {
  124|      0|            ret = sk_NAME_FUNCS_value(name_funcs_stack,
  125|      0|                                      a->type)->cmp_func(a->name, b->name);
  126|      0|        } else
  127|     97|            ret = strcmp(a->name, b->name);
  128|     97|    }
  129|     97|    return (ret);
  130|     97|}

check_defer:
  229|    160|{
  230|    160|    if (!obj_cleanup_defer && nid >= NUM_NID)
  231|      0|        obj_cleanup_defer = 1;
  232|    160|}
OBJ_nid2sn:
  341|    160|{
  342|    160|    ADDED_OBJ ad, *adp;
  343|    160|    ASN1_OBJECT ob;
  344|       |
  345|    160|    if ((n >= 0) && (n < NUM_NID)) {
  346|    160|        if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
  347|      0|            OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
  348|      0|            return (NULL);
  349|      0|        }
  350|    160|        return (nid_objs[n].sn);
  351|    160|    } else if (added == NULL)
  352|      0|        return (NULL);
  353|      0|    else {
  354|      0|        ad.type = ADDED_NID;
  355|      0|        ad.obj = &ob;
  356|      0|        ob.nid = n;
  357|      0|        adp = lh_ADDED_OBJ_retrieve(added, &ad);
  358|      0|        if (adp != NULL)
  359|      0|            return (adp->obj->sn);
  360|      0|        else {
  361|      0|            OBJerr(OBJ_F_OBJ_NID2SN, OBJ_R_UNKNOWN_NID);
  362|      0|            return (NULL);
  363|      0|        }
  364|      0|    }
  365|    160|}
OBJ_nid2ln:
  368|    160|{
  369|    160|    ADDED_OBJ ad, *adp;
  370|    160|    ASN1_OBJECT ob;
  371|       |
  372|    160|    if ((n >= 0) && (n < NUM_NID)) {
  373|    160|        if ((n != NID_undef) && (nid_objs[n].nid == NID_undef)) {
  374|      0|            OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
  375|      0|            return (NULL);
  376|      0|        }
  377|    160|        return (nid_objs[n].ln);
  378|    160|    } else if (added == NULL)
  379|      0|        return (NULL);
  380|      0|    else {
  381|      0|        ad.type = ADDED_NID;
  382|      0|        ad.obj = &ob;
  383|      0|        ob.nid = n;
  384|      0|        adp = lh_ADDED_OBJ_retrieve(added, &ad);
  385|      0|        if (adp != NULL)
  386|      0|            return (adp->obj->ln);
  387|      0|        else {
  388|      0|            OBJerr(OBJ_F_OBJ_NID2LN, OBJ_R_UNKNOWN_NID);
  389|      0|            return (NULL);
  390|      0|        }
  391|      0|    }
  392|    160|}

ERR_load_OBJ_strings:
   92|      1|{
   93|      1|#ifndef OPENSSL_NO_ERR
   94|       |
   95|      1|    if (ERR_func_error_string(OBJ_str_functs[0].error) == NULL) {
   96|      1|        ERR_load_strings(0, OBJ_str_functs);
   97|      1|        ERR_load_strings(0, OBJ_str_reasons);
   98|      1|    }
   99|      1|#endif
  100|      1|}

ERR_load_OCSP_strings:
  141|      1|{
  142|      1|#ifndef OPENSSL_NO_ERR
  143|       |
  144|      1|    if (ERR_func_error_string(OCSP_str_functs[0].error) == NULL) {
  145|      1|        ERR_load_strings(0, OCSP_str_functs);
  146|      1|        ERR_load_strings(0, OCSP_str_reasons);
  147|      1|    }
  148|      1|#endif
  149|      1|}

ERR_load_PEM_strings:
  161|      1|{
  162|      1|#ifndef OPENSSL_NO_ERR
  163|       |
  164|      1|    if (ERR_func_error_string(PEM_str_functs[0].error) == NULL) {
  165|      1|        ERR_load_strings(0, PEM_str_functs);
  166|      1|        ERR_load_strings(0, PEM_str_reasons);
  167|      1|    }
  168|      1|#endif
  169|      1|}

ERR_load_PKCS12_strings:
  141|      1|{
  142|      1|#ifndef OPENSSL_NO_ERR
  143|       |
  144|      1|    if (ERR_func_error_string(PKCS12_str_functs[0].error) == NULL) {
  145|      1|        ERR_load_strings(0, PKCS12_str_functs);
  146|      1|        ERR_load_strings(0, PKCS12_str_reasons);
  147|      1|    }
  148|      1|#endif
  149|      1|}

ERR_load_PKCS7_strings:
  199|      1|{
  200|      1|#ifndef OPENSSL_NO_ERR
  201|       |
  202|      1|    if (ERR_func_error_string(PKCS7_str_functs[0].error) == NULL) {
  203|      1|        ERR_load_strings(0, PKCS7_str_functs);
  204|      1|        ERR_load_strings(0, PKCS7_str_reasons);
  205|      1|    }
  206|      1|#endif
  207|      1|}

RAND_SSLeay:
  177|      1|{
  178|      1|    return (&rand_ssleay_meth);
  179|      1|}
ssleay_rand_bytes:
  344|    778|{
  345|    778|    static volatile int stirred_pool = 0;
  346|    778|    int i, j, k;
  347|    778|    size_t num_ceil, st_idx, st_num;
  348|    778|    int ok;
  349|    778|    long md_c[2];
  350|    778|    unsigned char local_md[MD_DIGEST_LENGTH];
  351|    778|    EVP_MD_CTX m;
  352|    778|#ifndef GETPID_IS_MEANINGLESS
  353|    778|    pid_t curr_pid = getpid();
  354|    778|#endif
  355|    778|    int do_stir_pool = 0;
  356|       |
  357|       |#ifdef PREDICT
  358|       |    if (rand_predictable) {
  359|       |        static unsigned char val = 0;
  360|       |
  361|       |        for (i = 0; i < num; i++)
  362|       |            buf[i] = val++;
  363|       |        return (1);
  364|       |    }
  365|       |#endif
  366|       |
  367|    778|    if (num <= 0)
  368|      0|        return 1;
  369|       |
  370|    778|    EVP_MD_CTX_init(&m);
  371|       |    /* round upwards to multiple of MD_DIGEST_LENGTH/2 */
  372|    778|    num_ceil =
  373|    778|        (1 + (num - 1) / (MD_DIGEST_LENGTH / 2)) * (MD_DIGEST_LENGTH / 2);
  374|       |
  375|       |    /*
  376|       |     * (Based on the rand(3) manpage:)
  377|       |     *
  378|       |     * For each group of 10 bytes (or less), we do the following:
  379|       |     *
  380|       |     * Input into the hash function the local 'md' (which is initialized from
  381|       |     * the global 'md' before any bytes are generated), the bytes that are to
  382|       |     * be overwritten by the random bytes, and bytes from the 'state'
  383|       |     * (incrementing looping index). From this digest output (which is kept
  384|       |     * in 'md'), the top (up to) 10 bytes are returned to the caller and the
  385|       |     * bottom 10 bytes are xored into the 'state'.
  386|       |     *
  387|       |     * Finally, after we have finished 'num' random bytes for the
  388|       |     * caller, 'count' (which is incremented) and the local and global 'md'
  389|       |     * are fed into the hash function and the results are kept in the
  390|       |     * global 'md'.
  391|       |     */
  392|    778|    if (lock)
  393|    778|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  394|       |
  395|       |    /* prevent ssleay_rand_bytes() from trying to obtain the lock again */
  396|    778|    CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
  397|    778|    CRYPTO_THREADID_current(&locking_threadid);
  398|    778|    CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
  399|    778|    crypto_lock_rand = 1;
  400|       |
  401|    778|    if (!initialized) {
  402|      0|        RAND_poll();
  403|      0|        initialized = 1;
  404|      0|    }
  405|       |
  406|    778|    if (!stirred_pool)
  407|      1|        do_stir_pool = 1;
  408|       |
  409|    778|    ok = (entropy >= ENTROPY_NEEDED);
  410|    778|    if (!ok) {
  411|       |        /*
  412|       |         * If the PRNG state is not yet unpredictable, then seeing the PRNG
  413|       |         * output may help attackers to determine the new state; thus we have
  414|       |         * to decrease the entropy estimate. Once we've had enough initial
  415|       |         * seeding we don't bother to adjust the entropy count, though,
  416|       |         * because we're not ambitious to provide *information-theoretic*
  417|       |         * randomness. NOTE: This approach fails if the program forks before
  418|       |         * we have enough entropy. Entropy should be collected in a separate
  419|       |         * input pool and be transferred to the output pool only when the
  420|       |         * entropy limit has been reached.
  421|       |         */
  422|      0|        entropy -= num;
  423|      0|        if (entropy < 0)
  424|      0|            entropy = 0;
  425|      0|    }
  426|       |
  427|    778|    if (do_stir_pool) {
  428|       |        /*
  429|       |         * In the output function only half of 'md' remains secret, so we
  430|       |         * better make sure that the required entropy gets 'evenly
  431|       |         * distributed' through 'state', our randomness pool. The input
  432|       |         * function (ssleay_rand_add) chains all of 'md', which makes it more
  433|       |         * suitable for this purpose.
  434|       |         */
  435|       |
  436|      1|        int n = STATE_SIZE;     /* so that the complete pool gets accessed */
  437|     53|        while (n > 0) {
  438|       |#if MD_DIGEST_LENGTH > 20
  439|       |# error "Please adjust DUMMY_SEED."
  440|       |#endif
  441|     52|#define DUMMY_SEED "...................." /* at least MD_DIGEST_LENGTH */
  442|       |            /*
  443|       |             * Note that the seed does not matter, it's just that
  444|       |             * ssleay_rand_add expects to have something to hash.
  445|       |             */
  446|     52|            ssleay_rand_add(DUMMY_SEED, MD_DIGEST_LENGTH, 0.0);
  447|     52|            n -= MD_DIGEST_LENGTH;
  448|     52|        }
  449|      1|        if (ok)
  450|      1|            stirred_pool = 1;
  451|      1|    }
  452|       |
  453|    778|    st_idx = state_index;
  454|    778|    st_num = state_num;
  455|    778|    md_c[0] = md_count[0];
  456|    778|    md_c[1] = md_count[1];
  457|    778|    memcpy(local_md, md, sizeof md);
  458|       |
  459|    778|    state_index += num_ceil;
  460|    778|    if (state_index > state_num)
  461|      7|        state_index %= state_num;
  462|       |
  463|       |    /*
  464|       |     * state[st_idx], ..., state[(st_idx + num_ceil - 1) % st_num] are now
  465|       |     * ours (but other threads may use them too)
  466|       |     */
  467|       |
  468|    778|    md_count[0] += 1;
  469|       |
  470|       |    /* before unlocking, we must clear 'crypto_lock_rand' */
  471|    778|    crypto_lock_rand = 0;
  472|    778|    if (lock)
  473|    778|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  474|       |
  475|  1.55k|    while (num > 0) {
  476|       |        /* num_ceil -= MD_DIGEST_LENGTH/2 */
  477|    778|        j = (num >= MD_DIGEST_LENGTH / 2) ? MD_DIGEST_LENGTH / 2 : num;
  478|    778|        num -= j;
  479|    778|        if (!MD_Init(&m))
  480|      0|           goto err;
  481|    778|#ifndef GETPID_IS_MEANINGLESS
  482|    778|        if (curr_pid) {         /* just in the first iteration to save time */
  483|    778|            if (!MD_Update(&m, (unsigned char *)&curr_pid, sizeof curr_pid))
  484|      0|                goto err;
  485|    778|            curr_pid = 0;
  486|    778|        }
  487|    778|#endif
  488|    778|        if (!MD_Update(&m, local_md, MD_DIGEST_LENGTH) ||
  489|    778|            !MD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c)))
  490|      0|            goto err;
  491|       |
  492|    778|#ifndef PURIFY                  /* purify complains */
  493|       |        /*
  494|       |         * The following line uses the supplied buffer as a small source of
  495|       |         * entropy: since this buffer is often uninitialised it may cause
  496|       |         * programs such as purify or valgrind to complain. So for those
  497|       |         * builds it is not used: the removal of such a small source of
  498|       |         * entropy has negligible impact on security.
  499|       |         */
  500|    778|        if (!MD_Update(&m, buf, j))
  501|      0|            goto err;
  502|    778|#endif
  503|       |
  504|    778|        k = (st_idx + MD_DIGEST_LENGTH / 2) - st_num;
  505|    778|        if (k > 0) {
  506|      7|            if (!MD_Update(&m, &(state[st_idx]), MD_DIGEST_LENGTH / 2 - k) ||
  507|      7|                !MD_Update(&m, &(state[0]), k))
  508|      0|                goto err;
  509|    771|        } else {
  510|    771|            if (!MD_Update(&m, &(state[st_idx]), MD_DIGEST_LENGTH / 2))
  511|      0|                goto err;
  512|    771|        }
  513|    778|        if (!MD_Final(&m, local_md))
  514|      0|            goto err;
  515|       |
  516|  8.55k|        for (i = 0; i < MD_DIGEST_LENGTH / 2; i++) {
  517|       |            /* may compete with other threads */
  518|  7.78k|            state[st_idx++] ^= local_md[i];
  519|  7.78k|            if (st_idx >= st_num)
  520|      8|                st_idx = 0;
  521|  7.78k|            if (i < j)
  522|  3.11k|                *(buf++) = local_md[i + MD_DIGEST_LENGTH / 2];
  523|  7.78k|        }
  524|    778|    }
  525|       |
  526|    778|    if (!MD_Init(&m) ||
  527|    778|        !MD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c)) ||
  528|    778|        !MD_Update(&m, local_md, MD_DIGEST_LENGTH))
  529|      0|        goto err;
  530|    778|    if (lock)
  531|    778|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  532|    778|    if (!MD_Update(&m, md, MD_DIGEST_LENGTH) ||
  533|    778|        !MD_Final(&m, md)) {
  534|      0|        if (lock)
  535|      0|            CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  536|      0|        goto err;
  537|      0|    }
  538|    778|    if (lock)
  539|    778|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  540|       |
  541|    778|    EVP_MD_CTX_cleanup(&m);
  542|    778|    if (ok)
  543|    778|        return (1);
  544|      0|    else if (pseudo)
  545|      0|        return 0;
  546|      0|    else {
  547|      0|        RANDerr(RAND_F_SSLEAY_RAND_BYTES, RAND_R_PRNG_NOT_SEEDED);
  548|      0|        ERR_add_error_data(1, "You need to read the OpenSSL FAQ, "
  549|      0|                           "http://www.openssl.org/support/faq.html");
  550|      0|        return (0);
  551|      0|    }
  552|       |
  553|      0| err:
  554|      0|    EVP_MD_CTX_cleanup(&m);
  555|      0|    return (0);
  556|    778|}
md_rand.c:ssleay_rand_add:
  194|     56|{
  195|     56|    int i, j, k, st_idx;
  196|     56|    long md_c[2];
  197|     56|    unsigned char local_md[MD_DIGEST_LENGTH];
  198|     56|    EVP_MD_CTX m;
  199|     56|    int do_not_lock;
  200|       |
  201|     56|    if (!num)
  202|      0|        return;
  203|       |
  204|       |    /*
  205|       |     * (Based on the rand(3) manpage)
  206|       |     *
  207|       |     * The input is chopped up into units of 20 bytes (or less for
  208|       |     * the last block).  Each of these blocks is run through the hash
  209|       |     * function as follows:  The data passed to the hash function
  210|       |     * is the current 'md', the same number of bytes from the 'state'
  211|       |     * (the location determined by in incremented looping index) as
  212|       |     * the current 'block', the new key data 'block', and 'count'
  213|       |     * (which is incremented after each use).
  214|       |     * The result of this is kept in 'md' and also xored into the
  215|       |     * 'state' at the same locations that were used as input into the
  216|       |     * hash function.
  217|       |     */
  218|       |
  219|       |    /* check if we already have the lock */
  220|     56|    if (crypto_lock_rand) {
  221|     56|        CRYPTO_THREADID cur;
  222|     56|        CRYPTO_THREADID_current(&cur);
  223|     56|        CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
  224|     56|        do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
  225|     56|        CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
  226|     56|    } else
  227|      0|        do_not_lock = 0;
  228|       |
  229|     56|    if (!do_not_lock)
  230|      0|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  231|     56|    st_idx = state_index;
  232|       |
  233|       |    /*
  234|       |     * use our own copies of the counters so that even if a concurrent thread
  235|       |     * seeds with exactly the same data and uses the same subarray there's
  236|       |     * _some_ difference
  237|       |     */
  238|     56|    md_c[0] = md_count[0];
  239|     56|    md_c[1] = md_count[1];
  240|       |
  241|     56|    memcpy(local_md, md, sizeof md);
  242|       |
  243|       |    /* state_index <= state_num <= STATE_SIZE */
  244|     56|    state_index += num;
  245|     56|    if (state_index >= STATE_SIZE) {
  246|      1|        state_index %= STATE_SIZE;
  247|      1|        state_num = STATE_SIZE;
  248|     55|    } else if (state_num < STATE_SIZE) {
  249|     52|        if (state_index > state_num)
  250|     52|            state_num = state_index;
  251|     52|    }
  252|       |    /* state_index <= state_num <= STATE_SIZE */
  253|       |
  254|       |    /*
  255|       |     * state[st_idx], ..., state[(st_idx + num - 1) % STATE_SIZE] are what we
  256|       |     * will use now, but other threads may use them as well
  257|       |     */
  258|       |
  259|     56|    md_count[1] += (num / MD_DIGEST_LENGTH) + (num % MD_DIGEST_LENGTH > 0);
  260|       |
  261|     56|    if (!do_not_lock)
  262|      0|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  263|       |
  264|     56|    EVP_MD_CTX_init(&m);
  265|    113|    for (i = 0; i < num; i += MD_DIGEST_LENGTH) {
  266|     57|        j = (num - i);
  267|     57|        j = (j > MD_DIGEST_LENGTH) ? MD_DIGEST_LENGTH : j;
  268|       |
  269|     57|        if (!MD_Init(&m) ||
  270|     57|            !MD_Update(&m, local_md, MD_DIGEST_LENGTH))
  271|      0|            goto err;
  272|     57|        k = (st_idx + j) - STATE_SIZE;
  273|     57|        if (k > 0) {
  274|      1|            if (!MD_Update(&m, &(state[st_idx]), j - k) ||
  275|      1|                !MD_Update(&m, &(state[0]), k))
  276|      0|                goto err;
  277|      1|        } else
  278|     56|            if (!MD_Update(&m, &(state[st_idx]), j))
  279|      0|                goto err;
  280|       |
  281|       |        /* DO NOT REMOVE THE FOLLOWING CALL TO MD_Update()! */
  282|     57|        if (!MD_Update(&m, buf, j))
  283|      0|            goto err;
  284|       |        /*
  285|       |         * We know that line may cause programs such as purify and valgrind
  286|       |         * to complain about use of uninitialized data.  The problem is not,
  287|       |         * it's with the caller.  Removing that line will make sure you get
  288|       |         * really bad randomness and thereby other problems such as very
  289|       |         * insecure keys.
  290|       |         */
  291|       |
  292|     57|        if (!MD_Update(&m, (unsigned char *)&(md_c[0]), sizeof(md_c)) ||
  293|     57|            !MD_Final(&m, local_md))
  294|      0|            goto err;
  295|     57|        md_c[1]++;
  296|       |
  297|     57|        buf = (const char *)buf + j;
  298|       |
  299|  1.15k|        for (k = 0; k < j; k++) {
  300|       |            /*
  301|       |             * Parallel threads may interfere with this, but always each byte
  302|       |             * of the new state is the XOR of some previous value of its and
  303|       |             * local_md (itermediate values may be lost). Alway using locking
  304|       |             * could hurt performance more than necessary given that
  305|       |             * conflicts occur only when the total seeding is longer than the
  306|       |             * random state.
  307|       |             */
  308|  1.09k|            state[st_idx++] ^= local_md[k];
  309|  1.09k|            if (st_idx >= STATE_SIZE)
  310|      1|                st_idx = 0;
  311|  1.09k|        }
  312|     57|    }
  313|       |
  314|     56|    if (!do_not_lock)
  315|      0|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  316|       |    /*
  317|       |     * Don't just copy back local_md into md -- this could mean that other
  318|       |     * thread's seeding remains without effect (except for the incremented
  319|       |     * counter).  By XORing it we keep at least as much entropy as fits into
  320|       |     * md.
  321|       |     */
  322|  1.17k|    for (k = 0; k < (int)sizeof(md); k++) {
  323|  1.12k|        md[k] ^= local_md[k];
  324|  1.12k|    }
  325|     56|    if (entropy < ENTROPY_NEEDED) /* stop counting when we have enough */
  326|      1|        entropy += add;
  327|     56|    if (!do_not_lock)
  328|      0|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  329|       |
  330|       |#if !defined(OPENSSL_THREADS) && !defined(OPENSSL_SYS_WIN32)
  331|       |    assert(md_c[1] == md_count[1]);
  332|       |#endif
  333|       |
  334|     56| err:
  335|     56|    EVP_MD_CTX_cleanup(&m);
  336|     56|}
md_rand.c:ssleay_rand_nopseudo_bytes:
  559|    778|{
  560|    778|    return ssleay_rand_bytes(buf, num, 0, 1);
  561|    778|}
md_rand.c:ssleay_rand_status:
  572|    778|{
  573|    778|    CRYPTO_THREADID cur;
  574|    778|    int ret;
  575|    778|    int do_not_lock;
  576|       |
  577|    778|    CRYPTO_THREADID_current(&cur);
  578|       |    /*
  579|       |     * check if we already have the lock (could happen if a RAND_poll()
  580|       |     * implementation calls RAND_status())
  581|       |     */
  582|    778|    if (crypto_lock_rand) {
  583|      0|        CRYPTO_r_lock(CRYPTO_LOCK_RAND2);
  584|      0|        do_not_lock = !CRYPTO_THREADID_cmp(&locking_threadid, &cur);
  585|      0|        CRYPTO_r_unlock(CRYPTO_LOCK_RAND2);
  586|      0|    } else
  587|    778|        do_not_lock = 0;
  588|       |
  589|    778|    if (!do_not_lock) {
  590|    778|        CRYPTO_w_lock(CRYPTO_LOCK_RAND);
  591|       |
  592|       |        /*
  593|       |         * prevent ssleay_rand_bytes() from trying to obtain the lock again
  594|       |         */
  595|    778|        CRYPTO_w_lock(CRYPTO_LOCK_RAND2);
  596|    778|        CRYPTO_THREADID_cpy(&locking_threadid, &cur);
  597|    778|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND2);
  598|    778|        crypto_lock_rand = 1;
  599|    778|    }
  600|       |
  601|    778|    if (!initialized) {
  602|      1|        RAND_poll();
  603|      1|        initialized = 1;
  604|      1|    }
  605|       |
  606|    778|    ret = entropy >= ENTROPY_NEEDED;
  607|       |
  608|    778|    if (!do_not_lock) {
  609|       |        /* before unlocking, we must clear 'crypto_lock_rand' */
  610|    778|        crypto_lock_rand = 0;
  611|       |
  612|    778|        CRYPTO_w_unlock(CRYPTO_LOCK_RAND);
  613|    778|    }
  614|       |
  615|    778|    return ret;
  616|    778|}

ERR_load_RAND_strings:
   92|      1|{
   93|      1|#ifndef OPENSSL_NO_ERR
   94|       |
   95|      1|    if (ERR_func_error_string(RAND_str_functs[0].error) == NULL) {
   96|      1|        ERR_load_strings(0, RAND_str_functs);
   97|      1|        ERR_load_strings(0, RAND_str_reasons);
   98|      1|    }
   99|      1|#endif
  100|      1|}

RAND_get_rand_method:
   93|  1.56k|{
   94|  1.56k|    if (!default_RAND_meth) {
   95|      1|#ifndef OPENSSL_NO_ENGINE
   96|      1|        ENGINE *e = ENGINE_get_default_RAND();
   97|      1|        if (e) {
   98|      0|            default_RAND_meth = ENGINE_get_RAND(e);
   99|      0|            if (!default_RAND_meth) {
  100|      0|                ENGINE_finish(e);
  101|      0|                e = NULL;
  102|      0|            }
  103|      0|        }
  104|      1|        if (e)
  105|      0|            funct_ref = e;
  106|      1|        else
  107|      1|#endif
  108|      1|            default_RAND_meth = RAND_SSLeay();
  109|      1|    }
  110|  1.56k|    return default_RAND_meth;
  111|  1.56k|}
RAND_add:
  149|      4|{
  150|      4|    const RAND_METHOD *meth = RAND_get_rand_method();
  151|      4|    if (meth && meth->add)
  152|      4|        meth->add(buf, num, entropy);
  153|      4|}
RAND_bytes:
  156|    778|{
  157|    778|    const RAND_METHOD *meth = RAND_get_rand_method();
  158|    778|    if (meth && meth->bytes)
  159|    778|        return meth->bytes(buf, num);
  160|      0|    return (-1);
  161|    778|}
RAND_status:
  172|    778|{
  173|    778|    const RAND_METHOD *meth = RAND_get_rand_method();
  174|    778|    if (meth && meth->status)
  175|    778|        return meth->status();
  176|      0|    return 0;
  177|    778|}

RAND_poll:
  244|      1|{
  245|      1|    unsigned long l;
  246|      1|    pid_t curr_pid = getpid();
  247|      1|#  if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
  248|      1|    unsigned char tmpbuf[ENTROPY_NEEDED];
  249|      1|    int n = 0;
  250|      1|#  endif
  251|      1|#  ifdef DEVRANDOM
  252|      1|    static const char *randomfiles[] = { DEVRANDOM };
  253|      1|    struct stat randomstats[sizeof(randomfiles) / sizeof(randomfiles[0])];
  254|      1|    int fd;
  255|      1|    unsigned int i;
  256|      1|#  endif
  257|      1|#  ifdef DEVRANDOM_EGD
  258|      1|    static const char *egdsockets[] = { DEVRANDOM_EGD, NULL };
  259|      1|    const char **egdsocket = NULL;
  260|      1|#  endif
  261|       |
  262|      1|#  ifdef DEVRANDOM
  263|      1|    memset(randomstats, 0, sizeof(randomstats));
  264|       |    /*
  265|       |     * Use a random entropy pool device. Linux, FreeBSD and OpenBSD have
  266|       |     * this. Use /dev/urandom if you can as /dev/random may block if it runs
  267|       |     * out of random entries.
  268|       |     */
  269|       |
  270|      2|    for (i = 0; (i < sizeof(randomfiles) / sizeof(randomfiles[0])) &&
  271|      2|         (n < ENTROPY_NEEDED); i++) {
  272|      1|        if ((fd = open(randomfiles[i], O_RDONLY
  273|      1|#   ifdef O_NONBLOCK
  274|      1|                       | O_NONBLOCK
  275|      1|#   endif
  276|       |#   ifdef O_BINARY
  277|       |                       | O_BINARY
  278|       |#   endif
  279|      1|#   ifdef O_NOCTTY              /* If it happens to be a TTY (god forbid), do
  280|       |                                 * not make it our controlling tty */
  281|      1|                       | O_NOCTTY
  282|      1|#   endif
  283|      1|             )) >= 0) {
  284|      1|            int usec = 10 * 1000; /* spend 10ms on each file */
  285|      1|            int r;
  286|      1|            unsigned int j;
  287|      1|            struct stat *st = &randomstats[i];
  288|       |
  289|       |            /*
  290|       |             * Avoid using same input... Used to be O_NOFOLLOW above, but
  291|       |             * it's not universally appropriate...
  292|       |             */
  293|      1|            if (fstat(fd, st) != 0) {
  294|      0|                close(fd);
  295|      0|                continue;
  296|      0|            }
  297|      1|            for (j = 0; j < i; j++) {
  298|      0|                if (randomstats[j].st_ino == st->st_ino &&
  299|      0|                    randomstats[j].st_dev == st->st_dev)
  300|      0|                    break;
  301|      0|            }
  302|      1|            if (j < i) {
  303|      0|                close(fd);
  304|      0|                continue;
  305|      0|            }
  306|       |
  307|      1|            do {
  308|      1|                int try_read = 0;
  309|       |
  310|       |#   if defined(OPENSSL_SYS_BEOS_R5)
  311|       |                /*
  312|       |                 * select() is broken in BeOS R5, so we simply try to read
  313|       |                 * something and snooze if we couldn't
  314|       |                 */
  315|       |                try_read = 1;
  316|       |
  317|       |#   elif defined(OPENSSL_SYS_LINUX)
  318|       |                /* use poll() */
  319|      1|                struct pollfd pset;
  320|       |
  321|      1|                pset.fd = fd;
  322|      1|                pset.events = POLLIN;
  323|      1|                pset.revents = 0;
  324|       |
  325|      1|                if (poll(&pset, 1, usec / 1000) < 0)
  326|      0|                    usec = 0;
  327|      1|                else
  328|      1|                    try_read = (pset.revents & POLLIN) != 0;
  329|       |
  330|       |#   else
  331|       |                /* use select() */
  332|       |                fd_set fset;
  333|       |                struct timeval t;
  334|       |
  335|       |                t.tv_sec = 0;
  336|       |                t.tv_usec = usec;
  337|       |
  338|       |                if (FD_SETSIZE > 0 && (unsigned)fd >= FD_SETSIZE) {
  339|       |                    /*
  340|       |                     * can't use select, so just try to read once anyway
  341|       |                     */
  342|       |                    try_read = 1;
  343|       |                } else {
  344|       |                    FD_ZERO(&fset);
  345|       |                    FD_SET(fd, &fset);
  346|       |
  347|       |                    if (select(fd + 1, &fset, NULL, NULL, &t) >= 0) {
  348|       |                        usec = t.tv_usec;
  349|       |                        if (FD_ISSET(fd, &fset))
  350|       |                            try_read = 1;
  351|       |                    } else
  352|       |                        usec = 0;
  353|       |                }
  354|       |#   endif
  355|       |
  356|      1|                if (try_read) {
  357|      1|                    r = read(fd, (unsigned char *)tmpbuf + n,
  358|      1|                             ENTROPY_NEEDED - n);
  359|      1|                    if (r > 0)
  360|      1|                        n += r;
  361|       |#   if defined(OPENSSL_SYS_BEOS_R5)
  362|       |                    if (r == 0)
  363|       |                        snooze(t.tv_usec);
  364|       |#   endif
  365|      1|                } else
  366|      0|                    r = -1;
  367|       |
  368|       |                /*
  369|       |                 * Some Unixen will update t in select(), some won't.  For
  370|       |                 * those who won't, or if we didn't use select() in the first
  371|       |                 * place, give up here, otherwise, we will do this once again
  372|       |                 * for the remaining time.
  373|       |                 */
  374|      1|                if (usec == 10 * 1000)
  375|      1|                    usec = 0;
  376|      1|            }
  377|      1|            while ((r > 0 ||
  378|      1|                    (errno == EINTR || errno == EAGAIN)) && usec != 0
  379|      1|                   && n < ENTROPY_NEEDED);
  380|       |
  381|      1|            close(fd);
  382|      1|        }
  383|      1|    }
  384|      1|#  endif                        /* defined(DEVRANDOM) */
  385|       |
  386|      1|#  ifdef DEVRANDOM_EGD
  387|       |    /*
  388|       |     * Use an EGD socket to read entropy from an EGD or PRNGD entropy
  389|       |     * collecting daemon.
  390|       |     */
  391|       |
  392|      1|    for (egdsocket = egdsockets; *egdsocket && n < ENTROPY_NEEDED;
  393|      1|         egdsocket++) {
  394|      0|        int r;
  395|       |
  396|      0|        r = RAND_query_egd_bytes(*egdsocket, (unsigned char *)tmpbuf + n,
  397|      0|                                 ENTROPY_NEEDED - n);
  398|      0|        if (r > 0)
  399|      0|            n += r;
  400|      0|    }
  401|      1|#  endif                        /* defined(DEVRANDOM_EGD) */
  402|       |
  403|      1|#  if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
  404|      1|    if (n > 0) {
  405|      1|        RAND_add(tmpbuf, sizeof tmpbuf, (double)n);
  406|      1|        OPENSSL_cleanse(tmpbuf, n);
  407|      1|    }
  408|      1|#  endif
  409|       |
  410|       |    /* put in some default random data, we need more than just this */
  411|      1|    l = curr_pid;
  412|      1|    RAND_add(&l, sizeof(l), 0.0);
  413|      1|    l = getuid();
  414|      1|    RAND_add(&l, sizeof(l), 0.0);
  415|       |
  416|      1|    l = time(NULL);
  417|      1|    RAND_add(&l, sizeof(l), 0.0);
  418|       |
  419|       |#  if defined(OPENSSL_SYS_BEOS)
  420|       |    {
  421|       |        system_info sysInfo;
  422|       |        get_system_info(&sysInfo);
  423|       |        RAND_add(&sysInfo, sizeof(sysInfo), 0);
  424|       |    }
  425|       |#  endif
  426|       |
  427|      1|#  if defined(DEVRANDOM) || defined(DEVRANDOM_EGD)
  428|      1|    return 1;
  429|       |#  else
  430|       |    return 0;
  431|       |#  endif
  432|      1|}

RSA_PKCS1_SSLeay:
  151|      7|{
  152|      7|    return (&rsa_pkcs1_eay_meth);
  153|      7|}

ERR_load_RSA_strings:
  239|      1|{
  240|      1|#ifndef OPENSSL_NO_ERR
  241|       |
  242|      1|    if (ERR_func_error_string(RSA_str_functs[0].error) == NULL) {
  243|      1|        ERR_load_strings(0, RSA_str_functs);
  244|      1|        ERR_load_strings(0, RSA_str_reasons);
  245|      1|    }
  246|      1|#endif
  247|      1|}

SHA1_Update:
  303|  6.46k|{
  304|  6.46k|    const unsigned char *data = data_;
  305|  6.46k|    unsigned char *p;
  306|  6.46k|    HASH_LONG l;
  307|  6.46k|    size_t n;
  308|       |
  309|  6.46k|    if (len == 0)
  310|      1|        return 1;
  311|       |
  312|  6.45k|    l = (c->Nl + (((HASH_LONG) len) << 3)) & 0xffffffffUL;
  313|       |    /*
  314|       |     * 95-05-24 eay Fixed a bug with the overflow handling, thanks to Wei Dai
  315|       |     * <weidai@eskimo.com> for pointing it out.
  316|       |     */
  317|  6.45k|    if (l < c->Nl)              /* overflow */
  318|      0|        c->Nh++;
  319|  6.45k|    c->Nh += (HASH_LONG) (len >> 29); /* might cause compiler warning on
  320|       |                                       * 16-bit */
  321|  6.45k|    c->Nl = l;
  322|       |
  323|  6.45k|    n = c->num;
  324|  6.45k|    if (n != 0) {
  325|  4.84k|        p = (unsigned char *)c->data;
  326|       |
  327|  4.84k|        if (len >= HASH_CBLOCK || len + n >= HASH_CBLOCK) {
  328|     53|            memcpy(p + n, data, HASH_CBLOCK - n);
  329|     53|            HASH_BLOCK_DATA_ORDER(c, p, 1);
  330|     53|            n = HASH_CBLOCK - n;
  331|     53|            data += n;
  332|     53|            len -= n;
  333|     53|            c->num = 0;
  334|       |            /*
  335|       |             * We use memset rather than OPENSSL_cleanse() here deliberately.
  336|       |             * Using OPENSSL_cleanse() here could be a performance issue. It
  337|       |             * will get properly cleansed on finalisation so this isn't a
  338|       |             * security problem.
  339|       |             */
  340|     53|            memset(p, 0, HASH_CBLOCK); /* keep it zeroed */
  341|  4.79k|        } else {
  342|  4.79k|            memcpy(p + n, data, len);
  343|  4.79k|            c->num += (unsigned int)len;
  344|  4.79k|            return 1;
  345|  4.79k|        }
  346|  4.84k|    }
  347|       |
  348|  1.66k|    n = len / HASH_CBLOCK;
  349|  1.66k|    if (n > 0) {
  350|      0|        HASH_BLOCK_DATA_ORDER(c, data, n);
  351|      0|        n *= HASH_CBLOCK;
  352|      0|        data += n;
  353|      0|        len -= n;
  354|      0|    }
  355|       |
  356|  1.66k|    if (len != 0) {
  357|  1.66k|        p = (unsigned char *)c->data;
  358|  1.66k|        c->num = (unsigned int)len;
  359|  1.66k|        memcpy(p, data, len);
  360|  1.66k|    }
  361|  1.66k|    return 1;
  362|  6.45k|}
SHA1_Final:
  370|  1.61k|{
  371|  1.61k|    unsigned char *p = (unsigned char *)c->data;
  372|  1.61k|    size_t n = c->num;
  373|       |
  374|  1.61k|    p[n] = 0x80;                /* there is always room for one */
  375|  1.61k|    n++;
  376|       |
  377|  1.61k|    if (n > (HASH_CBLOCK - 8)) {
  378|    779|        memset(p + n, 0, HASH_CBLOCK - n);
  379|    779|        n = 0;
  380|    779|        HASH_BLOCK_DATA_ORDER(c, p, 1);
  381|    779|    }
  382|  1.61k|    memset(p + n, 0, HASH_CBLOCK - 8 - n);
  383|       |
  384|  1.61k|    p += HASH_CBLOCK - 8;
  385|  1.61k|#if   defined(DATA_ORDER_IS_BIG_ENDIAN)
  386|  1.61k|    (void)HOST_l2c(c->Nh, p);
  387|  1.61k|    (void)HOST_l2c(c->Nl, p);
  388|       |#elif defined(DATA_ORDER_IS_LITTLE_ENDIAN)
  389|       |    (void)HOST_l2c(c->Nl, p);
  390|       |    (void)HOST_l2c(c->Nh, p);
  391|       |#endif
  392|  1.61k|    p -= HASH_CBLOCK;
  393|  1.61k|    HASH_BLOCK_DATA_ORDER(c, p, 1);
  394|  1.61k|    c->num = 0;
  395|  1.61k|    OPENSSL_cleanse(p, HASH_CBLOCK);
  396|       |
  397|       |#ifndef HASH_MAKE_STRING
  398|       |# error "HASH_MAKE_STRING must be defined!"
  399|       |#else
  400|  1.61k|    HASH_MAKE_STRING(c, md);
  401|  1.61k|#endif
  402|       |
  403|  1.61k|    return 1;
  404|  1.61k|}

SHA1_Init:
  130|  1.61k|{
  131|  1.61k|    memset(c, 0, sizeof(*c));
  132|  1.61k|    c->h0 = INIT_DATA_h0;
  133|  1.61k|    c->h1 = INIT_DATA_h1;
  134|  1.61k|    c->h2 = INIT_DATA_h2;
  135|  1.61k|    c->h3 = INIT_DATA_h3;
  136|  1.61k|    c->h4 = INIT_DATA_h4;
  137|  1.61k|    return 1;
  138|  1.61k|}

sk_new_null:
  153|     19|{
  154|     19|    return sk_new((int (*)(const void *, const void *))0);
  155|     19|}
sk_new:
  158|     20|{
  159|     20|    _STACK *ret;
  160|     20|    int i;
  161|       |
  162|     20|    if ((ret = OPENSSL_malloc(sizeof(_STACK))) == NULL)
  163|      0|        goto err;
  164|     20|    if ((ret->data = OPENSSL_malloc(sizeof(char *) * MIN_NODES)) == NULL)
  165|      0|        goto err;
  166|    100|    for (i = 0; i < MIN_NODES; i++)
  167|     80|        ret->data[i] = NULL;
  168|     20|    ret->comp = c;
  169|     20|    ret->num_alloc = MIN_NODES;
  170|     20|    ret->num = 0;
  171|     20|    ret->sorted = 0;
  172|     20|    return (ret);
  173|      0| err:
  174|      0|    if (ret)
  175|      0|        OPENSSL_free(ret);
  176|      0|    return (NULL);
  177|     20|}
sk_insert:
  180|     54|{
  181|     54|    char **s;
  182|       |
  183|     54|    if (st == NULL)
  184|      0|        return 0;
  185|     54|    if (st->num_alloc <= st->num + 1) {
  186|      8|        s = OPENSSL_realloc((char *)st->data,
  187|      8|                            (unsigned int)sizeof(char *) * st->num_alloc * 2);
  188|      8|        if (s == NULL)
  189|      0|            return (0);
  190|      8|        st->data = s;
  191|      8|        st->num_alloc *= 2;
  192|      8|    }
  193|     54|    if ((loc >= (int)st->num) || (loc < 0))
  194|     47|        st->data[st->num] = data;
  195|      7|    else {
  196|      7|        int i;
  197|      7|        char **f, **t;
  198|       |
  199|      7|        f = st->data;
  200|      7|        t = &(st->data[1]);
  201|     42|        for (i = st->num; i >= loc; i--)
  202|     35|            t[i] = f[i];
  203|       |
  204|       |#ifdef undef                    /* no memmove on sunos :-( */
  205|       |        memmove(&(st->data[loc + 1]),
  206|       |                &(st->data[loc]), sizeof(char *) * (st->num - loc));
  207|       |#endif
  208|      7|        st->data[loc] = data;
  209|      7|    }
  210|     54|    st->num++;
  211|     54|    st->sorted = 0;
  212|     54|    return (st->num);
  213|     54|}
sk_delete_ptr:
  216|     39|{
  217|     39|    int i;
  218|       |
  219|    109|    for (i = 0; i < st->num; i++)
  220|     77|        if (st->data[i] == p)
  221|      7|            return (sk_delete(st, i));
  222|     32|    return (NULL);
  223|     39|}
sk_delete:
  226|      7|{
  227|      7|    char *ret;
  228|      7|    int i, j;
  229|       |
  230|      7|    if (!st || (loc < 0) || (loc >= st->num))
  231|      0|        return NULL;
  232|       |
  233|      7|    ret = st->data[loc];
  234|      7|    if (loc != st->num - 1) {
  235|      0|        j = st->num - 1;
  236|      0|        for (i = loc; i < j; i++)
  237|      0|            st->data[i] = st->data[i + 1];
  238|       |        /*
  239|       |         * In theory memcpy is not safe for this memcpy( &(st->data[loc]),
  240|       |         * &(st->data[loc+1]), sizeof(char *)*(st->num-loc-1));
  241|       |         */
  242|      0|    }
  243|      7|    st->num--;
  244|      7|    return (ret);
  245|      7|}
sk_push:
  282|     47|{
  283|     47|    return (sk_insert(st, data, st->num));
  284|     47|}
sk_free:
  332|      4|{
  333|      4|    if (st == NULL)
  334|      0|        return;
  335|      4|    if (st->data != NULL)
  336|      4|        OPENSSL_free(st->data);
  337|      4|    OPENSSL_free(st);
  338|      4|}
sk_num:
  341|     23|{
  342|     23|    if (st == NULL)
  343|      0|        return -1;
  344|     23|    return st->num;
  345|     23|}
sk_value:
  348|      5|{
  349|      5|    if (!st || (i < 0) || (i >= st->num))
  350|      1|        return NULL;
  351|      4|    return st->data[i];
  352|      5|}
sk_set:
  355|      4|{
  356|      4|    if (!st || (i < 0) || (i >= st->num))
  357|      0|        return NULL;
  358|      4|    return (st->data[i] = value);
  359|      4|}
sk_sort:
  362|      1|{
  363|      1|    if (st && !st->sorted && st->comp != NULL) {
  364|      1|        int (*comp_func) (const void *, const void *);
  365|       |
  366|       |        /*
  367|       |         * same comment as in sk_find ... previously st->comp was declared as
  368|       |         * a (void*,void*) callback type, but this made the population of the
  369|       |         * callback pointer illogical - our callbacks compare type** with
  370|       |         * type**, so we leave the casting until absolutely necessary (ie.
  371|       |         * "now").
  372|       |         */
  373|      1|        comp_func = (int (*)(const void *, const void *))(st->comp);
  374|      1|        qsort(st->data, st->num, sizeof(char *), comp_func);
  375|      1|        st->sorted = 1;
  376|      1|    }
  377|      1|}

ERR_load_TS_strings:
  180|      1|{
  181|      1|#ifndef OPENSSL_NO_ERR
  182|       |
  183|      1|    if (ERR_func_error_string(TS_str_functs[0].error) == NULL) {
  184|      1|        ERR_load_strings(0, TS_str_functs);
  185|      1|        ERR_load_strings(0, TS_str_reasons);
  186|      1|    }
  187|      1|#endif
  188|      1|}

ERR_load_UI_strings:
  103|      1|{
  104|      1|#ifndef OPENSSL_NO_ERR
  105|       |
  106|      1|    if (ERR_func_error_string(UI_str_functs[0].error) == NULL) {
  107|      1|        ERR_load_strings(0, UI_str_functs);
  108|      1|        ERR_load_strings(0, UI_str_reasons);
  109|      1|    }
  110|      1|#endif
  111|      1|}

X509_get_default_cert_area:
   70|      2|{
   71|      2|    return (X509_CERT_AREA);
   72|      2|}

ERR_load_X509_strings:
  180|      1|{
  181|      1|#ifndef OPENSSL_NO_ERR
  182|       |
  183|      1|    if (ERR_func_error_string(X509_str_functs[0].error) == NULL) {
  184|      1|        ERR_load_strings(0, X509_str_functs);
  185|      1|        ERR_load_strings(0, X509_str_reasons);
  186|      1|    }
  187|      1|#endif
  188|      1|}

ERR_load_X509V3_strings:
  241|      1|{
  242|      1|#ifndef OPENSSL_NO_ERR
  243|       |
  244|      1|    if (ERR_func_error_string(X509V3_str_functs[0].error) == NULL) {
  245|      1|        ERR_load_strings(0, X509V3_str_functs);
  246|      1|        ERR_load_strings(0, X509V3_str_reasons);
  247|      1|    }
  248|      1|#endif
  249|      1|}

ERR_load_GOST_strings:
  183|      1|{
  184|      1|    if (GOST_lib_error_code == 0)
  185|      1|        GOST_lib_error_code = ERR_get_next_error_library();
  186|       |
  187|      1|    if (GOST_error_init) {
  188|      1|        GOST_error_init = 0;
  189|      1|#ifndef OPENSSL_NO_ERR
  190|      1|        ERR_load_strings(GOST_lib_error_code, GOST_str_functs);
  191|      1|        ERR_load_strings(GOST_lib_error_code, GOST_str_reasons);
  192|      1|#endif
  193|       |
  194|       |#ifdef GOST_LIB_NAME
  195|       |        GOST_lib_name->error = ERR_PACK(GOST_lib_error_code, 0, 0);
  196|       |        ERR_load_strings(0, GOST_lib_name);
  197|       |#endif
  198|      1|    }
  199|      1|}

register_ameth_gost:
  912|      3|{
  913|      3|    *ameth = EVP_PKEY_asn1_new(nid, ASN1_PKEY_SIGPARAM_NULL, pemstr, info);
  914|      3|    if (!*ameth)
  915|      0|        return 0;
  916|      3|    switch (nid) {
  917|      1|    case NID_id_GostR3410_94:
  918|      1|        EVP_PKEY_asn1_set_free(*ameth, pkey_free_gost94);
  919|      1|        EVP_PKEY_asn1_set_private(*ameth,
  920|      1|                                  priv_decode_gost, priv_encode_gost,
  921|      1|                                  priv_print_gost94);
  922|       |
  923|      1|        EVP_PKEY_asn1_set_param(*ameth,
  924|      1|                                gost94_param_decode, gost94_param_encode,
  925|      1|                                param_missing_gost94, param_copy_gost94,
  926|      1|                                param_cmp_gost94, param_print_gost94);
  927|      1|        EVP_PKEY_asn1_set_public(*ameth,
  928|      1|                                 pub_decode_gost94, pub_encode_gost94,
  929|      1|                                 pub_cmp_gost94, pub_print_gost94,
  930|      1|                                 pkey_size_gost, pkey_bits_gost);
  931|       |
  932|      1|        EVP_PKEY_asn1_set_ctrl(*ameth, pkey_ctrl_gost);
  933|      1|        break;
  934|      1|    case NID_id_GostR3410_2001:
  935|      1|        EVP_PKEY_asn1_set_free(*ameth, pkey_free_gost01);
  936|      1|        EVP_PKEY_asn1_set_private(*ameth,
  937|      1|                                  priv_decode_gost, priv_encode_gost,
  938|      1|                                  priv_print_gost01);
  939|       |
  940|      1|        EVP_PKEY_asn1_set_param(*ameth,
  941|      1|                                gost2001_param_decode, gost2001_param_encode,
  942|      1|                                param_missing_gost01, param_copy_gost01,
  943|      1|                                param_cmp_gost01, param_print_gost01);
  944|      1|        EVP_PKEY_asn1_set_public(*ameth,
  945|      1|                                 pub_decode_gost01, pub_encode_gost01,
  946|      1|                                 pub_cmp_gost01, pub_print_gost01,
  947|      1|                                 pkey_size_gost, pkey_bits_gost);
  948|       |
  949|      1|        EVP_PKEY_asn1_set_ctrl(*ameth, pkey_ctrl_gost);
  950|      1|        break;
  951|      1|    case NID_id_Gost28147_89_MAC:
  952|      1|        EVP_PKEY_asn1_set_free(*ameth, mackey_free_gost);
  953|      1|        EVP_PKEY_asn1_set_ctrl(*ameth, mac_ctrl_gost);
  954|      1|        break;
  955|      3|    }
  956|      3|    return 1;
  957|      3|}

ENGINE_load_gost:
  270|      1|{
  271|      1|    ENGINE *toadd;
  272|      1|    if (pmeth_GostR3410_94)
  273|      0|        return;
  274|      1|    toadd = engine_gost();
  275|      1|    if (!toadd)
  276|      0|        return;
  277|      1|    ENGINE_add(toadd);
  278|      1|    ENGINE_free(toadd);
  279|      1|    ERR_clear_error();
  280|      1|}
gost_eng.c:engine_gost:
  258|      1|{
  259|      1|    ENGINE *ret = ENGINE_new();
  260|      1|    if (!ret)
  261|      0|        return NULL;
  262|      1|    if (!bind_gost(ret, engine_gost_id)) {
  263|      0|        ENGINE_free(ret);
  264|      0|        return NULL;
  265|      0|    }
  266|      1|    return ret;
  267|      1|}
gost_eng.c:bind_gost:
   75|      1|{
   76|      1|    int ret = 0;
   77|      1|    if (id && strcmp(id, engine_gost_id))
   78|      0|        return 0;
   79|      1|    if (ameth_GostR3410_94) {
   80|      0|        printf("GOST engine already loaded\n");
   81|      0|        goto end;
   82|      0|    }
   83|       |
   84|      1|    if (!ENGINE_set_id(e, engine_gost_id)) {
   85|      0|        printf("ENGINE_set_id failed\n");
   86|      0|        goto end;
   87|      0|    }
   88|      1|    if (!ENGINE_set_name(e, engine_gost_name)) {
   89|      0|        printf("ENGINE_set_name failed\n");
   90|      0|        goto end;
   91|      0|    }
   92|      1|    if (!ENGINE_set_digests(e, gost_digests)) {
   93|      0|        printf("ENGINE_set_digests failed\n");
   94|      0|        goto end;
   95|      0|    }
   96|      1|    if (!ENGINE_set_ciphers(e, gost_ciphers)) {
   97|      0|        printf("ENGINE_set_ciphers failed\n");
   98|      0|        goto end;
   99|      0|    }
  100|      1|    if (!ENGINE_set_pkey_meths(e, gost_pkey_meths)) {
  101|      0|        printf("ENGINE_set_pkey_meths failed\n");
  102|      0|        goto end;
  103|      0|    }
  104|      1|    if (!ENGINE_set_pkey_asn1_meths(e, gost_pkey_asn1_meths)) {
  105|      0|        printf("ENGINE_set_pkey_asn1_meths failed\n");
  106|      0|        goto end;
  107|      0|    }
  108|       |    /* Control function and commands */
  109|      1|    if (!ENGINE_set_cmd_defns(e, gost_cmds)) {
  110|      0|        fprintf(stderr, "ENGINE_set_cmd_defns failed\n");
  111|      0|        goto end;
  112|      0|    }
  113|      1|    if (!ENGINE_set_ctrl_function(e, gost_control_func)) {
  114|      0|        fprintf(stderr, "ENGINE_set_ctrl_func failed\n");
  115|      0|        goto end;
  116|      0|    }
  117|      1|    if (!ENGINE_set_destroy_function(e, gost_engine_destroy)
  118|      1|        || !ENGINE_set_init_function(e, gost_engine_init)
  119|      1|        || !ENGINE_set_finish_function(e, gost_engine_finish)) {
  120|      0|        goto end;
  121|      0|    }
  122|       |
  123|      1|    if (!register_ameth_gost
  124|      1|        (NID_id_GostR3410_94, &ameth_GostR3410_94, "GOST94",
  125|      1|         "GOST R 34.10-94"))
  126|      0|        goto end;
  127|      1|    if (!register_ameth_gost
  128|      1|        (NID_id_GostR3410_2001, &ameth_GostR3410_2001, "GOST2001",
  129|      1|         "GOST R 34.10-2001"))
  130|      0|        goto end;
  131|      1|    if (!register_ameth_gost(NID_id_Gost28147_89_MAC, &ameth_Gost28147_MAC,
  132|      1|                             "GOST-MAC", "GOST 28147-89 MAC"))
  133|      0|        goto end;
  134|       |
  135|      1|    if (!register_pmeth_gost(NID_id_GostR3410_94, &pmeth_GostR3410_94, 0))
  136|      0|        goto end;
  137|      1|    if (!register_pmeth_gost(NID_id_GostR3410_2001, &pmeth_GostR3410_2001, 0))
  138|      0|        goto end;
  139|      1|    if (!register_pmeth_gost
  140|      1|        (NID_id_Gost28147_89_MAC, &pmeth_Gost28147_MAC, 0))
  141|      0|        goto end;
  142|      1|    if (!ENGINE_register_ciphers(e)
  143|      1|        || !ENGINE_register_digests(e)
  144|      1|        || !ENGINE_register_pkey_meths(e)
  145|       |        /* These two actually should go in LIST_ADD command */
  146|      1|        || !EVP_add_cipher(&cipher_gost)
  147|      1|        || !EVP_add_cipher(&cipher_gost_cpacnt)
  148|      1|        || !EVP_add_digest(&digest_gost)
  149|      1|        || !EVP_add_digest(&imit_gost_cpa)
  150|      1|        ) {
  151|      0|        goto end;
  152|      0|    }
  153|       |
  154|      1|    ERR_load_GOST_strings();
  155|      1|    ret = 1;
  156|      1| end:
  157|      1|    return ret;
  158|      1|}
gost_eng.c:gost_digests:
  166|      2|{
  167|      2|    int ok = 1;
  168|      2|    if (!digest) {
  169|      2|        *nids = gost_digest_nids;
  170|      2|        return 2;
  171|      2|    }
  172|       |    /*
  173|       |     * printf("Digest no %d requested\n",nid);
  174|       |     */
  175|      0|    if (nid == NID_id_GostR3411_94) {
  176|      0|        *digest = &digest_gost;
  177|      0|    } else if (nid == NID_id_Gost28147_89_MAC) {
  178|      0|        *digest = &imit_gost_cpa;
  179|      0|    } else {
  180|      0|        ok = 0;
  181|      0|        *digest = NULL;
  182|      0|    }
  183|      0|    return ok;
  184|      2|}
gost_eng.c:gost_ciphers:
  188|      2|{
  189|      2|    int ok = 1;
  190|      2|    if (!cipher) {
  191|      2|        *nids = gost_cipher_nids;
  192|      2|        return 2;               /* two ciphers are supported */
  193|      2|    }
  194|       |
  195|      0|    if (nid == NID_id_Gost28147_89) {
  196|      0|        *cipher = &cipher_gost;
  197|      0|    } else if (nid == NID_gost89_cnt) {
  198|      0|        *cipher = &cipher_gost_cpacnt;
  199|      0|    } else {
  200|      0|        ok = 0;
  201|      0|        *cipher = NULL;
  202|      0|    }
  203|      0|    return ok;
  204|      2|}
gost_eng.c:gost_pkey_meths:
  208|      2|{
  209|      2|    if (!pmeth) {
  210|      2|        *nids = gost_pkey_meth_nids;
  211|      2|        return 3;
  212|      2|    }
  213|       |
  214|      0|    switch (nid) {
  215|      0|    case NID_id_GostR3410_94:
  216|      0|        *pmeth = pmeth_GostR3410_94;
  217|      0|        return 1;
  218|      0|    case NID_id_GostR3410_2001:
  219|      0|        *pmeth = pmeth_GostR3410_2001;
  220|      0|        return 1;
  221|      0|    case NID_id_Gost28147_89_MAC:
  222|      0|        *pmeth = pmeth_Gost28147_MAC;
  223|      0|        return 1;
  224|      0|    default:;
  225|      0|    }
  226|       |
  227|      0|    *pmeth = NULL;
  228|      0|    return 0;
  229|      0|}

register_pmeth_gost:
  567|      3|{
  568|      3|    *pmeth = EVP_PKEY_meth_new(id, flags);
  569|      3|    if (!*pmeth)
  570|      0|        return 0;
  571|       |
  572|      3|    switch (id) {
  573|      1|    case NID_id_GostR3410_94:
  574|      1|        EVP_PKEY_meth_set_ctrl(*pmeth, pkey_gost_ctrl, pkey_gost_ctrl94_str);
  575|      1|        EVP_PKEY_meth_set_keygen(*pmeth, NULL, pkey_gost94cp_keygen);
  576|      1|        EVP_PKEY_meth_set_sign(*pmeth, NULL, pkey_gost94_cp_sign);
  577|      1|        EVP_PKEY_meth_set_verify(*pmeth, NULL, pkey_gost94_cp_verify);
  578|      1|        EVP_PKEY_meth_set_encrypt(*pmeth,
  579|      1|                                  pkey_gost_encrypt_init,
  580|      1|                                  pkey_GOST94cp_encrypt);
  581|      1|        EVP_PKEY_meth_set_decrypt(*pmeth, NULL, pkey_GOST94cp_decrypt);
  582|      1|        EVP_PKEY_meth_set_derive(*pmeth,
  583|      1|                                 pkey_gost_derive_init, pkey_gost94_derive);
  584|      1|        EVP_PKEY_meth_set_paramgen(*pmeth, pkey_gost_paramgen_init,
  585|      1|                                   pkey_gost94_paramgen);
  586|      1|        break;
  587|      1|    case NID_id_GostR3410_2001:
  588|      1|        EVP_PKEY_meth_set_ctrl(*pmeth, pkey_gost_ctrl, pkey_gost_ctrl01_str);
  589|      1|        EVP_PKEY_meth_set_sign(*pmeth, NULL, pkey_gost01_cp_sign);
  590|      1|        EVP_PKEY_meth_set_verify(*pmeth, NULL, pkey_gost01_cp_verify);
  591|       |
  592|      1|        EVP_PKEY_meth_set_keygen(*pmeth, NULL, pkey_gost01cp_keygen);
  593|       |
  594|      1|        EVP_PKEY_meth_set_encrypt(*pmeth,
  595|      1|                                  pkey_gost_encrypt_init,
  596|      1|                                  pkey_GOST01cp_encrypt);
  597|      1|        EVP_PKEY_meth_set_decrypt(*pmeth, NULL, pkey_GOST01cp_decrypt);
  598|      1|        EVP_PKEY_meth_set_derive(*pmeth,
  599|      1|                                 pkey_gost_derive_init, pkey_gost2001_derive);
  600|      1|        EVP_PKEY_meth_set_paramgen(*pmeth, pkey_gost_paramgen_init,
  601|      1|                                   pkey_gost01_paramgen);
  602|      1|        break;
  603|      1|    case NID_id_Gost28147_89_MAC:
  604|      1|        EVP_PKEY_meth_set_ctrl(*pmeth, pkey_gost_mac_ctrl,
  605|      1|                               pkey_gost_mac_ctrl_str);
  606|      1|        EVP_PKEY_meth_set_signctx(*pmeth, pkey_gost_mac_signctx_init,
  607|      1|                                  pkey_gost_mac_signctx);
  608|      1|        EVP_PKEY_meth_set_keygen(*pmeth, NULL, pkey_gost_mac_keygen);
  609|      1|        EVP_PKEY_meth_set_init(*pmeth, pkey_gost_mac_init);
  610|      1|        EVP_PKEY_meth_set_cleanup(*pmeth, pkey_gost_mac_cleanup);
  611|      1|        EVP_PKEY_meth_set_copy(*pmeth, pkey_gost_mac_copy);
  612|      1|        return 1;
  613|      0|    default:                   /* Unsupported method */
  614|      0|        return 0;
  615|      3|    }
  616|      2|    EVP_PKEY_meth_set_init(*pmeth, pkey_gost_init);
  617|      2|    EVP_PKEY_meth_set_cleanup(*pmeth, pkey_gost_cleanup);
  618|       |
  619|      2|    EVP_PKEY_meth_set_copy(*pmeth, pkey_gost_copy);
  620|       |    /*
  621|       |     * FIXME derive etc...
  622|       |     */
  623|       |
  624|      2|    return 1;
  625|      3|}

ENGINE_load_4758cca:
  264|      1|{
  265|      1|    ENGINE *e_4758 = engine_4758_cca();
  266|      1|    if (!e_4758)
  267|      0|        return;
  268|      1|    ENGINE_add(e_4758);
  269|      1|    ENGINE_free(e_4758);
  270|      1|    ERR_clear_error();
  271|      1|}
e_4758cca.c:engine_4758_cca:
  252|      1|{
  253|      1|    ENGINE *ret = ENGINE_new();
  254|      1|    if (!ret)
  255|      0|        return NULL;
  256|      1|    if (!bind_helper(ret)) {
  257|      0|        ENGINE_free(ret);
  258|      0|        return NULL;
  259|      0|    }
  260|      1|    return ret;
  261|      1|}
e_4758cca.c:bind_helper:
  228|      1|{
  229|      1|    if (!ENGINE_set_id(e, engine_4758_cca_id) ||
  230|      1|        !ENGINE_set_name(e, engine_4758_cca_name) ||
  231|      1|#  ifndef OPENSSL_NO_RSA
  232|      1|        !ENGINE_set_RSA(e, &ibm_4758_cca_rsa) ||
  233|      1|#  endif
  234|      1|        !ENGINE_set_RAND(e, &ibm_4758_cca_rand) ||
  235|      1|        !ENGINE_set_destroy_function(e, ibm_4758_cca_destroy) ||
  236|      1|        !ENGINE_set_init_function(e, ibm_4758_cca_init) ||
  237|      1|        !ENGINE_set_finish_function(e, ibm_4758_cca_finish) ||
  238|      1|        !ENGINE_set_ctrl_function(e, ibm_4758_cca_ctrl) ||
  239|      1|#  ifndef OPENSSL_NO_RSA
  240|      1|        !ENGINE_set_load_privkey_function(e, ibm_4758_load_privkey) ||
  241|      1|        !ENGINE_set_load_pubkey_function(e, ibm_4758_load_pubkey) ||
  242|      1|#  endif
  243|      1|        !ENGINE_set_cmd_defns(e, cca4758_cmd_defns))
  244|      0|        return 0;
  245|       |    /* Ensure the error handling is set up */
  246|      1|    ERR_load_CCA4758_strings();
  247|      1|    return 1;
  248|      1|}
e_4758cca.c:ibm_4758_cca_init:
  282|      1|{
  283|      1|    if (dso) {
  284|      0|        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_ALREADY_LOADED);
  285|      0|        goto err;
  286|      0|    }
  287|       |
  288|      1|    dso = DSO_load(NULL, get_CCA4758_LIB_NAME(), NULL, 0);
  289|      1|    if (!dso) {
  290|      1|        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_DSO_FAILURE);
  291|      1|        goto err;
  292|      1|    }
  293|      0|#  ifndef OPENSSL_NO_RSA
  294|      0|    if (!(keyRecordRead = (F_KEYRECORDREAD)
  295|      0|          DSO_bind_func(dso, n_keyRecordRead)) ||
  296|      0|        !(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)
  297|      0|          DSO_bind_func(dso, n_randomNumberGenerate)) ||
  298|      0|        !(digitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE)
  299|      0|          DSO_bind_func(dso, n_digitalSignatureGenerate)) ||
  300|      0|        !(digitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)
  301|      0|          DSO_bind_func(dso, n_digitalSignatureVerify)) ||
  302|      0|        !(publicKeyExtract = (F_PUBLICKEYEXTRACT)
  303|      0|          DSO_bind_func(dso, n_publicKeyExtract)) ||
  304|      0|        !(pkaEncrypt = (F_PKAENCRYPT)
  305|      0|          DSO_bind_func(dso, n_pkaEncrypt)) || !(pkaDecrypt = (F_PKADECRYPT)
  306|      0|                                                 DSO_bind_func(dso,
  307|      0|                                                               n_pkaDecrypt)))
  308|      0|    {
  309|      0|        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_DSO_FAILURE);
  310|      0|        goto err;
  311|      0|    }
  312|       |#  else
  313|       |    if (!(randomNumberGenerate = (F_RANDOMNUMBERGENERATE)
  314|       |          DSO_bind_func(dso, n_randomNumberGenerate))) {
  315|       |        CCA4758err(CCA4758_F_IBM_4758_CCA_INIT, CCA4758_R_DSO_FAILURE);
  316|       |        goto err;
  317|       |    }
  318|       |#  endif
  319|       |
  320|      0|#  ifndef OPENSSL_NO_RSA
  321|      0|    hndidx = RSA_get_ex_new_index(0, "IBM 4758 CCA RSA key handle",
  322|      0|                                  NULL, NULL, cca_ex_free);
  323|      0|#  endif
  324|       |
  325|      0|    return 1;
  326|      1| err:
  327|      1|    if (dso)
  328|      0|        DSO_free(dso);
  329|      1|    dso = NULL;
  330|       |
  331|      1|#  ifndef OPENSSL_NO_RSA
  332|      1|    keyRecordRead = (F_KEYRECORDREAD) 0;
  333|      1|    digitalSignatureGenerate = (F_DIGITALSIGNATUREGENERATE) 0;
  334|      1|    digitalSignatureVerify = (F_DIGITALSIGNATUREVERIFY)0;
  335|      1|    publicKeyExtract = (F_PUBLICKEYEXTRACT)0;
  336|      1|    pkaEncrypt = (F_PKAENCRYPT) 0;
  337|      1|    pkaDecrypt = (F_PKADECRYPT) 0;
  338|      1|#  endif
  339|      1|    randomNumberGenerate = (F_RANDOMNUMBERGENERATE) 0;
  340|      1|    return 0;
  341|      0|}
e_4758cca.c:get_CCA4758_LIB_NAME:
  142|      1|{
  143|      1|    if (CCA4758_LIB_NAME)
  144|      0|        return CCA4758_LIB_NAME;
  145|      1|    return CCA_LIB_NAME;
  146|      1|}

e_4758cca.c:ERR_CCA4758_error:
  149|      1|{
  150|      1|    if (CCA4758_lib_error_code == 0)
  151|      0|        CCA4758_lib_error_code = ERR_get_next_error_library();
  152|      1|    ERR_PUT_error(CCA4758_lib_error_code, function, reason, file, line);
  153|      1|}
e_4758cca.c:ERR_load_CCA4758_strings:
  115|      1|{
  116|      1|    if (CCA4758_lib_error_code == 0)
  117|      1|        CCA4758_lib_error_code = ERR_get_next_error_library();
  118|       |
  119|      1|    if (CCA4758_error_init) {
  120|      1|        CCA4758_error_init = 0;
  121|      1|#ifndef OPENSSL_NO_ERR
  122|      1|        ERR_load_strings(CCA4758_lib_error_code, CCA4758_str_functs);
  123|      1|        ERR_load_strings(CCA4758_lib_error_code, CCA4758_str_reasons);
  124|      1|#endif
  125|       |
  126|       |#ifdef CCA4758_LIB_NAME
  127|       |        CCA4758_lib_name->error = ERR_PACK(CCA4758_lib_error_code, 0, 0);
  128|       |        ERR_load_strings(0, CCA4758_lib_name);
  129|       |#endif
  130|      1|    }
  131|      1|}

ENGINE_load_aep:
  373|      1|{
  374|       |    /* Copied from eng_[openssl|dyn].c */
  375|      1|    ENGINE *toadd = engine_aep();
  376|      1|    if (!toadd)
  377|      0|        return;
  378|      1|    ENGINE_add(toadd);
  379|      1|    ENGINE_free(toadd);
  380|      1|    ERR_clear_error();
  381|      1|}
e_aep.c:engine_aep:
  361|      1|{
  362|      1|    ENGINE *ret = ENGINE_new();
  363|      1|    if (!ret)
  364|      0|        return NULL;
  365|      1|    if (!bind_aep(ret)) {
  366|      0|        ENGINE_free(ret);
  367|      0|        return NULL;
  368|      0|    }
  369|      1|    return ret;
  370|      1|}
e_aep.c:bind_aep:
  271|      1|{
  272|      1|#  ifndef OPENSSL_NO_RSA
  273|      1|    const RSA_METHOD *meth1;
  274|      1|#  endif
  275|      1|#  ifndef OPENSSL_NO_DSA
  276|      1|    const DSA_METHOD *meth2;
  277|      1|#  endif
  278|      1|#  ifndef OPENSSL_NO_DH
  279|      1|    const DH_METHOD *meth3;
  280|      1|#  endif
  281|       |
  282|      1|    if (!ENGINE_set_id(e, engine_aep_id) ||
  283|      1|        !ENGINE_set_name(e, engine_aep_name) ||
  284|      1|#  ifndef OPENSSL_NO_RSA
  285|      1|        !ENGINE_set_RSA(e, &aep_rsa) ||
  286|      1|#  endif
  287|      1|#  ifndef OPENSSL_NO_DSA
  288|      1|        !ENGINE_set_DSA(e, &aep_dsa) ||
  289|      1|#  endif
  290|      1|#  ifndef OPENSSL_NO_DH
  291|      1|        !ENGINE_set_DH(e, &aep_dh) ||
  292|      1|#  endif
  293|       |#  ifdef AEPRAND
  294|       |        !ENGINE_set_RAND(e, &aep_random) ||
  295|       |#  endif
  296|      1|        !ENGINE_set_init_function(e, aep_init) ||
  297|      1|        !ENGINE_set_destroy_function(e, aep_destroy) ||
  298|      1|        !ENGINE_set_finish_function(e, aep_finish) ||
  299|      1|        !ENGINE_set_ctrl_function(e, aep_ctrl) ||
  300|      1|        !ENGINE_set_cmd_defns(e, aep_cmd_defns))
  301|      0|        return 0;
  302|       |
  303|      1|#  ifndef OPENSSL_NO_RSA
  304|       |    /*
  305|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  306|       |     * aep-specific mod_exp and mod_exp_crt so we use those functions. NB: We
  307|       |     * don't use ENGINE_openssl() or anything "more generic" because
  308|       |     * something like the RSAref code may not hook properly, and if you own
  309|       |     * one of these cards then you have the right to do RSA operations on it
  310|       |     * anyway!
  311|       |     */
  312|      1|    meth1 = RSA_PKCS1_SSLeay();
  313|      1|    aep_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  314|      1|    aep_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  315|      1|    aep_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  316|      1|    aep_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  317|      1|#  endif
  318|       |
  319|      1|#  ifndef OPENSSL_NO_DSA
  320|       |    /*
  321|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  322|       |     */
  323|      1|    meth2 = DSA_OpenSSL();
  324|      1|    aep_dsa.dsa_do_sign = meth2->dsa_do_sign;
  325|      1|    aep_dsa.dsa_sign_setup = meth2->dsa_sign_setup;
  326|      1|    aep_dsa.dsa_do_verify = meth2->dsa_do_verify;
  327|       |
  328|      1|    aep_dsa = *DSA_get_default_method();
  329|      1|    aep_dsa.dsa_mod_exp = aep_dsa_mod_exp;
  330|      1|    aep_dsa.bn_mod_exp = aep_mod_exp_dsa;
  331|      1|#  endif
  332|       |
  333|      1|#  ifndef OPENSSL_NO_DH
  334|       |    /* Much the same for Diffie-Hellman */
  335|      1|    meth3 = DH_OpenSSL();
  336|      1|    aep_dh.generate_key = meth3->generate_key;
  337|      1|    aep_dh.compute_key = meth3->compute_key;
  338|      1|    aep_dh.bn_mod_exp = meth3->bn_mod_exp;
  339|      1|#  endif
  340|       |
  341|       |    /* Ensure the aep error handling is set up */
  342|      1|    ERR_load_AEPHK_strings();
  343|       |
  344|      1|    return 1;
  345|      1|}

e_aep.c:ERR_load_AEPHK_strings:
  121|      1|{
  122|      1|    if (AEPHK_lib_error_code == 0)
  123|      1|        AEPHK_lib_error_code = ERR_get_next_error_library();
  124|       |
  125|      1|    if (AEPHK_error_init) {
  126|      1|        AEPHK_error_init = 0;
  127|      1|#ifndef OPENSSL_NO_ERR
  128|      1|        ERR_load_strings(AEPHK_lib_error_code, AEPHK_str_functs);
  129|      1|        ERR_load_strings(AEPHK_lib_error_code, AEPHK_str_reasons);
  130|      1|#endif
  131|       |
  132|       |#ifdef AEPHK_LIB_NAME
  133|       |        AEPHK_lib_name->error = ERR_PACK(AEPHK_lib_error_code, 0, 0);
  134|       |        ERR_load_strings(0, AEPHK_lib_name);
  135|       |#endif
  136|      1|    }
  137|      1|}

ENGINE_load_atalla:
  279|      1|{
  280|       |    /* Copied from eng_[openssl|dyn].c */
  281|      1|    ENGINE *toadd = engine_atalla();
  282|      1|    if (!toadd)
  283|      0|        return;
  284|      1|    ENGINE_add(toadd);
  285|      1|    ENGINE_free(toadd);
  286|      1|    ERR_clear_error();
  287|      1|}
e_atalla.c:engine_atalla:
  267|      1|{
  268|      1|    ENGINE *ret = ENGINE_new();
  269|      1|    if (!ret)
  270|      0|        return NULL;
  271|      1|    if (!bind_helper(ret)) {
  272|      0|        ENGINE_free(ret);
  273|      0|        return NULL;
  274|      0|    }
  275|      1|    return ret;
  276|      1|}
e_atalla.c:bind_helper:
  199|      1|{
  200|      1|#  ifndef OPENSSL_NO_RSA
  201|      1|    const RSA_METHOD *meth1;
  202|      1|#  endif
  203|      1|#  ifndef OPENSSL_NO_DSA
  204|      1|    const DSA_METHOD *meth2;
  205|      1|#  endif
  206|      1|#  ifndef OPENSSL_NO_DH
  207|      1|    const DH_METHOD *meth3;
  208|      1|#  endif
  209|      1|    if (!ENGINE_set_id(e, engine_atalla_id) ||
  210|      1|        !ENGINE_set_name(e, engine_atalla_name) ||
  211|      1|#  ifndef OPENSSL_NO_RSA
  212|      1|        !ENGINE_set_RSA(e, &atalla_rsa) ||
  213|      1|#  endif
  214|      1|#  ifndef OPENSSL_NO_DSA
  215|      1|        !ENGINE_set_DSA(e, &atalla_dsa) ||
  216|      1|#  endif
  217|      1|#  ifndef OPENSSL_NO_DH
  218|      1|        !ENGINE_set_DH(e, &atalla_dh) ||
  219|      1|#  endif
  220|      1|        !ENGINE_set_destroy_function(e, atalla_destroy) ||
  221|      1|        !ENGINE_set_init_function(e, atalla_init) ||
  222|      1|        !ENGINE_set_finish_function(e, atalla_finish) ||
  223|      1|        !ENGINE_set_ctrl_function(e, atalla_ctrl) ||
  224|      1|        !ENGINE_set_cmd_defns(e, atalla_cmd_defns))
  225|      0|        return 0;
  226|       |
  227|      1|#  ifndef OPENSSL_NO_RSA
  228|       |    /*
  229|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  230|       |     * atalla-specific mod_exp and mod_exp_crt so we use those functions. NB:
  231|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  232|       |     * something like the RSAref code may not hook properly, and if you own
  233|       |     * one of these cards then you have the right to do RSA operations on it
  234|       |     * anyway!
  235|       |     */
  236|      1|    meth1 = RSA_PKCS1_SSLeay();
  237|      1|    atalla_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  238|      1|    atalla_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  239|      1|    atalla_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  240|      1|    atalla_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  241|      1|#  endif
  242|       |
  243|      1|#  ifndef OPENSSL_NO_DSA
  244|       |    /*
  245|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  246|       |     */
  247|      1|    meth2 = DSA_OpenSSL();
  248|      1|    atalla_dsa.dsa_do_sign = meth2->dsa_do_sign;
  249|      1|    atalla_dsa.dsa_sign_setup = meth2->dsa_sign_setup;
  250|      1|    atalla_dsa.dsa_do_verify = meth2->dsa_do_verify;
  251|      1|#  endif
  252|       |
  253|      1|#  ifndef OPENSSL_NO_DH
  254|       |    /* Much the same for Diffie-Hellman */
  255|      1|    meth3 = DH_OpenSSL();
  256|      1|    atalla_dh.generate_key = meth3->generate_key;
  257|      1|    atalla_dh.compute_key = meth3->compute_key;
  258|      1|#  endif
  259|       |
  260|       |    /* Ensure the atalla error handling is set up */
  261|      1|    ERR_load_ATALLA_strings();
  262|      1|    return 1;
  263|      1|}

e_atalla.c:ERR_load_ATALLA_strings:
  107|      1|{
  108|      1|    if (ATALLA_lib_error_code == 0)
  109|      1|        ATALLA_lib_error_code = ERR_get_next_error_library();
  110|       |
  111|      1|    if (ATALLA_error_init) {
  112|      1|        ATALLA_error_init = 0;
  113|      1|#ifndef OPENSSL_NO_ERR
  114|      1|        ERR_load_strings(ATALLA_lib_error_code, ATALLA_str_functs);
  115|      1|        ERR_load_strings(ATALLA_lib_error_code, ATALLA_str_reasons);
  116|      1|#endif
  117|       |
  118|      1|#ifdef ATALLA_LIB_NAME
  119|      1|        ATALLA_lib_name->error = ERR_PACK(ATALLA_lib_error_code, 0, 0);
  120|      1|        ERR_load_strings(0, ATALLA_lib_name);
  121|      1|#endif
  122|      1|    }
  123|      1|}

ENGINE_load_chil:
  419|      1|{
  420|       |    /* Copied from eng_[openssl|dyn].c */
  421|      1|    ENGINE *toadd = engine_chil();
  422|      1|    if (!toadd)
  423|      0|        return;
  424|      1|    ENGINE_add(toadd);
  425|      1|    ENGINE_free(toadd);
  426|      1|    ERR_clear_error();
  427|      1|}
e_chil.c:engine_chil:
  407|      1|{
  408|      1|    ENGINE *ret = ENGINE_new();
  409|      1|    if (!ret)
  410|      0|        return NULL;
  411|      1|    if (!bind_helper(ret)) {
  412|      0|        ENGINE_free(ret);
  413|      0|        return NULL;
  414|      0|    }
  415|      1|    return ret;
  416|      1|}
e_chil.c:bind_helper:
  352|      1|{
  353|      1|#  ifndef OPENSSL_NO_RSA
  354|      1|    const RSA_METHOD *meth1;
  355|      1|#  endif
  356|      1|#  ifndef OPENSSL_NO_DH
  357|      1|    const DH_METHOD *meth2;
  358|      1|#  endif
  359|      1|    if (!ENGINE_set_id(e, engine_hwcrhk_id) ||
  360|      1|        !ENGINE_set_name(e, engine_hwcrhk_name) ||
  361|      1|#  ifndef OPENSSL_NO_RSA
  362|      1|        !ENGINE_set_RSA(e, &hwcrhk_rsa) ||
  363|      1|#  endif
  364|      1|#  ifndef OPENSSL_NO_DH
  365|      1|        !ENGINE_set_DH(e, &hwcrhk_dh) ||
  366|      1|#  endif
  367|      1|        !ENGINE_set_RAND(e, &hwcrhk_rand) ||
  368|      1|        !ENGINE_set_destroy_function(e, hwcrhk_destroy) ||
  369|      1|        !ENGINE_set_init_function(e, hwcrhk_init) ||
  370|      1|        !ENGINE_set_finish_function(e, hwcrhk_finish) ||
  371|      1|        !ENGINE_set_ctrl_function(e, hwcrhk_ctrl) ||
  372|      1|        !ENGINE_set_load_privkey_function(e, hwcrhk_load_privkey) ||
  373|      1|        !ENGINE_set_load_pubkey_function(e, hwcrhk_load_pubkey) ||
  374|      1|        !ENGINE_set_cmd_defns(e, hwcrhk_cmd_defns))
  375|      0|        return 0;
  376|       |
  377|      1|#  ifndef OPENSSL_NO_RSA
  378|       |    /*
  379|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  380|       |     * cswift-specific mod_exp and mod_exp_crt so we use those functions. NB:
  381|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  382|       |     * something like the RSAref code may not hook properly, and if you own
  383|       |     * one of these cards then you have the right to do RSA operations on it
  384|       |     * anyway!
  385|       |     */
  386|      1|    meth1 = RSA_PKCS1_SSLeay();
  387|      1|    hwcrhk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  388|      1|    hwcrhk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  389|      1|    hwcrhk_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  390|      1|    hwcrhk_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  391|      1|#  endif
  392|       |
  393|      1|#  ifndef OPENSSL_NO_DH
  394|       |    /* Much the same for Diffie-Hellman */
  395|      1|    meth2 = DH_OpenSSL();
  396|      1|    hwcrhk_dh.generate_key = meth2->generate_key;
  397|      1|    hwcrhk_dh.compute_key = meth2->compute_key;
  398|      1|#  endif
  399|       |
  400|       |    /* Ensure the hwcrhk error handling is set up */
  401|      1|    ERR_load_HWCRHK_strings();
  402|      1|    return 1;
  403|      1|}
e_chil.c:hwcrhk_init:
  536|      1|{
  537|      1|    HWCryptoHook_Init_t *p1;
  538|      1|    HWCryptoHook_Finish_t *p2;
  539|      1|    HWCryptoHook_ModExp_t *p3;
  540|      1|#  ifndef OPENSSL_NO_RSA
  541|      1|    HWCryptoHook_RSA_t *p4;
  542|      1|    HWCryptoHook_RSALoadKey_t *p5;
  543|      1|    HWCryptoHook_RSAGetPublicKey_t *p6;
  544|      1|    HWCryptoHook_RSAUnloadKey_t *p7;
  545|      1|#  endif
  546|      1|    HWCryptoHook_RandomBytes_t *p8;
  547|      1|    HWCryptoHook_ModExpCRT_t *p9;
  548|       |
  549|      1|    if (hwcrhk_dso != NULL) {
  550|      0|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_ALREADY_LOADED);
  551|      0|        goto err;
  552|      0|    }
  553|       |    /* Attempt to load libnfhwcrhk.so/nfhwcrhk.dll/whatever. */
  554|      1|    hwcrhk_dso = DSO_load(NULL, get_HWCRHK_LIBNAME(), NULL, 0);
  555|      1|    if (hwcrhk_dso == NULL) {
  556|      1|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_DSO_FAILURE);
  557|      1|        goto err;
  558|      1|    }
  559|      0|    if (!(p1 = (HWCryptoHook_Init_t *)
  560|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_Init)) ||
  561|      0|        !(p2 = (HWCryptoHook_Finish_t *)
  562|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_Finish)) ||
  563|      0|        !(p3 = (HWCryptoHook_ModExp_t *)
  564|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExp)) ||
  565|      0|#  ifndef OPENSSL_NO_RSA
  566|      0|        !(p4 = (HWCryptoHook_RSA_t *)
  567|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSA)) ||
  568|      0|        !(p5 = (HWCryptoHook_RSALoadKey_t *)
  569|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSALoadKey)) ||
  570|      0|        !(p6 = (HWCryptoHook_RSAGetPublicKey_t *)
  571|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAGetPublicKey)) ||
  572|      0|        !(p7 = (HWCryptoHook_RSAUnloadKey_t *)
  573|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RSAUnloadKey)) ||
  574|      0|#  endif
  575|      0|        !(p8 = (HWCryptoHook_RandomBytes_t *)
  576|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_RandomBytes)) ||
  577|      0|        !(p9 = (HWCryptoHook_ModExpCRT_t *)
  578|      0|          DSO_bind_func(hwcrhk_dso, n_hwcrhk_ModExpCRT))) {
  579|      0|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_DSO_FAILURE);
  580|      0|        goto err;
  581|      0|    }
  582|       |    /* Copy the pointers */
  583|      0|    p_hwcrhk_Init = p1;
  584|      0|    p_hwcrhk_Finish = p2;
  585|      0|    p_hwcrhk_ModExp = p3;
  586|      0|#  ifndef OPENSSL_NO_RSA
  587|      0|    p_hwcrhk_RSA = p4;
  588|      0|    p_hwcrhk_RSALoadKey = p5;
  589|      0|    p_hwcrhk_RSAGetPublicKey = p6;
  590|      0|    p_hwcrhk_RSAUnloadKey = p7;
  591|      0|#  endif
  592|      0|    p_hwcrhk_RandomBytes = p8;
  593|      0|    p_hwcrhk_ModExpCRT = p9;
  594|       |
  595|       |    /*
  596|       |     * Check if the application decided to support dynamic locks, and if it
  597|       |     * does, use them.
  598|       |     */
  599|      0|    if (disable_mutex_callbacks == 0) {
  600|      0|        if (CRYPTO_get_dynlock_create_callback() != NULL &&
  601|      0|            CRYPTO_get_dynlock_lock_callback() != NULL &&
  602|      0|            CRYPTO_get_dynlock_destroy_callback() != NULL) {
  603|      0|            hwcrhk_globals.mutex_init = hwcrhk_mutex_init;
  604|      0|            hwcrhk_globals.mutex_acquire = hwcrhk_mutex_lock;
  605|      0|            hwcrhk_globals.mutex_release = hwcrhk_mutex_unlock;
  606|      0|            hwcrhk_globals.mutex_destroy = hwcrhk_mutex_destroy;
  607|      0|        }
  608|      0|    }
  609|       |
  610|       |    /*
  611|       |     * Try and get a context - if not, we may have a DSO but no accelerator!
  612|       |     */
  613|      0|    if (!get_context(&hwcrhk_context, &password_context)) {
  614|      0|        HWCRHKerr(HWCRHK_F_HWCRHK_INIT, HWCRHK_R_UNIT_FAILURE);
  615|      0|        goto err;
  616|      0|    }
  617|       |    /* Everything's fine. */
  618|      0|#  ifndef OPENSSL_NO_RSA
  619|      0|    if (hndidx_rsa == -1)
  620|      0|        hndidx_rsa = RSA_get_ex_new_index(0,
  621|      0|                                          "nFast HWCryptoHook RSA key handle",
  622|      0|                                          NULL, NULL, NULL);
  623|      0|#  endif
  624|      0|    return 1;
  625|      1| err:
  626|      1|    if (hwcrhk_dso)
  627|      0|        DSO_free(hwcrhk_dso);
  628|      1|    hwcrhk_dso = NULL;
  629|      1|    p_hwcrhk_Init = NULL;
  630|      1|    p_hwcrhk_Finish = NULL;
  631|      1|    p_hwcrhk_ModExp = NULL;
  632|      1|#  ifndef OPENSSL_NO_RSA
  633|      1|    p_hwcrhk_RSA = NULL;
  634|      1|    p_hwcrhk_RSALoadKey = NULL;
  635|      1|    p_hwcrhk_RSAGetPublicKey = NULL;
  636|      1|    p_hwcrhk_RSAUnloadKey = NULL;
  637|      1|#  endif
  638|      1|    p_hwcrhk_ModExpCRT = NULL;
  639|      1|    p_hwcrhk_RandomBytes = NULL;
  640|      1|    return 0;
  641|      0|}
e_chil.c:get_HWCRHK_LIBNAME:
  471|      1|{
  472|      1|    if (HWCRHK_LIBNAME)
  473|      0|        return HWCRHK_LIBNAME;
  474|      1|    return "nfhwcrhk";
  475|      1|}

e_chil.c:ERR_HWCRHK_error:
  153|      1|{
  154|      1|    if (HWCRHK_lib_error_code == 0)
  155|      0|        HWCRHK_lib_error_code = ERR_get_next_error_library();
  156|      1|    ERR_PUT_error(HWCRHK_lib_error_code, function, reason, file, line);
  157|      1|}
e_chil.c:ERR_load_HWCRHK_strings:
  119|      1|{
  120|      1|    if (HWCRHK_lib_error_code == 0)
  121|      1|        HWCRHK_lib_error_code = ERR_get_next_error_library();
  122|       |
  123|      1|    if (HWCRHK_error_init) {
  124|      1|        HWCRHK_error_init = 0;
  125|      1|#ifndef OPENSSL_NO_ERR
  126|      1|        ERR_load_strings(HWCRHK_lib_error_code, HWCRHK_str_functs);
  127|      1|        ERR_load_strings(HWCRHK_lib_error_code, HWCRHK_str_reasons);
  128|      1|#endif
  129|       |
  130|      1|#ifdef HWCRHK_LIB_NAME
  131|      1|        HWCRHK_lib_name->error = ERR_PACK(HWCRHK_lib_error_code, 0, 0);
  132|      1|        ERR_load_strings(0, HWCRHK_lib_name);
  133|      1|#endif
  134|      1|    }
  135|      1|}

ENGINE_load_cswift:
  302|      1|{
  303|       |    /* Copied from eng_[openssl|dyn].c */
  304|      1|    ENGINE *toadd = engine_cswift();
  305|      1|    if (!toadd)
  306|      0|        return;
  307|      1|    ENGINE_add(toadd);
  308|      1|    ENGINE_free(toadd);
  309|      1|    ERR_clear_error();
  310|      1|}
e_cswift.c:engine_cswift:
  290|      1|{
  291|      1|    ENGINE *ret = ENGINE_new();
  292|      1|    if (!ret)
  293|      0|        return NULL;
  294|      1|    if (!bind_helper(ret)) {
  295|      0|        ENGINE_free(ret);
  296|      0|        return NULL;
  297|      0|    }
  298|      1|    return ret;
  299|      1|}
e_cswift.c:bind_helper:
  234|      1|{
  235|      1|#  ifndef OPENSSL_NO_RSA
  236|      1|    const RSA_METHOD *meth1;
  237|      1|#  endif
  238|      1|#  ifndef OPENSSL_NO_DH
  239|      1|    const DH_METHOD *meth2;
  240|      1|#  endif
  241|      1|    if (!ENGINE_set_id(e, engine_cswift_id) ||
  242|      1|        !ENGINE_set_name(e, engine_cswift_name) ||
  243|      1|#  ifndef OPENSSL_NO_RSA
  244|      1|        !ENGINE_set_RSA(e, &cswift_rsa) ||
  245|      1|#  endif
  246|      1|#  ifndef OPENSSL_NO_DSA
  247|      1|        !ENGINE_set_DSA(e, &cswift_dsa) ||
  248|      1|#  endif
  249|      1|#  ifndef OPENSSL_NO_DH
  250|      1|        !ENGINE_set_DH(e, &cswift_dh) ||
  251|      1|#  endif
  252|      1|        !ENGINE_set_RAND(e, &cswift_random) ||
  253|      1|        !ENGINE_set_destroy_function(e, cswift_destroy) ||
  254|      1|        !ENGINE_set_init_function(e, cswift_init) ||
  255|      1|        !ENGINE_set_finish_function(e, cswift_finish) ||
  256|      1|        !ENGINE_set_ctrl_function(e, cswift_ctrl) ||
  257|      1|        !ENGINE_set_cmd_defns(e, cswift_cmd_defns))
  258|      0|        return 0;
  259|       |
  260|      1|#  ifndef OPENSSL_NO_RSA
  261|       |    /*
  262|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  263|       |     * cswift-specific mod_exp and mod_exp_crt so we use those functions. NB:
  264|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  265|       |     * something like the RSAref code may not hook properly, and if you own
  266|       |     * one of these cards then you have the right to do RSA operations on it
  267|       |     * anyway!
  268|       |     */
  269|      1|    meth1 = RSA_PKCS1_SSLeay();
  270|      1|    cswift_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  271|      1|    cswift_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  272|      1|    cswift_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  273|      1|    cswift_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  274|      1|#  endif
  275|       |
  276|      1|#  ifndef OPENSSL_NO_DH
  277|       |    /* Much the same for Diffie-Hellman */
  278|      1|    meth2 = DH_OpenSSL();
  279|      1|    cswift_dh.generate_key = meth2->generate_key;
  280|      1|    cswift_dh.compute_key = meth2->compute_key;
  281|      1|#  endif
  282|       |
  283|       |    /* Ensure the cswift error handling is set up */
  284|      1|    ERR_load_CSWIFT_strings();
  285|      1|    return 1;
  286|      1|}
e_cswift.c:cswift_init:
  391|      1|{
  392|      1|    SW_CONTEXT_HANDLE hac;
  393|      1|    t_swAcquireAccContext *p1;
  394|      1|    t_swAttachKeyParam *p2;
  395|      1|    t_swSimpleRequest *p3;
  396|      1|    t_swReleaseAccContext *p4;
  397|       |
  398|      1|    if (cswift_dso != NULL) {
  399|      0|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_ALREADY_LOADED);
  400|      0|        goto err;
  401|      0|    }
  402|       |    /* Attempt to load libswift.so/swift.dll/whatever. */
  403|      1|    cswift_dso = DSO_load(NULL, get_CSWIFT_LIBNAME(), NULL, 0);
  404|      1|    if (cswift_dso == NULL) {
  405|      1|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_NOT_LOADED);
  406|      1|        goto err;
  407|      1|    }
  408|      0|    if (!(p1 = (t_swAcquireAccContext *)
  409|      0|          DSO_bind_func(cswift_dso, CSWIFT_F1)) ||
  410|      0|        !(p2 = (t_swAttachKeyParam *)
  411|      0|          DSO_bind_func(cswift_dso, CSWIFT_F2)) ||
  412|      0|        !(p3 = (t_swSimpleRequest *)
  413|      0|          DSO_bind_func(cswift_dso, CSWIFT_F3)) ||
  414|      0|        !(p4 = (t_swReleaseAccContext *)
  415|      0|          DSO_bind_func(cswift_dso, CSWIFT_F4))) {
  416|      0|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_NOT_LOADED);
  417|      0|        goto err;
  418|      0|    }
  419|       |    /* Copy the pointers */
  420|      0|    p_CSwift_AcquireAccContext = p1;
  421|      0|    p_CSwift_AttachKeyParam = p2;
  422|      0|    p_CSwift_SimpleRequest = p3;
  423|      0|    p_CSwift_ReleaseAccContext = p4;
  424|       |    /*
  425|       |     * Try and get a context - if not, we may have a DSO but no accelerator!
  426|       |     */
  427|      0|    if (!get_context(&hac)) {
  428|      0|        CSWIFTerr(CSWIFT_F_CSWIFT_INIT, CSWIFT_R_UNIT_FAILURE);
  429|      0|        goto err;
  430|      0|    }
  431|      0|    release_context(hac);
  432|       |    /* Everything's fine. */
  433|      0|    return 1;
  434|      1| err:
  435|      1|    if (cswift_dso) {
  436|      0|        DSO_free(cswift_dso);
  437|      0|        cswift_dso = NULL;
  438|      0|    }
  439|      1|    p_CSwift_AcquireAccContext = NULL;
  440|      1|    p_CSwift_AttachKeyParam = NULL;
  441|      1|    p_CSwift_SimpleRequest = NULL;
  442|      1|    p_CSwift_ReleaseAccContext = NULL;
  443|      1|    return 0;
  444|      0|}
e_cswift.c:get_CSWIFT_LIBNAME:
  333|      1|{
  334|      1|    if (CSWIFT_LIBNAME)
  335|      0|        return CSWIFT_LIBNAME;
  336|      1|    return "swift";
  337|      1|}

e_cswift.c:ERR_CSWIFT_error:
  146|      1|{
  147|      1|    if (CSWIFT_lib_error_code == 0)
  148|      0|        CSWIFT_lib_error_code = ERR_get_next_error_library();
  149|      1|    ERR_PUT_error(CSWIFT_lib_error_code, function, reason, file, line);
  150|      1|}
e_cswift.c:ERR_load_CSWIFT_strings:
  112|      1|{
  113|      1|    if (CSWIFT_lib_error_code == 0)
  114|      1|        CSWIFT_lib_error_code = ERR_get_next_error_library();
  115|       |
  116|      1|    if (CSWIFT_error_init) {
  117|      1|        CSWIFT_error_init = 0;
  118|      1|#ifndef OPENSSL_NO_ERR
  119|      1|        ERR_load_strings(CSWIFT_lib_error_code, CSWIFT_str_functs);
  120|      1|        ERR_load_strings(CSWIFT_lib_error_code, CSWIFT_str_reasons);
  121|      1|#endif
  122|       |
  123|      1|#ifdef CSWIFT_LIB_NAME
  124|      1|        CSWIFT_lib_name->error = ERR_PACK(CSWIFT_lib_error_code, 0, 0);
  125|      1|        ERR_load_strings(0, CSWIFT_lib_name);
  126|      1|#endif
  127|      1|    }
  128|      1|}

ENGINE_load_nuron:
  407|      1|{
  408|       |    /* Copied from eng_[openssl|dyn].c */
  409|      1|    ENGINE *toadd = engine_nuron();
  410|      1|    if (!toadd)
  411|      0|        return;
  412|      1|    ENGINE_add(toadd);
  413|      1|    ENGINE_free(toadd);
  414|      1|    ERR_clear_error();
  415|      1|}
e_nuron.c:engine_nuron:
  395|      1|{
  396|      1|    ENGINE *ret = ENGINE_new();
  397|      1|    if (!ret)
  398|      0|        return NULL;
  399|      1|    if (!bind_helper(ret)) {
  400|      0|        ENGINE_free(ret);
  401|      0|        return NULL;
  402|      0|    }
  403|      1|    return ret;
  404|      1|}
e_nuron.c:bind_helper:
  327|      1|{
  328|      1|#  ifndef OPENSSL_NO_RSA
  329|      1|    const RSA_METHOD *meth1;
  330|      1|#  endif
  331|      1|#  ifndef OPENSSL_NO_DSA
  332|      1|    const DSA_METHOD *meth2;
  333|      1|#  endif
  334|      1|#  ifndef OPENSSL_NO_DH
  335|      1|    const DH_METHOD *meth3;
  336|      1|#  endif
  337|      1|    if (!ENGINE_set_id(e, engine_nuron_id) ||
  338|      1|        !ENGINE_set_name(e, engine_nuron_name) ||
  339|      1|#  ifndef OPENSSL_NO_RSA
  340|      1|        !ENGINE_set_RSA(e, &nuron_rsa) ||
  341|      1|#  endif
  342|      1|#  ifndef OPENSSL_NO_DSA
  343|      1|        !ENGINE_set_DSA(e, &nuron_dsa) ||
  344|      1|#  endif
  345|      1|#  ifndef OPENSSL_NO_DH
  346|      1|        !ENGINE_set_DH(e, &nuron_dh) ||
  347|      1|#  endif
  348|      1|        !ENGINE_set_destroy_function(e, nuron_destroy) ||
  349|      1|        !ENGINE_set_init_function(e, nuron_init) ||
  350|      1|        !ENGINE_set_finish_function(e, nuron_finish) ||
  351|      1|        !ENGINE_set_ctrl_function(e, nuron_ctrl) ||
  352|      1|        !ENGINE_set_cmd_defns(e, nuron_cmd_defns))
  353|      0|        return 0;
  354|       |
  355|      1|#  ifndef OPENSSL_NO_RSA
  356|       |    /*
  357|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  358|       |     * nuron-specific mod_exp and mod_exp_crt so we use those functions. NB:
  359|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  360|       |     * something like the RSAref code may not hook properly, and if you own
  361|       |     * one of these cards then you have the right to do RSA operations on it
  362|       |     * anyway!
  363|       |     */
  364|      1|    meth1 = RSA_PKCS1_SSLeay();
  365|      1|    nuron_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  366|      1|    nuron_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  367|      1|    nuron_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  368|      1|    nuron_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  369|      1|#  endif
  370|       |
  371|      1|#  ifndef OPENSSL_NO_DSA
  372|       |    /*
  373|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  374|       |     */
  375|      1|    meth2 = DSA_OpenSSL();
  376|      1|    nuron_dsa.dsa_do_sign = meth2->dsa_do_sign;
  377|      1|    nuron_dsa.dsa_sign_setup = meth2->dsa_sign_setup;
  378|      1|    nuron_dsa.dsa_do_verify = meth2->dsa_do_verify;
  379|      1|#  endif
  380|       |
  381|      1|#  ifndef OPENSSL_NO_DH
  382|       |    /* Much the same for Diffie-Hellman */
  383|      1|    meth3 = DH_OpenSSL();
  384|      1|    nuron_dh.generate_key = meth3->generate_key;
  385|      1|    nuron_dh.compute_key = meth3->compute_key;
  386|      1|#  endif
  387|       |
  388|       |    /* Ensure the nuron error handling is set up */
  389|      1|    ERR_load_NURON_strings();
  390|      1|    return 1;
  391|      1|}

e_nuron.c:ERR_load_NURON_strings:
  104|      1|{
  105|      1|    if (NURON_lib_error_code == 0)
  106|      1|        NURON_lib_error_code = ERR_get_next_error_library();
  107|       |
  108|      1|    if (NURON_error_init) {
  109|      1|        NURON_error_init = 0;
  110|      1|#ifndef OPENSSL_NO_ERR
  111|      1|        ERR_load_strings(NURON_lib_error_code, NURON_str_functs);
  112|      1|        ERR_load_strings(NURON_lib_error_code, NURON_str_reasons);
  113|      1|#endif
  114|       |
  115|      1|#ifdef NURON_LIB_NAME
  116|      1|        NURON_lib_name->error = ERR_PACK(NURON_lib_error_code, 0, 0);
  117|      1|        ERR_load_strings(0, NURON_lib_name);
  118|      1|#endif
  119|      1|    }
  120|      1|}

ENGINE_load_padlock:
  116|      1|{
  117|       |/* On non-x86 CPUs it just returns. */
  118|       |#   ifdef COMPILE_HW_PADLOCK
  119|       |    ENGINE *toadd = ENGINE_padlock();
  120|       |    if (!toadd)
  121|       |        return;
  122|       |    ENGINE_add(toadd);
  123|       |    ENGINE_free(toadd);
  124|       |    ERR_clear_error();
  125|       |#   endif
  126|      1|}

ENGINE_load_sureware:
  330|      1|{
  331|       |    /* Copied from eng_[openssl|dyn].c */
  332|      1|    ENGINE *toadd = engine_sureware();
  333|      1|    if (!toadd)
  334|      0|        return;
  335|      1|    ENGINE_add(toadd);
  336|      1|    ENGINE_free(toadd);
  337|      1|    ERR_clear_error();
  338|      1|}
e_sureware.c:engine_sureware:
  318|      1|{
  319|      1|    ENGINE *ret = ENGINE_new();
  320|      1|    if (!ret)
  321|      0|        return NULL;
  322|      1|    if (!bind_sureware(ret)) {
  323|      0|        ENGINE_free(ret);
  324|      0|        return NULL;
  325|      0|    }
  326|      1|    return ret;
  327|      1|}
e_sureware.c:bind_sureware:
  233|      1|{
  234|      1|#  ifndef OPENSSL_NO_RSA
  235|      1|    const RSA_METHOD *meth1;
  236|      1|#  endif
  237|      1|#  ifndef OPENSSL_NO_DSA
  238|      1|    const DSA_METHOD *meth2;
  239|      1|#  endif
  240|      1|#  ifndef OPENSSL_NO_DH
  241|      1|    const DH_METHOD *meth3;
  242|      1|#  endif
  243|       |
  244|      1|    if (!ENGINE_set_id(e, engine_sureware_id) ||
  245|      1|        !ENGINE_set_name(e, engine_sureware_name) ||
  246|      1|#  ifndef OPENSSL_NO_RSA
  247|      1|        !ENGINE_set_RSA(e, &surewarehk_rsa) ||
  248|      1|#  endif
  249|      1|#  ifndef OPENSSL_NO_DSA
  250|      1|        !ENGINE_set_DSA(e, &surewarehk_dsa) ||
  251|      1|#  endif
  252|      1|#  ifndef OPENSSL_NO_DH
  253|      1|        !ENGINE_set_DH(e, &surewarehk_dh) ||
  254|      1|#  endif
  255|      1|        !ENGINE_set_RAND(e, &surewarehk_rand) ||
  256|      1|        !ENGINE_set_destroy_function(e, surewarehk_destroy) ||
  257|      1|        !ENGINE_set_init_function(e, surewarehk_init) ||
  258|      1|        !ENGINE_set_finish_function(e, surewarehk_finish) ||
  259|      1|        !ENGINE_set_ctrl_function(e, surewarehk_ctrl) ||
  260|      1|        !ENGINE_set_load_privkey_function(e, surewarehk_load_privkey) ||
  261|      1|        !ENGINE_set_load_pubkey_function(e, surewarehk_load_pubkey))
  262|      0|        return 0;
  263|       |
  264|      1|#  ifndef OPENSSL_NO_RSA
  265|       |    /*
  266|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  267|       |     * cswift-specific mod_exp and mod_exp_crt so we use those functions. NB:
  268|       |     * We don't use ENGINE_openssl() or anything "more generic" because
  269|       |     * something like the RSAref code may not hook properly, and if you own
  270|       |     * one of these cards then you have the right to do RSA operations on it
  271|       |     * anyway!
  272|       |     */
  273|      1|    meth1 = RSA_PKCS1_SSLeay();
  274|      1|    if (meth1) {
  275|      1|        surewarehk_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  276|      1|        surewarehk_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  277|      1|    }
  278|      1|#  endif
  279|       |
  280|      1|#  ifndef OPENSSL_NO_DSA
  281|       |    /*
  282|       |     * Use the DSA_OpenSSL() method and just hook the mod_exp-ish bits.
  283|       |     */
  284|      1|    meth2 = DSA_OpenSSL();
  285|      1|    if (meth2) {
  286|      1|        surewarehk_dsa.dsa_do_verify = meth2->dsa_do_verify;
  287|      1|    }
  288|      1|#  endif
  289|       |
  290|      1|#  ifndef OPENSSL_NO_DH
  291|       |    /* Much the same for Diffie-Hellman */
  292|      1|    meth3 = DH_OpenSSL();
  293|      1|    if (meth3) {
  294|      1|        surewarehk_dh.generate_key = meth3->generate_key;
  295|      1|        surewarehk_dh.compute_key = meth3->compute_key;
  296|      1|    }
  297|      1|#  endif
  298|       |
  299|       |    /* Ensure the sureware error handling is set up */
  300|      1|    ERR_load_SUREWARE_strings();
  301|      1|    return 1;
  302|      1|}
e_sureware.c:surewarehk_init:
  456|      1|{
  457|      1|    char msg[64] = "ENGINE_init";
  458|      1|    SureWareHook_Init_t *p1 = NULL;
  459|      1|    SureWareHook_Finish_t *p2 = NULL;
  460|      1|    SureWareHook_Rand_Bytes_t *p3 = NULL;
  461|      1|    SureWareHook_Rand_Seed_t *p4 = NULL;
  462|      1|    SureWareHook_Load_Privkey_t *p5 = NULL;
  463|      1|    SureWareHook_Load_Rsa_Pubkey_t *p6 = NULL;
  464|      1|    SureWareHook_Free_t *p7 = NULL;
  465|      1|    SureWareHook_Rsa_Priv_Dec_t *p8 = NULL;
  466|      1|    SureWareHook_Rsa_Sign_t *p9 = NULL;
  467|      1|    SureWareHook_Dsa_Sign_t *p12 = NULL;
  468|      1|    SureWareHook_Info_Pubkey_t *p13 = NULL;
  469|      1|    SureWareHook_Load_Dsa_Pubkey_t *p14 = NULL;
  470|      1|    SureWareHook_Mod_Exp_t *p15 = NULL;
  471|       |
  472|      1|    if (surewarehk_dso != NULL) {
  473|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, ENGINE_R_ALREADY_LOADED);
  474|      0|        goto err;
  475|      0|    }
  476|       |    /* Attempt to load libsurewarehk.so/surewarehk.dll/whatever. */
  477|      1|    surewarehk_dso = DSO_load(NULL, surewarehk_LIBNAME, NULL, 0);
  478|      1|    if (surewarehk_dso == NULL) {
  479|      1|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, ENGINE_R_DSO_FAILURE);
  480|      1|        goto err;
  481|      1|    }
  482|      0|    if (!
  483|      0|        (p1 =
  484|      0|         (SureWareHook_Init_t *) DSO_bind_func(surewarehk_dso,
  485|      0|                                               n_surewarehk_Init))
  486|      0||| !(p2 =
  487|      0|     (SureWareHook_Finish_t *) DSO_bind_func(surewarehk_dso,
  488|      0|                                             n_surewarehk_Finish))
  489|      0||| !(p3 =
  490|      0|     (SureWareHook_Rand_Bytes_t *) DSO_bind_func(surewarehk_dso,
  491|      0|                                                 n_surewarehk_Rand_Bytes))
  492|      0||| !(p4 =
  493|      0|     (SureWareHook_Rand_Seed_t *) DSO_bind_func(surewarehk_dso,
  494|      0|                                                n_surewarehk_Rand_Seed))
  495|      0||| !(p5 =
  496|      0|     (SureWareHook_Load_Privkey_t *) DSO_bind_func(surewarehk_dso,
  497|      0|                                                   n_surewarehk_Load_Privkey))
  498|      0||| !(p6 =
  499|      0|     (SureWareHook_Load_Rsa_Pubkey_t *) DSO_bind_func(surewarehk_dso,
  500|      0|                                                      n_surewarehk_Load_Rsa_Pubkey))
  501|      0||| !(p7 =
  502|      0|     (SureWareHook_Free_t *) DSO_bind_func(surewarehk_dso, n_surewarehk_Free))
  503|      0||| !(p8 =
  504|      0|     (SureWareHook_Rsa_Priv_Dec_t *) DSO_bind_func(surewarehk_dso,
  505|      0|                                                   n_surewarehk_Rsa_Priv_Dec))
  506|      0||| !(p9 =
  507|      0|     (SureWareHook_Rsa_Sign_t *) DSO_bind_func(surewarehk_dso,
  508|      0|                                               n_surewarehk_Rsa_Sign))
  509|      0||| !(p12 =
  510|      0|     (SureWareHook_Dsa_Sign_t *) DSO_bind_func(surewarehk_dso,
  511|      0|                                               n_surewarehk_Dsa_Sign))
  512|      0||| !(p13 =
  513|      0|     (SureWareHook_Info_Pubkey_t *) DSO_bind_func(surewarehk_dso,
  514|      0|                                                  n_surewarehk_Info_Pubkey))
  515|      0||| !(p14 =
  516|      0|     (SureWareHook_Load_Dsa_Pubkey_t *) DSO_bind_func(surewarehk_dso,
  517|      0|                                                      n_surewarehk_Load_Dsa_Pubkey))
  518|      0||| !(p15 =
  519|      0|     (SureWareHook_Mod_Exp_t *) DSO_bind_func(surewarehk_dso,
  520|      0|                                              n_surewarehk_Mod_Exp))) {
  521|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, ENGINE_R_DSO_FAILURE);
  522|      0|        goto err;
  523|      0|    }
  524|       |    /* Copy the pointers */
  525|      0|    p_surewarehk_Init = p1;
  526|      0|    p_surewarehk_Finish = p2;
  527|      0|    p_surewarehk_Rand_Bytes = p3;
  528|      0|    p_surewarehk_Rand_Seed = p4;
  529|      0|    p_surewarehk_Load_Privkey = p5;
  530|      0|    p_surewarehk_Load_Rsa_Pubkey = p6;
  531|      0|    p_surewarehk_Free = p7;
  532|      0|    p_surewarehk_Rsa_Priv_Dec = p8;
  533|      0|    p_surewarehk_Rsa_Sign = p9;
  534|      0|    p_surewarehk_Dsa_Sign = p12;
  535|      0|    p_surewarehk_Info_Pubkey = p13;
  536|      0|    p_surewarehk_Load_Dsa_Pubkey = p14;
  537|      0|    p_surewarehk_Mod_Exp = p15;
  538|       |    /* Contact the hardware and initialises it. */
  539|      0|    if (p_surewarehk_Init(msg, threadsafe) == SUREWAREHOOK_ERROR_UNIT_FAILURE) {
  540|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, SUREWARE_R_UNIT_FAILURE);
  541|      0|        goto err;
  542|      0|    }
  543|      0|    if (p_surewarehk_Init(msg, threadsafe) == SUREWAREHOOK_ERROR_UNIT_FAILURE) {
  544|      0|        SUREWAREerr(SUREWARE_F_SUREWAREHK_INIT, SUREWARE_R_UNIT_FAILURE);
  545|      0|        goto err;
  546|      0|    }
  547|       |    /*
  548|       |     * try to load the default private key, if failed does not return a
  549|       |     * failure but wait for an explicit ENGINE_load_privakey
  550|       |     */
  551|      0|    surewarehk_load_privkey(e, NULL, NULL, NULL);
  552|       |
  553|       |    /* Everything's fine. */
  554|      0|#  ifndef OPENSSL_NO_RSA
  555|      0|    if (rsaHndidx == -1)
  556|      0|        rsaHndidx = RSA_get_ex_new_index(0,
  557|      0|                                         "SureWareHook RSA key handle",
  558|      0|                                         NULL, NULL, surewarehk_ex_free);
  559|      0|#  endif
  560|      0|#  ifndef OPENSSL_NO_DSA
  561|      0|    if (dsaHndidx == -1)
  562|      0|        dsaHndidx = DSA_get_ex_new_index(0,
  563|      0|                                         "SureWareHook DSA key handle",
  564|      0|                                         NULL, NULL, surewarehk_ex_free);
  565|      0|#  endif
  566|       |
  567|      0|    return 1;
  568|      1| err:
  569|      1|    if (surewarehk_dso)
  570|      0|        DSO_free(surewarehk_dso);
  571|      1|    surewarehk_dso = NULL;
  572|      1|    p_surewarehk_Init = NULL;
  573|      1|    p_surewarehk_Finish = NULL;
  574|      1|    p_surewarehk_Rand_Bytes = NULL;
  575|      1|    p_surewarehk_Rand_Seed = NULL;
  576|      1|    p_surewarehk_Load_Privkey = NULL;
  577|      1|    p_surewarehk_Load_Rsa_Pubkey = NULL;
  578|      1|    p_surewarehk_Free = NULL;
  579|      1|    p_surewarehk_Rsa_Priv_Dec = NULL;
  580|      1|    p_surewarehk_Rsa_Sign = NULL;
  581|      1|    p_surewarehk_Dsa_Sign = NULL;
  582|      1|    p_surewarehk_Info_Pubkey = NULL;
  583|      1|    p_surewarehk_Load_Dsa_Pubkey = NULL;
  584|      1|    p_surewarehk_Mod_Exp = NULL;
  585|      1|    return 0;
  586|      0|}

e_sureware.c:ERR_SUREWARE_error:
  150|      1|{
  151|      1|    if (SUREWARE_lib_error_code == 0)
  152|      0|        SUREWARE_lib_error_code = ERR_get_next_error_library();
  153|      1|    ERR_PUT_error(SUREWARE_lib_error_code, function, reason, file, line);
  154|      1|}
e_sureware.c:ERR_load_SUREWARE_strings:
  116|      1|{
  117|      1|    if (SUREWARE_lib_error_code == 0)
  118|      1|        SUREWARE_lib_error_code = ERR_get_next_error_library();
  119|       |
  120|      1|    if (SUREWARE_error_init) {
  121|      1|        SUREWARE_error_init = 0;
  122|      1|#ifndef OPENSSL_NO_ERR
  123|      1|        ERR_load_strings(SUREWARE_lib_error_code, SUREWARE_str_functs);
  124|      1|        ERR_load_strings(SUREWARE_lib_error_code, SUREWARE_str_reasons);
  125|      1|#endif
  126|       |
  127|      1|#ifdef SUREWARE_LIB_NAME
  128|      1|        SUREWARE_lib_name->error = ERR_PACK(SUREWARE_lib_error_code, 0, 0);
  129|      1|        ERR_load_strings(0, SUREWARE_lib_name);
  130|      1|#endif
  131|      1|    }
  132|      1|}

ENGINE_load_ubsec:
  278|      1|{
  279|       |    /* Copied from eng_[openssl|dyn].c */
  280|      1|    ENGINE *toadd = engine_ubsec();
  281|      1|    if (!toadd)
  282|      0|        return;
  283|      1|    ENGINE_add(toadd);
  284|      1|    ENGINE_free(toadd);
  285|      1|    ERR_clear_error();
  286|      1|}
e_ubsec.c:engine_ubsec:
  266|      1|{
  267|      1|    ENGINE *ret = ENGINE_new();
  268|      1|    if (!ret)
  269|      0|        return NULL;
  270|      1|    if (!bind_helper(ret)) {
  271|      0|        ENGINE_free(ret);
  272|      0|        return NULL;
  273|      0|    }
  274|      1|    return ret;
  275|      1|}
e_ubsec.c:bind_helper:
  207|      1|{
  208|      1|#  ifndef OPENSSL_NO_RSA
  209|      1|    const RSA_METHOD *meth1;
  210|      1|#  endif
  211|      1|#  ifndef OPENSSL_NO_DH
  212|      1|#   ifndef HAVE_UBSEC_DH
  213|      1|    const DH_METHOD *meth3;
  214|      1|#   endif                       /* HAVE_UBSEC_DH */
  215|      1|#  endif
  216|      1|    if (!ENGINE_set_id(e, engine_ubsec_id) ||
  217|      1|        !ENGINE_set_name(e, engine_ubsec_name) ||
  218|      1|#  ifndef OPENSSL_NO_RSA
  219|      1|        !ENGINE_set_RSA(e, &ubsec_rsa) ||
  220|      1|#  endif
  221|      1|#  ifndef OPENSSL_NO_DSA
  222|      1|        !ENGINE_set_DSA(e, &ubsec_dsa) ||
  223|      1|#  endif
  224|      1|#  ifndef OPENSSL_NO_DH
  225|      1|        !ENGINE_set_DH(e, &ubsec_dh) ||
  226|      1|#  endif
  227|      1|        !ENGINE_set_destroy_function(e, ubsec_destroy) ||
  228|      1|        !ENGINE_set_init_function(e, ubsec_init) ||
  229|      1|        !ENGINE_set_finish_function(e, ubsec_finish) ||
  230|      1|        !ENGINE_set_ctrl_function(e, ubsec_ctrl) ||
  231|      1|        !ENGINE_set_cmd_defns(e, ubsec_cmd_defns))
  232|      0|        return 0;
  233|       |
  234|      1|#  ifndef OPENSSL_NO_RSA
  235|       |    /*
  236|       |     * We know that the "PKCS1_SSLeay()" functions hook properly to the
  237|       |     * Broadcom-specific mod_exp and mod_exp_crt so we use those functions.
  238|       |     * NB: We don't use ENGINE_openssl() or anything "more generic" because
  239|       |     * something like the RSAref code may not hook properly, and if you own
  240|       |     * one of these cards then you have the right to do RSA operations on it
  241|       |     * anyway!
  242|       |     */
  243|      1|    meth1 = RSA_PKCS1_SSLeay();
  244|      1|    ubsec_rsa.rsa_pub_enc = meth1->rsa_pub_enc;
  245|      1|    ubsec_rsa.rsa_pub_dec = meth1->rsa_pub_dec;
  246|      1|    ubsec_rsa.rsa_priv_enc = meth1->rsa_priv_enc;
  247|      1|    ubsec_rsa.rsa_priv_dec = meth1->rsa_priv_dec;
  248|      1|#  endif
  249|       |
  250|      1|#  ifndef OPENSSL_NO_DH
  251|      1|#   ifndef HAVE_UBSEC_DH
  252|       |    /* Much the same for Diffie-Hellman */
  253|      1|    meth3 = DH_OpenSSL();
  254|      1|    ubsec_dh.generate_key = meth3->generate_key;
  255|      1|    ubsec_dh.compute_key = meth3->compute_key;
  256|      1|#   endif                       /* HAVE_UBSEC_DH */
  257|      1|#  endif
  258|       |
  259|       |    /* Ensure the ubsec error handling is set up */
  260|      1|    ERR_load_UBSEC_strings();
  261|      1|    return 1;
  262|      1|}

e_ubsec.c:ERR_load_UBSEC_strings:
  116|      1|{
  117|      1|    if (UBSEC_lib_error_code == 0)
  118|      1|        UBSEC_lib_error_code = ERR_get_next_error_library();
  119|       |
  120|      1|    if (UBSEC_error_init) {
  121|      1|        UBSEC_error_init = 0;
  122|      1|#ifndef OPENSSL_NO_ERR
  123|      1|        ERR_load_strings(UBSEC_lib_error_code, UBSEC_str_functs);
  124|      1|        ERR_load_strings(UBSEC_lib_error_code, UBSEC_str_reasons);
  125|      1|#endif
  126|       |
  127|      1|#ifdef UBSEC_LIB_NAME
  128|      1|        UBSEC_lib_name->error = ERR_PACK(UBSEC_lib_error_code, 0, 0);
  129|      1|        ERR_load_strings(0, UBSEC_lib_name);
  130|      1|#endif
  131|      1|    }
  132|      1|}

SSL_library_init:
   65|      1|{
   66|       |
   67|      1|#ifndef OPENSSL_NO_DES
   68|      1|    EVP_add_cipher(EVP_des_cbc());
   69|      1|    EVP_add_cipher(EVP_des_ede3_cbc());
   70|      1|#endif
   71|      1|#ifndef OPENSSL_NO_IDEA
   72|      1|    EVP_add_cipher(EVP_idea_cbc());
   73|      1|#endif
   74|      1|#ifndef OPENSSL_NO_RC4
   75|      1|    EVP_add_cipher(EVP_rc4());
   76|      1|# if !defined(OPENSSL_NO_MD5) && (defined(__x86_64) || defined(__x86_64__))
   77|      1|    EVP_add_cipher(EVP_rc4_hmac_md5());
   78|      1|# endif
   79|      1|#endif
   80|      1|#ifndef OPENSSL_NO_RC2
   81|      1|    EVP_add_cipher(EVP_rc2_cbc());
   82|       |    /*
   83|       |     * Not actually used for SSL/TLS but this makes PKCS#12 work if an
   84|       |     * application only calls SSL_library_init().
   85|       |     */
   86|      1|    EVP_add_cipher(EVP_rc2_40_cbc());
   87|      1|#endif
   88|      1|#ifndef OPENSSL_NO_AES
   89|      1|    EVP_add_cipher(EVP_aes_128_cbc());
   90|      1|    EVP_add_cipher(EVP_aes_192_cbc());
   91|      1|    EVP_add_cipher(EVP_aes_256_cbc());
   92|      1|    EVP_add_cipher(EVP_aes_128_gcm());
   93|      1|    EVP_add_cipher(EVP_aes_256_gcm());
   94|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA1)
   95|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha1());
   96|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha1());
   97|      1|# endif
   98|      1|# if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_SHA256)
   99|      1|    EVP_add_cipher(EVP_aes_128_cbc_hmac_sha256());
  100|      1|    EVP_add_cipher(EVP_aes_256_cbc_hmac_sha256());
  101|      1|# endif
  102|       |
  103|      1|#endif
  104|      1|#ifndef OPENSSL_NO_CAMELLIA
  105|      1|    EVP_add_cipher(EVP_camellia_128_cbc());
  106|      1|    EVP_add_cipher(EVP_camellia_256_cbc());
  107|      1|#endif
  108|       |
  109|      1|#ifndef OPENSSL_NO_SEED
  110|      1|    EVP_add_cipher(EVP_seed_cbc());
  111|      1|#endif
  112|       |
  113|      1|#ifndef OPENSSL_NO_MD5
  114|      1|    EVP_add_digest(EVP_md5());
  115|      1|    EVP_add_digest_alias(SN_md5, "ssl2-md5");
  116|      1|    EVP_add_digest_alias(SN_md5, "ssl3-md5");
  117|      1|#endif
  118|      1|#ifndef OPENSSL_NO_SHA
  119|      1|    EVP_add_digest(EVP_sha1()); /* RSA with sha1 */
  120|      1|    EVP_add_digest_alias(SN_sha1, "ssl3-sha1");
  121|      1|    EVP_add_digest_alias(SN_sha1WithRSAEncryption, SN_sha1WithRSA);
  122|      1|#endif
  123|      1|#ifndef OPENSSL_NO_SHA256
  124|      1|    EVP_add_digest(EVP_sha224());
  125|      1|    EVP_add_digest(EVP_sha256());
  126|      1|#endif
  127|      1|#ifndef OPENSSL_NO_SHA512
  128|      1|    EVP_add_digest(EVP_sha384());
  129|      1|    EVP_add_digest(EVP_sha512());
  130|      1|#endif
  131|      1|#if !defined(OPENSSL_NO_SHA) && !defined(OPENSSL_NO_DSA)
  132|      1|    EVP_add_digest(EVP_dss1()); /* DSA with sha1 */
  133|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, SN_dsaWithSHA1_2);
  134|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "DSS1");
  135|      1|    EVP_add_digest_alias(SN_dsaWithSHA1, "dss1");
  136|      1|#endif
  137|      1|#ifndef OPENSSL_NO_ECDSA
  138|      1|    EVP_add_digest(EVP_ecdsa());
  139|      1|#endif
  140|       |    /* If you want support for phased out ciphers, add the following */
  141|       |#if 0
  142|       |    EVP_add_digest(EVP_sha());
  143|       |    EVP_add_digest(EVP_dss());
  144|       |#endif
  145|      1|#ifndef OPENSSL_NO_COMP
  146|       |    /*
  147|       |     * This will initialise the built-in compression algorithms. The value
  148|       |     * returned is a STACK_OF(SSL_COMP), but that can be discarded safely
  149|       |     */
  150|      1|    (void)SSL_COMP_get_compression_methods();
  151|      1|#endif
  152|       |    /* initialize cipher/digest methods table */
  153|      1|    ssl_load_ciphers();
  154|      1|    return (1);
  155|      1|}

ssl_load_ciphers:
  406|      1|{
  407|      1|    ssl_cipher_methods[SSL_ENC_DES_IDX] = EVP_get_cipherbyname(SN_des_cbc);
  408|      1|    ssl_cipher_methods[SSL_ENC_3DES_IDX] =
  409|      1|        EVP_get_cipherbyname(SN_des_ede3_cbc);
  410|      1|    ssl_cipher_methods[SSL_ENC_RC4_IDX] = EVP_get_cipherbyname(SN_rc4);
  411|      1|    ssl_cipher_methods[SSL_ENC_RC2_IDX] = EVP_get_cipherbyname(SN_rc2_cbc);
  412|      1|#ifndef OPENSSL_NO_IDEA
  413|      1|    ssl_cipher_methods[SSL_ENC_IDEA_IDX] = EVP_get_cipherbyname(SN_idea_cbc);
  414|       |#else
  415|       |    ssl_cipher_methods[SSL_ENC_IDEA_IDX] = NULL;
  416|       |#endif
  417|      1|    ssl_cipher_methods[SSL_ENC_AES128_IDX] =
  418|      1|        EVP_get_cipherbyname(SN_aes_128_cbc);
  419|      1|    ssl_cipher_methods[SSL_ENC_AES256_IDX] =
  420|      1|        EVP_get_cipherbyname(SN_aes_256_cbc);
  421|      1|    ssl_cipher_methods[SSL_ENC_CAMELLIA128_IDX] =
  422|      1|        EVP_get_cipherbyname(SN_camellia_128_cbc);
  423|      1|    ssl_cipher_methods[SSL_ENC_CAMELLIA256_IDX] =
  424|      1|        EVP_get_cipherbyname(SN_camellia_256_cbc);
  425|      1|    ssl_cipher_methods[SSL_ENC_GOST89_IDX] =
  426|      1|        EVP_get_cipherbyname(SN_gost89_cnt);
  427|      1|    ssl_cipher_methods[SSL_ENC_SEED_IDX] = EVP_get_cipherbyname(SN_seed_cbc);
  428|       |
  429|      1|    ssl_cipher_methods[SSL_ENC_AES128GCM_IDX] =
  430|      1|        EVP_get_cipherbyname(SN_aes_128_gcm);
  431|      1|    ssl_cipher_methods[SSL_ENC_AES256GCM_IDX] =
  432|      1|        EVP_get_cipherbyname(SN_aes_256_gcm);
  433|       |
  434|      1|    ssl_digest_methods[SSL_MD_MD5_IDX] = EVP_get_digestbyname(SN_md5);
  435|      1|    ssl_mac_secret_size[SSL_MD_MD5_IDX] =
  436|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_MD5_IDX]);
  437|      1|    OPENSSL_assert(ssl_mac_secret_size[SSL_MD_MD5_IDX] >= 0);
  438|      1|    ssl_digest_methods[SSL_MD_SHA1_IDX] = EVP_get_digestbyname(SN_sha1);
  439|      1|    ssl_mac_secret_size[SSL_MD_SHA1_IDX] =
  440|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_SHA1_IDX]);
  441|      1|    OPENSSL_assert(ssl_mac_secret_size[SSL_MD_SHA1_IDX] >= 0);
  442|      1|    ssl_digest_methods[SSL_MD_GOST94_IDX] =
  443|      1|        EVP_get_digestbyname(SN_id_GostR3411_94);
  444|      1|    if (ssl_digest_methods[SSL_MD_GOST94_IDX]) {
  445|      1|        ssl_mac_secret_size[SSL_MD_GOST94_IDX] =
  446|      1|            EVP_MD_size(ssl_digest_methods[SSL_MD_GOST94_IDX]);
  447|      1|        OPENSSL_assert(ssl_mac_secret_size[SSL_MD_GOST94_IDX] >= 0);
  448|      1|    }
  449|      1|    ssl_digest_methods[SSL_MD_GOST89MAC_IDX] =
  450|      1|        EVP_get_digestbyname(SN_id_Gost28147_89_MAC);
  451|      1|    ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX] = get_optional_pkey_id("gost-mac");
  452|      1|    if (ssl_mac_pkey_id[SSL_MD_GOST89MAC_IDX]) {
  453|      0|        ssl_mac_secret_size[SSL_MD_GOST89MAC_IDX] = 32;
  454|      0|    }
  455|       |
  456|      1|    ssl_digest_methods[SSL_MD_SHA256_IDX] = EVP_get_digestbyname(SN_sha256);
  457|      1|    ssl_mac_secret_size[SSL_MD_SHA256_IDX] =
  458|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_SHA256_IDX]);
  459|      1|    ssl_digest_methods[SSL_MD_SHA384_IDX] = EVP_get_digestbyname(SN_sha384);
  460|      1|    ssl_mac_secret_size[SSL_MD_SHA384_IDX] =
  461|      1|        EVP_MD_size(ssl_digest_methods[SSL_MD_SHA384_IDX]);
  462|      1|}
SSL_COMP_get_compression_methods:
 1961|      1|{
 1962|      1|    load_builtin_compressions();
 1963|      1|    return (ssl_comp_methods);
 1964|      1|}
ssl_ciph.c:get_optional_pkey_id:
  388|      1|{
  389|      1|    const EVP_PKEY_ASN1_METHOD *ameth;
  390|      1|    ENGINE *tmpeng = NULL;
  391|      1|    int pkey_id = 0;
  392|      1|    ameth = EVP_PKEY_asn1_find_str(&tmpeng, pkey_name, -1);
  393|      1|    if (ameth) {
  394|      0|        if (EVP_PKEY_asn1_get0_info(&pkey_id, NULL, NULL, NULL, NULL,
  395|      0|                                    ameth) <= 0)
  396|      0|            pkey_id = 0;
  397|      0|    }
  398|      1|    if (tmpeng)
  399|      0|        ENGINE_finish(tmpeng);
  400|      1|    return pkey_id;
  401|      1|}
ssl_ciph.c:load_builtin_compressions:
  472|      1|{
  473|      1|    int got_write_lock = 0;
  474|       |
  475|      1|    CRYPTO_r_lock(CRYPTO_LOCK_SSL);
  476|      1|    if (ssl_comp_methods == NULL) {
  477|      1|        CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
  478|      1|        CRYPTO_w_lock(CRYPTO_LOCK_SSL);
  479|      1|        got_write_lock = 1;
  480|       |
  481|      1|        if (ssl_comp_methods == NULL) {
  482|      1|            SSL_COMP *comp = NULL;
  483|       |
  484|      1|            MemCheck_off();
  485|      1|            ssl_comp_methods = sk_SSL_COMP_new(sk_comp_cmp);
  486|      1|            if (ssl_comp_methods != NULL) {
  487|      1|                comp = (SSL_COMP *)OPENSSL_malloc(sizeof(SSL_COMP));
  488|      1|                if (comp != NULL) {
  489|      1|                    comp->method = COMP_zlib();
  490|      1|                    if (comp->method && comp->method->type == NID_undef)
  491|      1|                        OPENSSL_free(comp);
  492|      0|                    else {
  493|      0|                        comp->id = SSL_COMP_ZLIB_IDX;
  494|      0|                        comp->name = comp->method->name;
  495|      0|                        sk_SSL_COMP_push(ssl_comp_methods, comp);
  496|      0|                    }
  497|      1|                }
  498|      1|                sk_SSL_COMP_sort(ssl_comp_methods);
  499|      1|            }
  500|      1|            MemCheck_on();
  501|      1|        }
  502|      1|    }
  503|       |
  504|      1|    if (got_write_lock)
  505|      1|        CRYPTO_w_unlock(CRYPTO_LOCK_SSL);
  506|      0|    else
  507|      0|        CRYPTO_r_unlock(CRYPTO_LOCK_SSL);
  508|      1|}

ERR_load_SSL_strings:
  832|      1|{
  833|      1|#ifndef OPENSSL_NO_ERR
  834|       |
  835|      1|    if (ERR_func_error_string(SSL_str_functs[0].error) == NULL) {
  836|      1|        ERR_load_strings(0, SSL_str_functs);
  837|      1|        ERR_load_strings(0, SSL_str_reasons);
  838|      1|    }
  839|      1|#endif
  840|      1|}

SSL_load_error_strings:
   64|      1|{
   65|      1|#ifndef OPENSSL_NO_ERR
   66|      1|    ERR_load_crypto_strings();
   67|      1|    ERR_load_SSL_strings();
   68|      1|#endif
   69|      1|}

SSL_get_ex_new_index:
 3286|      4|{
 3287|      4|    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_SSL, argl, argp,
 3288|      4|                                   new_func, dup_func, free_func);
 3289|      4|}

